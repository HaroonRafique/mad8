      subroutine lnseq(label)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode a beam line sequence.                                       *
*   Magnets and their central positions are given as subcommands,      *
*   the drift spaces in between are generated by this routine.         *
* Input:                                                               *
*   LABEL     (char)    Name for generated sequence.                   *
*----------------------------------------------------------------------*
      integer mcfil,mcnam,mcrng,mcstr,mcwrd,mreal,mwflt,mwnam,
     +mbbparam
*---- Double precision version.
      parameter         (mwflt = 2, mcwrd = 4, mreal = 4)
      parameter         (mcnam = 16, mwnam = mcnam / mcwrd)
      parameter         (mcfil = 80, mcrng = 40, mcstr = 512)
      parameter         (mbbparam = 26)
      integer mttact
      parameter (mttact = 100)
      integer icat,idata,idir,ieval,iexpr,iln,ipr,isp,leng,mdi,mpi,ncat,
     +nelem,nkat
      double precision pos
      character*(mcnam) label
      integer memlen,memmin
      parameter         (memmin =  1600 000)
      parameter         (memlen = 16000 000)
      integer llump,lq,lroot
      double precision dq
 
*---- Memory pool definition.
      common //         fence, lq(mwflt*memlen)
      integer           iq(mwflt*memlen)
      real              fence(2), q(mwflt*memlen)
      dimension         dq(memlen)
      equivalence       (iq(1), q(1), dq(1), lq(9))
      equivalence       (lroot, lq(1)), (llump, lq(2))
      integer mbat,mbecls,mbelie,mbemap,mbfrm,mbln,mbnam,mbpr,mbsp
 
*---- Bias for bank descriptor words.
      parameter         (mbfrm  = 1, mbnam  = 2, mbln   = 3,
     +                   mbpr   = 4, mbsp   = 5, mbat   = 6)
      parameter         (mbemap = 1, mbelie = 2, mbecls = 3)
      integer mcf1,mcf2,mcsiz,mctyp,mcval
 
*---- Bias for command attribute groups.
      parameter         (mcf1 = 1, mctyp = 2, mcf2 = 3, mcval = 4,
     +                   mcsiz = mwnam + 3)
      integer mxf1,mxf2,mxop,mxsiz,mxval
 
*---- Bias for expression banks.
      parameter         (mxf1 = 1, mxop = 2, mxf2 = 3, mxval = 4,
     +                   mxsiz = mwflt + 3)
      integer mxals,mxcls,mxdef,mxdrp,mxknw,mxlmp,mxmod,mxord
 
*---- Expression marker bits.
      parameter         (mxdrp = 1, mxdef = 2, mxord = 3,
     +                   mxcls = 4, mxals = 5, mxlmp = 6,
     +                   mxmod = 7, mxknw = 8)
      integer mpcor,mpedi,mpelm,mpenv,mperr,mpfil,mphar,mpkey,mplie,
     +mplin,mpmat,mppar,mpplt,mppol,mpsrv,mpstr,mpsub,mpsur,mptrk,
     +mptws,mpdoom
 
*---- Standard process codes.
      parameter         (mpkey =  1, mppar =  2, mpstr =  3, mpelm =  5,
     +                   mplin =  6)
      parameter         (mpsub = 10)
      parameter         (mpsrv = 11, mpfil = 12, mpenv = 13, mpplt = 14,
     +                   mpsur = 15, mptws = 16, mpmat = 17, mptrk = 18,
     +                   mphar = 19, mperr = 20, mpcor = 21, mplie = 22,
     +                   mpedi = 23, mppol = 24, mpdoom = 25)
 
*---- Buffer for error and warning messages.
      common /message/  msg(8)
      save   /message/
      character*120     msg
      integer llnact,llnbnk,llncal,llneat,llnedr,llnefl,llnesq,llnhed,
     +llnrls,llnrsq,llnsup,llntmp,llnxls,llnxsq
 
*---- Link area for beam line handler.
      common /lnlink/   llnbnk, llnrls, llnrsq, llnsup,
     +                  llnact, llncal, llnhed, llnxls, llnxsq,
     +                  llnesq, llnedr, llneat, llntmp(4), llnefl
      save              /lnlink/
      double precision cofact,optflt
 
*---- Option flags.
      common /optflt/   optflt(10)
      equivalence       (cofact, optflt( 1))
      common /optint/   optint(10)
      integer           optint
      integer           icmdfl, ideffl, iexpfl, ikeyfl, ilinfl
      equivalence       (icmdfl, optint( 1)), (ideffl, optint( 2))
      equivalence       (iexpfl, optint( 3)), (ikeyfl, optint( 4))
      equivalence       (ilinfl, optint( 5))
      common /optlog/   optflg(20), optcon(5)
      logical           optflg, optcon
      logical           debug,  double, echo,   inter,  trace,  verify,
     +                  warn,   info,   sympl,  rbarc, ereset, bborbit
      logical           reset,  tell
      equivalence       (debug,  optflg( 1)), (double, optflg( 2))
      equivalence       (echo,   optflg( 3)), (inter,  optflg( 4))
      equivalence       (trace,  optflg( 5)), (verify, optflg( 6))
      equivalence       (warn,   optflg( 7)), (info,   optflg( 8))
      equivalence       (sympl,  optflg( 9)), (rbarc,  optflg(10))
      equivalence       (ereset,  optflg(11)),(bborbit,optflg(12))
      equivalence       (reset,  optcon( 1)), (tell,   optcon( 2))
      save              /optflt/, /optint/, /optlog/
      integer jtok,lentok,lintok,ntok
 
*---- Statement input buffer.
      parameter         (lentok = 150000)
      common /stbufc/   token(lentok)
      common /stbufi/   lintok, jtok, ntok
      save              /stbufc/, /stbufi/
      character*1       token
      integer lcali,lcatt,lccls,lccmd,lccom,lcdef,lcelm,lcexp,lcfld,
     +lckey,lcseq,lcspl,lcsrc,lcvar,ldbnk,ldkey,lref1,lref2,lsali,lscom,
     +lsdir,lsfld,lsflg,lsnum,lsspl,lbeam,lconsm,ldummy
 
*---- Global reference links.
      common /refer/    lref1,
     +                  lcali, lcatt, lccls, lccmd, lccom, lcdef, lcelm,
     +                  lcexp, lcfld, lckey, lcseq, lcspl, lcsrc, lcvar,
     +                  lbeam, lconsm, ldbnk(4), ldkey(4), ldummy(10),
     +                  lsali, lscom, lsdir, lsfld, lsflg, lsnum, lsspl,
     +                  lref2
      save              /refer/
      integer liftseq, currseq
      common /seqinfi/ liftseq, currseq
      character * (mcnam) sequnam, seqnames
      common /seqinfc/ sequnam, seqnames(mttact)
      integer imodul,iplflg,nfail,nwarn
 
*---- Status flags (flags which are not under user control).
      common /status/   error,  scan,   nwarn,  nfail, imodul, iplflg,
     +                  inval,  maycpl, stabx,  staby,  stabt,
     +                  newcor, newmap, prompt
      save              /status/
      logical           error,  scan,
     +                  inval,  maycpl, stabx,  staby,  stabt,
     +                  newcor, newmap, prompt
 
      character*(mcnam) atrnam, clsnam, elmnam, endseq
      logical           copy, eflag
      parameter         (mdi = 500, mpi = mwflt * mdi)
 
      data endseq       / 'ENDSEQUENCE' /
 
*---- Lift bank, link it to keyword, and mark it as modified.
      call kwget(lckey, iln, ipr, isp, nkat)
      call aabook(llneat, label, ipr, isp, lckey, 1)
 
*---- Decode REFER attribute.
      if (token(jtok) .ne. ';') then
        call aaattr(lq(lckey-2), llneat, nkat, error)
        if (error) then
          call lndrop(llneat)
          go to 9999
        endif
      endif
 
*---- Push command bank to make room for MDI element positions.
      call mzpush(0, llneat, mdi, mpi + 1, 'I')
      iq(llneat+mbat+mcsiz+1) = 16 * mpi + mreal
      idata = mbat + mcsiz + 2
 
*---- Book bank for directory index table.
*     Link 1 is reserved for sequence flag bank.
      call mzbook(2, llnedr, llneat, -1, 'SDIR', 1, 1, mdi + 1, 2, 0)
      nelem = 1
 
*==== Read and decode next subcommand of sequence.
  100 continue
        call rdstat(eflag)
        if (eflag .or. token(1) .eq. ';') go to 100
 
*---- Decode element name.
        call rdword(elmnam, leng)
        if (leng .eq. 0) then
          call rdfail('LNSEQ', 1, 'Expected element name here.')
          go to 100
        endif
 
*---- If a colon is seen, decode class name.
        if (token(jtok) .eq. ':') then
          jtok = jtok + 1
          call rdword(clsnam, leng)
          if (leng .eq. 0) then
            call rdfail('LNSEQ', 1, 'Expected class name here.')
            go to 100
          endif
 
*---- Test for end of sequence.
        else if (token(jtok).eq.';' .and. elmnam.eq.endseq(1:leng)) then
          go to 200
 
*---- Otherwise element and class name are the same.
        else
          clsnam = elmnam
        endif
 
*---- Comma expected.
        if (token(jtok) .ne. ',') then
          call rdfail('LNSEQ', 1, 'Expected "," here.')
          go to 100
        endif
        jtok = jtok + 1
 
*---- Decode "AT" attribute.
        call rdword(atrnam, leng)
        if (atrnam .ne. 'AT') then
          call rdfail('LNSEQ', 1, 'Expected "AT" attribute here.')
          go to 100
        endif
 
*---- Equals sign expected.
        if (token(jtok) .ne. '=') then
          call rdfail('LNSEQ', 1, 'Expected "=" here.')
          go to 100
        endif
        jtok = jtok + 1
 
*---- Read position value, may be expression.
        ieval = 2
        call exread(ieval, pos, iexpr)
        if (eflag) go to 100
        nelem = nelem + 1
        if (nelem .gt. iq(llnedr-1)) then
          call mzpush(0, llnedr, 0,   mdi, 'I')
          call mzpush(0, llneat, mdi, mpi, 'I')
        endif
        call exmake(llneat, nelem, idata, pos, iexpr)
        idata = idata + mwflt
 
*---- Look up class name.
        call utleng(clsnam, leng)
        call difind(ldbnk, clsnam(1:leng), idir, lccls)
        if (lccls .eq. 0) then
          msg(1) = 'Unknown class name "' // clsnam(1:leng) // '".'
          call rdfail('LNSEQ', 1, msg)
          go to 100
        endif
 
*---- Must be beam element.
        if (iq(lccls+mbpr) .ne. mpelm) then
          msg(1) = 'Name "' // label(1:leng) // '" is not a class.'
          call rdfail('LNSEQ', 1, msg)
          go to 100
        endif
 
*---- Set flag for allowable copy - force copy if class = el. type
        lcelm = lccls
        if (elmnam .ne. clsnam) then
          call direfe(ldbnk, elmnam, idir)
          if (lq(ldbnk(3)-idir) .ne. 0) then
            copy = .false.
          else
            lq(ldbnk(3)-idir) = lccls
            copy = .true.
          endif
        else
          copy = .false.
        endif
 
*---- Test for additional attributes.
        if (token(jtok) .eq. ',') then
 
*---- Attributes are allowed.
          if (copy) then
 
*---- Build new element.
            lckey = lq(lccls+1)
            call kwget(lckey, iln, ipr, isp, nkat)
            call aabook(lcelm, elmnam, ipr, isp, lckey, 1)
 
*---- Copy default attributes from class.
            ncat = iq(lccls+mbat)
            do 110 icat = 1, ncat
              call aacopy(lccls, icat, lcelm)
  110       continue
 
*---- Link to class name.
            call sbit1(iq(lccls), mxcls)
            lq(lcelm-ncat-mbecls) = lccls
 
*---- Decode additional attributes.
            lcdef = lq(lckey-2)
            call aaattr(lcdef, lcelm, nkat, eflag)
            if (eflag) then
              call aadrop(lcelm)
              go to 100
            endif
 
*---- DEFINE dump option.
            lq(ldbnk(3)-idir) = lcelm
            iq(lcelm+mbnam) = idir
            if (ideffl .eq. 1  .or.  ideffl .eq. 3) then
              call aadump(lcelm)
            endif
            if (ideffl .eq. 2  .or.  ideffl .eq. 3) then
              call dzshow('element', 0, lcelm, 'V', 0, 0, 0, 0)
            endif
 
*---- Duplicate name, change of attributes is not allowed.
          else
            call utleng(elmnam, leng)
            msg(1) = 'Name "' // elmnam(1:leng) // '" is not unique.'
            call rdfail('LNSEQ', 1, msg)
            go to 100
          endif
*---- Mark source bank as a synonym.
        else
          call sbit1(iq(lccls), mxals)
        endif
 
*---- Store directory index.
        iq(llnedr+nelem) = idir
      go to 100
 
*---- End of sequence.
  200 continue
 
*---- If all OK, define this sequence.
*     Do not drop excessive space; may be used in sequence editor.
      if (error) then
        call lndrop(llneat)
      else
        iq(llnedr+1) = nelem
        call didefi(ldbnk, label, llneat)
 
*---- DEFINE dump option.
        if (ideffl .eq. 1  .or.  ideffl .eq. 3) then
          call aadump(llneat)
        endif
        if (ideffl .eq. 2  .or.  ideffl .eq. 3) then
          call dzshow('sequence', 0, llneat, 'V', 0, 0, 0, 0)
        endif
      endif
 
 9999 end
