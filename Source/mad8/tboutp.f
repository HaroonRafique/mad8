      subroutine tboutp(key, nwid, iwords, iret)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Write a record to Cray SSD or direct access file.                  *
* Input:                                                               *
*    KEY          Record identifier (zero or integer generated by a    *
*                 previous call to TBOUTP).                            *
*    NWID           Number of words to write.                          *
*    IWORDS       Buffer containing the NWID words.                    *
* Output:                                                              *
*    KEY          Record identifier.                                   *
*    IRET         Return code:                                         *
*                      -1 = Written, but record length changed.        *
*                 0 = OK                                               *
*                 1 = Key KEY is not valid.                            *
*                 2 = No more user space available.                    *
*                 3 = Error occurred during transfer.                  *
* Usage:                                                               *
*   The routines TBINPT and TBOUTP allow to write and read random      *
*   access files in the Cray SSD (Solid-state Storage Device) or on    *
*   disk with records of arbitrary length.                             *
*   Each record is identified by a unique key generated by TBOUTP.     *
*   A write request with a zero key causes a new record to be written, *
*   and a new key to be returned.                                      *
*   A write request with a non-zero key causes the record to be        *
*   superseded by the new information. Reading and writing of a        *
*   record can occur any number of times.                              *
* Restrictions:                                                        *
*   The length of an already existing record cannot be increased.      *
*   If a write request is issued for an existing key, the record       *
*   is cut at the length of the previous (!) record.                   *
*   There is no garbage collection or drop mechanism: each request     *
*   with a zero key requires new space.                                *
*   Author: H. Grote    CERN / LEP                   nov. 14, 1988     *
*----------------------------------------------------------------------*
      integer mcfil,mcnam,mcrng,mcstr,mcwrd,mreal,mwflt,mwnam,
     +mbbparam
*---- Double precision version.
      parameter         (mwflt = 2, mcwrd = 4, mreal = 4)
      parameter         (mcnam = 16, mwnam = mcnam / mcwrd)
      parameter         (mcfil = 80, mcrng = 40, mcstr = 512)
      parameter         (mbbparam = 26)
      integer mttact
      parameter (mttact = 100)
      integer i,ibl,irb,iret,ist,jbyt,k,key,n,newkey,
     +nt,nwid,nwout
      integer iwords(*)
      integer icurr,itabun,itbbuf,itbfil,itbspc,koff,ltable,ltbbuf,
     +ltbcol,ltbcur,ltbdsc,ltbsav,ltbspc,ltbsum,ltbtab,ltbtmp,nblock,
     +nbout,ncmax,nrbmod
 
*---- Communication area for table manager routines.
      integer mleng,mnblck,mstep
      parameter         (mnblck=10, mleng=512*mnblck, mstep=100)
      common /tbcomm/   ltable, ltbcol, ltbsum,
     +                  ltbbuf, ltbspc, ltbdsc, ltbtab, ltbcur, ltbsav,
     +                  ltbtmp,
     +                  nblock, nbout, nrbmod, icurr, ncmax, itbspc,
     +                  koff, itbfil, itabun, itbbuf(mleng,2)
      save              /tbcomm/
 
*---- Is this a new write?
      iret = 0
      if (key .eq. 0) then
        newkey = 1
 
*---- Write if buffer full.
        if (koff .eq. mleng) then
          call tbput(itbbuf(1,2), nblock, mleng, iret)
          if (iret .ne. 0) go to 9999
          nbout = nblock
          nblock = nblock + mnblck
          koff = 0
        endif
 
*---- Build new key.
        call sbyt(koff + 1, key, 1, 16)
        call sbyt(nblock, key, 17, 16)
        k = koff
        ibl = nblock
        irb = 2
        nwout = nwid
 
*---- Key was given - write into old space.
      else
 
*---- Check validity of key.
        newkey = 0
        ibl = jbyt(key, 17, 16)
        k = jbyt(key, 1, 16) - 1
        if (key.lt.0 .or. k.gt.mleng .or. ibl.gt.nbout+mnblck) then
          iret = 1
          go to 9999
        endif
 
*---- Still in output buffer.
        irb = 1
        if (ibl .gt. nbout) then
          irb = 2
 
*---- Make sure read buffer is free.
        else if (ibl .ne. icurr) then
          if (nrbmod .ne. 0) then
            call tbput(itbbuf(1,1), icurr, mleng, iret)
            if (iret .ne. 0) go to 9999
          endif
 
*---- Load new block.
          call tbget(itbbuf(1,1), ibl, mleng, iret)
          if (iret .ne. 0) go to 9999
          icurr = ibl
        endif
        nwout = min(nwid, itbbuf(k+1,irb))
      endif
 
*---- Transfer.
      itbbuf(k+1,irb) = nwout
      k = k + 1
      nt = nwout
      ist = 0
   20 continue
 
*---- Copy data to buffer; mark read buffer as modified.
      if (irb .eq. 1) nrbmod = 1
      n = min(nt, mleng-k)
      do 30 i = 1, n
        itbbuf(k+i,irb) = iwords(ist+i)
   30 continue
      nt = nt - n
      if (newkey .ne. 0) koff = k + n
 
*---- Do we need another block?
      if (nt .gt. 0) then
        ist = ist + n
        ibl = ibl + mnblck
 
*---- Next block resides in output buffer or does not yet exist.
        if (ibl .gt. nbout) then
          irb = 2
 
*---- Have to add another block: write output buffer.
          if (ibl .gt. nblock) then
            call tbput(itbbuf(1,2), nblock, mleng, iret)
            if (iret .ne. 0) go to 9999
            nbout = nblock
            nblock = ibl
          endif
 
*---- Need another input block.
        else
 
*---- Make sure input buffer is free.
          if (nrbmod .ne. 0) then
            call tbput(itbbuf(1,1), icurr, mleng, iret)
            if (iret .ne. 0) go to 9999
          endif
 
*---- If new record uses partial buffer, load buffer first.
          if (nt .lt. mleng) then
            call tbget(itbbuf(1,1), ibl, mleng, iret)
            if (iret .ne. 0) go to 9999
          endif
          icurr = ibl
        endif
        k = 0
        go to 20
      endif
 
*---- Has truncation occurred?
      if (nwout .ne. nwid) iret = -1
      nwid = min(nwout,nwid)
 
 9999 end
