+dk history
+IF COMMENT
***** Modification History *****
* Version 8.51/15
* THIS IS THE FINAL MAD-8 VERSION, frozen from now on: June 30, 2002
* (trivial) bug fixed in FLXCIT
* Version 8.51/14
* Bug fix concerning the fringe field in bends (EMDAMP, LMBEND, TMBEND)
* Version 8.51/13
* Updated following constants to more recent (or more precise) values:
* elementary charge (old: 1.60217733d-19, new: 1.602176462d-19 As)
* electron mass (old: 051099906d-03, new: 0.510998902d-3 GeV)
* mu mass (old: 0.105658389d+00, new: 0.1056583568d+00 GeV)
* proton mass (old: 0.93827231d+00, new: 0.938271998d+00 GeV)
* hbar (Planck) (old: 6.5821220d-25, new: 6.58211889d-25 GeV*s)
* erad (classical el. radius, a function of emass):
*      (old 2.81794092d-15, new = 2.817940285d-15)
* pi (!!) (old: 3.1415926535898d0, new: 3.141592653589793d0)
* Version 8.51/12
* Fixed sign error in tmmult in orbit(5) calculation
* Added "normal" flag on EFCOMP for different order in error attribution
* Added correct drift tracking to ttdrf (see 8.51/09)
* Version 8.51/11
* Fixed bug in beambeam orbit subtraction
* Fixed bug in beambeam map accumulation
* Version 8.51/10
* small bug fixed in ENPUT
* Fixed bug in TWOPSV (wrong interpolation for OPTICS with CENTRE)
* Fixed bug in TWCPIN (gave "unstable" for perfectly uncoupled machines)
* Version 8.51/09
* sign of skew octupoles inverted to make them correspond to multipoles
* off-momentum tracking: correction for drift and cavity
* (the previous tracking was only correct to first order in deltap).
* beam-beam elements (4D version only): the kicks are no longer
* applied to the orbit; this because the orbit without these kicks
* is closer to reality. The previous scheme can be switched on with
* option,bborbit
* Version 8.51/08
* sequence name in plot if no title
* mcnam=24 (doom version only)
* mult_refs table even without errors (domm version only)
* Version 8.51/07
* New SETPLOT defaults
* Introduce windows flag for specific mods
* Bug fix in ANYLCAV (LCELM changed by mistake)
* Bug fix in LMMULT (undefined logical flag bvflag)
* Version 8.51/06
* Default for BUNCHED set TRUE
* Blank common doubled (now 64 Mbyte)
* Fixed inconsistency in lmmult (nord sometimes order, sometimes 2*order)
* Version 8.51/05
* bug fix: "bv" flag was ignored for bends.
* maxseql increased to 50000 to accomodate VLHC.
* new option "dump" on track command; if set, then at the positions 
* selected by "select, track, {full, pattern = etc.}" the tracking
* results will be dumped into file "trackdump" rather than printed in PRINT;
* Format: i (particle number), 7e (s, orbit(1..6)).
* changed command subcodes from 24 (all of them) to the ones below:
* profile 28 wire 29 slmonitor 30 blmonitor 31 imonitor 32.
* fixed bug when reading sequence (terminating ";" caused trouble)
* "accel" flag removed: acceleration version now only version.
* Version 8.51/04
* swapped sign for skew multipole components in dictionary and in code
* added GMAX and GMIN (max. and min. field in Tesla/m**n) to all magnets
* added DIRECT flag to PUTKICK and GETKICK; with this flag set, the
* kicker names are written/read rather than the forces. ATTENTION:
* works only correctly if all kicker names in the sequence differ
* The sub-process code for the following (dummy-)element types has been
* changed in the dictionary:
* profile   from 24 to 28
* wire      from 24 to 29
* slmonitor from 24 to 30
* blmonitor from 24 to 31
* imonitor  from 24 to 32
* Version 8.51/03
* changed ENER to ENER1 for obvious reasons
* suppressed ENERGY (equal to EN0)
* This leaves three energies: 
* 1. ener0 = very first energy set by BEAM
* 2. en0   = updated energy, reset by subsequent BEAM
* 3. ener1 = updated energy (through accelereration)
* introduced option ERESET to keep things as they were before
* suppress (unused) FREQ attribute on RFCAVITY command
* Twiss printout modified (energy only if LCAVITY present)
* Version 8.51/02
* Change RBEND length to arc length in map calculations - HG001026
* --> remove EXHALF, new EXFACT
* accel version default
* remove flags: linux, aix, hp
* Version 8.51/01
* Removed cray, vms versions, only one unix, osf1 left for recl
* Introduced bv, field*velocity sign (+1 or -1)
* Normal and global match for two rings simultaneously
* Version 8.23/05
* Do not set sigt and sige in EMSUMM if no cavity voltage
* Supress eigenvalue print in echo file (EMEMGO)
* use BLANK common for pool
* split memory common into declaration (MAD, AAINIT, TBCHCK) and rest
* double memory pool
* add particles POSMUON and NEGMUON
* make USER1(dummy) return rndm() - useful in DO loops
* fix some inconsistencies in BEAM and RESBEAM command
* insert tracking method into RUN header
* Version 8.23/03
* print headers at STATIC and DYNAMIC
* increase partial match to names > 3 characters (from > 1)
* Version 8.23/02
***** HG000301 *****
* move output unit back to 6 on HP
***** HG000228 *****
* fix bug in FLSEQ (visible when editing a sequence from MAKESEQUENCE)
* HG000222
* modify TRDYNRUN (long. coord. not multiplied by dynapfrac)
***** CI000111 *****
* fix bug in TTMULT concerning thin lens only
***** HG991213 *****
* fix sign in TMBB
* Addition of linux flag
* various adiabatic mods concerning the linux compiler
***** HG991115 *****
* Version 8.23/01
* Minor bug fix in MTPINI
* DOOM part: invert signs of multipoles at read + write
* DOOM command: added STRICT option which suppresses writing
* tables to files if they are written into DOOM
* IMPORTANT: Added acceleration version of
* T. Raubenheimer + M. Woodley (SLAC). Everything behind
* +if accel flags for this first version.
***** HG990920 *****
* only DOOM:
* Matrix to DOOM modified
* sectormap into DOOM
* DOOM command ISP changed to 25
* Resequenced because of common block mods
***** HG990623 *****
* Version 8.23/00
* Resequenced - implicit none introduced - lower case -
* one source for standard and doom version
* 6D beam-beam added (BEAMINT etc.)
* mods: PT replaced DELTAP in track table
*       Twiss suppressed if one plane unstable
*       zero beta values as input to Twiss cause fatal error
*       colour option in track plots added
***** CI990120 *****
***** CI981202 *****
* Version 8.22/13
* Correction to TMBB and TTBB to avoid rounding errors for
* Sigma(x) approximately equal to sigma(y).
* MTINIT: Default weights for chromatic functions set to zero.
* TRNOIS: Delete dependence
***** Version 8.22/12 *****
* Bug correction in ENSRNG and LNESEL: segmentation fault.
* Was introduced in Version 8.22/8.
*
***** Version 8.22/11 *****
* Bug correction in LNXSEQ: segmentation fault.
* Was introduced in Version 8.22/8.
*
***** Version 8.22/10 *****
* Change to HP version:
* Terminal output sent to unit 7 to avoid buffering.
* Bug corrections:
* - Correct interpretation of additional observation points.
* - Better handling of interactive mode.
*
***** CI971117 *****
* Version 8.22/8
* Bug correction with occurrence counts:
* Count members of classes also as class elements, so as to have the
* correct occurrence count on subsequence class elements.
*
***** CI971031 *****
* Bug correction: Problem with element replacement in SEQEDIT.
* Version 8.22/7
*
***** CI970822 *****
* Version 8.22/6
* Changes to output format.
* Extents and divergences now contain the emittances.
*
***** CI970819 *****
* Version 8.22/3
* Bug correction for CONSTRAINT, LINE=...
***** CI970702 *****
* Version 8.22/1
* Bug correction: Lie-algebraic tracking was missing the order parameter.
*
***** CI970604 *****
* Version 8.22/0
* Changes to LUMP calculations:
* MAKELUMP now creates an ordinary LUMP,
* but keeps imperfections in its range.
*
***** CI970530 *****
* Bug correction on EXCITE command, creating a PARAMETER
*
***** CI970527 *****
* Version 8.21/12 (resequenced)
* Check for correct dictionary version
* Improved statement reading
* Plot RF cavities
*
***** HG970411 *****
* Version 8.21/11
* Add option to set screen picture size in pixels (PLMAIN)
*
***** CI970325 *****
* Version 8.21/10
* Bug corrections:
* LNEMOV: define undefined variable SELECT
* TRPHOT: ignore sign of deflection to keep energy loss positive.
* TTBB:   wrong sign of displacement for opposite beam.
* TTMULT: undefined variable EL
*
***** CI970120 *****
* Verison 8.21/9
* Correction to quadrupole and sextupole field errors in tracking.
*
***** CI970114 *****
* Version 8.21/8
* Corrections to EMDAMP to make Jx consistent with BMPM
*
***** CI961231 *****
* Version 8.21/7
* Bug correction in MOVE command (FROM was not accepted).
*
***** CI961205 *****
* Version 8.21/6
* Correction of bug in NOISE tracking.
*
***** CI961111 *****
* Version 8.21/4
* Sign corrections for thin multipole effects.
*
***** HG961108 *****
* Version 8.21/4
*    Threader added to CORRECT command (with automatic usage)
*
***** HG961104 *****
* Version 8.21/3
* Speed up of thin-lens tracking.
*
***** HG961014 *****
* Version 8.21/2
*    SPRINT command added
*    CO guess added to POOLDUMP
*
***** CI961015 *****
* Version 8.21/1
*   Minor bug corrections.
*
***** CI960916 *****
* Version 8.21/0
* Allow constraints on chromatic functions.
* INCREMENT and EXCITE commands also accept bank attributes.
*
***** CI960911 *****
* Version 8.20/2
* Added printing of penalty contribution to HARMON HCELL command.
***** CI960909 *****
* No new version
* Suppress message for redefinition of a command with blank name.
*
***** HG960904 *****
* Version 8.20/1
* Option in COGUESS command to transmit the previous closed orbit
* as an initial guess for subsequent closed orbit searches.
*
***** CI960822 *****
* Version 8.20/0
* Resequenced.
*
***** CI960822 *****
* Version 8.19/15
* Bug correction: Allow SAVEBETA of chromatic functions
*
***** CI960816 *****
* Verions 8.19/14:
* Bug correction in track plot.
* Corrected termination criterion in LMDIF.
*
***** CI960815 *****
* Version 8.19/13:
* Correction to Lie algebra:
* Core dump when losing a particle.
* Correction to SAVELINE command:
* output user-defined drifts which occur in sequence.
*
***** CI960814 *****
* Version 8.19/12
* Remove field errors if they are all zero.
* Field errors were taken by mistake as K values instead of K*L
* in the Lie algebra routines for dipoles ... octupoles.
*
***** CI960730 *****
* Version 8.19/11
* Precision problem corrected in random generators.
*
***** CI960703 *****
* Version 8.19/10
* Added saving of initial position in track table.
*
***** CI960620 *****
* Version 8.19/9
* Corrected status setting for GETKICK, GETORBIT, and GETDISPERSION.
*
***** CI9606717 *****
* Version 8.19/8
* All bank names made four characters long.
* Double file open removed for tracking.
*
***** CI960522 *****
* Version 8.19/6
* Bug corrections for error superposition in EFCOMP and EFIELD commands.
*
***** CI960521 *****
* Version 8.19/5
* Added flag ORBIT to DYNAPSTART command
* (suppress c.o. calculation when false)
*
***** CI960508 *****
* Version 8.19/4
* Corrected print frequency to always get printing at first and last
* turn.
*
***** CI960506 *****
* Version 8.19/3
* Bug correction in MAKESEQUENCE: Positions for thin multipoles were
* wrong.
*
***** CI960430 *****
* Version 8.19/2:
* Implement new selection scheme for ESAVE and alignment errors.
*
***** CI960424 *****
* Version 8.19/1
* Minor bug corrections.
*
***** RGO960318 *****
* Version 8.19/0:
* IMPLICIT:   Maximum string length increased to 512.
* LAMAPS:     New working block.
* LARGO:      New common block.
* MTGLOB:     New common deck.
* TBCOMM:     Added link for SPECIAL table.
* TBHEAD:     Maximum number of table columns increased to 100.
* TRDATA:     Added flags for dynamic aperture.
* TRDYNAP:    New common deck.
*
* AAPROC,AARUNS,AASUBR,SVSUBR: Rudimentary IF statement.
* AASERV,AAPUSH,AAEPUSH:       PUSH and ENDPUSH statements.
* AASETP,AAGETP:               Set and get global parameter.
* HALONG:                      Added missing call to ENFREQ.
* MTGLOB,MTUCON,MTUFUN:        Global constraints.
* TRBEGN,TREXEC,TRFLOW,TRKILL,TRMAIN,TRTRKCMD:
*                              Modified for dynamic aperture determination.
* TRINICMD,TRDYNCMD,TRDYNRUN,TRTBSVLY:
*                              DYNAPSTART and DYNAP commands.
* MTINIT,MTMAIN,MTUCON,MTUFUN: Global constraints on STATIC and DYNAP
* PLGTBS,PLPLOT,PLSTRG:        Plotting improvements.
* TWMAIN:                      Save global data as parameters.
* FITLYAP,FFT,TUNEABT,TUNEABT2,WMAXMIN:
*                              Utilities.
*
***** CI960315 *****
* Version 8.18/4 (resequenced)
* ENDUMP, LNESEL: bug corrections
* ERSAVE: save relative errors
*
***** CI960302 *****
* Version 8.18/3
*   EROPT, ERSAVE: consider SELECT,FLAG=ERROR
*
***** CI960213 *****
* Version 8.18/2
* Implement changes for LHC:
* - Modified range selection
* - New sequence editor
* - New error selection
* - Random seed is expression
* - Train interface allows deltap!=0
*
***** CI951121 *****
* Version 8.18/0 (resequenced)
*
***** CI951011 *****
* Version 8.17/9
* Sign of ETA corrected in ENFIX and TWSUMM
*
***** CI950913 *****
* Version 8.17/8
* Allow skewed multipoles to be output by OPTICS
*
***** CI950913 *****
* Version 8.17/7
* New sequence editor command REPLACE
*
***** CI950905 *****
* Version 8.17/6
* Correct ROT angle in ERFICA
* Correct dispersion in GBEND element
*
***** CI950901 *****
* Version 8.17/5
* Correction to read strings correctly
* Minor bugs in ERFCCOM removed
*
***** CI950530 *****
* Version 8.17/4
*   new command SECTORMAP:
*   compute transfer map by sectors
*
***** CI950524 *****
* Version 8.17/3
*   Lines and sequences have no class object -> correction in UTGPOS
*
***** CI950516 *****
* Version 8.17/2
* Added TOLERANCE on COGUESS command
***** Version 8.17/0 *****
*
***** CI950428 *****
* Version 8.16/9
*   Allow relative errors in EFCOMP command,
*   and for multipoles in EFIELD command.
*
***** CI950323 *****
* Version 8.16/8
*   Re-use BETA0 or SIGMA0 banks when redefined
*
***** HG950321 *****
* Version 8.16/7
*   PS/EPS switch on SETPLOT command
*
***** CI950228 *****
* Version 8.16/5
* Allow initial guess for closed orbit, COGUESS command.
*
***** HG941208 *****
* Version 8.16/4
* Plotting:
* - Avoid name conflicts between STRINGs and existing names,
*   and between names defined in different tables
* - Suppress plotting of the beam line except for plots using TWISS tables
*
***** HG941117 *****
* Version 8.16/3
* PLOTCP: Corrections to plot range selection
*
***** CI941110 *****
* Version 8.16/2:
* EMEMDO: Check presence of main beam line
*
*
***** CI941012 *****
* Version 8.16/0:
* Resequenced.
* TWISS now resets DELTAS to zero.
*
***** CI940630 *****
* Version 8.15/2: Changes to HARMON module
* - Use field errors of orders 1 through 4
* - Initialisiation corrected (was wrong in case of symmetric machine)
*
***** CI940629 *****
* Proper diagnosis if BETA0 does not refer to a BETA0 module
* Avoid CYCLE to position which is already START
* Avoid sequence edit during scanning mode
* Avoid unneccessary recomputation of closed orbit
* 16 characters in names for HELP and SHOW without a parameter
*
***** CI940624 *****
* Version 8.15/0
* some minor corrections:
* ERALCA: call to JBIT replaced by call to JBYT
* SOLVER: changed DET to IRANK in some calls
* SVDICT: corrected CALL SVNAME(MD) to CALL SVNAME(LABEL)
* SVLINE: added CHARACTER*(MCNAM) FRMNAM
* SVNAME: BSLASH not used
* MTHESS, TRTBSV: added LOGICAL EFLAG
*
***** HG940622 *****
* Version 8.14/7
* improve clipping, select points in range before spline
*
***** HG940516 *****
* Added FFT plots
*
***** CI940420 *****
* Version 8.14/6
*
* FLXCIT: Added FACTOR to INCREMENT command.
* MTEND, MTVARY: Added option INCREMENT to ENDMATCH command.
*
***** CI940420 *****
* Version 8.14/5
*
* New command MAKELUMP:
*   COTBLE, ENMAIN: Updated to fit new command
*   ENARG, ENLUMP: New routines
* Drop beam line expansion in LNEBGN, if sequence is in use
*
***** CI940325 *****
* Version 8.14/4
*
* ERFICA: Relative errors become fraction in integrated strength
*
***** CI940322 *****
* Version 8.14/3
*
* LNECYC: Correction to drop obsolete expressions correctly
***** CI940310 *****
*
* Modified command SAVELINE: All element attributes constant
*
***** CI940210 *****
* Version 8.14/1
*   Correction to dispersion in TWISS3, ENVELOPE, and EIGEN
*   Removed IRNDM (unused deck)
*   Avoid too many continuation lines in TRPHOT
*
***** CI940131 *****
* Version 8.14/0
* Avoid null labels in HELP
* Version resequenced
*
***** CI940126 *****
* Version 8.13/14
* Length of strings increased to 256
*
***** CI940120 *****
* Versiont 8.13/13
* New STRUCTURE command added
*
***** HG940118 *****
* In absence of cavities, calculate at least synchrotron integrals
*
***** HG931117 *****
* take cavity only into account when voltage set
*
***** HG931215 *****
* HIGZ only: filenames for .ps or .eps file on PLOT command
*
***** CI931217 *****
* Version 8.13/11
* Main program: delete table file after execution
* TWOPTC: Correct use of DELTAP
*
***** CI931213 *****
* Version 8.13/10:
* FL module: Removed variables IOLR and IOLF
*   Decks affected: FLTABLE, FLOPEN, FLTELL, FLTEXT
* OPTICS command: Output of DELTAP corrected in TWOPSV
* Print ending time in ZEND
*
***** CI931203 *****
* Version 8.13/9:
* EMENGO,EMEVGO,EMTWGO:
*   Remove automatic selection of #S and #E for table output
* FLRTFS:
*   Change record length for FLOPEN to zero
* TBLIST:
*   Accept hollerith columns for output
* TWOPSV:
*   Add descriptor TYPE=OPTICS to optics table
***** CI931116 *****
* Version 8.13/8
* ENPRGL:
*   Print RADIATE flag
* PLPVAL:
*   Normalize track coordinates using eigenvectors
* TR Module:
*   Generate track tables in observation points, OBSERVE command
*   Print DAMP and QUANTUM flags
*
***** CI931110 *****
* Version 8.13/7
* TTSEP: Corrected to consider separators correctly.
*
***** CI931109 *****
* Version 8.13/6
* ENFREQ: Suppress message
* TWBTPR: Correct sign of delta(s)
* TWISS, TWOPTC: Moved call to ENFREQ
*
*
***** CI931102 *****
* Version 8.13/5
* ENFIX: removed calculation of SIGX, SIGY
* MTGETI: decreased tolerance EPS
* MTMTCH: removed call to ENFIX
*
***** CI931029 *****
* Version 8.13/4
* TRTURN corrected to define LCCOM properly
*
***** CI931025 *****
* Version 8.13/2
* SAVELINE modified to output all element and parameter definitions
*
***** CI931020 *****
* Version 8.13/1
* Tracking module: quantum fluctuations added (flag QUANTUM)
* New deck: TRPHOT
* Modified decks: TTBEND, TTCORR, TTMULT, TTOCT, TTQUAD, TTSEXT
*
***** CI931012 *****
* Version 8.13/0
* LM, TM, TT Modules: Exact momentum dependence of maps for DELTAS given
* New common variables DELTAS, DELTAT, BETAS, GAMMAS
* Time difference for DELTAS.ne.0 remodelled
* Comdeck /SUMMRY/ merged with /BEAM/
*
***** CI931008 *****
* Version 8.12/4
* LADYNA, LASTAT: Refer maps to actual closed orbit
* LALUMP, LATURN, LMCLOR: Modified accordingly
*
***** CI931009 *****
* MTCOND: Correction to COUPLE constraint
*
***** HG930222 *****
* plot tilted bends smaller than others
*
***** HG930827 *****
* Corrections and minor modifications in BMPM:
* Current from BEAM now (correctly) taken as bunch current.
* If some cavities have a voltage (+length and shunt impedance),
* cavities without voltage are suppressed.
* A preceding PRINT is now considered as print request.
* The dispersion at IP may now have a finite value (user parameter
* DYTOL on BMPM command).
* A warning is printed if the orbit is > 10**(-9) m at the start.
*
***** CI930818 *****
* Version 8.12/3
* Improved excitation integrals for dipoles:
*   EMDAMP
* Format correction in track file:
*   TRFILE,TRRUN corrected
* Tracking speed up:
*   TRDSP1,TRDSP2,TRTURN: avoid divisions
*   TTMULT: split loops to reduce number of tests
* Symplecticity correction:
*   TTSEXT
*
***** CI930722 *****
* Version 8.12/2
* TMMULT: Dispersive terms was included twice
* TMQUAD,TMSEXT: Error in treatement of mispowering
* TMRF: Correction to transfer map for non-zero delta(t)
*
***** CI930612 *****
* Version 8.12/1
* Plotting: minor bug corrected
* TRBEGN: Initialization corrected
***** CI930619 *****
* Version 8.12/0
* Synchrotron radiation completeley remodeled
* Modules affected: EM, TM, TR, TT
* Single decks affected: COFILL, COTBLE, HALONG, MTCOND,
*   TWBTGO, TWCHGO, TWCPGO, TWOPGO, TWOPSV
*   (Calling sequence to TMMAP group routines).
*
***** CI930518 *****
* Version 8.11/4
*   CORKIK: Allow additive corrector settings to be read
*   FLCALL: Leave scanning mode only if interactive
*
***** CI930518 *****
* Version 8.11/3
*   AAMAIN, AAREAD, RDLINE: COMMENT/ENDCOMMENT commands
*   AAVALU: Print expression together with value
*
***** CI930429 *****
* Version 8.11/2:
* TMCLOR:
*   Yet improved algorithm
*
***** CI930429 *****
* Version 8.11/1
* MTEND:
*   Correct dropping of constraint banks and their links,
*   avoid unlinked banks to remain
* LNEREM,SVMAIN:
*   Drop pattern structure after use
*
***** CI930423 *****
* STRGROUP, AAINIT, AAPROC:
*   Keep sequence number for subroutine commands in root bank
* MTCOND:
*   Correction for output of COUPLE constraints
* MTCONS, MTPINI:
*   Correct overwriting of variables in BETA0 bank
*
***** CI930331 *****
* MAD:
*   Remove calls to ZFATAM to avoid lengthy core dumps
* FLMAIN, SVSLIN:
*   Added command SAVELINE
*
***** CI930211 *****
* Version 8.10/6
* ER module:
*   Allow additive imperfections, EOPT,ADD command
* TR module:
*   Consider difference in circulation time
*
***** CI930217 *****
* Version 8.10/5
* EMDAMP,TMMULT,TMQUAD,TTQUAD:
*   Correct repartition of operations for damping
* TMALI1,TMALI2,TMBEND,TMCLOR,TMMAP:
*   Improved closed orbit search
* MTMAIN:
*   Adjust RF before cell matching
* MTPINI:
*   Reset error flag after failing C.O. search
* TR Module:
*   Corrections to reference for non-zero average momentum error
*
***** CI930211 *****
* Version 8.10/4
* MTCONS:
*   Two redundant lines deleted to correct an overwrite bug
* TWCPGO:
*   Corrected to print proper line and range
*
***** CI930126 *****
* TW module:
*   Set RF frequency before searching for closed orbit
*
***** CI930111 *****
* Version 8.10/3
* EM module:
*   Select output in tables via SELECT,OPTICS
* EM and TM modules:
*   Improved damping calculations, also considering quadrupoles
* TM module:
*   Improved closed orbit search
*
***** HG921208 *****
* PL module:
*   Interface to GKS for CERN HP workstations
*
***** CI9201210 *****
* Version 8.10/1
* DIDEFI:
*   Allow redefinition of a STRING
* various modules:
*   Consistent treatement of BETA0
* EMENSV,EMTWSV:
*   Changed name for table type
*
***** Version 8.10/0 created on 25/11/92 *****
*
***** CO9201125 *****
* Version 8.09/2
* CO module:
*   New commands USEKICK, USEMONITOR
*
***** CO9201120 *****
* Version 8.9/1
* All modules:
*   Calling sequences for ENFIX, ENFREQ, TMCLOR, TMTURN revised
* EM module:
*   New commands EMIT, EIGEN, TWISS3, ENVELOPE
*   NORMAL now calls EMIT, EIGEN, TWISS3 and ENVELOPE
* EN module:
*   New commands SAVESIGMA, SIGMA; ALFA corrected
*   ENFIX no longer makes adjustments to RF system
* TR module:
*   Correction to closed orbit search
* TW module:
*   Correction to closed orbit search
*   Hooks for new commands, ALFA corrected
*
***** Version 8.9/0 created on 06/11/92 *****
*
***** CI921106 *****
* Version 8.8/5
* AAOPTS:
*   bug correction to read COFACT correctly
* MT module:
*   hooks for user-defined constraints
*
***** CI921102 *****
* Version 8.8/4
* Allow reading of reduced monitor tables in GETDISP and GETORBIT
* New process code for polarization
*
***** CI921015 *****
* Version 8.8/3
* Close print files when switching
* Tracking sped up for thin multipoles
*
***** Version 8.8/1 *****
* Versions added for RS6000, SUN, and VAX-Station
* running under UNIX-like systems
* AA module:
*   Option INFO, control information messages
* CO module:
*   Minor bug: stop correction by RMS condition,
* EX module:
*   Correction to EXUNST, evaluate random numbers correctly
* MT module:
*   MTEND, MTFCN reorganized to eliminate duplicate code
*   MTCOND added routine for matching conditions
* TM module:
*   Sign of beam-beam displacement corrected
*   Improved map building for bend, cavity and corrector
* TR module:
*   TRSAVE format corrected to be consistent with START command
*
***** CO920916 *****
* Version 8.7/7
* COTBLE: Make sure that correct maps are taken
* TMRF:   Use more precise map
*
***** CI920903 *****
*
* STORE/ENDSTORE commands removed
* Option SYMPLEC added
*
***** CO920722 *****
* Version 8.7/5
* LNMAIN:
*   Correction for evaluation of expressions
*
***** CO920713 *****
* Version 8.7/4
*   CO module: Keep HALFQX, HALFQY, NCOR, NMON in LSCOM bank
*
***** CI920625 *****
* Version 8.7/3
* COTBLE:
*   Add comdeck COLINK
*
***** CI920625 *****
* Version 8.7/2
* TWISS,TWOPTC:
*   Come back to older version
*
***** CI920623 *****
* Version 8.7/1
* CORDIS,CORKIK,CORMON:
*   Improved diagnostics, read tables as written by COWKIK
* EMSUMM:
*   Avoid negative emittance
* TMARB:
*   Use element length
* Version 8.7/0
*
***** CI920609 *****
* Version 8.6/2
* AAATTR:
*   Modified for use with new LNEINS
* LNECYC:
*   New CYCLE command
* LNEDIT,LNMAIN:
*   Routines merged
* LNEINS:
*   Allow element definition during install
* LNEREF:
*   New REFLECT command
* SVMAIN:
*   Order of saving changed
***** CI920604 *****
* Cosmetic changes to conform to ANSI FORTRAN
*
***** CI920521 *****
* Version 8.6/1
* New orbit correction module:
*   New data structure for orbit correction
*   Dispersion correction added
* AASMOD:
*   Dropping of correction tables simplified
* ERALCA,ERALIG:
*   Added monitor read errors for dispersion
* TBWTFS:
*   Modified formats for writing a TFS
* TMMAP,TMTURN:
*   Moved filling in of monitors to COFILL
*
***** CI920424, HG920330 *****
* Version 8.6/0 (resequenced)
* Small bugs in BMPM corrected
* Elimination of various unused variables
* Two missing variable definitions added
* Declaration of dummy externals
* Length of message lines increased to 120
* Version for HP/UX system added
*
***** CI920227 *****
* Version 8.5/4
* LAEMIT:
*   Serious bug in misalignment calculation corrected
*
***** CI920217 *****
* Version 8.5/3
* MTBTTK,TWBTTK,TWCPTK:
*   Avoid adding 1 to tune for small negative phase advance
*   (see Version 8.5/1 for TWBTTK/TWCPTK)
* TWBTIN:
*   Messages should all have three lines
* UTGFLT:
*   Correction to correctly retrieve deferred values
*
***** CI920124 *****
*
* Version 8.5/2
* EXSTRG:
*   Call to AAWARN corrected.
* LADPU2,LASPU2:
*   Minor correction.
* PLOTCP,PLGTBS:
*   Table type EIGEN added
* RDLINE:
*   Suppressed test for read error, to adapt to new VM/CMS system.
*
***** CI911212 *****
*
* Version 8.5/1
* AAEXEC:
*   Correction to TRACE message
* /EMDATA/,EMxxxx,LAEMIT:
*   New version of NORMAL command, based on TRANSPORT method
* LADEIG,LADPU2,LADYNA,LASEIG,LASPU2,LASTAT:
*   Quit, if eigenvalue computation fails
* TMCLOR:
*   Corrected to consider time lag
* TWBTGO:
*   Added +CA RANGE
* TWBTTK,TWCPTK:
*   Avoid adding 1 to tune for small negative phase advance
*   (Correction was lost in version 8.5/0)
*
***** CI911120 *****
*
* Version 8.5/0 (resequenced)
* /IMPLICIT/:
*   Make MCWRD dependent on SINGLE flag
* /OPTION/,AAOPTS:
*   Storage and decoding of WARN option
* AAFAIL,AAWARN,RDFAIL,RDWARN:
*   Centralized printing of messages
* AAWARP,BMWARP,PLWARP:
*   Eliminated
*
***** CI911202 *****
*
* Version 8.4/6
* LNEINS,LNEMOV,LNEREM:
*   Bug correction, removed redefinition message
* TWBTTK,TWCPTK:
*   Avoid adding 1 to tune for small negative phase advance
*
***** HG911202 *****
* Plotting:
*   Modified to plot general table expressions
*
***** CI911126 *****
*
* Version 8.4/5
* PRCGROUP,AAMAIN,AASTRG:
*   String services added.
* AAPARA,SVPARM:
*   Reverted to previous version
* DIMAKE,DIMARK,SVMAIN:
*   Do not save definitions from dictionary
* EMBPRT,EMEPRT,EMESAV,EMSPRT,EMSUMM,LAEMIT:
*   Command and service routines for NORMAL command
* ENFIX,ENFREQ:
*   Removed print-out for greater modularity
* ENPRRF:
*   New output routine for RF system
* ERLIST,HAFUNC,HALONG,HAPRNT,LADYNA,LASTAT,MTEND
* SUHEAD,TRBEGN,TREXEC,TWBTPR,TWCHPR,TWCPPR:
*   Page header made consistent
* EXSTRG:
*   Table-specific expressions added
* FLRTFS,FLWTFS:
*   Record length changed to allow long lines
* PRHEAD
*   New routine to print page header
* General:
*   Adapted to make output format consistent
*
***** CI911024 *****
*
* Version 8.4/4
* FUNDEFS,EXINIT,EXOPER,EXREAD:
*   Added definition of '^', ACOS, ATAN, and ATAN2
* AADUMP:
*   Added dump of string data type
* AAPARA,DCSTRG,SVATTR,SVPARM,SVSTRG,UTGSTR:
*   Allow longer string, economic storage, new STRING command
* AAWARP:
*   New routine to print warning messages
* ENFIX:
*   Redefine current as bunch current instead of beam current
* ERLIST,ERSAVE:
*   Format changes
* EXDUMP,EXEVL1,EXMAK1,EXSTRG:
*   Handle expressions stored in strings
* FLMAIN,TBLIST:
*   New TABLE command
* SVEXPR,SVLIST:
*   Bug corrections
* TBOPEN:
*   Accept blank table name for last table created
* TBQDSC:
*   Query format of descriptor
*
***** CI911015 *****
*
* Version 8.4/3
* LNXPND:
*   Wrong labelling of line ends corrected
***** HG911010 *****
*
* Version 8.4/2
* Add Arnold web plotting
*
***** CI910925 *****
*
* Version 8.4/1
* MAD:
*   Unit number changed for table file to avoid VM/CMS problem
* BMINI2,EXLKEX,EXLKVR,TWOPSV:
*   Changed call to MZPUSH to conform with new ZEBRA version
* ENFIX:
*   Add occurrence count for RF cavities
* LMBEND:
*   Clear field errors before setting
* LMMAP:
*   Correct handling of orbit corrector
* LMMAP,SUELEM,TMMAP:
*   Changed incorrect call to MZDROP
* LAEMIT:
*   Correct element number print
* LNEREM:
*   Revised class handling mechanism
*
***** HG910924 *****
*
* PLGACN:
*   Correct curve annotation plotting
* PLPLOT:
*   Extra blank line at left for annotation
* PLGCMD,PLMAIN,PLPLOT:
*   Add NOLINE option to plot
*
***** CI910826 *****
*
* Version 8.4/0 (resequenced)
*
***** CI910822 *****
*
* Version 8.3/8:
* /BEAM/,ENBEAM,ENFIX,ENGET,ENPUT:
*   Make number of particles depend on beam current
* /BEAGROUP/,/BEAM/,ENGET,ENPUT:
*   Include revolution frequency in BEAM common
* HAVARY,MTVARY:
*   Give message when varying an element length
* LNEINS,LNEMOV,LNEREM:
*   Mark sequence as modified,
*   REMOVE allowed for classes and wild cards
* LNXSEQ:
*   Save space by sharing equal anonymous drifts
* TMBB,TTBB:
*   Allow upright beams (sigmay > sigmax)
* TREXEC,TRMAIN,TRNOIS,TRNRES,TRNSET:
*   Include noise on tracking
*
***** CI910709 *****
*
* Version 8.3/7:
* ENDUMP,ENPRNT,ENSPLT,ENSRNG,ENSTYP,ENPRNT:
*   All element selections now refer to the working range set by USE
* MTEND,MTFCN:
*   Correction to T-matrix fit
*
***** CI910705 *****
*
* Version 8.3/6:
* MAD:
*   Record length of standard files changed to zero, to allow re-use
* AASMOD,ENUSE,LMMAP,LNREFE,MTCONS,MTEND,SUELEM,TMMAP,TWISS,TWOPTC:
*   Delete old beam line expansion via LNDROP
* AABOOK,LNMAKE:
*   Redundant formats deleted
* AADUMP,ENSPCA,ENSPLT,ERALIG,ERFCOM,ERFIEL:
*   Remove data structure dependence
* AAPARA,DCATTR,DCCONS,MTEND,MTPINI:
*   Expression linkage changed
* DILOOK:
*   Bug correction, found wrong name for abbreviations
* MTPINI:
*   Deal with SYMM flag in CELL matching
* LNMAKE:
*   Removed redundant reference link in line bank
* Structure of beam line SEQUENCE changed for sequence editor:
*   LNLINK: New reference links
*   PRCGROUP: Parameter MPEDI added
*   AAEXEC: New branch to sequence editor
*   EXBIN,EXCOPY,EXHALF,EXLOAD: New routines for expressions in sequences
*   EXDUMP,EXFILL,EXEVAL,EXFILL,EXMAKE,EXREFE: Deal with "AT=value"
*   LNDROP: New routine to drop beam line expansion
*   LNINIT: New links for sequence editor
*   LNSEQ,SVBANK,SVLINE,SVSEQ: New data structure
*   LNE...: New set of routines for sequence editor
*   LNX...: New set of routines for expansion of lines and sequences
*
***** CI910529 *****
*
* Version 8.3/5:
* ENFIX:
*   Ignore unstability
*
***** CI910523 *****
* Version 8.3/4:
*
* EMSUMM:
*   Save SIGT and SIGE to /BEAM/ added
*
***** CI910513 *****
* Version 8.3/3:
* DILOOK, UTLOOK:
*   Accept abbreviations only if at least two characters
* UTWILD:
*   Removed
* UTDASH, UTMTCH, UTMTPT, UTPATT:
*   Improved wildcard routines
* SVMAIN:
*   Modified to use UTPATT/UTMTPT
* GETBIT, SETBIT:
*   Simulate bit string operations
*
***** CI910411 *****
* Version 8.3/2:
*
* ENUSE:
*   Return when RANGE specified for non-existing line
* MTMIG1, MTSIM1, LMDIF:
*   Improved message for initially unstable match
* SVMAIN:
*   Modified for selective save with "wildcard" patterns
* TMMAP:
*   Bug correction in LUMP handling
* UTWILD:
*   New routine for "wildcard" test
*
***** CI910405 *****
* Version 8.3/1:
*
* AALINK:
*   Link LAAELM renamed to LAACUR
* AAPDRP:
*   New routine to drop all precomputed maps after a BEAM command
* AAPMOD:
*   comdeck AALINK added
* EMSUMM:
*   Avoid square root of negative number
* EMINIT, ENFIX, LMRF, TMRF, TTRF:
*   Signs corrected for proper handling of negative particles
*
***** CI910311 *****
* Version 8.3/0 (resequenced):
*
* /STFLAG/:
*   Status flags for TRANSPORT map module
*   Used to switch cavities, radiation, errors, etc.
*   Better diagnostics about use of cavities and radiation.
* TMCLOR:
*   Improved closed orbit search
* Tracking:
*   Allow unnormalized tracking for unstable or one-pass systems
*
***** CI910225 *****
* Version 8.2/16:
*
* ERALCA, ERALIG, ERFCCA, ERFCOM, ERFICA, ERFIEL:
*   Suppress verbose messages about errors replaced
* ENSBET, ENUSE, TWBTGO, TWCHGO, TWCPGO, TWOPGO, TWSBET:
*   Install new SAVEBETA command
* LMYROT, LMSROT, TRTURN, TTYROT, TWMAIN:
*   Cosmetic changes
*
***** CI910219 *****
* Version 8.2/15:
* Corrected handling of longitudinal emittances
* /BEAM/:
*   Flag IETFLG added
* BMSTOR, EMSUMM, ENBEAM:
*   Set IETFLG
* ENGET, ENPUT:
*   retrieve and store IETFLG in BEAM bank
*
***** HG910208 *****
* Version 8.2/14:
* PLOT module additions:
*   DUMP flag prints the plot bank structure
*        rather than plotting it.
*   HELP flag lists all known variables.
*   COLOUR index allows to choose GKS colours,
*        usage similar to STYLE (i.e. 100 loops over 1 to 4).
*   Any variable (known or unknown) from any table can now
*        be plotted.
*
***** CI910206 *****
*
* Version 8.2/13:
* LMDSP1, LMDSP2, TMALI1, TMALI2, TRDSP1, TRDPS2:
*   Misalignments now treated purlely linear.
* LMSEP, TMSEP:
*   Improved separator
*
***** CI910205 *****
* Version 8.2/12:
* ENSBET, TWFILL:
*   Handle factor 2*pi correctly to make consistent with MTPINI
* MTMTCH:
*   Allow overwrite of BETA0 data by command data
* TMMAP:
*   Monitor read errors where ignored
*
***** CI910201 *****
*
* Version 8.2/11:
* AAEXEC, AAMAIN:
*   Suppress command execution in subroutines in case of error
* DCCONS, UTGPOS:
*   Corrections to diagnostics
* LMDSP1, LMDSP2:
*   Interchange of angles corrected
* MTEND:
*   Format corrected
*
***** CI910125 *****
*
* Version 8.2/10:
* ERFCCA, ERFICA, LMELEM, LMMAP, TMMAP, TTELEM:
*   More economic storage of field errors
* LMTRAK:
*   Avoid problems with order = 2
* TMARB:
*   MATRIX element was a complete mess
*
***** CI910114 *****
*
* Version 8.2/9:
* ENMAIN, ENSBET:
*   SAVEBETA command re-introduced
* LNPMOD:
*   Avoid infinite looping for recursive lumps
*
***** CI901221 *****
*
* Version 8.2/8:
* UTPFLT:
*   Could not replace value defined via expression
*
***** CI901203 *****
*
* Version 8.2/7:
* MTBTIN:
*   Correction to rounding error in coupling instability
* MTPINI:
*   Correction to stability check in penalty function
*
***** CI901130 *****
*
* Version 8.2/6:
* HARMON Module:
*   Effect of octupoles and decapoles added to dispersion
*   and chromaticity, weights introduced for Q'
*
***** CI901129 *****
*
* Version 8.2/5:
* TROPTC:
*   Missing SAVE statement added
* ENFIX:
*   Formula for synchrotron tune corrrected
* ERLIST:
*   Error in format statement
* LNPMOD:
*   Rewritten to work on the Cray
* SVMAIN:
*   Bug caused dropping of last item saved
* TRBEGN:
*   Added printing of orbit and eigenvectors
*
***** CI901123 *****
*
* Version 8.2/4:
* COSKIK:
*   Drop one-turn maps after changing kickers
*
***** CI901121 *****
*
* Version 8.2/3: Delete LUMP maps only if required.
*                New parameter group MATGROUP for VARY records
* AALINK:
*   New local links LAAKEY, LAACUR
* MARKBITS:
*   New mark bits MXMOD, MXKNW
* MATGROUP:
*   New parameter group for variables in matching
* AAATTR:
*   Mark bank as modified, if a new attribute is read
* AABOOK, LNMAKE:
*   Mark new bank as modified
* AAELEM:
*   Build new bank, if a class object is updated
* AAEXEC, AAPMOD, LNPMOD:
*   Process lumps and drop modified ones
* AASET, FLXCIT:
*   Mark bank via call to UTPFLT
* COSKIK:
*   Mark one turn maps as obsolete
* DIDEFI, ENBEAM, HATUNE:
*   Marking of one-turn maps removed
* ENUSE:
*   Dropping of one-turn maps changed to marking
* EXEVAL:
*   Propagate modifications and mark banks
* MTPMOD:
*   New routine: drop obsolete element maps
* MTGETI:
*   Adapted to new VARY record, mark affected lumps
* MTLINK, HAVARY, MTVARY, MTVFND:
*   Adapted to new VARY record
* MTPUTI:
*   Adapted to new VARY record, using MTPMOD.
* UTPFLT:
*   Mark bank as modified
* TRCONT:
*   Unused routine deleted
*
***** CI901105 *****
*
* Version 8.2/2
* ENGET:
*   Did not properly unpack beam data after a pool reload
* ERMAIN, ERFCCA, ERFCOM:
*   New command EFCOMP: Multipole errors by components
* TRTURN:
*   Correct accumulation of length for output
* TTMULT:
*   Correction to synchrotron radiation and time lag in multipole
*
***** CI901019 *****
*
* Version 8.2/1
* BMSTOR:
*   Corrected definition of ET
*   Using UTPFLT to store cavity values
* EMDAMP, EMSUMM:
*   Correct sign convention for damping
*   Better tune calculation
* ENDUMP:
*   Corrected for using TYPE
* ENFIX, ENFREQ:
*   Using UTPFLT to store cavity values
* PLGETN:
*   Correct axis label for c*t
* SVMAIN
*   Changed case for "SAVE" file name
*
***** RESEQUENCED *****
* Version 8.2/0
*
***** CI900928 *****
*
* Version 8.1/9
* TMCLOR, TMTURN:
*   Corrections to closed orbit finder to accept RF cavities
* New tracking module installed:
*   Output of particle positions in binary format, using EPIO
*   Normalize particle positions using eigenvectors
*
***** CI900924 *****
*
* TMREFE:
*   Corrected to ignore field errors
* TRTURN:
*   Unused statement function JBIT removed
* TWCPIN:
*   Missing declarations added
*
***** CI900919 *****
*
* ENFIX:
*   Changed format for emittances
* ENUSE, LNXPND:
*   Message changed about expansion of line
* ENSRNG, ERALCA, ERALIG, ERFICA, ERFIEL:
*   Reorganized to allow misalignment of lines and sequences
* Matching and optics routines:
*   Handle misalignment of lines and sequences
* LAEMIT:
*   Page header added for output
* MTDERI, MTHESS, MTMIG1:
*   Minor bugs corrected, better convergence
* TMMAP:
*   Keep track of kicks in lumps
* TRKEEP:
*   New command TSAVE
* TRMAIN:
*   Hook to call TRKEEP
*
***** CI900831 *****
*
* ERSAVE:
*   Print correct file name in message
* Matching:
*   Make consistent with TWISS, COUPLE
*
***** CI900829 *****
*
* ENSRNG:
*   Better treatment of classes
* ERALCA, ERFICA:
*   Better diagnostics
* ERFIEL:
*   Suppress message about missing RADIUS
* ERMAIN:
*   Hook to call ERSAVE
* ERSAVE:
*   New command ESAVE
* EXORDR:
*   Unused variable IBIAS changed to IDATA
* FLASSI:
*   Variable IQPRT changed to IQPRNT
* FLDUMP, FLLOAD:
*   Provide for saving of tables
* HAVARY, MTVARY:
*   Unused variables eliminated.
* LALUMP:
*   Unused variable SUML
* LMARB:
*   Unused variable EL
* LNCHCK:
*   Make missing line a fatal error
* MTBTIN, MTBTTK:
*   Consider coupling in match
* MTFCN:
*   Correct initialization for MATCH case
* MTFIX:
*   LCVAR changed to LVAR
* MTMIG1:
*   Unused variable GDGSSQ
* PLPLOT, PLPREP:
*   Unused variables NCURV, ICURV
* RDLINE:
*   Call to ZFATAM, not ZFATAL
* RDSTAT:
*   Warning for overrun string
* TBRTFS/TBWTFS:
*   Keep table segmentation information
*   Move table descriptors to begin of table
* TREXEC:
*   Time limit recovery corrected
* TWIBS:
*   Unused variables
* UTGPOS:
*   Unused variable JPOS
*
***** CI900817 *****
*
* COMDECKS:
*   Make use of COMMENT flag consistent.
* MAIN PROGRAM:
*   Phone number updated.
* EMSUMM, FLDELE, UTLOOK:
*   Cleaned up for VAX.
* ENFIX:
*   Corrected dimensions for emittances.
* EXFILL:
*   Check legal use of parameter names.
* MAD, AAOPTS, EXFILL:
*   VERIFY option added.
* EXREFE:
*   Safer test for CONSTANT use.
* ERALIG, ERFIEL:
*   Warning for missing range.
* UTGPOS:
*   Bug correction (clear occurrence counts before search).
* TWISS;
*   Corrected TUNES option for unstable points.
*
***** HG900809 *****
*
*   suppress questions to user when reading from disk file.
*   suppress (m) on curve annotation for dispersion.
*   minor corrections in plot and BMP.
*
***** CI900625 *****
*
* TWBTGO:
*   Use orbit w.r.t. unshifted beam line for summary.
*
* TWCPGO/TWCPPR:
*   Use orbit w.r.t. unshifted beam line for summary.
*   R.m.s. dispersion added.
*   Print orbit summary in mm.
*
***** HG900621 *****
*
* BMSTOR:
*   Add energy, voltage, and phase lag store when calculated.
*
*
***** CI900621 *****
*
* HALONG:
*   Add output of title to avoid mixing HARMON output with output
*   of previous command.
*
* LNSEQ:
*   REFER attribute added.
*
* SVLINE/SVSEQ:
*   REFER attribute added. Element classes now handled correctly.
*
* TBWTFS:
*   Table descriptors moved to end of table.
*
* TWISS:
*   Bank for LINE attribute is now local to Twiss module.
*
* UTGPOS:
*   Element classes now handled correctly.
+EI
+cd aparam
      integer mcfil,mcnam,mcrng,mcstr,mcwrd,mreal,mwflt,mwnam,
     +mbbparam
*---- Double precision version.
      parameter         (mwflt = 2, mcwrd = 4, mreal = 4)
+if doom
      parameter         (mcnam = 24, mwnam = mcnam / mcwrd)
+el
      parameter         (mcnam = 16, mwnam = mcnam / mcwrd)
+ei
      parameter         (mcfil = 80, mcrng = 40, mcstr = 512)
      parameter         (mbbparam = 26)
      integer mttact
      parameter (mttact = 100)
+if comment
*     MWFLT             Number of words for a real.
*     MREAL             Zebra data type for real (single or double).
*     MCNAM             Number of characters for one name:
*                       Integer multiple of MWFLT, = MWNAM*MCWRD.
*     MWNAM             Number of words for a name.
*     MCFIL             Number of characters for a file name.
*     MCRNG             Number of characters in a range name.
*     MCSTR             Number of characters for a string.
*     mbbparam          dimension of parvec for beam-beam elements
*     mttact            max. no. of active sequences, beams, ...
+ei
+cd ablink
      integer laabnk,laacur,laadef,laakey,laanew,laaold,laaprc,laasrc,
     +laastk,laatar

*---- Local links for control module.
      common /aalink/   laabnk, laadef, laasrc, laatar, laakey, laacur,
     +                  laaprc, laastk, laanew, laaold
      save              /aalink/
+if comment
*     LAABNK  (AAATTR)  Bank to be filled.
*     LAADEF  (AAATTR)  Defaults value bank.
*     LAASRC  (AACOPY)  Source bank.
*     LAATAR  (AACOPY)  Target bank.
*     LAAKEY  (AAPMOD)  Current keyword bank.
*     LAACUR  (AAPMOD)  Current element or command bank.
*     LAAPRC  (AAPROC)  Procedure being built.
*     LAASTK  (AARUNS)  Procedure stack during execution.
*     LAANEW  (AASMOD)  New bank to be defined.
*     LAAOLD  (AASMOD)  Old bank to be replaced.
+ei
+cd message

*---- Buffer for error and warning messages.
      common /message/  msg(8)
      save   /message/
      character*120     msg
+if comment
*     MSG(12)           Buffer for up to 8 lines of message.
+ei
+cd bankhead
      integer mbat,mbecls,mbelie,mbemap,mbfrm,mbln,mbnam,mbpr,mbsp

*---- Bias for bank descriptor words.
      parameter         (mbfrm  = 1, mbnam  = 2, mbln   = 3,
     +                   mbpr   = 4, mbsp   = 5, mbat   = 6)
      parameter         (mbemap = 1, mbelie = 2, mbecls = 3)
+if comment
*     Bias for bank description words:
*     MBFRM             Format descriptor.
*     MBNAM             Bank name (directory index).
*     MBLN              Definition line.
*     MBPR, MBSP        Process and subprocess codes.
*     MBAT              Number of attributes, followed by attributes.
*     Bias for element links:
*     NCAT + MBEMAP     Transport map of an element.
*     NCAT + MBELIE     Lie algebraic map of an element.
*     NCAT + MBECLS     Reference link to element class.
+ei
+cd bbcomm
      integer bbd_max, bbd_cnt, bbd_pos, bbd_loc, bbd_flag
      parameter (bbd_max = 200)
      common / bbcommi / bbd_cnt, bbd_pos, bbd_flag, bbd_loc(bbd_max)
      double precision bb_kick
      common / bbcommr / bb_kick(2, bbd_max)
+cd beagroup
      integer mbarad,mbbeta,mbbnum,mbchrg,mbcurr,mbdamp,mbdata,mbener,
     +mbet,mbex,mbexn,mbey,mbeyn,mbfbch,mbfrad,mbfreq,mbgamm,mbmass,
     +mbpart,mbpc,mbpnum,mbsige,mbsigt,mbu0,mbsequ,mbbv

*---- Attribute positions in BEAM bank.
      parameter         (mbpart =  1, mbsequ =  2,
     +                   mbmass =  3, mbchrg =  4,
     +                   mbener =  5, mbpc   =  6, mbgamm =  7,
     +                   mbex   =  8, mbexn  =  9, mbey   = 10,
     +                   mbeyn  = 11, mbet   = 12, mbsigt = 13,
     +                   mbsige = 14, mbbnum = 15, mbpnum = 16,
     +                   mbcurr = 17, mbfbch = 18, mbfrad = 19,
     +                   mbfreq = 20, mbbeta = 21, mbu0   = 22,
     +                   mbarad = 23, mbbv   = 24,
     +                   mbdamp = 25, mbdata = 27)
+cd beam
      integer ietflg,ipnflg, liftbeam,currbeam
      double precision alfa,amass,arad,beta,betas,bunch,bxmax,bymax,
     +charge,cosmux,cosmuy,currnt,deltas,deltat,dtbyds,dxmax,dymax,
     +et,ex,exn,ey,eyn,freq0,gamma,gammas,gamtr,parnum,pc,pdamp,
     +qs,qx,qy,sigdx,sigdy,sige,sigt,sigx,sigxco,sigy,sigyco,sinmux,
     +sinmuy,u0,xcomax,xix,xiy,ycomax,en0,beambv,elkfact,elmfact

*---- Particles, emittances and sigmas.
      integer mfact, mbmult
      parameter (mfact = 50, mbmult = 20)
      common /beanam/   prtnam, bsequnam,
     +                  prtnames(mttact), bseqnames(mttact)
      common /beaflt/   amass, charge, en0, pc, gamma,
     +                  ex, exn, ey, eyn, et, sigt, sige,
     +                  bunch, parnum, currnt
      common /beaaux/   sigx, qx, xix, cosmux, sinmux, bxmax, dxmax,
     +                  xcomax, sigxco, sigdx,
     +                  sigy, qy, xiy, cosmuy, sinmuy, bymax, dymax,
     +                  ycomax, sigyco, sigdy,
     +                  qs, alfa, gamtr, deltas, dtbyds, deltat,
     +                  freq0, beta, u0, arad, beambv, pdamp(3),
     +                  gammas, betas,
     +                  elkfact(mfact), elmfact(0:mbmult)
      common /beaint/   ietflg, ipnflg, liftbeam, currbeam
      save   /beaint/
      common /bealog/   fbch, frad
      save              /beanam/, /beaflt/, /beaaux/, /bealog/
      logical           fbch, frad
      character*(mcnam) prtnam, bsequnam, prtnames, bseqnames
+if comment
* Data from BEAM command:
*     PRTNAM            Alphanumeric particle name.
*     BSEQUNAM          Alphanumeric sequence name for this bank
*     AMASS             Particle mass.
*     CHARGE            Particle charge (multiple of electron charge).
*     EN0               E (total energy) in Gev.
*     PC                p (momentum) Gev / c.
*     GAMMA             Relativistic parameter E / m.
*     EX                Horizontal emittance.
*     EXN               Normalized horizontal emittance.
*     EY                Vertical emittance.
*     EYN               Normalized vertical emittance.
*     ET                Longitudinal emittance.
*     SIGT              Bunch length.
*     SIGE              Energy spread.
*     BUNCH             Number of bunches in the machine.
*     PARNUM            Number of particles per bunch.
*     CURRNT            Beam current in Amps.
* Derived quantities:
*     SIGX              Horizontal beam size.
*     QX                Horizontal tune.
*     XIX               Horizontal chromaticity.
*     COSMUX            Cos(2*pi*Qx).
*     SINMUX            Sin(2*pi*Qx).
*     BXMAX             Maximum beta(x).
*     DXMAX             Maximum D(x).
*     XCOMAX            Maximum x(co).
*     SIGXCO            Sigma x(co).
*     SIGDX             Sigma Dx.
*
*     SIGY              Vertical beam size.
*     QY                Vertical tune.
*     XIY               Vertical chromaticity.
*     COSMUY            Cos(2*pi*Qy).
*     SINMUY            Sin(2*pi*Qy).
*     BYMAX             Maximum beta(y).
*     DYMAX             Maximum D(y).
*     YCOMAX            Maximum y(co).
*     SIGYCO            Sigma y(co).
*     SIGDY             Sigma Dy.
*
*     QS                Synchrotron tune.
*     ALFA              Momentum compaction factor.
*     GAMTR             Gamma(transition).
*     DELTAS            Average energy error.
*     DTBYDS            Orbit length change by unit length.
*     DELTAT            Orbit length change.
*     FREQ0             Revolution frequency for design particle.
*     BETA              Relativistic parameter v / c.
*     U0                Radiation loss per turn in GeV.
*     ARAD              Classical particle radius.
*     BEAMBV            sign of field B times velocity V
*     PDAMP(3)          Damping partition numbers.
*     BETAS, GAMMAS     Relativistic parameters for momentum p_s.

*     IETFLG            1: ET given,       2: SIGT given,  3: SIGE given.
*     IPNFLG            1: BCURRENT given, 2: NPART given.
*     LIFTBEAM          no. of stored beam banks
*     CURRBEAM          # of the current beam bank
*     FBCH              .TRUE. for bunched beam.
*     FRAD              .TRUE. if synchrotron radiation considered.
+ei
+cd bmerrc
      integer nerrat,nerrsc,nerrup
      common /bmerrc/   nerrsc, nerrat, nerrup
      save              /bmerrc/
+if comment
*   NERRSC     error count for BMSYNC  (asin argument)
*   NERRAT     error count for BMVDAT  (acos argument)
*   NERRUP     error count for BMCOUP  (sqrt argument)
+ei
+cd bmparm
      integer mgcmd,micmd,mlcmd,mncmd,mnmbmi,mnmcav,mpbuck,mpclor,
     +mpcoup,mpdelq,mpevar,mpexda,mpi4i2,mpintr,mpkhm,mpmidc,mpnint,
     +mprang,mpsing,mpsynr,mptauq,mptous,mpxbsz,mpybsz,mpytol,mrcmd,
     +msbmpm,msbmrs
      double precision eight,fifty,five,four,half,one,p15d5,p16d0,p17d1,
     +p1d2,p1d3,p1d6,p1d9,p1dm15,p1dm2,p1dm3,p1dm4,p1dm6,p1dm8,p1dm9,
     +p23d0,p25d0,p2dm1,p32d0,p3d6,p55d0,p5dm3,p6d2,p6dm2,p8d2,pfacnb,
     +pfacnq,pfsig,rtodeg,seven,six,sixty,ten,three,twenty,two,twopi,
     +twothd,zero
      parameter      (zero   = 0.0d0,        one    = 1.0d0,
     +                two    = 2.0d0,        three  = 3.0d0,
     +                four   = 4.0d0,        five   = 5.0d0,
     +                six    = 6.0d0,        seven  = 7.0d0,
     +                eight  = 8.0d0,        ten    = 10.0d0,
     +                p16d0  = 16.0d0,       twenty = 20.0d0,
     +                p23d0  = 23.0d0,       p25d0  = 25.0d0,
     +                p32d0  = 32.0d0,       fifty  = 50.0d0,
     +                p55d0  = 55.0d0,       sixty  = 60.0d0,
     +                p1d2   = 1.0d2,        p17d1  = 17.0d1,
     +                p6d2   = 6.0d2,        p8d2   = 8.0d2,
     +                p1d3   = 1.0d3,        p1d6   = 1.0d6,
     +                p3d6   = 3.0d6,        p15d5  = 15.0d5,
     +                p1d9   = 1.0d9,        half   = 0.5d0,
     +                p1dm15 = 1d-15,        p1dm9  = 1.0d-9,
     +                p1dm8  = 1.0d-8,       p1dm6  = 1.0d-6,
     +                p1dm4  = 1.0d-4,       p1dm3  = 1.0d-3,
     +                p1dm2  = 1.0d-2,       p5dm3  = 5.0d-3,
     +                p6dm2  = 6.0d-2,       p2dm1  = 0.2d0    )

      parameter      (pfacnb = 0.40404d0,    pfacnq = 0.31859d0,
     +                pfsig  = 0.804d0                         )

      parameter      (twopi  = two * pi,     rtodeg = 180.0d0 / pi,
     +                twothd = two / three                     )

      parameter      (msbmpm = 2,            msbmrs = 16,
     +                mnmbmi = 80,           mnmcav = 9        )

      parameter      (micmd = 1,             mrcmd = micmd + 10,
     +                mlcmd = mrcmd + 6,     mncmd = mlcmd,
     +                mgcmd = mncmd + 2                        )

      parameter      (mpnint = 1                               )

      parameter      (mpdelq = 1,            mptauq = 2,
     +                mpbuck = 3,            mpcoup = 4,
     +                mpi4i2 = 5,            mpexda = 6,
     +                mpxbsz = 7,            mpybsz = 8,
     +                mpkhm  = 9,            mpytol = 10       )

      parameter      (mpsynr = 1,            mpclor = 2,
     +                mptous = 3,            mpsing = 4,
     +                mpevar = 5,            mpmidc = 6        )

      parameter      (mpintr = 1,            mprang = 2        )

+if comment
*   MSBMPM     no. of structural links in LBMPM
*              1: bank for flag whether variables have been read
*              2: bank for IPOS of cavities
*   MSBMRS     no. of structural links in LBMRS
*              1: bank for average betx values
*              2: bank for average bety values
*              3: bank for x beam radius
*              4: bank for y beam radius
*              5: bank for SIGX*
*              6: bank for SIGY*
*              7: bank for RHOB
*              8: bank for EC (synch. energy loss)
*              9: bank for synch. power
*             10: bank for no. of synch. photons
*             11: bank for BXB (closed orbit amp. factor calc.)
*             12: bank for BYB (        -                     )
*             13: bank for PQ_x (       -                     )
*             14: bank for PQ_y (       -                     )
*             15: bank for PB_x (       -                     )
*             16: bank for PB_y (       -                     )
*   MNMBMI     dimension of BEAMIS, IUBDEF
*   MNMCAV     dimension of IUCDEF

*   MPNINT     pos. of NINT (no. of crossing points)

*   MICMD      end of integers in MAD command BMPM
*   MRCMD      end of reals
*   MLCMD      end of logicals
*   MNCMD      end of names
*   MGCMD      end of ranges

*   MPDELQ     pos. of DELQ rel. to MICMD
*   MPTAUQ     pos. of TAUQ rel. to MICMD
*   MPBUCK     pos. of BUCKET rel. to MICMD
*   MPCOUP     pos. of COUPL rel. to MICMD
*   MPI4I2     pos. of SI4I2 rel. to MICMD
*   MPEXDA     pos. of EXDATA rel. to MICMD
*   MPXBSZ     pos. of FXBEAM rel. to MICMD
*   MPYBSZ     pos. of FYBEAM rel. to MICMD
*   MPKHM      pos. of FCTKHM  rel. to MICMD
*   MPYTOL     pos. of DSPYTL  rel. to MICMD

*   MPSYNR     pos. of SYNRAD rel. to MRCMD
*   MPCLOR     pos. of CLORB rel. to MRCMD
*   MPTOUS     pos. of TOUSCH rel. to MRCMD
*   MPSING     pos. of SINGLE rel. to MRCMD
*   MPEVAR     pos. of EVARY rel. to MRCMD
*   MPMIDC     pos. of MIDARC rel. to MRCMD

*   MPINTR     pos. of interaction point rel. to MNCMD
*   MPRANG     pos. of machine range rel. to MNCMD

+ei
+cd bmpmcm
      integer idcoup,idener,idtauq,iflgbm,ihilim,ihirng,ilolim,ilorng,
     +intrct,irg1,irg2,isup,iubdef,iucdef,lbmpm,lbmrs,lbref1,lbref2,
     +nbmcav,nbmelm,nint
      double precision alamda,amasc2,beamis,bucket,coupl,cvbtrf,cvfill,
     +cvfreq,cvharm,cvleng,cvpow,cvpsi,cvshnt,cvvolt,delq,dspytl,elak1,
     +elak2,elang,ele1d,ele2d,eleng,enerev,energv,exdata,fctkhm,fxbeam,
     +fybeam,game0,power,radius,si4i2,tauq,tauqs
      common /bmpmcm/   lbmpm, lbmrs, lbref1, lbref2
      save              /bmpmcm/
+if comment
*   LBMPM      pointer to internal of BMPM
*              top bank  : positions of elements in total line seq.
*              daughters : see under MSBMPM above
*   LBMRS      pointer to result bank of BMPM
*              daughters : see under MSBMRS above
*   LBREF1     start of reference link area
*   LBREF2     end of reference link area
+ei
      common /bmpmin/   nint, ilolim, ihilim, ilorng, ihirng, intrct,
     +                  irg1, irg2, isup, nbmelm, nbmcav, idener,
     +                  idcoup, idtauq, iflgbm,
     +                  iucdef(mnmcav),iubdef(mnmbmi)
      save              /bmpmin/
+if comment
*--- input (command) parameters
*   NINT       # of crossing points
*   ILOLIM     lower range limit for detail print
*   IHILIM     upper range limit for detail print
*   ILORNG     lower range limit for detail print in element counts
*   IHIRNG     upper range limit for detail print in element counts
*   INTRCT     element number at interaction point
*--- other (local) parameters
*   IRG1       lower range value (from UTBEAM)
*   IRG2       upper range value (from UTBEAM)
*   ISUP       # of super-periods (from UTBEAM)
*   NBMELM     # of elements (in bank LBMPM)
*   NBMCAV     # of cavities (in bank LQ(LBMPM-2))
*   IDENER     0 if energy calc., 1 if user defined
*   IDCOUP     0 if coupling calc., 1 if user defined
*   IDTAUQ     0 if tau_Q calc., 1 if user defined
*   IFLGBM     print flag from UTELEM for current element
*   IUCDEF     0: cav. parameter not defined, 1: defined (/BMPMCV/)
*   IUBDEF     0: BEAMIS value calc., 1: user defined
+ei
      common /bmpmrl/   delq, bucket, si4i2, coupl, tauq,
     +                  exdata, fxbeam, fybeam, fctkhm, dspytl,
     +                  radius, energv, enerev, power, tauqs,
     +                  amasc2, alamda, game0, beamis(mnmbmi)
      save              /bmpmrl/
+if comment
*--- input (command) parameters (or routine)
*   DELQ       delta q = max. beam-beam tune shift (or BMINI2)
*   BUCKET     sigma(b)[bucket half height] / sigma(e)[rel. rms
*              energy spread] (or BMBCON, BMVDAT)
*   SI4I2      user provided value for I4 / I2 (or BMIPAR)
*   COUPL      coupling constant
*   TAUQ       quantum lifetime  [min]
*   EXDATA     if > 0, make Exc = EXDATA (hor. emittance with
*              coupling)
*   FXBEAM     factor for x_beamsize (default = 10.)
*   FYBEAM     factor for y_beamsize (default = 10.)
*   FCTKHM     higher mode loss factor
*   DSPYTL     tolerance for D_y at IP (default 1.e-3)
*--- other (local) parameters
*   RADIUS     machine radius (MAD)
*   ENERGV     energy in GeV (maybe different from ENERGY if EXDATA
*              is given) (MAD or BMMAIN or BMENPW)
*   ENEREV     energy in eV
*   POWER      total RF power  [MW]
*   TAUQS      quantum lifetime [sec]
*   AMASC2     mc**2 [eV]
*   ALAMDA     h_bar/mc [m]
*   GAME0      (current) gamma = E/mc**2 (BMBCON)
*   BEAMIS     beam integrals and other parameters, being
*   Naming convention: _0: at IP, betatron, no coupling
*                      _c: at IP, betatron, coupling
*                      _T: at IP, total
*                                                        set in:
*  1 to 5: I1 to I5                                      BMINTI
*  6, 7:   I6X, I6Y                                        -
*  8, 9:   I7X, I7Y                                        -
*  10:     I7XY                                            -
*  11, 12: I8X, I8Y                                        -
*  13, 14: I9X, I9Y                                        -
*  15:     ZETMAX                                          -
*  16:     I8                                              -
*  17:     SJXD (dJx/ddelta) = -2 * I8 / I2              BMIPAR
*  18:     SJYD (dJy/ddelta = 0 for planar machine)        -
*  19:     SJED (dJe/ddelta = -SJXD for planar machine)    -
*  20:     momentum compaction = I1 / circ   (ALPHFD)      -
*  21:     dE/E = -SI4I2 / SJXD              (DELTAS)      -
*          ( SI4I2 = I4/I2 or user spec.)
*  22:     I4 / I2 (calc. or user specified, in latter     -
*          case I4 calc. from this value)
*  23:     one-turn time [sec]                           BMINI2
*  24:     1 / BEAMIS(23)  [Hz]              (FFIND)       -
*  25:     JX                                            BMCOUP
*  26:     JY                                            BMIPAR
*  27:     JE                                              -
*  28:     beta_x at interaction point       (BHINT)     BMINI2
*  29:     beta_y at interaction point       (BVINT)       -
*  30:     D_x at interaction point          (ETINT)       -
*  31:     D_y at interaction point          (ETAYS)       -
*  32:     total cavity impedance [MOhm]     (SHUNTV)      -
*  33:     higher mode loss factor           (ZHM)         -
*  34:     tau_z                             (TAUZ)        -
*  35:     current [A] given                 (BMCURR)      -
*  36:     RF voltage [V]                    (VRF)         -   , BMCURR
*  37:     radiation loss per turn           (U0PR)      BMBCON
*  38:     damping time tau_x                              -
*  39:     damping time tau_y                              -
*  40:     damping time tau_e                (TAUE)        -
*  41:     sigma_e                           (BMSIGE)      -
*  42:     sig_x_0  [m]                      (SIGXS0)      -
*  43:     sig_y_0  [m]                                    -
*  44:     E_x_0 (emittance) [m]             (RATIO,EX0)   -
*  45:     E_x_c (emittance) [m]             (EXC)       BMCDEP
*  46:     E_x_y (emittance) [m]             (EYC)         -
*  47:     sig_x_c  [m]                      (SIGXSC)      -
*  48:     sig_y_c  [m]                      (SIGYSC)      -
*  49:     sig_x_T  [m]                      (SIGXST)      -
*  50:     sig_y_T  [m]                      (SIGYST)      -
*  51:     bucket half-hight                 (SIGB)      BMBCON
*  52:     sigma for bremstr. losses         (SIGSIG)      -
*  53:     beam-gamma at zero current        (BMGAM0)      -
*  54:     current I_x [A]  calc.            (SIXX)      BMCURR, BMPOWR
*  55:     current I_y [A]  calc.            (SIY)         -
*  56:     n_x (number of stored particles)  (SNX)       BMLUDQ
*  57:     n_y                               (SNY)         -
*  58:     L_x (luminosity)                  (SLX)         -
*  59:     L_y                               (SLY)         -
*  60:     delta_q_x                         (DELQX)       -
*  61:     delta_q_y                         (DELQY)       -
*  62:     calculated delta_q                (DELQC)       -
*  63:     tau_brems [sec]                   (TBREMS)      -
*  64:     beam_gamma                        (BGAM)      BMVOLT, BMVDAT
*  65:     higher mode losses [V]            (VHM)       BMCURR
*  66:     phi_s (stable phase angle)        (PHIS)      BMSYNC
*  67:     sig_z [m]                         (SIGZ)        -
*  68:     nu_s (synchrotron tune)           (SNUS)        -
*  69:     f_s (synchrotron frequency) [Hz]  (FS)          -
*  70:     psi_rf                            (PSI)       BMINI1, BMPOWR
*  71:     beta_rf                           (BETRF)     BMINI1, BMPOWR
*  72:     power [W] calc.                   (PG)        BMCURR->BMPOWR
*  73:     delta_freq [MHz]                  (DFRF)      BMIPAR
*  74:     B_rho [Tm]                        (BRHO)      BMBCON
*  75:     Touschek lifetime [sec]           (TAUH)      BMTALL
*  76:     Polarization time [sec]           (TAUPOL)    BMIPAR
*  77:     SQX for closed orbit amp. fact.   (SQX)       BMINTI
*  78:     SQY for closed orbit amp. fact.   (SQY)       BMINTI
*  79:     SBX for closed orbit amp. fact.   (SBX)       BMINTI
*  80:     SQX for closed orbit amp. fact.   (SQY)       BMINTI
+ei
      common /bmpmel/   eleng, elang, elak1, elak2, ele1d, ele2d
      save              /bmpmel/
+if comment
*--- parameters of current element (Twiss parameters are in OPTIC0)
*   ELENG      length
*   ELANG      bending angle
*   ELAK1      quad. strength
*   ELAK2      sext. strength
*   ELE1D      entrance face angle
*   ELE2D      exit face angle
+ei
      common /bmpmcv/   cvvolt, cvpsi, cvfreq, cvleng, cvbtrf,
     +                  cvpow, cvshnt, cvfill, cvharm
      save              /bmpmcv/
+if comment
*--- parameters of cavities
*   CVVOLT     cavity voltage [MV]
*   CVPSI      tuning angle [rad]
*   CVFREQ     frequency [MHz]
*   CVLENG     length [m]
*   CVBTRF     beta
*   CVPOW      power [MW]
*   CVSHNT     shunt impedance per length [MOhm/m]
*   CVFILL     unloaded filling time [micro-sec]
*   CVHARM     harmonic number
+ei
      common /bmpmlg/   synrad, clorb, tousch, single, evary, polwig,
     +                  midarc, sym
      logical           synrad, clorb, tousch, single, evary, polwig,
     +                  midarc, sym
      save              /bmpmlg/
+if comment
*--- input (command) parameters
*   SYNRAD     treat synchr. rad.
*   CLORB      closed orbit calc.
*   TOUSCH     Touschek integrals requested
*   SINGLE     only one beam
*   EVARY      vary energy until Power(calc) = Power(given)
*   MIDARC     true: bunches of e+ and e- interleaved in cavities,
*              false: bunches coincide (default)
*--- other (local) parameters
*   SYM        symmetry flag (from UTBEAM)
+ei
      common /bmpmch/   chname, chtype, chbvar(mnmbmi)
      save   /bmpmch/
      character*(mcnam) chname, chtype
      character*40      chbvar
+if comment
*--- input (command) parameters
*--- local parameters
*   CHNAME     name of current element (from BMEGET)
*   CHTYPE     type of current element (from BMEGET)
*   CHBVAR     descr. of contents of var. in BEAMIS
+ei
+cd bslash
      character*1       bslash
+if unix
      parameter         (bslash = '\\')
+el
      parameter         (bslash = '\')
+ei
+cd chcode
      integer ichtyp

*---- Character code translation tables.
      common /chcode/   ch2low(0:255), ch2upp(0:255)
      common /chtype/   ichtyp(0:255)
      save              /chcode/, /chtype/
      character*1       ch2low, ch2upp
+if comment
*     CH2LOW(*)         Translation to lower case.
*     CH2UPP(*)         Translation to upper case.
*     ICHTYP(*)         Character type.
+ei
+cd cmdgroup
      integer mcf1,mcf2,mcsiz,mctyp,mcval

*---- Bias for command attribute groups.
      parameter         (mcf1 = 1, mctyp = 2, mcf2 = 3, mcval = 4,
     +                   mcsiz = mwnam + 3)
+if comment
*     MCF1, MCF2         Format control words.
*     MCTYP              Attribute type code.
*     MCVAL              Attribute value.
*     MCSIZ              Length of command attribute group.
+ei
+cd codata
      integer ncor,nmon
      double precision akl,amuxcm,amuycm,betxcm,betycm,dxcm,dycm,halfqx,
     +halfqy,qual,scm,weight,xcm,ycm

*---- Data for current corrector or monitor.
*     Order of variables is important for UCOPY calls.
      common /codata/   xcm, ycm, dxcm, dycm, scm, betxcm, betycm,
     +                  amuxcm, amuycm, akl, halfqx, halfqy,
     +                  qual, weight(2), ncor(2), nmon(2)
      save              /codata/
+if comment
*     XCM               Corrector or monitor reading in X.
*     YCM               Corrector or monitor reading in Y.
*     DXCM              Dispersion in X at monitor.
*     DYCM              Dispersion in Y at monitor
*     SCM               Longitudinal position of centre.
*     BETXCM            Horizontal beta function.
*     BETYCM            Vertical beta function.
*     AMUXCM            Horizontal phase.
*     AMUYCM            Vertical phase.
*     AKL               Integrated quadrupole strength,
*                       or integrated sextupole strength times Dx.
*     HALFQX            (fractional part of Q_x) / 2.
*     HALFQY            (fractional part of Q_y) / 2.
*     QUAL              Allowed tolerance.
*     WEIGHT(2)         Weights for dispersion.
*     NCOR(2)           Number of horizontal and vertical correctors.
*     NMON(2)           Number of horizontal and vertical monitors.
+ei
+cd coesti
      double precision coest,cotol

*---- Estimate for closed orbit search.
      common /coesti/ coest(6), cotol
      save            /coesti/
+if comment
*     COEST(6)        Initial estimate for closed orbit search.
*     COTOL           Tolerance for closed orbit search.
+ei
+cd colink
      integer lcobuf,lcocor,lcoelm,lcomon,lcotab

*---- Links for closed orbit correction module.
      common /colink/   lcotab, lcobuf, lcocor, lcomon, lcoelm
      save              /colink/
+if comment
*     LCOTAB            Pointer to an internal table.
*     LCOBUF            Pointer to a table buffer.
*     LCOCOR            Temporary pointer to corrector detail bank.
*     LCOMON            Temporary pointer to monitor detail bank.
*     LCOELM            Temporary pointer to element detail bank.
+ei
+cd datatype
      integer mtcon,mtdef,mtflt,mtint,mtlin,mtlog,mtnam,mtrng,mtstr,
     +mtvar

*---- Attribute type codes.
      parameter         (mtnam =  1, mtint =  2, mtflt =  3,
     +                   mtdef =  4, mtlog =  5, mtstr =  6,
     +                   mtlin =  7, mtrng =  8, mtcon =  9,
     +                   mtvar = 10)
+cd dclink
      integer ldcatt,ldcbnk,ldcfrm,ldckey,ldclin

*---- Local links for decoder.
      common /dclink/   ldcatt, ldcbnk, ldcfrm, ldckey, ldclin
      save              /dclink/
+if comment
*     LDCATT            Attribute.
*     LDCBNK            Bank to be filled.
*     LDCFRM            Formal parameter list.
*     LDCKEY            Keyword.
*     LDCLIN            LINE keyword.
+ei
+cd dilink
      integer ldinew,ldiold

*---- Local links for decoder.
      common /dilink/   ldinew, ldiold
      save              /dilink/
+if comment
*     LDINEW            New bank to be defined.
*     LDIOLD            Old bank to be replaced.
+ei
+cd dmcommon
+if doom
      integer icleng,idleng,indoom,isvcnt,isvflg,lcc_optsum,lcc_row,
     +lcc_seq,maxbuff,maxch,maxcom,maxord,maxseql,
     +max_delta,max_mult,max_opt,max_seq,mdmelm,mtwcol,
     +mtwscol,mtw_leng,multord,mxdmod,mxdoom,m_align,m_corr,m_field,
     +m_moni,nbanks,nbct,nbklow,nbkup,ndirec,newdb,nfsave,ninfob,nlct,
     +nmult,nshutin,nsleng,nsrv_col,ntw_warn,mxdmxp
      double precision dltime,dmalf,dmamu,dmbet,dmemat,dmgam,dmvals,
     +dm_dbl,optics_summ,optics_tb,refmult,s_pos,dm_suml
      parameter (m_align = 101, m_field = 102, m_corr = 105,
     +m_moni = 115)
      parameter (maxch = 512, mxdmxp=8000,
     +maxcom = 260, maxord = 20, mdmelm = 26, maxseql = 50000,
     +maxbuff = 30000, max_seq = 20,
     +nsrv_col = 7, max_mult = 10000, max_delta = 25, mtwcol = 46,
     +mtwscol = 17, max_opt = 70, mtw_leng = mtwcol*maxseql)
      parameter (mxdoom = 9, mxdmod = 10)
      common / dmicomm / nbanks, ninfob, nlct, nbct, nmult, pos_flag,
     +nbklow, nbkup, indoom, actdoom, clsdoom, elstore, elload,
     +parstore, parload, seqstore, seqload, newdb, isvcnt, ndirec,
     +nfsave, icleng, idleng,  nsleng, nshutin, sqlmark, lcc_seq,
     +lcc_optsum, ntw_warn, opt_col, opt_row, lcc_row, currocct,
     +seq_lng, last_part, curr_pos,
     +isvflg(maxcom), occt(maxseql), multord(max_mult)
      integer actdoom, elstore, elload, parstore, parload, seqstore,
     +seqload, clsdoom, occt, sqlmark, opt_col, opt_row,
     +currocct, pos_flag, seq_lng, last_part, curr_pos
      common / dmlcomm / doomflag, tree, noupdate, dmdict, skipfl,
     +strict
      logical doomflag, tree, noupdate, dmdict, skipfl, strict
      common / dmrcomm / dm_dbl, dm_suml, dltime, dmalf(3,3),
     +dmbet(3,3), dmgam(3,3), dmamu(3), dmvals(maxcom), s_pos(maxseql),
     +dmemat(36), refmult(max_mult),
     +optics_summ(mtwscol, max_delta), optics_tb(mtw_leng)
      common / dmccomm / doom_name, dmsave, seqname, usename, currname,
     +opt_name, opt_table(max_opt),
     +director(maxbuff), elm_nam(maxseql), multname(max_mult)
      character * (maxch) doom_name
      character * (mxdmxp) dmsave
      character * (mcnam) director, seqname, usename, elm_nam, multname,
     +currname, opt_name, opt_table
+ei
+cd elmgroup
      integer meangb,meangg,meangr,mechg,mee1b,mee1g,mee2b,mee2g,meflde,
     +mefrqc,megapb,megapg,meh1b,meh1g,meh2b,meh2g,mehrmc,meintb,meintg,
     +mek1b,mek1g,mek1q,mek2b,mek2s,mek3b,mek3o,mekick,meklm,meksg,
     +mekss,melagc,melen,mesigx,mesigy,metltb,metlte,metltg,metltm,
     +metlto,metltq,metlts,metyp,mevltc,mexcol,mexma,meycol,meyma
      integer meintbx,meintgx,meapro,mek0lm,met0m,mek1lm,met1m,
     +mek2lm,met2m,mek3lm,met3m,meaprm,meapss,melosc,meaprc,mee0l,
     +medel,mephil,mefrql,melosl,mevoll,melagl,meaprl

*---- Bias for element attribute values.
*     These statements MUST be consistent with the command dictionary.
*     Routines using this group must also include BANKHEAD and CMDGROUP.
*     Common to all elements: TYPE and L attributes.
      parameter    (metyp  = mbat   + mcval, melen  = metyp  + mcsiz)
*     Common to RBEND and SBEND.
      parameter    (meangb = melen  + mcsiz, mek1b  = meangb + mcsiz,
     +              mee1b  = mek1b  + mcsiz, mee2b  = mee1b  + mcsiz,
     +              metltb = mee2b  + mcsiz, mek2b  = metltb + mcsiz,
     +              meh1b  = mek2b  + mcsiz, meh2b  = meh1b  + mcsiz,
     +              megapb = meh2b  + mcsiz, meintb = megapb + mcsiz)
      parameter (meintbx = meintb + mcsiz, mek3b  = meintbx + mcsiz)
*     QUADRUPO.
      parameter    (mek1q  = melen  + mcsiz, metltq = mek1q  + mcsiz)
      integer meaprq
      parameter    (meaprq = metltq + mcsiz)
*     SEXTUPOL.
      parameter    (mek2s  = melen  + mcsiz, metlts = mek2s  + mcsiz)
      integer meaprs
      parameter    (meaprs = metlts + mcsiz)
*     OCTUPOLE.
      parameter    (mek3o  = melen  + mcsiz, metlto = mek3o  + mcsiz)
      parameter    (meapro = metlto + mcsiz)
*     MULTIPOL.
      parameter    (mek0lm = melen  + mcsiz, met0m  = mek0lm + mcsiz,
     +              mek1lm = met0m  + mcsiz, met1m  = mek1lm + mcsiz,
     +              mek2lm = met1m  + mcsiz, met2m  = mek2lm + mcsiz,
     +              mek3lm = met2m  + mcsiz, met3m  = mek3lm + mcsiz,
     +              meaprm = melen  + 21*mcsiz)
*     MULTIPOL.
      parameter    (meklm  = melen  + mcsiz, metltm = meklm  + mcsiz)
*     SOLENOID.
      parameter    (mekss  = melen  + mcsiz, meapss = mekss  + mcsiz)
*     RFCAVITY.
      parameter    (mevltc = melen  + mcsiz, melagc = mevltc + mcsiz,
     +              mefrqc = melagc + mcsiz, mehrmc = mefrqc + mcsiz)
      parameter    (melosc = mehrmc + 5*mcsiz,
     +              meaprc = melosc + 3*mcsiz)
*     ELSEPARA.
      parameter    (meflde = melen  + mcsiz, metlte = meflde + mcsiz)
*     Common to SROT and YROT.
      parameter    (meangr = melen  + mcsiz)
*     Common to KICK, HKICK, and VKICK.
      parameter    (mekick = melen  + mcsiz)
*     Common to ECOLLIMA and RCOLLIMA.
      parameter    (mexcol = melen  + mcsiz, meycol = mexcol + mcsiz)
*     BEAMBEAM.
      parameter    (mesigx = melen  + mcsiz, mesigy = mesigx + mcsiz,
     +              mexma  = mesigy + mcsiz, meyma  = mexma  + mcsiz,
     +              mechg  = meyma  + mcsiz)
*     GBEND.
      parameter    (meangg = melen  + mcsiz, mek1g  = meangg + mcsiz,
     +              mee1g  = mek1g  + mcsiz, mee2g  = mee1g  + mcsiz,
     +              metltg = mee2g  + mcsiz, meksg  = metltg + mcsiz,
     +              meh1g  = meksg  + mcsiz, meh2g  = meh1g  + mcsiz,
     +              megapg = meh2g  + mcsiz, meintg = megapg + mcsiz)
*     lcavity.
      parameter    (mee0l  = melen  + mcsiz, medel  = mee0l  + mcsiz,
     +              mephil = medel  + mcsiz, mefrql = mephil + mcsiz,
     +              melosl = mefrql + mcsiz, mevoll = melosl + mcsiz,
     +              melagl = mevoll + mcsiz, meaprl = melagl + mcsiz)
      parameter (meintgx = meintg + mcsiz)
+cd emdata
      double precision cg,sum,sumu0

*---- Communication area for radiation damping.
      common /emdata/   cg, sum(3), sumu0
      save   /emdata/
+if comment
*     CG                Factor r_e gamma^3 / 3.
*     SUM(3)            Sums for emittance calculation.
*     SUMU0             Sum for U0 calculation.
+ei
+cd erdata

*---- Option for additive error components.
      common /erdata/   adderr
      logical           adderr
      save              /erdata/
+if comment
*     ADDERR            If true, error components are additive,
*                       otherwise they are overriding.
+ei
+cd exlink
      integer lexbnk,lexexp,lexpar,lexsub,lexvar

*---- Local links for expression handler.
      common /exlink/   lexbnk, lexexp, lexpar, lexsub, lexvar
      save              /exlink/
+if comment
*     LEXBNK            Expressions's mother bank.
*     LEXEXP            Expression.
*     LEXPAR            PARAMETER keyword.
*     LEXSUB            Subexpression.
*     LEXVAR            Variable reference.
+ei
+cd expgroup
      integer mxf1,mxf2,mxop,mxsiz,mxval

*---- Bias for expression banks.
      parameter         (mxf1 = 1, mxop = 2, mxf2 = 3, mxval = 4,
     +                   mxsiz = mwflt + 3)
+cd express
      integer ixopr,ixsub1,ixsub2,ixsub3,maxexp,nxopr
      double precision rxval

*---- Expression description.
      parameter         (maxexp = 100)
      common /exprsa/   nxopr, ixopr(maxexp),
     +                  ixsub1(maxexp), ixsub2(maxexp), ixsub3(maxexp)
      common /exprsc/   axbank(maxexp), axattr(maxexp)
      common /exprsr/   rxval(maxexp)
      save              /exprsa/, /exprsc/, /exprsr/
      character*(mcnam) axbank, axattr
+if comment
*     NXOPR             Number of operations.
*     IXOPR(I)          Operation type code.
*     IXSUB1(I)         First subscript.
*     IXSUB2(I)         Second subscript.
*     IXSUB3(I)         Third subscript.
*     AXATTR(I)         Attribute name for operand.
*     RXVAL(I)          Constant value.
+ei
+cd exstak
      integer isopr,isval,level,maxstk
      double precision rsval

*---- Stack for expression decoding and evaluation.
      parameter         (maxstk = 100)
      common /exstki/   level, isopr(maxstk), isval(maxstk)
      common /exstkr/   rsval(maxstk)
      save              /exstki/, /exstkr/
+if comment
*     LEVEL             Stack level.
*     ISOPR(I)          Operation type code (Values see FUNDEF).
*     ISVAL(I)          Value type code.
*     RSVAL(I)          Stacked value.
*     0: Constant, 1: Operator, 2: Function, 3: Random.
+ei
+cd fllink
      integer lflbuf,lfltab

*---- Links for closed orbit correction module.
      common /fllink/   lfltab, lflbuf
      save              /fllink/
+if comment
*     LFLTAB            Pointer to an internal table.
*     LFLBUF            Pointer to a table buffer.
+ei
+cd fltable
      integer iost,maxdef,maxfil

*---- Table of I/O streams, files and units.
***** Do not access this table directly from user programs *****
      parameter         (maxdef = 20, maxfil = 50)
      common /fltabc/   iofn(0:maxfil), ioac(0:maxfil), iodr(0:maxfil),
     +                  iofr(0:maxfil), iolc(0:maxfil)
      common /fltabi/   iost(0:maxfil)
      save              /fltabc/, /fltabi/
      character*(mcfil) iofn
      character*1       ioac, iodr,  iofr, iolc
+if comment
*     IOFN(IUNIT)       File name for file IUNIT.
*     IOAC(IUNIT)       'S': sequential, 'D': direct.
*     IODR(IUNIT)       'R': read,       'W': write.
*     IOFR(IUNIT)       'F': formatted,  'U': unformatted.
*     IOLC(IUNIT)       'D': disk,       'T': terminal,    'S': scratch.
*     IOST(IUNIT)       Status flag for file IUNIT.
+ei
+cd fundef
      integer ifun,ipre,narg,nfun

*---- Function definitions for expressions.
      parameter         (nfun = 26)
      common /funnam/   funnam(nfun)
      common /fundat/   ipre(-8:nfun), ifun(nfun), narg(nfun)
      save              /funnam/, /fundat/
      character*(mcnam) funnam
+if comment
*     FUNNAM(I)         Function names.
*     IPRE(I)           Precedence.
*     IFUN(I)           Function type codes:
*                       1: Operator, 2: Function, 3: Random.
*     NARG(I)           Number of arguments.
+ei
+cd hacomm
      double precision ensige,ensigx,ensigy

*---- Communication area for HARMON module.
      common /harchr/   lngnam, shtnam
      common /harflt/   ensigx, ensigy, ensige
      save              /harchr/, /harflt/
      character*(mcnam) lngnam, shtnam
+if comment
*     LNGNAM            Name for "long" table.
*     SHTNAM            Name for "short" table.
*     ENSIGX            Number of horizontal sigmas to be considered.
*     ENSIGY            Number of vertical sigmas to be considered.
*     ENSIGE            Number of longitudinal sigmas to be considered.
+ei
+cd hafbad
      integer mhfun
      double precision hdes,hfac,hfun,hwei

*---- Data for minimization in HARMON.
      parameter         (mhfun = 21)
      common /hafbad/   hdes(mhfun), hfun(mhfun), hwei(mhfun),
     +                  hfac(mhfun)
      save              /hafbad/
+if comment
*     HDES(*)           Desired values of badness functions.
*     HFUN(*)           Achieved values of badness functions.
*     HWEI(*)           Weights for badness functions.
*     HFAC(*)           Factor for badness functions.
+ei
+cd halbuf
      double precision amux1,amux2,amuy1,amuy2,ax1,ax2,ay1,ay2,bx1,bx2,
     +by1,by2,ct1,ct2,delta1,delta2,dpx1,dpx2,dpy1,dpy2,dx1,dx2,dy1,dy2,
     +px1,px2,py1,py2,s1,s2,x1,x2,y1,y2

*---- Buffer for "long" HARMON table: Values at both ends of an element.
      common /halbuf/   bx1, ax1, amux1, by1, ay1, amuy1,
     +                  x1, px1, y1, py1, ct1, delta1,
     +                  dx1, dpx1, dy1, dpy1, s1,
     +                  bx2, ax2, amux2, by2, ay2, amuy2,
     +                  x2, px2, y2, py2, ct2, delta2,
     +                  dx2, dpx2, dy2, dpy2, s2
      save   /halbuf/
+if comment
*     Values at entrance:
*     BX1,AX1,AMUX1     Horizontal beta, alpha, and phase.
*     BY1,AY1,AMUY1     Vertical beta, alpha, and phase.
*     X1,PX1,Y1,PY1,CT1 Horizontal orbit.
*     DELTA1            Momentum error.
*     DX1,DPX1,DY1,DPY1 Dispersion vector.
*     S2                Accumulated length.
*     Values at exit:
*     BX2,AX2,AMUX2     Horizontal beta, alpha, and phase.
*     BY2,AY2,AMUY2     Vertical beta, alpha, and phase.
*     X2,PX2,Y2,PY2,CT2 Horizontal orbit.
*     DELTA2            Momentum error.
*     DX2,DPX2,DY2,DPY2 Dispersion vector.
*     S2                Accumulated length.
+ei
+cd halink
      integer lhalbf,lhaltb,lhasbf,lhastb,mlcol,mscol

*---- Link area for HARMON module.
      parameter         (mlcol = 17, mscol = 12)
      common /halink/   lhaltb, lhalbf, lhastb, lhasbf
      save              /halink/
+if comment
*     MLCOL             Column size for "long" table.
*     MSCOL             Column size for "short" table.
*     LHALTB            Pointer to "long" table.
*     LHALBF            Pointer to current buffer in "long" table.
*     LHASTB            Pointer to "short" table.
*     LHASBF            Pointer to current buffer in "short" table.
+ei
+cd hasbuf
      double precision amuxb,amuyb,bxb,bxbp,byb,bybp,dxb,dxbp,dxbpp,dyb,
     +dybp,dybpp

*---- Buffer for "short" HARMON table: Values averaged over an element.
      common /hasbuf/   bxb, dxb, amuxb, byb, dyb, amuyb,
     +                  bxbp, dxbp, dxbpp, bybp, dybp, dybpp
      save   /hasbuf/
+if comment
*     BXB               Horizontal beta.
*     DXB               Horizontal dispersion.
*     AUMXB             Horizontal phase.
*     BYB               Vertical beta.
*     DYB               Vertical dispersion.
*     AMUYB             Vertical phase.
*     BXBP              Horizontal delta(beta) / beta = B.
*     DXBP              Horizontal delta(disp).
*     AXBPP             Horizontal delta**2(disp).
*     BYBP              Vertical delta(beta) / beta = B.
*     DYBP              Vertical delta(disp).
*     DYBPP             Vertical delta**2(disp).
+ei
+cd header

*---- Page header information.
      common /header/   ctitle, cdate, ctime, nvers, cvers
      save              /header/
      character         ctitle*80, cdate*8, ctime*8, nvers*8, cvers*16
+if comment
*     CTITLE            Page title from TITLE command.
*     CDATE             Date of program run.
*     CTIME             Time of program run.
*     NVERS             Version number.
*     CVERS             Computer and operating system identification.
+ei
+cd keygroup
      integer mkdim1,mkdim2,mkdim3,mkf1,mkf2,mkname,mksiz,mktype

*---- Bias for keyword attribute groups.
      parameter         (mkf1 = 1, mktype = 2, mkdim1 = 3, mkdim2 = 4,
     +                   mkdim3 = 5, mkf2 = 6, mkname = 7,
     +                   mksiz = mwnam + 6)
+if comment
*     MKF1, MKF2         Format control code.
*     MKTYPE             Keyword attribute type code.
*     MKDIM1...MKDIM3    Attribute dimensions.
*     MKNAME             Attribute name.
*     MKSIZ              Size of keyword attribute group.
+ei
+cd keyword
      integer iadim1,iadim2,iadim3,iatype,maxat

*---- Block for current keyword.
      parameter         (maxat = 100)
      common /keywdi/   iatype(maxat),
     +                  iadim1(maxat), iadim2(maxat), iadim3(maxat)
      common /keywdc/   katnam(maxat)
      save              /keywdi/, /keywdc/
      character*(mcnam) katnam
+if comment
*     IATYPE(I)         Data type.
*     IADIM1(I)         First dimension.
*     IADIM2(I)         Second dimension.
*     IADIM3(I)         Third dimension.
*     KATNAM(I)         Attribute names.
+ei
+cd lamaps
      double precision a1m,a2m,bm,bp,fm,fp,gm,gp,hm,hp,pm,pp,tm,tp

*---- Working store for STATIC and DYNAMIC commands.
      common /lamaps/   bp(209), bm(6,6), fp(209), fm(6,6),
     +                  gp(209), gm(6,6), hp(209), hm(6,6),
     +                  pp(209), pm(6,6), tp(209), tm(6,6),
     +                  a1m(6,6), a2m(6,6)
+cd largo
      double precision dq1de1,dq1de2,dq2de2,q1,q2,q3,xi1,xi2,xi3,xin1,
     +xin2,xin3

*---- Global quantities computed by STATIC and DYNAMIC.
      common /largo/    q1, q2, q3, xi1, xi2, xi3, xin1, xin2, xin3,
     +                  dq1de1, dq1de2, dq2de2
      save              /largo/

+if comment
*---- Communication area for LADYNA and LASTAT.
*     Q1                Tune for mode 1.
*     Q2                Tune for mode 2.
*     Q3                Tune for mode 3.
*     XI1               Linear chromaticity for mode 1.
*     XI2               Linear chromaticity for mode 2.
*     XI3               Linear chromaticity for mode 3.
*     XIN1              Non-linear chromaticity for mode 1.
*     XIN2              Non-linear chromaticity for mode 2.
*     XIN3              Non-linear chromaticity for mode 3.
*     DQ1DE1            Normalized anharmonicity for mode 1.
*     DQ1DE2            Normalized anharmonicity for mode 2.
*     DQ2DE3            Normalized anharmonicity for mode 3.
*     DQ1DE2            Normalized cross anharmonicity 1/2.
*     DQ1DE3            Normalized cross anharmonicity 1/3.
*     DQ2DE3            Normalized cross anharmonicity 2/3.
+ei
+cd lingroup
      integer mlact,mlf1,mlf2,mlfm,mlfree,mlhd,mlnxt,mlprv,mlref,mlrep,
     +mlsiz,mltyp

*---- Bias for beam line list information.
      parameter         (mlfm = mbat + 1, mlhd = mbat + 2,
     +                   mlf1 = mbat + 3, mlf2 = mbat + 4,
     +                   mlfree = mbat + 4)
+if comment
*     MLFM              Format control: Rest of bank is integer.
*     MLHD              Bias for list header.
*     MLF1              Bias for first formal (LINE).
*                       Bias for current item (LIST).
*     MLF2              Bias for last formal (LINE).
*                       Current repeat count (LIST).
*     MLFREE            First available cell.
+ei

*---- Bias for beam line list cells.
      parameter         (mltyp = 1, mlprv = 2, mlnxt = 3, mlrep = 4,
     +                   mlref = 5, mlact = 6, mlsiz = 6)
+if comment
*     MLTYP             Cell type.
*     MLPRV             Bias of previous cell.
*     MLNXT             Bias of next cell.
*     MLREP             Repeat count (member cell).
*                       Stack for repeat count (header cell).
*     MLREF             Directory index of bias for member.
*                       Stack for calling cell (header cell).
*     MLACT             Bias for actuals list (member cell).
*                       Directory index of calling line (header cell).
*     MLSIZ             Cell size.
+ei
+cd lnbuff
      integer jtext,lintxt,ltext,ntext

*---- Input line buffer.
      parameter         (ltext = 80)
      common /lnbufc/   text(ltext)
      common /lnbufi/   lintxt, jtext, ntext
      save              /lnbufc/, /lnbufi/
      character*1       text
+if comment
*     TEXT              Contents of last input line read.
*     LINTXT            Number of last input line read.
*     JTEXT             Buffer pointer into TEXT.
*     NTEXT             Length of TEXT array.
+ei
+cd lnlink
      integer llnact,llnbnk,llncal,llneat,llnedr,llnefl,llnesq,llnhed,
     +llnrls,llnrsq,llnsup,llntmp,llnxls,llnxsq

*---- Link area for beam line handler.
      common /lnlink/   llnbnk, llnrls, llnrsq, llnsup,
     +                  llnact, llncal, llnhed, llnxls, llnxsq,
     +                  llnesq, llnedr, llneat, llntmp(4), llnefl
      save              /lnlink/
+if comment
*     LLNBNK  (LNREFE)  Bank containing line reference.
*     LLNRLS  (LNREFE)  Beam line list.
*     LLNRSQ  (LNREFE)  Beam line sequence.
*     LLNSUP  (LNREFE)  Supporting link for LLNRSQ.
*     LLNACT  (LNXPND)  Actual argument list.
*     LLNCAL  (LNXPND)  Called sublist.
*     LLNHED  (LNXPND)  Bank containing list header.
*     LLNXLS  (LNXPND)  LIST keyword.
*     LLNXSQ  (LNXPND)  Beam line sequence.
*     LLNESQ  (LNEDIT)  Sequence being edited.
*     LLNEDR  (LNEDIT)  Directory index bank in edited sequence.
*     LLNEAT  (LNEDIT)  Position bank in edited sequence.
*     LLNEFL  (LNEDIT)  Flag bank for SELECT in seqence edit.
+ei
+cd mapelm
      double precision ek,re,te

*---- Transfer map for current element.
      common /mapelm/   ek(6), re(6,6), te(6,6,6)
      save              /mapelm/
+if comment
*     EK(6)             Element kick.
*     RE(6,6)           Transfer matrix.
*     TE(6,6,6)         Second order terms.
+ei
+cd maptrn
      double precision rt,rtp,tt

*---- Transfer map for complete turn.
      common /maptrn/   rt(6,6), tt(6,6,6), rtp(6,6)
      save              /maptrn/
+if comment
*     RT(6,6)           Transfer matrix.
*     TT(6,6,6)         Second order terms.
*     RTP(6,6)          Derivative of RT w.r.t. delta.
+ei
+cd markbits
      integer mxals,mxcls,mxdef,mxdrp,mxknw,mxlmp,mxmod,mxord

*---- Expression marker bits.
      parameter         (mxdrp = 1, mxdef = 2, mxord = 3,
     +                   mxcls = 4, mxals = 5, mxlmp = 6,
     +                   mxmod = 7, mxknw = 8)
+if comment
*     MXDRP             Bank is to be dropped.
*     MXDEF             Bank represents deferred expression.
*     MXORD             Bank is defined ordinary expression.
*     MXCLS             Bank is class definition, cannot drop.
*     MXALS             Bank is used as a synonym.
*     MXLMP             Marks lump bank, to avoid recursion.
*     MXMOD             Bank is modified.
*     MXKNW             Bank is known to be up to date.
+ei
+cd matgroup
      integer mmbias,mmbnam,mmcode,mmdata,mmf1,mmf2,mmf3,mmold,mmsiz,
     +mmvnam

*---- Bias for variable parameters group.
      parameter         (mmf1   = 1, mmcode = 2, mmbias = 3,
     +                   mmf2   = 4, mmold = 5, mmdata = mmold+mwflt,
     +                   mmf3   = mmdata+4*mwflt, mmbnam = mmf3+1,
     +                   mmvnam = mmbnam+mwnam, mmsiz = mmf3+2*mwnam)
+if comment
*     -1                Pointer to bank containing variable.
*     MMF1, MMF2, MMF3  Format control codes.
*     MMCODE            Code for variation limits:
*                       0 = no limit, 1 = lower, 2 = upper, 3 = both.
*     MMBIAS            Attribute number to be varied in bank.
*     MMOLD             Old parameter value (before matching).
*     MMDATA            Real data: STEP, LOWER, UPPER.
*     MMBNAM            Name of bank containing variable.
*     MMVNAM            Name of attribute to be varied.
*     MMSIZ             Number of data words.
+ei
+cd maxlin
      integer maxlin

*---- Number of lines per print page.
      parameter         (maxlin = 55)
+cd maxmul
      integer maxmul

*---- Maximum order of multipoles.
      parameter         (maxmul = 20)
+cd mchpar
      integer intmax
      double precision epsmch,fltmax,fltmin

*---- Parameters suitable for most computer systems.
      parameter         (epsmch = 1.0d-16)
      parameter         (fltmin = 1.0d-35)
      parameter         (fltmax = 1.0d+35)
      parameter         (intmax = 1000000000)
+if comment
*     EPSMCH            A small number such that 1 + EPSMCH .NE. 1.
*     FLTMIN            Lower limit for reals.
*     FLTMAX            Upper limit for reals.
*     INTMAX            Upper limit for integers.
+ei
+cd memdef
      integer memlen,memmin
+if small
      parameter         (memmin =   50 000)
      parameter         (memlen =  500 000)
+el
      parameter         (memmin =  1600 000)
      parameter         (memlen = 16000 000)
+ei
+ca memory
+cd memdum
      integer memlen,memmin
+if windows
+if small
      parameter         (memmin =   50 000)
      parameter         (memlen =  500 000)
+el
      parameter         (memmin =  1600 000)
      parameter         (memlen = 16000 000)
+ei
+el
      parameter         (memmin =   50 000)
      parameter         (memlen =  500 000)
+ei
+ca memory
+cd memory
      integer llump,lq,lroot
      double precision dq

*---- Memory pool definition.
      common //         fence, lq(mwflt*memlen)
      integer           iq(mwflt*memlen)
      real              fence(2), q(mwflt*memlen)
      dimension         dq(memlen)
      equivalence       (iq(1), q(1), dq(1), lq(9))
      equivalence       (lroot, lq(1)), (llump, lq(2))
+if comment
*     Structural links:
*     LROOT             Root of keyword tree.
*     LLUMP             Root of LUMP stack.
+ei
+cd minuit
      integer icall,icovar,ifirst,ilevel,imode,istrat,ncon,nfcn,nfcnmx,
     +nvar
      double precision edm,fmin,tol,up

*---- Communication area for routines derived from MINUIT.
      common /minchr/   crout, cstat
      common /mindbl/   edm, fmin, tol, up
      common /minint/   icall, icovar, ifirst, imode, ilevel, istrat,
     +                  ncon, nvar, nfcn, nfcnmx
      common /minflt/   time1, time2
      save              /minchr/, /mindbl/, /minint/, /minflt/
      character         crout*8, cstat*16
      real              time1, time2
+if comment
*     CROUT   (char)    Name of current matching command.
*     CSTAT   (char)    Current status of matching.
*     EDM     (real)    Estimated distance to minimum.
*     FMIN    (real)    Best fit found so far.
*     TOL     (real)    Tolerance for current minimization.
*     UP      (real)    Change of penalty function for parameter errors.
*     ICOVAR  (integer) Covariance flag.
*     IMODE   (integer) Matching mode flag.
*     ILEVEL  (integer) Printout level.
*     ISTRAT  (integer) Strategy flag.
*     NCON    (integer) Number of constraints.
*     NVAR    (integer) Number of variables.
*     NFCN    (integer) Number of calls to penalty function done so far.
*     NFCNMX  (integer) Limit for calls to penalty function.
*     ICALL   (integer) Flags limit of calls to penalty function.
*     IFIRST  (integer) Flags first call of penalty function done.
*     TIME1   (real)    Starting time for matching.
*     TIME2   (real)    Ending time for matching.
+ei
+cd mtccon
      integer icc
      double precision cmax,cmin,cval,cwgt

*---- Working area for a single matching constraint.
      common /mtccon/   icc(maxval), cmin(maxval), cmax(maxval),
     +                  cwgt(maxval), cval(maxval)
      save   /mtccon/
+if comment
*     ICC(*)            Operator codes.
*     CMAX(*)           Maximum values.
*     CMIN(*)           Minimum values.
*     CVAL(*)           Actual values.
*     CWGT(*)           Weights.
+ei
+cd mtcflg

*---- Flags for matching.
      common /mtcflg/   flbeta, florb, flrmat, fltmat, flchrm
      save              /mtcflg/
      logical           flbeta, florb, flrmat, fltmat, flchrm
      character *(mcnam)  sequd, betnm
      common / dmatchc / sequd(2), betnm(2)
      integer mtdbfl, imsequ
      common / dmatchi / mtdbfl, imsequ
      logical bdtflg
      common / dmatchl / bdtflg(2)
+if comment
*     FLBETA            .TRUE., if lattice functions are constrained.
*     FLORB             .TRUE., if orbit computation is desired.
*     FLRMAT            .TRUE., if R matrix is constrained.
*     FLTMAT            .TRUE., if T matrix is constrained.
*     FLCHRM            .TRUE., if chromatic functions are constrained.
*     sequd     sequence name(s)
*     betnm     beta0 names as read
*     mtdbfl    no. of sequences to match simultaneously (1 or 2)
*     imsequ    current match sequence (1 or 2)
*     bdtflg    flag if beta0 given
+ei
+cd mtcmtx
      double precision rtdes,rtsav,rtwgt,ttsav

*---- Working area for matrix constraints.
      common /mtcmtx/   rtsav(36), ttsav(216), rtdes(216), rtwgt(216)
      save   /mtcmtx/
+if comment
*     RTSAV(36)         Inverted accumulated R for beginning of range.
*     TTSAV(216)        Inverted accumulated T for beginning of range.
*     RTDES(216)        Desired R or T matrix.
*     RTWGT(216)        Matching weight.
+ei
+cd mtcvar
      integer ivcode
      double precision vmax,vmin,vold,vstep

*---- Working area for a single matching variable.
      common /mtcvar/   vold, vstep, vmin, vmax, ivcode
      save   /mtcvar/
+if comment
*     VOLD              Old variable value before matching.
*     VSTEP             Step size.
*     VMIN              Lower limit.
*     VMAX              Upper limit.
*     IVCODE            Limits code.
+ei
+cd mtglob
      integer iformula,igflag,nuglob,nuloc
      double precision gpesi,gtarget

*---- Communication area for GLOBAL constraints.
      common /mtfrgo/   gtarget(29,2), gpesi(29)
      common /mtirgo/   nuglob, nuloc, igflag(32,2), iformula
      common /mtlrgo/   dynapflag, fixpointfl, statflag
      logical           dynapflag, fixpointfl, statflag
+if comment
*     GTARGET           Target values for global constraints.
*     GPESI             Weights for global constraints.
*     IGFLAG            Integer flags for global constraints.
*     IFORMULA          File number for output during formula matching.
*     DYNAPFLAG         Logical flag for call to DYNAP in MATCH.
*     FIXPOINTFL        Logical flag for fixed point search.
*     STATFLAG          Logical flag for call to STATIC in MATCH.
+ei
+cd mtcwgt
      double precision wgt

*---- Information for matching module.
      common /mtcwgt/   wgt(maxval)
      save              /mtcwgt/
+if comment
*     WGT(*)            Matching weights.
*     MCONF1, MCONF2    Format codes.
*     MCONTP(*)         Constraint types.
*     MCONMN(*)         Minimum values for constraint.
*     MCONMX(*)         Maximum values for constraint.
*     MCONVL(*)         Actual values for constraint.
*     MCONWT(*)         Weights for constraint.
+ei
+cd mtlink
      integer lcon,lmcon,lmtbet,lmtlin,lmtseq,lmtsub,lmvar,lptr,lref,
     +lsmat,lvar,lbeta0

*---- Link area for matching.
      common /mtlink/   lsmat, lmcon, lmvar,
     +                  lmtlin, lmtseq, lmtbet, lbeta0(2), lmtsub,
     +                  lcon, lref, lvar, lptr
      save              /mtlink/
+if comment
*     Structural links:
*     LSMAT             mother of constraint banks parallel to beam lines.
*     LMCON             List of matching contraints.
*     LMVAR             List of matching variables.
*     Reference links:
*     LMTLIN            Expansion of sequence for LINE on MATCH cmd.
*     LMTSEQ            Temporary beam line sequence.
*     LMTBET            Bank for initial values.
*     LMTSUB            Subroutine to be executed during match.
*     LCON              Current constraint bank.
*     LREF              Pointer to bank containing variable.
*     LVAR              Pointer to bank for variable reference.
*     LPTR              Temporary pointer.
+ei
+cd mtpara
      integer maxlin,maxval,mconf1,mconf2,mconmn,mconmx,mcontp,mconvl,
     +mconwt

*---- Parameters for matching module.
      parameter         (maxlin = 16, maxval = 36)
      parameter         (mconf1 = 1, mcontp = 2, mconf2 = maxval + 2)
      parameter         (mconmn = mconf2 + 1)
      parameter         (mconmx = mconmn + maxval * mwflt)
      parameter         (mconvl = mconmx + maxval * mwflt)
      parameter         (mconwt = mconvl + maxval * mwflt)
      integer energy_val, chrom_val
      parameter         (energy_val = 27, chrom_val = 26)
+cd optic0
      double precision alfx0,alfy0,amux0,amuy0,betx0,bety0,circ,ddisp0,
     +disp0,dmux0,dmuy0,orbit0,phix0,phiy0,r0mat,wx0,wy0, ener0

*---- Initial conditions for optical functions.
      common /optic0/   betx0, alfx0, amux0, bety0, alfy0, amuy0,
     +                  orbit0(6), disp0(6),
     +                  wx0, phix0, dmux0, wy0, phiy0, dmuy0,
     +                  ddisp0(6), circ, r0mat(2,2), ener0
      save              /optic0/
+if comment
*     Linear functions:
*     BETX0             Horizontal beta.
*     ALFX0             Horizontal alpha.
*     AMUX0             Horizontal phase.
*     BETY0             Vertical beta.
*     ALFY0             Vertical alpha.
*     AMUY0             Vertical phase.
*     ORBIT0(6)         Closed orbit vector.
*     DISP0(6)          Dispersion vector.
*     Chromatic functions:
*     WX0               Horizontal chromatic amplitude.
*     PHIX0             Horizontal chromatic phase.
*     DMUX0             Horizontal phase'.
*     WY0               Vertical chromatic amplitude.
*     PHIY0             Vertical chromatic phase.
*     DMUY0             Vertical phase'.
*     DDISP0(6)         Derivative of dispersion by delta.
*     Other terms:
*     CIRC              Machine circumference.
*     R0MAT(2,2)        Coupling terms.
+ei
+cd optic1
      double precision alfx,alfy,amux,amuy,betx,bety,ddisp,disp,dmux,
     +dmuy,orbit,phix,phiy,rmat,suml,wx,wy,ener1

*---- Current conditions for optical functions.
      common /optic1/   betx, alfx, amux, bety, alfy, amuy,
     +                  orbit(6), disp(6),
     +                  wx, phix, dmux, wy, phiy, dmuy,
     +                  ddisp(6), suml, rmat(2,2), ener1
      save              /optic1/
+if comment
*     Linear functions:
*     BETX              Horizontal beta.
*     ALFX              Horizontal alpha.
*     AMUX              Horizontal phase.
*     BETY              Vertical beta.
*     ALFY              Vertical alpha.
*     AMUY              Vertical phase.
*     ORBIT(6)          Closed orbit vector.
*     DISP(6)           Dispersion vector.
*     Chromatic functions:
*     DDISP(6)          Derivative of dispersion by delta.
*     WX                Horizontal chromatic amplitude.
*     PHIX              Horizontal chromatic phase.
*     DMUX              Horizontal phase'.
*     WY                Vertical chromatic amplitude.
*     PHIY              Vertical chromatic phase.
*     DMUY              Vertical phase'.
*     Other terms:
*     SUML              Cumulated length.
*     RMAT(2,2)         Coupling terms.
+ei
+cd option
      double precision cofact,optflt

*---- Option flags.
      common /optflt/   optflt(10)
      equivalence       (cofact, optflt( 1))
      common /optint/   optint(10)
      integer           optint
      integer           icmdfl, ideffl, iexpfl, ikeyfl, ilinfl
      equivalence       (icmdfl, optint( 1)), (ideffl, optint( 2))
      equivalence       (iexpfl, optint( 3)), (ikeyfl, optint( 4))
      equivalence       (ilinfl, optint( 5))
      common /optlog/   optflg(20), optcon(5)
      logical           optflg, optcon
      logical           debug,  double, echo,   inter,  trace,  verify,
     +                  warn,   info,   sympl,  rbarc, ereset, bborbit
      logical           reset,  tell
      equivalence       (debug,  optflg( 1)), (double, optflg( 2))
      equivalence       (echo,   optflg( 3)), (inter,  optflg( 4))
      equivalence       (trace,  optflg( 5)), (verify, optflg( 6))
      equivalence       (warn,   optflg( 7)), (info,   optflg( 8))
      equivalence       (sympl,  optflg( 9)), (rbarc,  optflg(10))
      equivalence       (ereset,  optflg(11)),(bborbit,optflg(12))
      equivalence       (reset,  optcon( 1)), (tell,   optcon( 2))
      save              /optflt/, /optint/, /optlog/
+if comment
* Real option value:
*     COFACT            Closed orbit stabilization factor.
* Integer option flags:
*     ICMDFL            Command dump flag.
*     IDEFFL            Definition dump flag.
*     IEXPFL            Expression dump flag.
*     IEXPFL            Line dump flag.
*     IKEYFL            Keyword dump flag.
* Logical option flags:
*     DEBUG             Debug messages about bank manipulation.
*     DOUBLE            Flag for double precision TFS tables.
*     ECHO              Print echo stream.
*     INTER             Running in interactive mode.
*     TRACE             Trace command execution.
*     VERIFY            Verify undefined parameters.
*     WARN              Switch for warning messages.
*     INFO              Switch for information messages.
*     SYMPL             Enforce symplecticity of transfer matrix.
*     RBARC             Convert RBEND length to arc length (default)
*     ERESET            reset energy to original in match, Twiss etc.
* Flags controlling OPTION command:
*     RESET             Reset all options.
*     TELL              List all options.
+ei
+cd pa3lnk
      integer ibot3,itop3,lexp3,lind31,lind32,lprd3

*---- Bookkeeping tables for polynomials of three variables.
      common /pa3lnk/   ibot3(-6:6), itop3(-6:6), lexp3(3),
     +                  lind31, lind32, lprd3
      save              /pa3lnk/
+if comment
*     IBOT3(-6:6)       Lowest  monomial index for order JORD.
*     ITOP3(-6:6)       Highest monomial index for order JORD.
*     LEXP3(3)          Table of exponents in monomials.
*     LIND31, LIND32    Table used to build monomials.
*     LPRD3             Table of products for monomials.
+ei
+cd pa6lnk
      integer ibot6,itop6,larrp,larrq,lexp6,lind61,lind62,lprd6

*---- Bookkeeping tables for polynomials of six variables.
      common /pa6lnk/   ibot6(-6:6), itop6(-6:6), lexp6(6),
     +                  lind61, lind62, larrq, larrp, lprd6
      save              /pa6lnk/
+if comment
*     IBOT6(-6:6)       Lowest  monomial index for order JORD.
*     ITOP6(-6:6)       Highest monomial index for order JORD.
*     LEXP6(6)          Table of exponents in monomials.
*     LIND61, LIND62    Table to build monomials.
*     LARRQ, LARRP      Table to rearrange polynomials.
*     LPRD6             Table of products for monomials.
+ei
+cd physicpm
      double precision amu0,asube,asubp,clight,elamda,emass,eps0,erad,
     +falfa,hbar,plamda,pmass,qelect,mumass

*---- Universal physical constants.
*     Velocity of light [m/s]:
      parameter         (clight = 2.997 924 58 d+08)
*     Permeability of vacuum [V*s/A*m]:
      parameter         (amu0   = 1.256 637 061d-06)
*     Permittivity of vaccum [A*S/V*m]:
      parameter         (eps0   = 8.854 187 817d-12)
*     Reduced Plack's constant [GeV*s]:
      parameter         (hbar   = 6.58211889d-25)

*---- Electromagnetic constants.
*     Elementary charge [A*s]:
      parameter         (qelect = 1.602176462d-19)
*     Fine structure constant [1]:
      parameter         (falfa  = 7.297 353 08 d-03)

*---- Electron.
*     Rest mass [GeV]:
      parameter         (emass  = 0.510998902d-3)
*     Classical radius [m]:
      parameter         (erad   = 2.817940285d-15)
*     Reduced Compton wavelength [m]:
      parameter         (elamda = 3.861 593 23 d-13)
*     Magnetic moment anomaly [1]:
      parameter         (asube  = 1.159 652 193d-03)

*---- Proton.
*     Rest mass [GeV]:
      parameter         (pmass  = 0.938271998d+00)
*     Reduced Compton wavelength [m]:
      parameter         (plamda = 2.103 089 37 d-16)
*     Magnetic moment anomaly [1]:
      parameter         (asubp  = 1.792 847 386d+00)

*---- Muon.
*     Rest mass [GeV]:
      parameter         (mumass  = 0.1056583568d+00)
+cd pi
      double precision pi
      parameter         (pi = 3.141592653589793d0)
+cd plcomm
      integer idsbis,idsfrm,ihpntr,iqrang,irg1,irg2,irpos,itbv,ivpar,
     +ivpntr,laux,lbias,lbuf,lcnt,lexpv,lform,lframe,lhval,lindx,lm1,
     +lm2,locc,lpint,lpmain,lpparl,lproc,lqv1,lrvc,lrvv,ltab,ltbr,ltmp,
     +lvcurv,lvrw,lvsg,lvval,lvvar,nexpvr,nform,nntv,nocc,ntmax,ntvvar,
     +nvvar
      double precision usrv
      common /plcomm/      lpmain, ltbr, lexpv, ltab, lvsg, lvrw, locc,
     +                     lcnt, lproc, lform, lbias, lpint, lm1, lm2,
     +                     ltmp, lframe, lvvar, lvcurv, lhval, lvval,
     +                     lindx, lpparl, lrvv(4), laux(maux), lqv1,
     +                     lrvc(4*mpmxvr), lbuf
      save   /plcomm/
      common /plcoms/ haxis, vaxis, type, table, sparm, title,
     +                plfnam, plpnam, qcond(mxqcnd)
      save   /plcoms/
      character*(mcnam) haxis, type, table, sparm,
     +                  vaxis(mpmxvr,4)
      character*(mtitl) title
      character*(mcstr) qcond, plfnam, plpnam
+if comment
*   HAXIS   var. name of hor. axis
*   VAXIS   var. names of vert. axes
*   TYPE    table type
*   TABLE   table name
*   SPARM   parameter name: for each value of SPARM one picture
*   TITLE   (user) picture title
*   PLFNAM  (user) plotfile name (HIGZ only)
*   PLPNAM  (user) previous (or default) plotfile name (HIGZ only)
*   QCOND   K_x etc. selection conditions for Q_y versus Q_x plot
+ei
      common /plcomp/      nntv(musrv), ntvvar, ihpntr, nocc, nform,
     +                     idsbis(mtbv), idsfrm(mtbv), irg1, irg2, itbv,
     +                     ntmax, nexpvr,
     +                     sortfl, splifl, multfl, fftfl, dumpfl,
     +                     helpfl,
     +                     ivpntr(mpmxvr,4), nvvar(4), ivpar(mxipar),
     +                     irpos(2), iqrang(3,mxqcnd), hrange(2),
     +                     vrange(2,4), qsval
      save   /plcomp/

      real                 hrange, vrange, qsval

      logical              sortfl, splifl, multfl, fftfl, dumpfl, helpfl

      common /plcomd/      usrv(25, musrv)
      save   /plcomd/
+if comment
*   NNTV    no. of user specified values per "range" in USRV
*   NTVVAR  total no. of vert. var.
*   IHPNTR  pointer for horizontal variables into LOCC, LCNT, LPROC
*   NOCC    current length of LOCC, LCNT, LPROC
*   NFORM    current length of LFORM, LBIAS
*   IDSBIS  table biasses for potential parameters
*   IDSFRM  table formats for potential parameters
*   IRG1    first row in table
*   IRG2    last row in table
*   ITBV    table index (1 = Twiss, 2 = tunes, 3 = track, 4 = sitf,
*           5 = any)
*   NTMAX   user max. of |k_x| + |k_y| + |k_s| in Q_plot (Arnold web)
*   SORTFL  sort points in hor. var.
*   SPLIFL  connect points by natural 3rd order spline
*   MULTFL  if true, put all points into one single frame
*   FFTFL   if true, plot FFT spectrum of current frame
*   DUMPFL  dump the plot bank to output rather than plot
*   IVPNTR  pointer for vertical variables into LOCC, LCNT, LPROC
*   NVVAR   no. of vert. var. / vert. axis
*   IVPAR   plot parameters:
*           1 = vertical bar flag
*           2 = line style
*           3 = symbol
*           4 = max. no. of frames per PLOT command
*           5 = colour
*           for defaults see data statement in routine PLGTBS
*   IRPOS   user specified table range in S
*   IQRANG  lower, upper, and step value for QCOND
*   HRANGE  range of hor. var.
*   VRANGE  ranges for vert. axes
*   QSVAL   Q_s

*   USRV    user provided values for DELTAP, PARTICLE, TURNS
+ei
+cd plotcd
      integer icvref,iframe,ipar,ipxval,ipyval,ivnarw,nptval
      common /plotcl/   fpmach
      save   /plotcl/

      logical           fpmach
+if comment
*--- logicals:
*   FPMACH    if true, machine is plotted on top
+ei
      common /plotcr/   yvtop, fdum, chh,
     +vpt(4), window(4,4), actwin(4,4), range(2), xax(2), yax(8)
      save   /plotcr/

      real              yvtop, fdum, chh
      real              vpt, window, actwin, range, xax, yax

+if comment
*--- reals:
*   YVTOP  top value of viewport
*   FDUM   dummy variable
*   CHH    character height

*--- real arrays:
*   VPT    current view port
*   WINDOW window for compound var. I
*   ACTWIN active window for compound var. I
*   RANGE  range variable in get/set axis calls
*   XAX    min. and max. x values for frame call
*   YAX         - " -    y       - " -
+ei
      common /plotci/   iframe, ivnarw,
     +                  ipar(50), nptval(4), ipxval(4), ipyval(4),
     +                  icvref(4)
      save   /plotci/
+if comment
*--- integers:
*   IFRAME    current frame number
*   IVNARW    no. of vertical variable for Arnold web, or 0

*--- integer arrays:
*   IPAR      parameters in get/set axis and curves calls
*   NPTVAL    no. of values per curve (only for frame)
*   IPXVAL    x coord. ref.s
*   IPYVAL    y corrd. ref.s
*   ICVREF    curve parameter set ref.s
+ei
+cd plotcp
      integer maux,maxitp,maxppt,mdsv,mint,mksmax,mntmax,mnvar,mpanno,
     +mpascl,mpbars,mpbtit,mpcolr,mpfelm,mpfont,mpfram,mplscl,mplscw,
     +mpmax,mpmin,mpmxvr,mpname,mpparn,mppcrn,mpsclf,mpspli,
     +mpsscl,mpstyl,mpsymb,mpsymf,mptscl,mpttit,mpvaxr,mpxsiz,mpysiz,
     +mqadd,mtbv,mtitl,musrv,mxdep,mxipar,mxlabl,mxqbnk,mxqcnd

      real              pflmax

      parameter         (mpparn = 11, mppcrn = 170)
      parameter         (mpmxvr = 5,  mxipar = 8, mtitl  = 128)
      parameter         (mxlabl = 40, pflmax = 1.e20)
      parameter         (mtbv = 6, mdsv = 3, musrv = 3)
      parameter         (maxppt = 20000, mnvar = 74, mxdep = 2)
      parameter         (mint = 10, maux = mint + 1, maxitp = 5000)
      parameter         (mxqcnd = 10, mxqbnk = 1000, mqadd = 100000)
      parameter         (mntmax = 20, mksmax = 10)

+if comment
*--- preceding parameters:
*   MPPARN      no. of SEPLOT par., length of bank at IQ(LROOT-MPPARL)
*   MPPCRN      no. of PLOT par.
*   MPMXVR      max. no. of variables / vertical axis
*   MXIPAR      no. of integer plot command parameters IVPAR
*   MTITL       title length in bank
*   MXLABL      max. length of variable plot prescription
*   PFLMAX      used to preset floating variables as "undefined"
*   MTBV        no. of valid tables (TWISS,TUNES,TRACK,SITF,EIGEN,any)
*   MDSV        max. no. of potential parameters + 1
*   MUSRV       no. of user provided ranges (DELTAP, PARTICLES, TURNS)
*   MAXPPT      max. no. of points per frame
*   MNVAR       dimension of arrays for variable names etc.
*   MXDEP       max. no. of dependent variables (PLCOLI, PLGETN, etc.)
*   MINT        no. of variables which are interpolated correctly
*   MAUX        no. of auxiliary banks for interpolation
*   MAXITP      max. no. of additional points in interpolation
*   MXQCND      max. number of QCOND (---> MPPCRN !)
*   MXQBNK      max. length of constrains bank
*   MQADD       constant added to coded variables and operators
*   MNTMAX      max. total of |k_x| + |k_y| + |k_s|
*   MKSMAX      max. total of |k_s|
+ei
      parameter         (mpfont = 1, mpxsiz = 3, mpysiz = 4)
      parameter         (mplscl = 6, mptscl = 8, mpascl = 5)
      parameter         (mplscw = 2, mpsscl = 7, mpfelm = 9)
      parameter         (mpfram = 2, mpmin  = 1, mpmax  = 2)
      parameter         (mpsclf = 3, mpvaxr = 4, mpname = 5)
      parameter         (mpstyl = 1, mpspli = 2, mpbars = 3)
      parameter         (mpsymf = 4, mpcolr = 5, mpsymb = 6)
      parameter         (mpanno = 7)
      parameter         (mpttit = mpname + mtitl / mcwrd)
      parameter         (mpbtit = mpttit + mtitl / mcwrd)

*--- preceding parameters: see LPMAIN description (routine PLPLOT)
+cd prcgroup
      integer mpcor,mpedi,mpelm,mpenv,mperr,mpfil,mphar,mpkey,mplie,
     +mplin,mpmat,mppar,mpplt,mppol,mpsrv,mpstr,mpsub,mpsur,mptrk,
     +mptws,mpdoom

*---- Standard process codes.
      parameter         (mpkey =  1, mppar =  2, mpstr =  3, mpelm =  5,
     +                   mplin =  6)
      parameter         (mpsub = 10)
      parameter         (mpsrv = 11, mpfil = 12, mpenv = 13, mpplt = 14,
     +                   mpsur = 15, mptws = 16, mpmat = 17, mptrk = 18,
     +                   mphar = 19, mperr = 20, mpcor = 21, mplie = 22,
     +                   mpedi = 23, mppol = 24, mpdoom = 25)
+if comment
*     MPKEY             Keyword definition.
*     MPPAR             Parameter definition.
*     MPELM             Element definition.
*     MPLIN             Line and list definition.
*     MPSUB             Subroutine commands.
*     MPSRV             Services.
*     MPFIL             File services.
*     MPENV             Environment commands.
*     MPPLT             Plotting commands.
*     MPSUR             Survey command.
*     MPTWS             Twiss commands.
*     MPMAT             Matching commands.
*     MPTRK             Tracking commands.
*     MPHAR             HARMON command.
*     MPERR             Error definition commands.
*     MPCOR             Correction commands.
*     MPLIE             Lie algebraic commands.
*     MPEDI             Sequence editor commands.
*     MPPOL             Polarization commands.
+ei
+cd quest
      integer iquest

*---- ZEBRA system block: Returns system information.
      common /quest/    iquest(100)
      save              /quest/
+cd range
      integer irg1,irg2,nsup

*---- Communication area for current beam line.
      common /rngchr/   linnam, rngnam
      common /rngint/   irg1, irg2, nsup
      common /rnglog/   symm
      save              /rngchr/, /rngint/, /rnglog/
      character         linnam*(mcnam), rngnam*(mcrng)
      logical           symm
+if comment
*     LINNAM  (char)    Name of matched line.
*     RNGNAM  (char)    Name of matching range.
*     IRG1    (integer) Begin of matching range.
*     IRG2    (integer) End of matching range.
*     NSUP    (integer) Number of superperiods.
*     SYMM    (logical) Symmetry flag.
+ei
+cd ranqzq
      integer irn,maxran,next,nr

*---- Generate pseudo-random integers in batches of NR.
      parameter         (nr = 55)
*     The random integers are generated in the range [0, MAXRAN).
      parameter         (maxran = 1 000 000 000)
      common /ranqzq/   next, irn(nr)
      save              /ranqzq/
+if comment
*     NEXT              The next item to be used in the random sequence.
*     IRN(NR)           A set of "NR" random integers
*                       in the range [0:MAXRAN).
+ei
+cd refer
      integer lcali,lcatt,lccls,lccmd,lccom,lcdef,lcelm,lcexp,lcfld,
     +lckey,lcseq,lcspl,lcsrc,lcvar,ldbnk,ldkey,lref1,lref2,lsali,lscom,
     +lsdir,lsfld,lsflg,lsnum,lsspl,lbeam,lconsm,ldummy

*---- Global reference links.
      common /refer/    lref1,
     +                  lcali, lcatt, lccls, lccmd, lccom, lcdef, lcelm,
     +                  lcexp, lcfld, lckey, lcseq, lcspl, lcsrc, lcvar,
     +                  lbeam, lconsm, ldbnk(4), ldkey(4), ldummy(10),
     +                  lsali, lscom, lsdir, lsfld, lsflg, lsnum, lsspl,
     +                  lref2
      save              /refer/
      integer liftseq, currseq
      common /seqinfi/ liftseq, currseq
      character * (mcnam) sequnam, seqnames
      common /seqinfc/ sequnam, seqnames(mttact)
+if comment
*     LREF1             Begin marker.
*     LCALI             Current misalignment bank.
*     LCCLS             Current class bank.
*     LCCMD             Current command bank.
*     LCCOM             Current corrector or monitor bank.
*     LCDEF             Current default values bank.
*     LCELM             Current element bank.
*     LCEXP             Current expression bank.
*     LCFLD             Current field error bank.
*     LCKEY             Current keyword bank.
*     LCPRC             Current procedure bank while decoding.
*     LCSEQ             Current beam line sequence.
*     LCSPL             Current split pointer.
*     LCSRC             Current source bank for copy or defaults.
*     LCSTK             Current innermost procedure while executing.
*     LCVAR             Current variable reference bank.
*     LBEAM             current beam bank
*     LCONSM            constraint master bank
*     LDBNK(4)          Data bank directory.
*     LDKEY(4)          Keyword directory.
*     LSALI             Bank for misalignment pointer sequence.
*     LSCOM             Bank for corrector and monitor table.
*     LSDIR             Bank for directory index sequence.
*     LSFLD             Bank for field error pointer sequence.
*     LSFLG             Bank for position flag sequence.
*     LSNUM             Bank for occurrence numbers.
*     LSSPL             Bank holding split pointers.
*     LREF2             End marker.
*     liftseq           no. of active sequences (USEd) stored
*     currseq           number of the current sequence (in lcseq)
*     seqnames          names of USEd sequences
*     sequnam           name of current sequence (in lcseq)
+ei
+cd savbuf
      integer isave,isvbuf

*---- Buffer for SAVE and VIEW commands.
      common /svbuff/   savbuf
      common /svinfo/   isave, isvbuf
      save              /svbuff/, /svinfo/
      character*80      savbuf
+if comment
*     SAVBUF            Buffer for one line.
*     ISAVE             Logical unit number for SAVE or VIEW.
*     ISVBUF            Buffer pointer.
+ei
+cd seqflag
      integer mcode,mfrst,mlump,mocc1,mocc2,moptc,mprnt,mrefe,msbet,
     +mscnd,mserr,mtrck

*---- Status flags for sequence group.
      parameter         (mcode = 3, mocc1 = 13, mocc2 = 20,
     +                   mfrst = mcode + 1, mlump = mcode + 2,
     +                   mrefe = mcode + 3, mscnd = mcode + 4,
     +                   moptc = mcode + 5, mprnt = mcode + 6,
     +                   mtrck = mcode + 7, msbet = mcode + 8,
     +                   mserr = mcode + 9)
+if comment
*     MCODE             Bits 1..MCODE contain position code.
*     MOCC1             Bias for occurrence number.
*     MOCC2             Size of occurrence number.
*     MFRST             Dump transfer matrix w.r.t. actual orbit.
*     MLUMP             Dump transfer map for LUMP accumulation.
*     MREFE             Dump transfer matrix w.r.t. ideal orbit.
*     MSCND             Dump complete map w.r.t. actual orbit.
*     MOPTC             Row selection for optics table.
*     MPRNT             Print flag for SURVEY, TWISS etc.
*     MTRCK             Print flag for TRACK.
*     MSBET             Flag for SAVEBETA.
*     MSERR             Flag for error selection.
+ei
+cd seqgroup
      integer msali,msbn,mscom,mscor,msdir,mselm,msf1,msf2,msfld,msflg,
     +mslie,mslnk,msmap,msmon,msnum,msr1,msr2,msref,msrn,mss,msspl,msup,
     +msym

*---- Bias for sequence description banks.
      parameter         (msf1 = 1, msr1 = 2, msr2 = 3, msym = 4,
     +                   msup = 5, msf2 = 6, msbn = 7,
     +                   msrn = msbn + mwnam, mss = msrn + 40 / mcwrd)
*     Links for sequence description banks.
      parameter         (msdir =  1, msflg =  2, msali =  3, msfld =  4,
     +                   msnum =  5, mscom =  6, msmap =  9, mslie = 10,
     +                   msspl = 11, mscor = 12, msmon = 13, mselm = 14)
      parameter         (mslnk = 11, msref = 14)
+if comment
*     MSF1              Format control: 4 integers.
*     MSR1              Index for begin of range.
*     MSR2              Index for end of range.
*     MSYM              Symmetry flag.
*     MSUP              Number of superperiods.
*     MSF2              Format control: 4 names.
*     MSBN              Beam line name.
*     MSRN              Range name.
*     MSS               Number of data words.
*     MSDIR             Bank containing object directory indices.
*     MSFLG             Bank containing position flags.
*     MSALI             Bank containing "misalignment" bank pointers.
*     MSNUM             Bank containing element numbers.
*     MSFLD             Bank containing "field error" bank pointers.
*     MSMAP             Chain of precomputed TRANSPORT maps.
*     MSLIE             Chain of precomputed Lie algebraic maps.
*     MSCOM             Bank containing corrector and monitor table.
*     MSSPL             Bank containing "split" bank pointers.
*     MSLNK             Number of structural links.
*     MSCOR             Chain of corrector details banks.
*     MSMON             Chain of monitor details banks.
*     MSELM             Chain of element details banks.
+ei
+cd status
      integer imodul,iplflg,nfail,nwarn

*---- Status flags (flags which are not under user control).
      common /status/   error,  scan,   nwarn,  nfail, imodul, iplflg,
     +                  inval,  maycpl, stabx,  staby,  stabt,
     +                  newcor, newmap, prompt
      save              /status/
      logical           error,  scan,
     +                  inval,  maycpl, stabx,  staby,  stabt,
     +                  newcor, newmap, prompt
+if comment
*     ERROR             Fatal error in current command.
*     SCAN              Running in scanning mode.
*     NWARN             Counter for warning messages.
*     NFAIL             Counter for fatal error messages.
*     IMODUL            Marks currently active module.
*     IPLFLG            Set to one for first plot.
*     INVAL             Tracking optics with initial values.
*     MAYCPL            Coupling effects detected.
*     STABX             Mode 1 is stable.
*     STABY             Mode 2 is stable.
*     STABT             Mode 3 is stable.
*     NEWCOR            Fill in of MICADO tables required.
*     NEWMAP            Drop precomputed maps.
*     PROMPT            Prompt desired for terminal input.
+ei
+cd stbuff
      integer jtok,lentok,lintok,ntok

*---- Statement input buffer.
      parameter         (lentok = 150000)
      common /stbufc/   token(lentok)
      common /stbufi/   lintok, jtok, ntok
      save              /stbufc/, /stbufi/
      character*1       token
+if comment
*     TOKEN             Contents of current statement.
*     LINTOK            Line number where statement begins.
*     JTOK              Buffer pointer into TOKEN.
*     NTOK              Length of current statement.
+ei
+cd stflag
      integer maxcpf,maxdof

*---- Status flags for TRANSPORT map module.
*     Set to consider everything before each executable command.
      parameter         (maxcpf = 10, maxdof = 10)
      common /stflag/   cpflag(maxcpf), doflag(maxdof)
      logical           cpflag, cplxy, cplxt
      logical           doflag, docav, dorad, doali, dofld, dokick
      logical           dodamp, dorand
      save              /stflag/
      equivalence       (cplxy,  cpflag( 1)), (cplxt,  cpflag( 2))
      equivalence       (docav,  doflag( 1)), (dorad,  doflag( 2))
      equivalence       (doali,  doflag( 3)), (dofld,  doflag( 4))
      equivalence       (dokick, doflag( 5)), (dodamp, doflag( 6))
      equivalence       (dorand, doflag( 7))
+if comment
*     DOCAV             .TRUE.: Consider RF cavities.
*     DORAD             .TRUE.: Consider synchrotron radiation.
*     DOALI             .TRUE.: Consider misalignment errors.
*     DOFLD             .TRUE.: Consider excitation errors.
*     DOKICK            .TRUE.: Consider orbit corrections.
*     DODAMP            .TRUE.: Consider synchrotron damping in track.
*     DORAND            .TRUE.: Consider random effects in radiation.
*     CPLXY             .TRUE.: Transverse coupling detected.
*     CPLXT             .TRUE.: Synchro-betatron coupling detected.
+ei
+cd strgroup
      integer mbeam,mcseq,md,mdbnk,mdexp,mdkey,mdvar,minit,mlr,mls,
     +mrkey,msrseq,mdmtrk,mpparl,mconsm

*---- Link bias in "Great Master Bank".
      parameter         (mls   = 20, mlr   = mls + 20, md = 20)
      parameter         (mdkey =  1, mdbnk =  5, mdexp =  9, mdvar = 10,
     +                   mrkey = 11, mcseq = 12, minit = 13, mbeam = 14,
     +                   mdmtrk = 15, mpparl = 16, mconsm = 17)
      parameter         (msrseq = 1)
+if comment
*     MLR               Total number of links.
*     MLS               Number of structural links.
*     MD                Number of data words.
*     MDKEY             Keyword name directory.
*     MDBNK             Data bank name directory.
*     MDEXP             Expression table.
*     MDVAR             Variable reference table.
*     MRKEY             Root of keyword tree.
*     MCSEQ             bank with all active beam lines.
*     MINIT             Beam line for LINE option.
*     MBEAM             Bank for BEAM data.
*     MDMTRK            DOOM track survival table bias in LROOT
*     MPPARL            no. of structural link in LROOT for SETPLOT data
*     MSRSEQ            Sequence number for subroutine commands.
+ei
+cd synch
*---- Synchrotron integrals, etc.
      common /synch/    synch_1, synch_2, synch_3, synch_4, synch_5,
     +                  blen, rhoinv
      double precision  synch_1, synch_2, synch_3, synch_4, synch_5,
     +                  blen, rhoinv
+cd tbcomm
      integer icurr,itabun,itbbuf,itbfil,itbspc,koff,ltable,ltbbuf,
     +ltbcol,ltbcur,ltbdsc,ltbsav,ltbspc,ltbsum,ltbtab,ltbtmp,nblock,
     +nbout,ncmax,nrbmod

*---- Communication area for table manager routines.
      integer mleng,mnblck,mstep
      parameter         (mnblck=10, mleng=512*mnblck, mstep=100)
      common /tbcomm/   ltable, ltbcol, ltbsum,
     +                  ltbbuf, ltbspc, ltbdsc, ltbtab, ltbcur, ltbsav,
     +                  ltbtmp,
     +                  nblock, nbout, nrbmod, icurr, ncmax, itbspc,
     +                  koff, itbfil, itabun, itbbuf(mleng,2)
      save              /tbcomm/
+if comment
*     LTABLE (struct)   Head of chain for table definitions.
*     LTBCOL            Bank for column expressions in TBLIST.
*     LTBSUM            Bank for sum expressions in TBLIST.
*     LTBBUF (ref)      Working buffer for TBRTFS and TBWTFS.
*     LRBSPC            Pointer to special table.
*     LTBDSC            Temporary pointer to descriptor.
*     LTBCUR            Temporary pointer to table.
*     LTBSAV            Working table for TBCREA and TBOPEN.
*     LTBTAB            Working table for TBRTFS and TBWTFS.
*     LTBTMP            Temporary pointer to buffer.
*     NBLOCK            Number of blocks used.
*     NBOUT             Current block in write buffer.
*     NRBMOD            Flags read buffer, if modified.
*     ICURR             Current block in read buffer.
*     NCMAX             Current last block booked.
*     ITBSPC            Position in special table.
*     KOFF              Current offset.
*     ITBFIL            Initialization flag.
*     ITABUN            Logical unit number for direct access file.
*     ITBBUF(*,K)       Buffer.
+ei
+cd tbhead
      integer icfrm,iclen,maxcol

*---- Table header information.
      parameter         (maxcol = 100)
      common /tbhedc/   cname(maxcol), cform(maxcol)
      common /tbhedf/   icfrm(maxcol), iclen(maxcol)
      save              /tbhedc/, /tbhedf/
      character*20      cname, cform
+if comment
*     CNAME(*)          Column names, or coded data for one line.
*     CFORM(*)          Column format codes in coded form.
*     ICFRM(*)          Column format codes in integer form.
*     ICLEN(*)          Maximum length for strings.
+ei
+cd tbpara
      integer mtbact,mtbbky,mtbbuf,mtbcfm,mtbcnm,mtbcol,mtbcps,mtbdsc,
     +mtbf1,mtbf2,mtbfst,mtblst,mtbmod,mtbnam,mtbrow,mtbseg,mtbsiz,
     +mtbsky,mtbwid

*---- Parameters for table manager bank structure.
      parameter         (mtbact = 1, mtbbuf = 2, mtbmod = 1)
      parameter         (mtbf1  = 1,
     +                   mtbseg = 2, mtbrow = 3, mtbcol = 4, mtbwid = 5,
     +                   mtbf2  = 6,
     +                   mtbnam = 7, mtbsiz = mtbnam + mwnam - 1)
      parameter         (mtbsky = 2, mtbbky = 3, mtbcnm = 4,
     +                   mtbcfm = 5, mtbcps = 6, mtbdsc = 7,
     +                   mtbfst = 8, mtblst = 9)
+if comment
*     Marker bits for various table banks:
*     MTBACT            Status bit for table: Table is active.
*     MTBBUF            Status bit for table: Table has buffers.
*     MTBMOD            Status bit for buffer: Buffer is modified.
*     Data words in main table bank:
*     MTBF1             Format control: 2 integers.
*     MTBSEG            Number of table segments.
*     MTBROW            Number of table rows.
*     MTBCOL            Number of table columns.
*     MTBWID            Length of table buffers in words.
*     MTBF2             Format control: 1 name.
*     MTBNAM            Table name.
*     MTBSIZ            Total number of data words for table bank.
*     Bias for table links:
*     1                 First link is reserved for a bank with
*                       private information for the calling program.
*     MTBSKY            Bank for segment keys.
*     MTBBKY            Bank for buffer keys and links.
*     MTBCNM            Bank for column names.
*     MTBCFM            Bank for column formats.
*     MTBCPS            Bank for column bias.
*     MTBDSC            Chain for table descriptors.
*     MTBFST            Buffer chain.
*     MTBLST            End of buffer chain (reference link).
+ei
+cd thrcom
      integer mmaxel,mwind,ndccnt,ndflag,nditer,ndocc,ndpos,ndtype,
     +nlpos
      double precision admatr,adorbt,adsuml,adtol,orbkpt,reforb,skpt
*--- common block for threader variables
      parameter (mwind = 500, mmaxel = 20000)
      common/thrcml/adthfl, adwofl, adcofl
      logical adthfl, adwofl, adcofl
      common/thrcmi/ndccnt, ndocc, nlpos, nditer,
     +ndpos(mwind), ndtype(mwind), ndflag(mmaxel)
      common/thrcmr/adtol(6), reforb(6), adsuml(mwind),
     +adorbt(6,mwind), admatr(6,6,mwind), orbkpt(6,mmaxel),
     +skpt(mmaxel)
+if comment
*   mwind     size of sliding element window

*   adthfl    if true, use threader
*   adwofl    if true and adthfl, write orbit on file threader.orbit
*   adcofl    true if in routines called from cocorr

*   ndccnt    call flag (counter)
*   ndocc     buffer occupation
*   nditer    after nditer iterations in tmfrst threader switched off
*   ndpos     element position in line (ipos)
*   ndtype    element type
*   ndflag    orbit only checked if flag = 0

*   adtol     tolerances: 1 to 4: orbit (x, px, y, py),
*             5 + 6: lin. independence of successive kickers
*   adsuml    s at element exit
*   adorbt    orbit at element exit
*   admatr    cumulated transfer matrix at element exit
+ei
+cd tmcomm
      double precision cohelp

*---- Communication area for TM module.
*     Positive sign means deflection to negative coordinates.
      common /tmcomm/   cohelp
      save              /tmcomm/
+if comment
*     COHELP            Help factor for c. o. search.
+ei
+cd trdata
      integer iffreq,ipfreq,itrfil,npart,ntrack

*---- Common flags for tracking.
      common /trkchr/   trktitle
      character * 32    trktitle
      common /trkint/   ipfreq, iffreq, npart, ntrack, itrfil
      common /trktim/   time1, time2, dtime
      common /trkflg/   onepss, fdamp, frand, fdynap, fstart, fbelow,
     +                  oneshot
      save              /trkint/, /trktim/, /trkflg/
      real              time1, time2, dtime
      logical           onepss, fdamp, frand, fdynap, fstart, fbelow,
     +                  oneshot
+if comment
*     IPFREQ            Print frequency.
*     IFFREQ            Output frequency for binary file.
*     NPART             Number of particles defined by START commands.
*     NTRACK            Number of particles left for tracking.
*     ITRFIL            Logical unit number for binary track output.
*     TIME1             Starting time.
*     TIME2             End time.
*     DTIME             Time difference.
*     ONEPSS            .TRUE.: Do not normalize.
*     FDAMP             .TRUE.: Consider synchrotron radiation damping.
*     FRAND             .TRUE.: Consider random effects in radiation.
*     FDYNAP            .TRUE.: Doing dynamic aperture
*     FSTART            .TRUE.: DYNAPSTART has been seen.
*     FBELOW            .TRUE.:$Checking below first stable particle.$
*     ONESHOT           .TRUE.: dump first full turn in DOOM
+ei
+cd trdynap
      integer itrturns,ktrturns
      double precision chkbelow,deltax,dtune,dynapfrac,fracmin,smear,
     +trstep,tunx,tuny,wxmax,wxmin,wxstart,wxymax,wxymin,wxystart,wymax,
     +wymin,wystart,yapunov,zendyn,zstart

*---- Communication area for DYNAP command.
      common /trcdyn/   trknam(2)
      character*(mcnam) trknam
      common /trfdyn/   chkbelow, deltax, dtune, dynapfrac, fracmin,
     +                  smear, trstep, tunx, tuny,
     +                  wxmax, wxmin, wymax, wymin, wxymax, wxymin,
     +                  wxstart, wystart, wxystart, yapunov,
     +                  zstart(6), zendyn(6)
      common /tridyn/   itrturns, ktrturns
      common /trldyn/   fastune, lyapflag, orbflag
      logical           fastune, lyapflag, orbflag
      save              /trcdyn/, /trfdyn/, /tridyn/, /trldyn/
+if comment
*     TRKNAM(1)         String name for the tracking METHOD.
*     TRKNAM(2)         String name for the tracking TABLE.
*     CHKBELOW          Fraction of DYNAP for stability check below.
*     DELTAX            Horizontal displacement of Lyapunov companion.
*     DTUNE             Variation of fast tunes over half turns.
*     DYNAPFRAC         Fractional dynamic aperture in terms of ZSTART.
*     FRACMIN           Minimum DYNAPFRAC for downward search.
*     SMEAR             2 * (WXYMAX-WXYMIN) / (WXYMAX+WXYMIN).
*     TRSTEP            Fractional step for reduction of ZSTART.
*     TUNX              Fast tune determined in mode 1.
*     TUNY              Fast tune determined in mode 1.
*     WXMAX,MIN         Max and min betatron invariant for mode 1.
*     WYMAX,MIN         Max and min betatron invariant for mode 2.
*     WXYMAX,MIN        Max and min  WX + WY.
*     WXSTART           Initial betatron invariant for mode 1.
*     WYSTART           Initial betatron invariant for mode 2.
*     WXYSTART          Initial sum of the betatron invariants.
*     YAPUNOV           Lyapunov exponent.
*     ZSTART            Real array of initial values.
*     ZENDYN            Real array of final particle coordinates.
*     ITRTURNS          Initial number of turns for tracking.
*     KTRTURNS          Final number of turns after tracking.
*     FASTUNE           Logical flag for fast tune determination.
*     LYAPFLAG          Logical flag for Lyapunov calculation.
*     ORBFLAG           Logical flag for recalculating closed orbit.
+ei
+cd trlink
      integer ltrbuf,ltrcur,ltrfbf,ltrnoi,ltrnum,ltrobs,ltrrbf,ltrstt,
     +ltrtab,ltrtmp

*---- Links used for tracking.
      common /trlink/   ltrnum, ltrstt, ltrnoi, ltrfbf, ltrrbf, ltrobs,
     +                  ltrcur, ltrtmp, ltrtab, ltrbuf
      save              /trlink/
+if comment
*     Structural links:
*     LTRNUM            Bank for numbers of surviving particles.
*     LTRSTT            Bank for initial conditions.
*     LTRNOI            Linear list of noise records.
*     LTRFBF            Track file buffer.
*     LTRRBF            Track record buffer.
*     LTROBS            Pointer to track tables list.
*     Reference links:
*     LTRCUR            Current noise record.
*     LTRTMP            Pointer to track table list item.
*     LTRTAB            Pointer to track table.
*     LTRBUF            Pointer to current track buffer.
+ei
+cd trndat
      integer maxnoi
      double precision ampl,freq,orig,phas

*---- Data for noise banks.
      parameter         (maxnoi = 20)
      common /trndat/   orig, ampl(maxnoi), freq(maxnoi), phas(maxnoi)
      save   /trndat/
+cd trodat
      integer mobs,morng,mosiz,motab

*---- Parameters for observation points.
      parameter         (mobs = 10)
      parameter         (motab = 1, morng = motab + mwnam)
      parameter         (mosiz = morng + mcrng / mcwrd - 1)
+if comment
*     MOBS              Number of observation points allocated.
*     MOTAB             Table name.
*     MORNG             Encoded range name.
+ei
+cd troptc
      double precision aival,eigen,reval

*---- Initial conditions for optical functions for tracking.
      common /troptc/   eigen(6,6), reval(6), aival(6)
      save              /troptc/
+if comment
*     EIGEN(6,6)        Eigenvectors in start point.
*     REVAL(6)          Real parts of eigenvalues.
*     AIVAL(6)          Imaginary parts of eigenvalues.
+ei
+cd twdata
      integer ndelta

*---- Common for Twiss module.
      common /twchar/   funnam, optnam, sumnam, betnam
      common /twdata/   ndelta, chrom, couple
      save              /twdata/, /twchar/
      character*(mcnam) funnam, optnam, sumnam, betnam
      logical           chrom, couple
+if comment
*     FUNNAM            Name for lattice function table.
*     OPTNAM            Name for OPTICS table.
*     SUMNAM            Name for summary table.
*     BETNAM            Name for BETA0 bank.
*     NDELTA            Number of DELTAP values desired.
*     CHROM             CHROM option flag.
*     COUPLE            COUPLE option flag.
+ei
+cd twlink
      integer ltwbet,ltwbuf,ltwfun,ltwlin,ltwopt,ltwsum

*---- Reference links for lattice function tables.
      common /twlink/   ltwlin, ltwbet, ltwbuf, ltwfun, ltwopt, ltwsum
      save              /twlink/
+if comment
*     Structural link:
*     LTWLIN            Current initial value line (LINE clause).
*     Reference links:
*     LTWBET            Data bank for BETA0 option.
*     LTWBUF            Current buffer bank.
*     LTWFUN            Lattice function table.
*     LTWOPT            OPTICS table.
*     LTWSUM            Summary table (tunes etc.).
+ei
+cd utpgroup
      integer many,mccl,mclos,mlit,mnccl

*---- Parameter group used for pattern matching.
      parameter         (many = 1, mccl = 2, mnccl = 3, mclos = 4,
     +                   mlit = 5)
+cd vargroup
      integer mvattr,mvbank,mvbias,mvf1,mvf2,mvind1,mvind2,mvind3,
     +mvseen,mvsiz

*---- Bias for variable reference group.
      parameter         (mvf1   = 1,
     +                   mvbank = 2,
     +                   mvattr = mvbank + mwnam,
     +                   mvf2   = mvattr + mwnam,
     +                   mvseen = mvf2 + 1,
     +                   mvind1 = mvseen + 1,
     +                   mvind2 = mvind1 + 1,
     +                   mvind3 = mvind2 + 1,
     +                   mvbias = mvind3 + 1,
     +                   mvsiz = mvbias)
+if comment
*     MVF1, MVF2        Format control words.
*     MVBANK            Bank name.
*     MVATTR            Attribute name.
*     MVSEEN            Type of reference: 1=parameter, 2=attribute.
*     MVIND1            First index.
*     MVIND2            Second index.
*     MVIND3            Third index.
*     MVBIAS            Bias of attribute in bank.
*     MVSIZ             Size of variable reference group.
+ei
+cd wstack
      integer iwork,nwork

*---- Working space stack pointers (all in double words).
      common /wstack/   iwork, nwork
      save              /wstack/
+if comment
*     IWORK   (integer) Limit of working space currently used.
*     NWORK   (integer) Limit of working space currently allocated.
+ei
+cd zunit
      integer iqlog,iqpnch,iqpr2,iqprnt,iqread,iqttin,iqtype

*---- Logical unit numbers for ZEBRA system.
      common /zunit/    iqread, iqprnt, iqpr2,  iqlog,  iqpnch,
     +                  iqttin, iqtype
      save              /zunit/
+if comment
*     IQREAD            System input.
*     IQPRNT            Output of DZ package.
*     IQPR2             MAD listings.
*     IQLOG             Input echo and messages.
*     IQPNCH            Punch output (not used in MAD).
*     IQTTIN            Terminal input.
*     IQTYPE            Terminal output.
+ei
+dk mad
      program mad
      implicit none
*----------------------------------------------------------------------*
*                                                                      *
*                           CERN                                       *
*                                                                      *
*     European Organization for Nuclear Research                       *
*                                                                      *
*     Program name: MAD: Methodical Accelerator Design                 *
*                                                                      *
*     Authors and contact:  Hans GROTE, F. Christoph ISELIN            *
*                           SL Division                                *
*                           CERN                                       *
*                           CH-1211 GENEVA 23                          *
*                           SWITZERLAND                                *
*                      Tel. [041] (022) 767 36 57                      *
*                           FCI at CERNVM.BITNET                       *
*                                                                      *
*     Copyright  CERN,  Geneva  1990  -  Copyright  and  any   other   *
*     appropriate  legal  protection  of  this  computer program and   *
*     associated documentation reserved  in  all  countries  of  the   *
*     world.                                                           *
*                                                                      *
*     Organizations collaborating with CERN may receive this program   *
*     and documentation freely and without charge.                     *
*                                                                      *
*     CERN undertakes no obligation  for  the  maintenance  of  this   *
*     program,  nor responsibility for its correctness,  and accepts   *
*     no liability whatsoever resulting from its use.                  *
*                                                                      *
*     Program  and documentation are provided solely for the use  of   *
*     the organization to which they are distributed.                  *
*                                                                      *
*     This program  may  not  be  copied  or  otherwise  distributed   *
*     without  permission. This message must be retained on this and   *
*     any other authorized copies.                                     *
*                                                                      *
*     The material cannot be sold. CERN should be  given  credit  in   *
*     all references.                                                  *
*                                                                      *
*----------------------------------------------------------------------*
+ca aparam
+ca erdata
+ca header
+ca memdef
+ca option
+ca refer
+ca lnlink
+ca status
+ca tmcomm
+ca zunit
+ca ablink
+if doom
+ca dmcommon
+ei
      integer ierr,iloglv,mtbfil
      double precision dipx,dipy,elrad,one,zero
+if doom
      integer iargc,k,lch
+ei

      parameter         (mtbfil = 72)
      parameter         (one = 1.0d0, zero = 0.0d0)

      integer           idate(2), itime(2)
      logical           intrac, vflag
      character*(mcfil) fname
+if doom
      character*80      inp_line
      character*(mcstr) filename
      character*(mcnam) dictname
      data dictname     / 'MAD-8-DICT' /
+ei
+if standard
      character*4       dvers
+ei
      data              vflag / .false. /

*--- set version
      nvers = '8.51/15'

*---- Initialize ZEBRA system and I/O system.
      iloglv = - 2
      call mzebra(iloglv)
      call chinit
      call flinit

+if unix
*---- UNIX Version.
      vflag = .true.
      cvers = 'Unix'
+ei
+if windows
*---- UNIX Version.
      vflag = .true.
      cvers = 'Windows'
+ei

*---- Initialize timer.
      call timest(1.0e9)

*---- Terminal and message files.
      iqlog  = iqtype
      iqprnt = iqlog

*---- Check that version is defined.
      if (.not. vflag) then
        call aafail('MAD', 1,
     +    'Bad compilation: Omitted version selection -- Aborted.')
        call zend
        stop
      endif

*---- File to receive listings.
      iqpr2 = 14
      call flnset('print', fname)
      call fltext(fname, 'W', 0, iqpr2, error)
      if (error) then
        call aafail('MAD', 1, 'Unable to open PRINT stream -- Aborted.')
        call zend
        stop
      endif

*---- Start-up message.
      ctitle = ' '
      call datimh(idate, itime)
      call uhtoc(idate, mcwrd, cdate, 8)
      call uhtoc(itime, mcwrd, ctime, 8)
      write (iqlog, 910) nvers, cvers, cdate, ctime
      call mzvers

*---- Define system banks.
      call aainit

*---- Direct access file for table manager.
      call tbinit(mtbfil)

*---- EPIO package (machine independent binary I/O).
      call epinit

*---- Initialize status information and options.
      adderr = .false.
      inter  = .false.
      echo   = .false.
      trace  = .false.
      warn   = .false.
      info   = .false.
      sympl  = .true.
      rbarc  = .true.
      ereset = .false.
      bborbit= .false.
      prompt = .false.
      verify = .false.
      debug  = .false.
      ikeyfl = 0
      icmdfl = 0
      ideffl = 0
      iexpfl = 0
      ilinfl = 0
      cofact = one

*---- Communication area for TM module.
      cohelp = one
      elrad  = zero
      dipx   = zero
      dipy   = zero
+if doom
      print *,'+++++++++++ MAD - DOOM version +++++++++++'
      filename = ' '
      k = iargc()
      if (k .eq. 0)  then
        print *, ' '
        print *, '== no d.b. file name - fatal =='
        stop
      else
        call getarg(1, filename)
        call dmifile(filename)
*--- d.b. must exist already (including dictionary)
        call doom_setvar('force_old ', 1)
        call dminit
*---- Read command dictionary.
        call aainfo('MAD', 1, 'Reading command dictionary.')
        call dmgline(dictname, inp_line, lch)
        if (lch .le. 2)  then
          print *, inp_line
          print *, '== no MAD-8 dictionary in d.b. - fatal ==', lch
          stop
        endif
        if (inp_line(:4) .ne. nvers(:4)) then
          call aafail('MAD', 1,
     +    'Wrong version of dictionary -- Aborted.')
          call zend
          stop
        endif
*--- set flag to read from dictionary buffer
        dmdict = .true.
        call aamain
*--- reset read flag to normal
        dmdict = .false.
        call dimark(ldkey)
        call dimark(ldbnk)
      endif
+ei
+if standard
*---- Read command dictionary.
      call aainfo('MAD', 1, 'Reading command dictionary.')
      iqread = 11
      call flnset('dict', fname)
      call fltext(fname, 'R', 0, iqread, error)
      if (error) then
        call aafail('MAD', 1, 'Unable to open DICT stream -- Aborted.')
        call zend
        stop
      endif
      read (iqread, '(A4)') dvers
      if (dvers .ne. nvers(1:4)) then
        call aafail('MAD', 1, 'Wrong version of dictionary -- Aborted.')
        call zend
        stop
      endif
      call aamain
      close (unit = iqread, status = 'KEEP', iostat = ierr)
      if (ierr .ne. 0) then
        call aafail('MAD', 1, 'Unable to close DICT stream -- Aborted.')
        call zend
        stop
      endif
      call dimark(ldkey)
      call dimark(ldbnk)
+ei
      echo = .true.
      warn = .true.
      info = .true.

*---- Enter operation phase and call control routine.
      inter = intrac()
      prompt = inter
      iqread = iqttin
+if doom
      call dmgdir(1)
      call dmmain(1)
+ei
      call aainfo('MAD', 1, 'Reading standard input file.')
      call aamain
+if doom
*--- save non-standard items (errors, elements, ...)
      call dmmain(2)
*--- close and save standard items
      call dmclose
+ei
*---- End of program; delete table file.
      close (unit = mtbfil, status = 'DELETE', iostat = ierr)
      call zend

  910 format('1"MAD" Version ',a,a,t51,'Copyright (C) 1990 by CERN.'/
     +       t51,a,5x,a/' '/' Input stream and message log:'/' ')

      end
+dk aaaaaa
+dk aaattr
      subroutine aaattr(ldef, lbank, nnkat, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode attributes for a command or an element definition.          *
* Input:                                                               *
*   LDEF(1)  (pointer)  Pointer to data bank containing defaults.      *
*   LBANK(1) (pointer)  Pointer to data bank to be filled.             *
*   NKAT     (integer)  Number of attributes for keyword.              *
* Output:                                                              *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ic,icase,ichar,ichr,idata,ifrst,ikat,ilast,ind1,ind2,ind3,
     +index,itype,ival,j,jcomma,jfrst,jind,jkat,jlast,jtmp,jtype,leng,
     +nkat,nnkat
      integer           ldef(*), lbank(*)
      logical           eflag
+ca memdum
+ca bankhead
+ca cmdgroup
+ca ablink
+ca chcode
+ca keyword
+ca refer
+ca stbuff
+ca datatype

      character*(mcnam) atrnam
      logical           sflag,  sign

*---- Initialize position counters for first attribute.
*     Assuming that at least one attribute is modified.
      laadef = ldef(1)
      laabnk = lbank(1)
      eflag = .false.
      ikat = 0
      nkat = abs(nnkat)
      ifrst = 1
      ilast = 0
      call aamark('AAATTR', laabnk)

*---- While current token is comma ...
  100 if (token(jtok) .eq. ',') then
        jcomma = jtok
        jtok = jtok + 1

*---- Setup for next attribute. Will be used, if no attribute name seen.
        if (ifrst .gt. ilast) then
          ikat = ikat + 1
          if (ikat .le. nkat) then
            itype = iatype(ikat)
            ilast = ilast + iadim1(ikat) * iadim2(ikat) * iadim3(ikat)
          endif
        endif

*---- Empty field: Update attribute pointer and go to next field.
        if (token(jtok) .eq. ',') then
          ifrst = ifrst + 1
          go to 100
        else if (token(jtok) .eq. ';') then
          go to 9999
        endif

*---- Sign may be part of a flag name.
        sflag = .false.
        sign = token(jtok) .eq. '-'  .or.  token(jtok) .eq. '+'
        if (sign) jtok = jtok + 1

*---- Read attribute name.
        icase = 1
        call rdword(atrnam, leng)

*---- If there is no name, the field must contain data.
        if (leng .eq. 0) then
          jtok = jcomma + 1

*---- Name found. Look for a subscript list.
        else
          if (token(jtok) .eq. '(') then
            jind = jtok
  120       continue
              jtok = jtok + 1
              ic = ichtyp(ichar(token(jtok)))
            if (ic .le. 9  .or.  token(jtok) .eq. ',') go to 120
            if (token(jtok) .eq. ')') then
              jtok = jtok + 1
            else
              jtok = jind
              jind = 0
            endif
          else
            jind = 0
          endif

*---- If next character is not relational or end of field,
*     the field must contain data (probably an expression).
          ichr = index('=><,;', token(jtok))
          if (ichr .eq. 0) then
            jtok = jcomma + 1

*---- We have a name followed by relational or end of field.
*     Test if known attribute name.
          else
            call utlook(atrnam(1:leng), katnam, nkat, jkat)
            if (jkat .eq. 0) then

*---- Name alone is data.
              if (ichr .gt. 3) then
                jtok = jcomma + 1

*---- Exit for special attribute list; resume at comma.
              else if (nnkat .lt. 0) then
                jtok = jcomma
                go to 9999

*---- Unknown name followed by relational is not allowed.
              else
                call rdfail('AAATTR', 1, 'Unknown attribute name.')
                sflag = .true.
              endif

*---- Known attribute name. Decode subscript list, if any.
            else
              if (jind .ne. 0) then
                jtmp = jtok
                jtok = jind
                call dcindx(ind1, ind2, ind3, sflag)
                if (sflag) then
                  sflag = .true.
                else if (ind1 .gt. iadim1(jkat)  .or.
     +                   ind2 .gt. iadim2(jkat)  .or.
     +                   ind3 .gt. iadim3(jkat)) then
                  call rdfail('AAATTR', 1, 'Index out of range.')
                  sflag = .true.
                endif
                jtok = jtmp
              else
                ind1 = 1
                ind2 = 1
                ind3 = 1
              endif

*---- Compute position in bank.
              jlast = 0
              do 130 j = 1, jkat
                jlast = jlast + iadim1(j) * iadim2(j) * iadim3(j)
  130         continue
              jfrst = jlast + (ind1 - iadim1(jkat))
     +          + (ind2 - iadim2(jkat)) * iadim1(jkat)
     +          + (ind3 - iadim3(jkat)) * iadim1(jkat) * iadim2(jkat)

*---- If relational is present, use name and index.
              if (ichr .le. 3) then
                if (sign) then
                  call rdfail('AAATTR', 1, 'Invalid attribute phrase.')
                  sflag = .true.
                endif
                ikat = jkat
                ifrst = jfrst
                ilast = jlast
                itype = iatype(jkat)
                jtok = jtok + 1

*---- Deal with logical type.
              else if (iatype(jkat) .eq. mtlog) then
                ikat = jkat
                ifrst = jfrst
                ilast = jlast
                itype = iatype(jkat)
                icase = 3

*---- Name (possibly subscripted). Look for default.
              else
                idata = mbat + mcsiz * (jfrst - 1)
                jtype = iq(laadef+idata+mctyp)
                if (mod(jtype,10) .ne. 0) then
                  if (sign) then
                    call rdfail('AAATTR',1,'Invalid attribute phrase.')
                    sflag = .true.
                  endif
                  ikat = jkat
                  ifrst = jfrst
                  ilast = jlast
                  itype = iatype(jkat)
                  icase = 2

*---- Anything else must be data.
                else
                  jtok = jcomma + 1
                endif
              endif
            endif
          endif
        endif

*---- ICASE = 1. Following field must be data.
        if (.not. sflag) then
          if (icase .eq. 1) then
            if (ikat .le. nkat) then
              call dcattr(itype, laabnk, ifrst, ilast, sflag)

*---- Exit for special attribute list; resume at comma.
            else if (nnkat .lt. 0) then
              jtok = jcomma
              go to 9999

*---- Storing beyond end of bank.
            else
              call rdfail('AAATTR', 1,
     +        'Attempt to store beyond last attribute.')
              sflag = .true.
            endif

*---- ICASE = 2. Copy default value for this field.
          else if (icase .eq. 2) then
            call aacopy(laadef, ifrst, laabnk)
            ifrst = ifrst + 1

*---- ICASE = 3. Decode logical flag.
          else if (icase .eq. 3) then
            idata = mbat + mcsiz * (ifrst - 1)
            ival = 0
            if (token(jcomma+1) .ne. '-') ival = 1
            iq(laabnk+idata+mctyp) = 10 * mtlog + 1
            iq(laabnk+idata+mcval) = ival
            ifrst = ifrst + 1
          endif
        endif

*---- After an error try to skip to next field.
        if (sflag) then
          eflag = .true.
          call rdfind(',;')
        endif
        go to 100
      endif

*---- End of attribute list.
      if (token(jtok) .ne. ';') then
        call rdfail('AAATTR', 1, 'Semicolon ";" expected.')
        eflag = .true.
      endif

 9999 end
+dk aabook
      subroutine aabook(lbank, label, ipr, isp, lkey, ilink)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Book new command or parameter bank and link it to keyword bank.    *
*   Requires that the keyword common blocks are loaded first.          *
* Input:                                                               *
*   LABEL    (char)     Name for new bank.                             *
*   IPR      (integer)  Process code.                                  *
*   ISP      (integer)  Subprocess code.                               *
*   LKEY(1)  (pointer)  Pointer to current keyword.                    *
*   ILINK    (integer)  Link bias in keyword bank.                     *
* Output:                                                              *
*   LBANK(1) (pointer)  Pointer to new command bank.                   *
*----------------------------------------------------------------------*
+ca aparam
      integer idata,ikat,ilink,ipr,isp,j,ncat,nd,nkat,nr,ns
      character*(*)     label
      integer           lbank(*), lkey(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca keyword
+ca refer
+ca stbuff
+ca datatype

      character*4       name

*---- Count command attributes.
      nkat = iq(lkey(1)+mbat)
      ncat = 0
      do 10 j = 1, nkat
        ncat = ncat + iadim1(j) * iadim2(j) * iadim3(j)
   10 continue

*---- Set up data and link counters.
      nd = mbat + ncat * mcsiz
      ns = ncat
      nr = ncat
      if (ipr .eq. mpelm) then
        ns = ncat + mbelie
        nr = ncat + mbecls
      endif

*---- Lift bank, link it to keyword, and mark it as modified.
      name = label
      call mzbook(2, lbank, lkey, -ilink, name, nr, ns, nd, 0, 0)
      call aamark('AABOOK', lbank)

*---- Store bank description.
      iq(lbank(1)+mbfrm) = 16 * 5 + 2
      iq(lbank(1)+mbnam) = 0
      iq(lbank(1)+mbln) = lintok
      iq(lbank(1)+mbpr) = ipr
      iq(lbank(1)+mbsp) = isp
      iq(lbank(1)+mbat) = ncat

*---- Format control words and data types.
      idata = mbat
      do 90 ikat = 1, nkat
        nd = iadim1(ikat) * iadim2(ikat) * iadim3(ikat)
        do 80 j = 1, nd
          iq(lbank(1)+idata+mcf1) = 16 * 1 + 2
          iq(lbank(1)+idata+mctyp) = 10 * iatype(ikat)
          if (iatype(ikat) .eq. mtnam) then
            iq(lbank(1)+idata+mcf2) = 16 * mwnam + 5
            call vblank(iq(lbank(1)+idata+mcval), mwnam)
          else if (iatype(ikat) .eq. mtflt  .or.
     +             iatype(ikat) .eq. mtdef) then
            iq(lbank(1)+idata+mcf2) = 16 * mwnam + mreal
          else
            iq(lbank(1)+idata+mcf2) = 16 * mwnam + 2
          endif
          idata = idata + mcsiz
   80   continue
   90 continue

      end
+dk aacmnd
      subroutine aacmnd(label, key)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode complete command.                                           *
*   Uses the pointers to current keyword and current command.          *
* Input:                                                               *
*   LABEL    (char)     Name of command bank.                          *
*   KEY      (char)     Name of keyword bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer icat,iln,ipr,isp,ncat,nkat
      character*(mcnam) label, key
+ca memdum
+ca bankhead
+ca refer
+ca status
+ca stbuff

      logical           new

*---- Copy keyword to local storage.
      call kwget(lckey, iln, ipr, isp, nkat)

*---- Build new command bank, if not already done.
      new = .false.
      if (lccmd .eq. 0) then
        new = .true.
        call aabook(lccmd, label, ipr, isp, lckey, 1)

*---- Copy default attributes, if a subclass is being defined.
        if (lccls .ne. 0) then
          ncat = iq(lccmd+mbat)
          do 10 icat = 1, ncat
            call aacopy(lccls, icat, lccmd)
   10     continue
        endif
      endif

*---- Decode attributes.
      if (token(jtok) .ne. ';') then
        new = .true.
        call aaattr(lq(lckey-2), lccmd, nkat, error)
      endif

*---- If all OK, link command bank to directory.
      if (error) then
        call aadrop(lccmd)
      else if (new) then
        call didefi(ldbnk, label, lccmd)
      endif

      end
+dk aacopy
      subroutine aacopy(lsrc, ilink, ltar)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Copy one attribute of a command bank and link expressions etc.     *
* Input:                                                               *
*   LSRC(1)   (pointer) Source bank.                                   *
*   ILINK     (integer) Attribute number.                              *
*   LTAR(1)   (pointer) Target bank.                                   *
*----------------------------------------------------------------------*
+ca aparam
      integer idata,idsrc,idtar,ilink,ilsrc,iltar,itype
      integer           lsrc(*), ltar(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca ablink
+ca refer
+ca datatype

*---- Both banks must exist.
      laasrc = lsrc(1)
      laatar = ltar(1)
      if (laasrc .eq. 0  .or.  laatar .eq. 0) go to 9999

*---- Banks must be large enough.
      idata = mbat + mcsiz * (ilink - 1)
      idsrc = iq(laasrc-1)
      idtar = iq(laatar-1)
      ilsrc = iq(laasrc-2)
      iltar = iq(laatar-2)
      if (idata .ge. idsrc  .or.  ilink .gt. ilsrc) go to 9999
      if (idata .ge. idtar  .or.  ilink .gt. iltar) go to 9999

*---- Copy only if this field has been set.
      itype = iq(laasrc+idata+mctyp)
      if (mod(itype,10) .eq. 0) go to 9999

*---- Copy data block.
      call ucopy(q(laasrc+idata+1), q(laatar+idata+1), mcsiz)

*---- Drop previous dependent bank(s).
      if (lq(laatar-ilink) .ne. 0) then
        lcatt = lq(laatar-ilink)
        call aadrop(lcatt)
      endif

*---- Duplicate new dependent bank(s).
      if (lq(laasrc-ilink) .ne. 0) then
        lcatt = lq(laasrc-ilink)
        call mzcopy(2, lcatt, 2, ltar, -ilink, 'Z')

*---- Expressions for real data.
        lcatt = lq(laatar-ilink)
        if (itype .eq. 10 * mtflt + 2  .or.
     +      itype .eq. 10 * mtflt + 3) then
          lcexp = lcatt
          call exlkex

*---- Expressions for constraints.
        else if (itype .eq. 10 * mtcon + 1) then
          lcexp = lq(lcatt-1)
          if (lcexp .ne. 0) then
            call exlkex
          endif
          lcexp = lq(lcatt-2)
          if (lcexp .ne. 0) then
            call exlkex
          endif

*---- Variable references.
        else if (itype .eq. 10 * mtvar + 1) then
          lcvar = lcatt
          call exlkvr
        endif
      endif

 9999 end
+dk aadrop
      subroutine aadrop(lbank)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Drop a data bank.                                                  *
*   Clean out expression and variable directories.                     *
* Input:                                                               *
*   LBANK(1) (pointer)  Pointer to bank to be dropped.                 *
* Output:                                                              *
*   LBANK(1) (pointer)  Zero.                                          *
*----------------------------------------------------------------------*
+ca aparam
      integer jbit,jexp,jlast,jvar,lexp,lvar,nexp,nvar
      integer           lbank(*)
+ca memdum
+ca markbits
+ca strgroup

*---- Mark data structure to be dropped.
      if (lbank(1) .eq. 0) go to 9999
      if (jbit(iq(lbank(1)),mxcls) .ne. 0) go to 9999
      call mzflag(0, lbank, mxdrp, '.')

*---- Remove marked expression banks.
*     Warning: LEXP is local link. No Zebra calls allowed in DO loop!
      nexp = iq(lq(lroot-mdexp)+1)
      jlast = 0
      do 90 jexp = 1, nexp
        lexp = lq(lq(lroot-mdexp)-jexp)
        if (jbit(iq(lexp),mxdrp) .eq. 0) then
          jlast = jlast + 1
          lq(lq(lroot-mdexp)-jlast) = lexp
        endif
   90 continue
      if (jlast .lt. nexp) then
        iq(lq(lroot-mdexp)+1) = jlast
        iq(lq(lroot-mdexp)+2) = 0
      endif

*---- Remove marked variable references.
*     Warning: LVAR is local link. No Zebra calls allowed in DO loop!
      nvar = iq(lq(lroot-mdvar)+1)
      jlast = 0
      do 190 jvar = 1, nvar
        lvar = lq(lq(lroot-mdvar)-jvar)
        if (jbit(iq(lvar),mxdrp) .eq. 0) then
          jlast = jlast + 1
          lq(lq(lroot-mdvar)-jlast) = lvar
        endif
  190 continue
      if (jlast .lt. nvar) then
        iq(lq(lroot-mdvar)+1) = jlast
      endif

*---- Now drop data structure.
      call mzdrop(0, lbank, '.')
      lbank(1) = 0

 9999 end
+dk aadump
      subroutine aadump(lbank)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Dump a complete command or parameter bank.                         *
* Input:                                                               *
*   LBANK(1) (pointer)  Bank pointer.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ibdata,ic,idim1,idim2,idim3,ikat,ikdata,ilen,itype,ival,
     +j1,j2,j3,jtype,l,lbnk,lkey,nkat
      double precision rval
      integer           lbank(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca keygroup
+ca refer
+ca zunit

      character*(mcnam) atrnam, label
      character*1       atype(10)
      character*(mcstr) string
      logical           lval
      data atype / 'N', 'I', 'R', 'D', 'L', 'S', 'B', 'R', 'C', 'V' /

*---- Print header information.
      call diname(ldbnk, iq(lbank(1)+mbnam), label)
      write (iqlog, 910) label,
     +  iq(lbank(1)+mbln), iq(lbank(1)+mbpr), iq(lbank(1)+mbsp)

*---- Get keyword attributes.
*     Warning: LKEY and LBNK are local links.
*              No ZEBRA calls should be made after this point.
      lbnk = lbank(1)
      lkey = lq(lbnk+1)
      if (iq(lkey+mbat) .gt. 0) then
        write (iqlog, 920)
        ikdata = mbat
        ibdata = mbat
        ic = 0
        nkat = iq(lkey+mbat)
        do 190 ikat = 1, nkat

*---- Data from keyword bank.
          itype = iq(lkey+ikdata+mktype)
          idim1 = iq(lkey+ikdata+mkdim1)
          idim2 = iq(lkey+ikdata+mkdim2)
          idim3 = iq(lkey+ikdata+mkdim3)
          call uhtoc(q(lkey+ikdata+mkname), mcwrd, atrnam, mcnam)
          ikdata = ikdata + mksiz
          write (iqlog, 930) atrnam, atype(itype), idim1, idim2, idim3

*---- Data from command or definition bank.
          do 180 j3 = 1, idim3
          do 180 j2 = 1, idim2
          do 180 j1 = 1, idim1
            ic = ic + 1
            jtype = iq(lbnk+ibdata+mctyp)
*                  NAM INT FLT DEF LOG STR LIN RNG CON VAR
            go to (10, 20, 30, 40, 50, 60, 70, 80, 90, 100), itype
            go to 170
   10       continue
              call utgnam(lbnk, ic, ic, atrnam)
              write (iqlog, 940) ic, j1, j2, j3, jtype, atrnam
            go to 170
   20       continue
              ival = iq(lbnk+ibdata+mcval)
              write (iqlog, 950) ic, j1, j2, j3, jtype, ival
            go to 170
   30       continue
   40       continue
              call ucopy(q(lbnk+ibdata+mcval), rval, mwflt)
              write (iqlog, 960) ic, j1, j2, j3, jtype, rval
            go to 170
   50       continue
              lval = iq(lbnk+ibdata+mcval) .ne. 0
              write (iqlog, 970) ic, j1, j2, j3, jtype, lval
            go to 170
   60       continue
              call utgstr(lbnk, ic, ic, string)
              ilen = min(iq(lbnk+ibdata+mcval), mcstr)
              write (iqlog, 980) ic, j1, j2, j3, jtype, ilen
              do 65 i = 1, ilen, 80
                l = min(ilen, i + 79)
                write (iqlog, 985) string(i:l)
   65         continue
            go to 170
   70       continue
   80       continue
   90       continue
  100       continue
  170       continue
            ibdata = ibdata + mcsiz
  180     continue
  190   continue
        write (iqlog, 990)
      endif

  910 format(' '/' AADUMP.  Command name:     ',a/
     +       t11,'Definition line:  ',i8/
     +       t11,'Process code:     ',i8/
     +       t11,'Subprocess code:  ',i8)
  920 format(' '/t11,'Attribute',t23,'Type',t36,'Dim 1',t48,'Dim 2',
     +       t60,'Dim 3')
  930 format(t11,a,t24,a1,t36,i5,t48,i5,t60,i5)
  940 format(t11,5i5,5x,a)
  950 format(t11,5i5,5x,i8)
  960 format(t11,5i5,5x,1pe16.8)
  970 format(t11,5i5,5x,l8)
  980 format(t11,6i5,5x,i8)
  985 format(t11,a)
  990 format(' ')

      end
+dk aaelem
      subroutine aaelem(label, key)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode element definition.                                         *
*   Uses the pointers to current keyword and current command.          *
* Input:                                                               *
*   LABEL    (char)     Name of element bank.                          *
*   KEY      (char)     Name of keyword bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer icat,idata,il,ileng,iln,iord,ipr,isp,jbit,lmap,ncat,nkat,
     +ns
      double precision fm,fp
      character*(mcnam) label, key
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca markbits
+ca message
+ca lnlink
+ca maptrn
+ca optic1
+ca option
+ca pa6lnk
+ca refer
+ca status
+ca stbuff
+ca datatype

      dimension         fm(6,6), fp(923)

*---- Copy keyword to local storage.
      call kwget(lckey, iln, ipr, isp, nkat)

*---- Set up for copy, if an alias is being updated.
      if (lccmd .ne. 0  .and.  token(jtok) .ne. ';') then
        if (jbit(iq(lccmd),mxals) .ne. 0) then
          lccls = lccmd
          lccmd = 0
        endif
      endif

*---- Build new element bank if required.
      if (lccmd .eq. 0) then
        call aabook(lccmd, label, ipr, isp, lckey, 1)

*---- Find class object, if not already known.
        if (lccls .eq. 0) lccls = lq(lckey-3)

*---- Copy attributes of class.
        ncat = iq(lccls+mbat)
        do 10 icat = 1, ncat
          call aacopy(lccls, icat, lccmd)
   10   continue

*---- Link to class object.
        call sbit1(iq(lccls), mxcls)
        lq(lccmd-ncat-mbecls) = lccls

*---- Decode attributes.
        if (token(jtok) .ne. ';') then
          call aaattr(lq(lckey-2), lccmd, nkat, error)
        endif

*---- If all OK, link element bank to directory.
        if (.not. error) then
          call didefi(ldbnk, label, lccmd)
        endif

*---- Decode attributes for update.
      else if (token(jtok) .ne. ';') then
        call aaattr(lq(lckey-2), lccmd, nkat, error)
      endif

*---- Check data for LUMP element.
      if (isp .eq. 23) then
        idata = mbat + 2 * mcsiz
        if (iq(lccmd+idata+mctyp) .ne. 10 * mtint + 1) then
          iq(lccmd+idata+mcval) = 4
        endif
        idata = idata + mcsiz
        if (mod(iq(lccmd+idata+mctyp),10) .eq. 0) then
          call utleng(label, ileng)
          msg(1) = 'Unable to build lump "' // label(1:ileng)
     +    // '" --- LINE attribute missing.'
          call aafail('AAELEM', 1, msg)
        else

*---- Construct the LUMP sequence.
          call lnrefe(lccmd, 4, llnxsq, lccmd, -1)

*---- TRANSPORT map.
          call tmscnd(llnxsq)
          il = iq(lccmd+mbat) + mbemap
          ns = (6 + 36 + 216) * mwflt
          call mzbook(2, lmap, lccmd, -il, 'LMAP', 0, 0, ns, mreal, 0)
          call utpflt(lccmd, 2, 2, suml)
          call uzero(q(lmap+1), 1, 6*mwflt)
          call ucopy(rt, q(lmap+6*mwflt+1), 36*mwflt)
          call ucopy(tt, q(lmap+42*mwflt+1), 216*mwflt)

*---- Lie map.
          iord = 4
          call utgint(lccmd, 3, 3, iord)
          iord = min(iord,6)
          il = iq(lccmd+mbat) + mbelie
          ns = (36 + itop6(iord)) * mwflt
          call lalump(iord, llnxsq, fp, fm)
          call mzbook(2, lmap, lccmd, -il, 'LMAP', 0, 0, ns, mreal, 0)
          call ucopy(fm, q(lmap+1), 36*mwflt)
          call ucopy(fp, q(lmap+36*mwflt+1), itop6(iord)*mwflt)

*---- Drop the LUMP sequence.
          call lndrop(llnxsq)
        endif
      endif

*---- DEFINE dump option.
      if (error) then
        call aadrop(lccmd)
      else
        if (ideffl .eq. 1  .or.  ideffl .eq. 3) then
          call aadump(lccmd)
        endif
        if (ideffl .eq. 2  .or.  ideffl .eq. 3) then
          call dzshow('element', 0, lccmd, 'V', 0, 0, 0, 0)
        endif
      endif

      end
+dk aaepush
      subroutine aaepush
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Write out SPECIAL table. ENDPUSH command.                          *
* Attributes:                                                          *
*   TABLE     (name)    Name of table to be written.                   *
*   FILENAME  (string)  Name to be given to the TFS file.              *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca message
+ca refer
+ca status
+ca tbcomm
+ca tbpara
      integer ileng,iunit

      character*(mcnam)  tabnam, savnam
      character*(mcfil)  filnam, strnam

      call uhtoc(q(ltbspc+mtbnam), mcwrd, tabnam, mcnam)
      call tbclos(ltbspc)
      ltbspc = 0
      itbspc = 0
      msg(1) = 'Special table closed: ' // tabnam
      call aainfo('AAEPUSH', 1, msg)

*---- Get attributes.
      savnam = ' '
      call utgnam(lccmd, 1, 1, savnam)
      if (savnam .ne. ' ') then
        strnam = savnam

*---- Open file.
        call flopen(strnam, 'SWFD', 2048, 0, iunit, error)
        if (.not. error) then
          call flname(iunit, filnam)

*---- Write table on file.
          call tbwtfs(tabnam, iunit)
          call flclos(iunit, error)
          if (.not. error) then
            call utleng(tabnam, ileng)
            msg(1) = 'Table "' // tabnam(1:ileng)
     +        // '" written on file: ' // filnam
            call aainfo('FLWTFS', 1, msg)
          endif
        endif
      endif

      end
+dk aaexec
      subroutine aaexec(label, key)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Main switch routine (process code) for command execution.          *
*   Uses pointers to current command and to current keyword.           *
* Input:                                                               *
*   LABEL     (char)    Name of command bank.                          *
*   KEY       (char)    Name of keyword bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer ipr,isp
      character*(mcnam) label, key
+ca memdum
+ca bankhead
+ca beam
+ca prcgroup
+ca message
+ca option
+ca refer
+ca status

      real              time1, time2, dtime

*---- Skip in case of error.
      if (error .or. scan) return

*---- Fill in variable references.
      call exfill
      if (.not. error) then

*---- Order and evaluate expressions.
        call exordr
        if (.not. error) then
          call exupdt
        endif
      endif

*---- Propagate change flags in data structure.
      call aapmod

*---- Load in BEAM common from BEAM bank.
      call enget
*---  Save if default
      if (liftbeam .eq. 0)  call enput
*---- Command TRACE option.
      call timex(time1)
      if (trace) then
        write (msg, 910) time1, label, key
  910   format(f12.3,' begin "',a,':',a,'"')
        call aainfo('AAEXEC', 1, msg)
      endif

*---- COMMAND dump option.
      if (icmdfl .eq. 1  .or.  icmdfl .eq. 3) then
        call aadump(lccmd)
      endif
      if (icmdfl .eq. 2  .or.  icmdfl .eq. 3) then
        call dzshow('keyword', 0, lckey, 'V', 0, 0, 0, 0)
        call dzshow('command', 0, lccmd, 'V', 0, 0, 0, 0)
      endif

*---- Switch on process code.
      ipr = iq(lccmd+mbpr)
      isp = iq(lccmd+mbsp)

*---- User-defined process codes.
      if (ipr .le. 0  .or.  ipr .gt. 30) then
        call usercm(ipr, isp)

*---- IPR = MPSRV, Pool services section.
      else if (ipr .eq. mpsrv) then
        call aaserv(ipr, isp)

*---- IPR = MPFIL, File services section.
      else if (ipr .eq. mpfil) then
        call flmain(ipr, isp)

*---- IPR = MPENV, Environment section.
      else if (ipr .eq. mpenv) then
        call enmain(ipr, isp)

*---- IPR = MPPLT, Plotting section.
      else if (ipr .eq. mpplt) then
        call plmain(ipr, isp)

*---- IPR = MPSUR, Survey section.
      else if (ipr .eq. mpsur) then
        call sumain(ipr, isp)

*---- IPR = MPTWS, Twiss section.
      else if (ipr .eq. mptws) then
        call twmain(ipr, isp)

*---- IPR = MPMAT, Matching section.
      else if (ipr .eq. mpmat) then
        call mtmain(ipr, isp)

*---- IPR = MPTRK, Tracking section.
      else if (ipr .eq. mptrk) then
        call trmain(ipr, isp)

*---- IPR = MPHAR, HARMON section.
      else if (ipr .eq. mphar) then
        call hamain(ipr, isp)

*---- IPR = MPERR, Error section.
      else if (ipr .eq. mperr) then
        call ermain(ipr, isp)

*---- IPR = MPCOR, Correction section.
      else if (ipr .eq. mpcor) then
        call comain(ipr, isp)

*---- IPR = MPLIE, Lie algebraic analysis.
      else if (ipr .eq. mplie) then
        call lamain(ipr, isp)

*---- IPR = MPEDI, Sequence editor commands.
      else if (ipr .eq. mpedi) then
        call lnedit(ipr, isp)

*---- IPR = MPPOL, Polarization commands.
      else if (ipr .eq. mppol) then
        call spmain(ipr, isp)
+if doom
*---- IPR = MPDOOM, doom commands.
      else if (ipr .eq. mpdoom) then
        call dmcmnd(ipr, isp)
+ei
      endif

*---- Command trace option.
      if (trace) then
        call timex(time2)
        dtime = time2 - time1
        write (msg, 920) time2, label, key, dtime
  920   format(f12.3,' end   "',a,':',a,'",',f12.3,' seconds used.')
        call aainfo('AAEXEC', 1, msg)
      endif

      end
+dk aafail
      subroutine aafail(rout, lines, text)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print fatal error message.                                         *
* Input:                                                               *
*   ROUT      (char)    Calling routine name.                          *
*   LINES     (integer) Number of lines in message.                    *
*   TEXT      (char)    Message.                                       *
*----------------------------------------------------------------------*
+ca aparam
      integer i,leng,lines
      character*(*)     rout, text(lines)
+ca status
+ca zunit

      call utleng(text(1), leng)
      write (iqlog, 910) rout, text(1)(1:leng)
      do 90 i = 2, lines
        call utleng(text(i), leng)
        write (iqlog, 920) text(i)(1:leng)
   90 continue
      write (iqlog, 930)
      nfail = nfail + 1
      error = .true.

  910 format(' '/' ',a,'.',t11,'*** Error *** ',a)
  920 format(t11,a)
  930 format(' ')

      end
+dk aagetp
      subroutine aagetp(parname, parvalue)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Read value of a parameter; inverse of AASETP.                      *
* Input:                                                               *
*   PARNAME   (char) Parameter name.                                   *
* Output:                                                              *
*   PARVALUE  (real) Parameter value.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer idir
      double precision parvalue
      character*(*)  parname
+ca memdum
+ca refer

*---- Find parameter PARNAME.
      call direfe(ldbnk, parname, idir)
      lcelm = lq(ldbnk(3)-idir)

*---- Get value if defined.
      if (lcelm .ne. 0) then
        call utgflt(lcelm, 1, 1, parvalue)
      else
        parvalue = 0.0
      endif

      end
+dk aainfo
      subroutine aainfo(rout, lines, text)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print informative message.                                         *
* Input:                                                               *
*   ROUT      (char)    Calling routine name.                          *
*   LINES     (integer) Number of lines in message.                    *
*   TEXT      (char)    Message.                                       *
*----------------------------------------------------------------------*
+ca aparam
      integer i,leng,lines
      character*(*)     rout, text(lines)
+ca option
+ca zunit

      if (info) then
        call utleng(text(1), leng)
        write (iqlog, 910) rout, text(1)(1:leng)
        do 90 i = 2, lines
          call utleng(text(i), leng)
          write (iqlog, 920) text(i)(1:leng)
   90   continue
        write (iqlog, 930)
      endif

  910 format(' '/' ',a,'.',t11,a)
  920 format(t11,a)
  930 format(' ')

      end
+dk aainit
      subroutine aainit
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initialize data structures.                                        *
*----------------------------------------------------------------------*
+ca aparam
+ca memdef
+ca bankhead
+ca bbcomm
+ca beam
+ca prcgroup
+ca strgroup
+ca ablink
+ca coesti
+ca option
+ca refer
+ca status
+ca thrcom
+ca wstack
      integer l,mbi,mki,mxi
      double precision onem6
+if doom
      logical dmuse
+ei
*---- Initial directory sizes.
      parameter         (mki = 1000, mbi = 10000, mxi = 1000)
      parameter         (onem6 = 1.0d-6)
      character*(mcnam) label

*---- Initialize status flags.
      error  = .false.
      scan   = .false.
      nwarn  = 0
      nfail  = 0
      imodul = 0
      iplflg = 0
      liftseq = 0
      currseq = 0
      liftbeam = 0
      currbeam = 0
      bbd_flag = 0
      bbd_cnt = 0
      sequnam = ' '
      adthfl = .false.
      adwofl = .false.
      adcofl = .false.
      inval  = .false.
      stabx  = .false.
      staby  = .false.
      stabt  = .false.
      newcor = .false.
      newmap = .false.
      optflg(20) = .false.

*---- Initialize dynamic store and global links.
      call mzstor(0, '/ /', '.', fence, lroot, iq, iq,
     +            iq(mwflt*memmin), iq(mwflt*memlen))
*     Lift the "Great Master Bank".
      call mzbook(2, lroot, lroot, 1, 'ROOT', mlr, mls, md, 2, 0)
*     Lift the bank for active (USEd) beam lines.
      call mzbook(2, l, lroot, -mcseq, 'ACTS', mttact, mttact, 0, 0, 0)
*     Lift the bank for active (defined) beam commands.
      call mzbook(2, l, lroot, -mbeam, 'BACT', mttact, mttact, 0, 0, 0)
*     Lift the constraint master bank
      call mzbook(2, l, lroot, -mconsm, 'CMAS', mttact, mttact, 0, 0, 0)
*     Global reference links.
      call mzlink(0, '/REFER/', lref1, lref1, lref2)
*     Local links for control module.
      call mzlink(0, '/AALINK/', laabnk, laabnk, laaold)

*---- Initialize other modules.
      call uzero(coest, 1, 6*mwflt)
      cotol = onem6
      call dcinit
      call exinit
      call lninit

*---- Bank name directories.
      call dimake(mki, mdkey, ldkey)
      call dimake(mbi, mdbnk, ldbnk)
+if doom
      if (.not. dmuse())  then
+ei
*---- Build KEYWORD mother bank.
*     Lift bank.
      call mzbook(2, lckey, lroot, -mrkey, 'KEYW', 3, 3, mbat, 7, 0)
*     Link to directory.
      label = 'KEYWORD'
      call didefi(ldkey, label, lckey)
*     Store bank description.
      iq(lckey+mbfrm) = 16 * 5 + 2
      iq(lckey+mbnam) = 0
      iq(lckey+mbln) = 0
      iq(lckey+mbpr) = mpkey
      iq(lckey+mbsp) = 1
      iq(lckey+mbat) = 0

*---- Build KEYEDIT keyword.
      label = 'KEYEDIT'
      call kwmake(label, 1, 2, 0)

*---- Expression and variable reference directories.
*     Link L will not be used, it can be local to AAINIT.
      call mzbook(2, l, lroot, -mdexp, 'EDIR', mxi, 0, 2, 2, 0)
      call mzbook(2, l, lroot, -mdvar, 'VDIR', mxi, 0, 1, 2, 0)
*---- Initialize polynomial package.
      call painit(6)
+if doom
      endif
+ei
*---- Random generator.
      call init55(123456789)

*---- Clear working space.
      iwork = 0
      nwork = 0
      call mzwork(0, dq(1), dq(1), - 1)

      end
+dk aamain
      subroutine aamain
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Main routine for decoder.                                          *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca prcgroup
+ca option
+ca refer
+ca status
+ca zunit
      integer if1,if2,ipr

      character*(mcnam) label,  key

*---- Clear input buffers.
      call rdinit
      scan = .false.

*---- Main command loop.
  100 continue
        error = .false.

*---- Read label and keyword.
*     If there is no keyword, LCCMD is set to non-zero.
        call aaread(label, key, if1, if2)

*---- STOP, RETURN, or END_FILE is executed even in case of error.
        if (key .eq. 'STOP') then
          go to 9999
        else if (key .eq. 'RETURN') then
          call flcall(2)
          go to 100
        else if (key .eq. 'END_FILE') then
          if (iqread .eq. iqttin) go to 9999
          call flcall(2)
          go to 100
        endif

*---- Get process code.
        if (.not. error) then
          ipr = iq(lckey+mbpr)

*---- Keyword definition.
          if (ipr .eq. mpkey) then
            call kwmain(label)

*---- Constant or parameter definition.
          else if (ipr .eq. mppar) then
            call aapara(label, key)

*---- String services: STRING, table-specific expressions.
          else if (ipr .eq. mpstr) then
            call aastrg(label, key)

*---- Beam element definition.
          else if (ipr .eq. mpelm) then
            call aaelem(label, key)

*---- Beam lines or list definition.
          else if (ipr .eq. mplin) then
            call lnmain(label, if1, if2)

*---- Subroutines. This also executes subroutine calls.
          else if (ipr .eq. mpsub) then
            call aasubr(label, key)

*---- Executable commands.
          else
            call aacmnd(label, key)
            call aaexec(label, key)
            if (label .eq. ' ') then
              call didrop(ldbnk, label)
              call aadrop(lccmd)
            endif
          endif
        endif

*---- In case of error, enter scanning mode or request retyping.
        if (error) then
          if (inter  .and.  iqread .eq. iqttin) then
            call aainfo('AAMAIN', 1, '*** Please retype command ***')
          else if (.not. scan) then
            call aainfo('AAMAIN', 1, 'Entering scanning mode.')
            scan = .true.
          endif
        endif
      go to 100

 9999 end
+dk aamark
      subroutine aamark(subr, lbank)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Mark element or beam line as modified.                             *
* Input:                                                               *
*   SUBR      (char*6)  Name of calling routine.                       *
*   LBANK(1)  (pointer) Pointer to modified element.                   *
*----------------------------------------------------------------------*
+ca aparam
      character*(*)     subr
      integer           lbank(1)
+ca memdum
+ca bankhead
+ca markbits
+ca message
+ca option
+ca refer
+if doom
+ca dmcommon
+ei
      character*(mcnam) bnknam

*---- Mark bank as modified.
      call sbit1(iq(lbank(1)), mxmod)
+if doom
      call sbit1(iq(lbank(1)), mxdmod)
+ei
      if (debug) then
        if (iq(lbank(1)+mbnam) .eq. 0) then
          bnknam = 'New bank'
        else
          call diname(ldbnk, iq(lbank(1)+mbnam), bnknam)
          if (bnknam .eq. ' ') bnknam = 'Unnamed'
        endif
        msg(1) = 'Marking bank as modified: ' // bnknam
        call aainfo(subr, 1, msg)
      endif

      end
+dk aaopts
      subroutine aaopts
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Set command options.                                               *
* Attributes, must be given in this order in the dictionary:           *
* Real attribute:                                                      *
*   COFACT    (real)    Factor to stabilize closed orbit search.       *
* Integer flags:                                                       *
*   COMMAND   (integer) Dump new command definitions.                  *
*   DEFINE    (integer) Dump new element definitions.                  *
*   EXPRESS   (integer) Dump new expression banks.                     *
*   KEYWORD   (integer) Dump new keyword definitions.                  *
*   LINE      (integer) Dump new line definitions.                     *
* Logical flags:                                                       *
*   DEBUG     (logical) Debug output about bank manipulation.          *
*   DOUBLE    (logical) TFS tables are in double precision.            *
*   ECHO      (logical) Print input echo.                              *
*   INTER     (logical) Interactive mode.                              *
*   TRACE     (logical) Trace command execution.                       *
*   VERIFY    (logical) Verify undefined parameters.                   *
*   WARN      (logical) Switch for warning messages.                   *
* Logical flags controlling this command:                              *
*   RESET     (logical) Reset all options to default.                  *
*   TELL      (logical) List all options.                              *
*----------------------------------------------------------------------*
+ca aparam
+ca option
+ca refer
+ca zunit
      integer i1,i2,mopcon,mopflg,mopflt,mopint

      parameter         (mopcon =  2)
      parameter         (mopflt =  1)
      parameter         (mopint =  5)
      parameter         (mopflg =  12)
      logical           intrac

*---- Retrieve options controlling OPTION command.
      call utglog(lccmd, 1, mopcon, optcon)

*---- RESET option.
      if (reset) then
        cofact = 1.0
        icmdfl = 0
        ideffl = 0
        iexpfl = 0
        ikeyfl = 0
        ilinfl = 0
        debug  = .false.
        double = .false.
        echo   = .true.
        inter  = intrac()
        trace  = .false.
        verify = .false.
        warn   = .true.
        info   = .true.
        sympl  = .true.
        rbarc  = .true.
      endif

*---- Real option values.
      i1 = mopcon + 1
      i2 = mopcon + mopflt
      call utgflt(lccmd, i1, i2, optflt)

*---- Integer option values.
      i1 = i2 + 1
      i2 = i2 + mopint
      call utgint(lccmd, i1, i2, optint)

*---- Logical flags.
      i1 = i2 + 1
      i2 = i2 + mopflg
      call utglog(lccmd, i1, i2, optflg)

*---- TELL option.
      if (tell) then
        write (iqlog, 910) cofact,
     +    icmdfl, ideffl, iexpfl, ikeyfl, ilinfl,
     +    debug, double, echo, inter, trace, verify, warn, info,
     +    sympl, rbarc
      endif

  910 format(' '/' AAOPTS.  Command options in effect:'/
     +       t11,'COFACT (orbit factor):       ',f8.6/
     +       t11,'COMMAND dump level:          ',i1/
     +       t11,'DEFINE dump level:           ',i1/
     +       t11,'EXPRESSion dump level:       ',i1/
     +       t11,'KEYWORD dump level:          ',i1/
     +       t11,'LINE dump level:             ',i1/
     +       t11,'DEBUG modification flags:    ',l1/
     +       t11,'DOUBLE precision tables:     ',l1/
     +       t11,'ECHO file log:               ',l1/
     +       t11,'INTERactive execution:       ',l1/
     +       t11,'TRACE command execution:     ',l1/
     +       t11,'VERIFY undefined params:     ',l1/
     +       t11,'WARNing messages:            ',l1/
     +       t11,'INFOrmation messages:        ',l1/
     +       t11,'SYMPLECtify matrices:        ',l1/
     +       t11,'convert RBEND length to arc: ',l1/' ')

      end
+dk aapara
      subroutine aapara(label, key)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode CONSTANT, PARAMETER, or STRING definition.                  *
*   Uses the pointers to current keyword and current command.          *
* Input:                                                               *
*   LABEL    (char)     Name of new parameter bank.                    *
*   KEY      (char)     Name of keyword bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer ieval,iexpr,ifrst,iln,ipr,isp,nkat
      double precision rval
      character*(mcnam) label, key
+ca memdum
+ca bankhead
+ca cmdgroup
+ca message
+ca option
+ca refer
+ca status
+ca stbuff
+ca datatype

*---- Check format of command.
      if (token(jtok) .ne. ','  .and.  token(jtok) .ne. '=') then
        msg(1) =
     +  'Character "' // token(jtok) // '" is not allowed here.'
        call rdfail('AAPARA', 1, msg)
      else

*---- Copy keyword to working store and book definition bank.
        call kwget(lckey, iln, ipr, isp, nkat)
        call aabook(lccmd, label, ipr, isp, lckey, 1)

*---- ISP = 1: Constant, or ISP = 2: parameter.
        if (isp .eq. 1  .or.  isp .eq. 2) then
          jtok = jtok + 1
          ieval = isp
          call exread(ieval, rval, iexpr)
          ifrst = 1
          call exmake(lccmd, ifrst, mbat + mcval, rval, iexpr)
          iq(lccmd+mbat+mctyp) = 10 * mtflt + iexpr
          if (token(jtok) .ne. ';') then
            call rdfail('AAPARA', 1, 'Invalid form of PARAMETER.')
          endif

*---- ISP = 3: Plot variable.
        else if (isp .eq. 3  .and.  token(jtok) .ne. ';') then
          call aaattr(lq(lckey-2), lccmd, nkat, error)
        endif

*---- If error detected, drop data bank, else link it to directory.
        if (error) then
          call aadrop(lccmd)
        else
          call didefi(ldbnk, label, lccmd)
        endif

*---- DEFINE dump option.
        if (.not. error) then
          if (ideffl .eq. 1  .or.  ideffl .eq. 3) then
            call aadump(lccmd)
          endif
          if (ideffl .eq. 2  .or.  ideffl .eq. 3) then
            call dzshow('parameter', 0, lccmd, 'V', 0, 0, 0, 0)
          endif
        endif
      endif

      end
+dk aapdrp
      subroutine aapdrp
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Delete all precomputed maps after something has changed in BEAM.   *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca seqgroup
+ca ablink
+ca option
+ca refer

*---- Drop one-turn maps.
      if (lcseq .ne. 0) then
        if (lq(lcseq-msmap) .ne. 0) then
          if (debug) then
            call aainfo('AAPDRP', 1,
     +      'Dropping TRANSPORT map for main beam line.')
          endif
          call mzdrop(0, lq(lcseq-msmap), 'L')
        endif
        if (lq(lcseq-mslie) .ne. 0) then
          if (debug) then
            call aainfo('AAPDRP', 1,
     +      'Dropping Lie algebraic map for main beam line.')
          endif
          call mzdrop(0, lq(lcseq-mslie), 'L')
        endif
      endif

      end
+dk aapmod
      subroutine aapmod
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Delete precomputed maps, when a parameter has changed.             *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca markbits
+ca seqgroup
+ca ablink
+ca option
+ca refer
+ca status
      integer ipos,jbit

*---- Look for modified elements in main beam line.
      if (lcseq .ne. 0) then
        lsdir = lq(lcseq-msdir)
        do 20 ipos = iq(lcseq+msr1), iq(lcseq+msr2)
          if (jbit(iq(lq(ldbnk(3)-iq(lsdir+ipos))),mxmod) .ne. 0)
     +      newmap = .true.
   20   continue
      endif

*---- Drop one-turn maps.
      if (newmap) then
        newmap = .false.
        if (lcseq .ne. 0) then
          if (lq(lcseq-msmap) .ne. 0) then
            if (debug) then
              call aainfo('AAPMOD', 1,
     +        'Dropping TRANSPORT map for main beam line.')
            endif
            call mzdrop(0, lq(lcseq-msmap), 'L')
          endif
          if (lq(lcseq-mslie) .ne. 0) then
            if (debug) then
              call aainfo('AAPMOD', 1,
     +        'Dropping Lie algebraic map for main beam line.')
            endif
            call mzdrop(0, lq(lcseq-mslie), 'L')
          endif
        endif
      endif

      end
+dk aaproc
      subroutine aaproc
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Build procedure for DO or SUBROUTINE command.                      *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca prcgroup
+ca strgroup
+ca message
+ca ablink
+ca option
+ca refer
+ca status
+ca zunit
      integer icmd,if1,if2,ileng,ipr,ipush,isp,mpi,ncmd

      character*(mcnam) label, key, subnam
      parameter         (mpi = 20)

*---- Book procedure bank, reserve one pointer for stack pointer.
      call mzbook(2, laaprc, lccmd, -1, 'PROC', mpi + 1, 0, 2, 2, 0)
      ncmd = 1

*---- Command loop.
  100 continue
      error = .false.

*---- Read label and keyword.
*     If there is no keyword, LCCMD is set to non-zero.
      call aaread(label, key, if1, if2)

*---- Get process code, make sure the command is labelled.
      if (.not. error) then
        ipr = iq(lckey+mbpr)
        isp = iq(lckey+mbsp)
        if (label .eq. ' ') then
          iq(lroot+msrseq) = iq(lroot+msrseq) + 1
          write (label, '(A8,''*'',I6.6,''*'')') key, iq(lroot+msrseq)
        endif

*==== Definitions should not occur.
        if (ipr .lt. mpsub) then
          call rdwarn('AAPROC', 1, 'Definition should not occur'
     +    // ' within a subroutine --- it will be executed now.')

*==== Subroutine commands.
        else if (ipr .eq. mpsub) then

*---- ENDDO, ENDSUBROUTINE or ENDIF.
          if (isp .eq. 2 .or. isp .eq. 6 .or. isp .eq. 9) then
            go to 200

*---- CALLSUBROUTINE.
          else if (isp .eq. 7) then
            call aacmnd(label, key)
            call utgnam(lccmd, 1, 1, subnam)
            call difind(ldbnk, subnam, icmd, lccmd)
            call utleng(subnam, ileng)
            msg(1) = '"' // subnam(1:ileng)
     +      // '" is not known as a subroutine.'
            if (lccmd .eq. 0) then
              call rdfail('AAPROC', 1, msg)
            else if (iq(lccmd+mbpr) .ne. mpsub  .or.
     +               iq(lccmd+mbsp) .ne. 5) then
              call rdfail('AAPROC', 1, msg)
            endif

*---- STORE and ENDSTORE are invalid.
          else if (isp .eq. 3  .or.  isp .eq. 4) then
            call rdfail('AAPROC', 1, 'STORE or ENDSTORE must not'
     +      // ' occur within DO or SUBROUTINE range.')

*---- Nested definition?
          else if (lccmd .eq. 0) then
            call rdfail('AAPROC', 1,
     +      'Nested definition of DO or SUBROUTINE.')
          endif

*==== Executable commands.
        else
          call aacmnd(label, key)
        endif
      endif

*---- Test for error.
      if (error) then
        if (inter  .and.  iqread .eq. iqttin) then
          msg(1) = '*** Please retype command ***'
          msg(2) = '*** To quit subroutine, type ENDSUB ***'
          call aainfo('AAPROC', 2, msg)
        else if (.not. scan) then
          call aainfo('AAPROC', 1, 'Entering scanning mode.')
          scan = .true.
        endif

*---- Link to procedure.
      else
        ncmd = ncmd + 1
        if (ncmd .gt. iq(laaprc-3)) then
          call mzpush(0, laaprc, mpi, 0, 'I')
        endif
        lq(laaprc-ncmd) = lccmd
      endif
      go to 100

*---- Drop unused space and restore command pointer.
  200 continue
      ipush = ncmd - iq(laaprc-3)
      call mzpush(0, laaprc, ipush, 0, 'I')
      lccmd = lq(laaprc+1)

 9999 end
+dk aapush
      subroutine aapush
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Push up to MAXCOL variables and/or expressions to SPECIAL table.   *
*   Determine the number of columns in the special table.              *
* Attributes:                                                          *
*   up to MAXCOL expressions.                                          *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca refer
+ca savbuf
+ca tbcomm
+ca tbhead
+ca datatype
      integer ibias,icat,idata,nb,nc,ncat,nr,ns
      double precision dummy

      character*(mcnam) tabnam, colhed(maxcol)
      integer           icform(maxcol)

*---- Create new SPECIAL table, if it does not exist yet.
      if (ltbspc .eq. 0) then
        tabnam = 'SPECIAL'
        nb = 1
        nr = 1000
        ns = 1
        nc = 0
        ncat = iq(lccmd+mbat)
        idata = mbat
        do 10 icat = 1, ncat
          if (mod(iq(lccmd+idata+mctyp),10) .ne. 0) then
            isvbuf = 0
            call svattr(lccmd, icat, mtflt)
            nc = nc + 1
            colhed(nc) = savbuf(1:min(isvbuf,mcnam))
            icform(nc) = mreal
          endif
          idata = idata + mcsiz
   10   continue

        call tbcrea(tabnam, ns, nr, nc, colhed, icform, nb, ltbspc)
        call tbpdsc(ltbspc, 'TYPE', 5, 0, dummy, 'SPECIAL')
        itbspc = 0
      endif

*---- Store the expression values in next table row.
      itbspc = itbspc + 1
      call tbset(ltbspc, itbspc, 3, ltbbuf)
      ncat = iq(lccmd+mbat)
      idata = mbat
      ibias = 1
      do 20 icat = 1, ncat
        if (mod(iq(lccmd+idata+mctyp),10) .ne. 0) then
          call ucopy(q(lccmd+idata+mcval), q(ltbbuf+ibias), mwflt)
          ibias = ibias + mwflt
        endif
        idata = idata + mcsiz
   20 continue

      end
+dk aaread
      subroutine aaread(label, key, if1, if2)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Read and decode a command.                                         *
*   Returns pointer to current keyword,                                *
*   and optionally to current command.                                 *
* Output:                                                              *
*   LABEL    (char)     Command label.                                 *
*   KEY      (char)     Command keyword.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer icmd,icmnt,if1,if2,ikey,isrc,jcase,jform,leng1,leng2
      character*(mcnam) label,  key
+ca memdum
+ca bankhead
+ca prcgroup
+ca refer
+ca stbuff
      character*8       toks
      equivalence       (toks, token(1))

      logical           eflag
      character*(mcnam) word1, word2

      data icmnt / 0 /
      save icmnt

*---- Read statement into buffer and skip empty statements.
   10 continue
        call rdstat(eflag)
        if (eflag) go to 9999
      if (token(1) .eq. ';') go to 10

*---- Skip comment blocks.
      if (toks(1:4) .eq. 'COMM') then
        icmnt = icmnt + 1
        go to 10
      else if (icmnt .gt. 0) then
        if (toks(1:4) .eq. 'ENDC') then
          icmnt = icmnt - 1
          go to 10
        else if (toks .eq. 'END_FILE') then
          call aawarn('AAREAD', 1, 'Unclosed "COMMENT" at end of file.')
          icmnt = 0
        else
          go to 10
        endif
      endif

*---- Initialize.
      label = ' '
      key = ' '
      if1 = 0
      if2 = 0
      jcase = 0
      jform = 0

*==== PHASE 1. Decode possible label and keyword.
*---- Command must begin with an identifier.
      call rdword(word1, leng1)
      if (leng1 .eq. 0) then
        call rdfail('AAREAD', 1,
     +  'Command should begin with a label or a keyword.')
        go to 9999
      endif

*---- Formal argument list.
      if (token(jtok) .eq. '(') then
        call rdform(if1, if2, eflag)
        if (eflag) go to 9999
        jform = 1
      endif

*---- ":" marks first name as label.
      if (token(jtok) .eq. ':') then
        jtok = jtok + 1

*---- ":=" marks statement as a parameter definition.
        if (token(jtok) .eq. '=') then
          jcase = 3
        else

*---- A keyword must follow the ":".
          call rdword(word2, leng2)
          if (leng2 .eq. 0) then
            call rdfail('AAREAD', 1, 'Keyword expected after ":".')
          else
            jcase = 2
          endif
        endif

*---- "=" marks statement as a parameter definition.
      else if (token(jtok) .eq. '=') then
        jcase = 3

*---- "," or ';': Keyword only or label only.
      else if (token(jtok) .eq. ','  .or.  token(jtok) .eq. ';') then
        jcase = 1

*---- All other characters are illegal at this point.
      else
        call rdfail('AAREAD', 1, 'End of statement ";" expected.')
        go to 9999
      endif

*==== PHASE 2. Find command keyword.
      lckey = 0
      lccmd = 0
      lccls = 0

*---- JCASE = 1. One word only; decide if keyword or label.
      if (jcase .eq. 1) then

*---- Exact match with keyword or stored command.
        call difind(ldkey, word1, ikey, lckey)
        if (lckey .ne. 0) then
          if (iq(lckey+mbpr) .eq. mpelm) lccmd = lq(lckey-3)
        else
          call difind(ldbnk, word1, icmd, lccmd)
          if (lccmd .ne. 0) then
            lckey = lq(lccmd+1)

*---- Approximate match with keyword or stored command.
          else
            call difind(ldkey, word1(1:leng1), ikey, lckey)
            if (lckey .ne. 0) then
              if (iq(lckey+mbpr) .eq. mpelm) lccmd = lq(lckey-3)
            else
              call difind(ldbnk, word1(1:leng1), icmd, lccmd)
              if (lccmd .ne. 0) then
                lckey = lq(lccmd+1)
              endif
            endif
          endif
        endif

*---- JCASE = 2. Two words; decide if second is keyword or class.
      else if (jcase .eq. 2) then
        label = word1

*---- Exact match with keyword or class name.
        call difind(ldkey, word2, ikey, lckey)
        if (lckey .ne. 0) then
          if (iq(lckey+mbpr) .eq. mpelm) lccls = lq(lckey-3)
        else
          call difind(ldbnk, word2, isrc, lccls)
          if (lccls .ne. 0) then
            lckey = lq(lccls+1)

*---- Approximate match with keyword or class name.
          else
            call difind(ldkey, word2(1:leng2), ikey, lckey)
            if (lckey .ne. 0) then
              if (iq(lckey+mbpr) .eq. mpelm) lccls = lq(lckey-3)
            else
              call difind(ldbnk, word2(1:leng2), isrc, lccls)
              if (lccls .ne. 0) then
                lckey = lq(lccls+1)
              endif
            endif
          endif
        endif

*---- JCASE = 3. Find parameter keyword.
      else if (jcase .eq. 3) then
        label = word1
        call difind(ldkey, 'PARAMETE', ikey, lckey)
      endif

*---- Check if a keyword was recognized.
      if (lckey .eq. 0) then
        call rdfail('AAREAD', 1, 'No command keyword found.')

*---- Test for redundant formal argument list.
      else
        if (jform .ne. 0) then
          if (iq(lckey+mbpr).ne.mplin .or. iq(lckey+mbsp).ne.1) then
            call rdwarn('AAREAD', 1, 'Redundant formal argument list.')
          endif
        endif
        call diname(ldkey, ikey, key)
        if (lccmd .ne. 0) call diname(ldbnk, icmd, label)
      endif

 9999 end
+dk aaruns
      subroutine aaruns
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Execute a procedure: DO or SUBROUTINE.                             *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca message
+ca ablink
+ca refer
+ca status
      integer ileng
      double precision condif,valif

      character*(mcnam) label, key, opif
      logical           iftest

*---- Enter procedure: Link procedure to stack and set repetition.
  100 continue
        lq(lq(lccmd-1)-1) = laastk
        laastk = lq(lccmd-1)

*---- Variable evaluation for IF condition, similar to AAEXEC.
          if (iq(lccmd+mbsp) .eq. 8) then
            call exfill
            if (.not. error) then
              call exordr
              if (.not. error) then
                call exupdt
              endif
            endif

*---- Propagate change flags in data structure.
            call aapmod

*---- Set repetition to 1 or 0 according to COND, OP and VALUE.
            condif = 0.
            valif  = 0.
            opif   = '>'
            call utgflt(lccmd,2,2,condif)
            call utgnam(lccmd,3,3,opif)
            call utgflt(lccmd,4,4,valif)
            if       (opif .eq. '>') then
              iftest = (condif .gt. valif)
            else if  (opif .eq. '<') then
              iftest = (condif .lt. valif)
            else if  (opif .eq. '=') then
              iftest = (condif .eq. valif)
            else if (opif .eq. '>=') then
              iftest = (condif .ge. valif)
            else if (opif .eq. '<=') then
              iftest = (condif .le. valif)
            else if (opif .eq. '<>') then
              iftest = (condif .ne. valif)
            else
              iftest = .false.
            endif
            if (iftest) then
              iq(lccmd+mbat+mcval) = 1
            else
              iq(lccmd+mbat+mcval) = 0
            endif
          endif

*---- End of evaluation of number of repetitions.
        iq(laastk+2) = iq(lccmd+mbat+mcval)

*---- Skip procedure if counter is less or equal to 0.
        if (iq(laastk+2) .le. 0) go to 400

*---- Begin repetition: Skip one pointer for stack pointer.
  200   continue
          iq(laastk+1) = 1

*---- Execute one pass through procedure.
  300     continue
          iq(laastk+1) = iq(laastk+1) + 1
          if (iq(laastk+1) .le. iq(laastk-3)) then
            lcsrc = 0
            lccmd = lq(laastk-iq(laastk+1))
            if (iq(lccmd+mbpr) .eq. mpsub) then
              if (iq(lq(lccmd-1)+1) .ne. 0) then
                call diname(ldbnk, iq(lccmd+mbnam), label)
                call utleng(label, ileng)
                msg(1) = 'Recursive call to "' // label(1:ileng)
     +          // '" --- call skipped.'
                call aawarn('AARUNS', 1, msg)
              else
                go to 100
              endif
            endif
            lckey = lq(lccmd+1)
            call diname(ldbnk, iq(lccmd+mbnam), label)
            call diname(ldkey, iq(lckey+mbnam), key)
            call aaexec(label, key)
            go to 300
          endif

*---- More repetions.
          iq(laastk+2) = iq(laastk+2) - 1
        if (iq(laastk+2) .gt. 0) go to 200

*---- Resume outer procedure, if any.
400     iq(laastk+1) = 0
        laastk = lq(laastk-1)
      if (laastk .ne. 0) go to 300

      end
+dk aaserv
      subroutine aaserv(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Switch routine (subprocess code) for services.                     *
* Input:                                                               *
*   IPR       (integer) Process code.                                  *
*   ISP       (integer) Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca refer
+ca status
+ca zunit
      integer ipr,isp

*---- ISP = 1, PACKMEM. Wipe out division 1, compact division 2.
      if (isp .eq. 1) then
        call mzgarb(2, 1)

*---- ISP = 2, OPTION.
      else if (isp .eq. 2) then
        call aaopts

*---- ISP = 3, STOP. This command is handled in AAMAIN.
      else if (isp .eq. 3) then
        continue

*---- ISP = 4, SET.
      else if (isp .eq. 4) then
        call aaset

*---- ISP = 5, VALUE.
      else if (isp .eq. 5) then
        call aavalu

*---- ISP = 6, END_FILE.
      else if (isp .eq. 6) then

*---- ISP = 7, PUSH.
      else if (isp .eq. 7) then
        call aapush

*---- ISP = 8, ENDPUSH.
      else if (isp .eq. 8) then
        call aaepush

*---- ISP = 9, reserved.
      else if (isp .eq. 9) then

*---- ISP = 10, reserved.
      else if (isp .eq. 10) then

*---- User-defined services.
      else
        call usercm(ipr, isp)
      endif

      end
+dk aaset
      subroutine aaset
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Execute SET command.                                               *
* Input:                                                               *
* Attributes:                                                          *
*   VARIABLE  (vari)    Variable to be set.                            *
*   DEFAULE   (real)    Expression to be evaluted and stored.          *
* Local links (no Zebra operations called):                            *
*   LEXP                Expression.                                    *
*   LTAR                Target bank.                                   *
*   LVAR                Variable reference.                            *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca markbits
+ca vargroup
+ca message
+ca refer
+ca status
+ca datatype
      integer ileng,itar,ival,ivar,jbit,jtar,lexp,ltar,lvar
      double precision vval

      character*(mcnam) label

*---- Check for all defined.
      ivar = mbat
      ival = mbat + mcsiz
      lvar = lq(lccmd-1)
      ltar = lq(lvar-1)

*---- Check presence of variable name.
      if (iq(lccmd+ivar+mctyp) .eq. 10 * mtvar) then
        call aawarn('AASET', 1,
     +  'No variable name found in SET command --- Command ignored.')

*---- Check presence of value.
      else if (iq(lccmd+ival+mctyp) .eq. 10 * mtflt) then
        call aawarn('AASET', 1,
     +  'No value found in SET command --- Command ignored.')

*---- Update not allowed for an alias.
      else if (jbit(iq(ltar),mxals) .ne. 0) then
        call diname(ldbnk, iq(ltar+mbnam), label)
        call utleng(label, ileng)
        msg(1) = 'Cannot SET name "' // label(1:ileng)
     +  // '", it occurs in a sequence.'
        call aafail('AASET', 2, msg)

*---- Check variable type.
      else
        jtar = iq(lvar+mvbias)
        itar = mbat + (jtar - 1) * mcsiz
        if (iq(ltar+itar+mctyp) / 10 .ne. mtflt) then
          call aawarn('AASET', 1,
     +    'Variable to be SET is not real --- command ignored.')

*---- Replace value.
        else
          lexp = lq(ltar-jtar)
          if (lexp .ne. 0) call aadrop(lexp)
          call utgflt(lccmd, 2, 2, vval)
          call utpflt(ltar, jtar, jtar, vval)
        endif
      endif

      end
+dk aasetp
      subroutine aasetp(parname, parvalue)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Define a global parameter with a given value.                      *
* Input:                                                               *
*   PARNAME   (char) Parameter name.                                   *
*   PARVALUE  (real) Parameter value.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,ikey,iln,ipr,isp,nkat
      double precision parvalue
      character*(*)  parname
+ca memdum
+ca bankhead
+ca refer

*---- Find parameter PARNAME, or make a new one.
      call direfe(ldbnk, parname, idir)
      lcelm = lq(ldbnk(3)-idir)

*---- Find 'PARAMETER' keyword.
      if (lcelm .eq. 0) then
        call difind(ldkey, 'PARAMETER', ikey, lckey)
        call kwget(lckey, iln, ipr, isp, nkat)
        call aabook(lcelm, parname, ipr, isp, lckey, nkat)
        lq(ldbnk(3)-idir) = lcelm
        iq(lcelm+mbnam) = idir
      endif

*---- Store new value.
      call utpflt(lcelm, 1, 1, parvalue)

      end
+dk aasmod
      subroutine aasmod(idir, lold, lnew)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Perform actions required for a modification of the main beam line. *
*   Reject redefinition of a class; drop data which are outdated, etc. *
* Input:                                                               *
*   IDIR     (integer)  Directory index of old element.                *
*   LOLD(1)  (pointer)  Pointer to old bank.                           *
*   LNEW(1)  (pointer)  Pointer to new bank.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,ileng,ipos,isp,jsp,lines
      integer           lold(*), lnew(*)
+ca memdum
+ca bankhead
+ca markbits
+ca prcgroup
+ca seqgroup
+ca message
+ca ablink
+ca refer
+ca status

      character*(mcnam) label
      logical           found, drpali, drpfld, drpspl

*---- Get label of element.
      laaold = lold(1)
      laanew = lnew(1)
      call diname(ldbnk, idir, label)
      call utleng(label, ileng)
      lines = 1
      msg(1) = 'Replacing name "' // label(1:ileng) // '",'

*==== Replacement element --> element.
      if (iq(laaold+mbpr) .eq. mpelm  .and.
     +         iq(laanew+mbpr) .eq. mpelm) then

*---- Find occurrences of exact name in main beam line.
*     If element type changes, drop error definitions on this element.
        found = .false.
        drpali = .false.
        drpfld = .false.
        drpspl = .false.
        isp = iq(laanew+mbsp)
        jsp = iq(laaold+mbsp)
        if (lcseq .ne. 0) then
          lsdir = lq(lcseq-msdir)
          lsali = lq(lcseq-msali)
          lsspl = lq(lcseq-msspl)
          lsfld = lq(lcseq-msfld)
          do 30 ipos = 1, iq(lsdir-1)
            if (iq(lsdir+ipos) .eq. idir) then
              found = .true.
              if (isp .ne. jsp) then
                if (lsali .ne. 0) then
                  lcali = lq(lsali-ipos)
                  if (lcali .ne. 0) then
                    call mzdrop(0, lcali, '.')
                    drpali = .true.
                  endif
                endif
                if (lsfld .ne. 0) then
                  lcfld = lq(lsfld-ipos)
                  if (lcfld .ne. 0) then
                    call mzdrop(0, lcfld, '.')
                    drpfld = .true.
                  endif
                endif
                if (lsspl .ne. 0) then
                  lcspl = lq(lsspl-ipos)
                  if (lcspl .ne. 0) then
                    call mzdrop(0, lcspl, '.')
                    drpspl = .true.
                  endif
                endif
              endif
            endif
   30     continue
        endif

*---- If replacement involves monitor or corrector, drop MICADO tables.
        if (found) then
          call lnmark('AASMOD')
          lines = lines + 1
          msg(lines) = 'All occurrences replaced in main beam line,'
          if (isp .ne. jsp  .and.  lq(lcseq-mscom) .ne. 0) then
            if (isp .ge. 14  .and.  isp .le. 18   .or.
     +          jsp .ge. 14  .and.  jsp .le. 18) then
              lines = lines + 1
              msg(lines) =
     +        'Replacement involves a corrector or monitor'
     +        // ' (Closed orbit correction lost),'
              call mzdrop(0, lq(lcseq-mscom), 'L')
            endif
          endif
        endif
        if (drpali) then
          lines = lines + 1
          msg(lines) = 'Misalignment errors dropped,'
        endif
        if (drpfld) then
          lines = lines + 1
          msg(lines) = 'Field errors dropped,'
        endif
        if (drpspl) then
          lines = lines + 1
          msg(lines) = 'SPLIT information dropped,'
        endif

*==== Replacement involving beam line.
      else

*---- Look for occurence of item in sequence.
        found = .false.
        if (lcseq .ne. 0) then
          lsdir = lq(lcseq-msdir)
          do 10 ipos = iq(lcseq+msr1), iq(lcseq+msr2)
            if (iq(lsdir+ipos) .eq. idir) found = .true.
   10     continue
        endif

*---- If found, then drop sequence.
        if (found) then
          lines = lines + 1
          msg(lines) =
     +    'Name occurs in main beam line; expansion deleted,'
          call mzdrop(0, lcseq, '.')
          lcseq = 0
        endif
      endif

*---- Finish warning message.
      lines = lines + 1
      write (msg(lines), 910) iq(laaold+mbln)
  910 format('Previous definition occurred in line ',i6,'.')
      call aawarn('AASMOD', lines, msg)

      end
+dk aasubr
      subroutine aasubr(label, key)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode (and execute) subroutine command.                           *
*   Uses the pointers to current keyword and current command.          *
* Input:                                                               *
*   LABEL    (char)     Name of subroutine bank.                       *
*   KEY      (char)     Name of keyword bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,ileng,iln,ipr,isp,nkat
      character*(mcnam) label, key
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca message
+ca option
+ca refer
+ca status

      character*(mcnam) subnam
      logical           eflag

*---- Command called by label only. Decode attributes.
      if (lccmd .ne. 0) then
        call aaattr(lq(lckey-2), lccmd, nkat, error)
        if (.not. error) then
          isp = iq(lccmd+mbsp)

*---- DO, SUBROUTINE or IF.
          if (isp .eq. 1 .or. isp .eq. 5 .or. isp .eq. 8) then
            call aaruns

*---- CALLSUBROUTINE.
          else if (isp .eq. 7) then
            call utgnam(lccmd, 1, 1, subnam)
            call utleng(subnam, ileng)
            call difind(ldbnk, subnam(1:ileng), idir, lccmd)
            msg(1) = '"' // subnam(1:ileng)
     +      // '" is not known as a subroutine.'
            if (lccmd .eq. 0) then
              call rdfail('AASUBR', 1, msg)
            else if (iq(lccmd+mbpr) .ne. mpsub  .or.
     +               iq(lccmd+mbsp) .ne. 5) then
              call rdfail('AASUBR', 1, msg)
            else
              call aaruns
            endif

*---- Other subroutine commands not allowed here.
          else
            call rdfail('AASUBR', 1, 'Subroutine command out of order.')
          endif
        endif

*---- Lift command bank and decode attributes.
      else
        call kwget(lckey, iln, ipr, isp, nkat)
        call aabook(lccmd, label, ipr, isp, lckey, 1)
!        lq(lckey-2) = lq(lckey-2)
        call aaattr(lq(lckey-2), lccmd, nkat, eflag)

*---- If error detected, drop command bank, else link it to directory.
        if (eflag) then
          call aadrop(lccmd)
        else
          call didefi(ldbnk, label, lccmd)

*---- ISP = 1 or 8: Build procedure bank for DO or IF and execute it.
          if (isp .eq. 1 .or. isp .eq. 8) then
            iq(lccmd+mbat+mcval) = iq(lccmd+mbat+mcval+mcsiz)
            call aaproc

*---- Execute DO or IF only when no LABEL is present.
            if (label .eq. ' ') then
              call aaruns
            endif

*---- ISP = 5: Build procedure bank for SUBROUTINE.
          else if (isp .eq. 5) then
            iq(lccmd+mbat+mcval) = 1
            call aaproc

*---- ISP = 7: Execute CALLSUBROUTINE.
          else if (isp .eq. 7) then
            call utgnam(lccmd, 1, 1, subnam)
            call utleng(subnam, ileng)
            call difind(ldbnk, subnam(1:ileng), idir, lccmd)
            msg(1) = '"' // subnam(1:ileng)
     +      // '" is not known as a subroutine.'
            if (lccmd .eq. 0) then
              call rdfail('AASUBR', 1, msg)
            else if (iq(lccmd+mbpr) .ne. mpsub  .or.
     +               iq(lccmd+mbsp) .ne. 5) then
              call rdfail('AASUBR', 1, msg)
            else
              call aaruns
            endif
          endif
        endif
      endif

      end
+dk aastrg
      subroutine aastrg(label, key)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode string or table-specific expression set.                    *
*   Uses the pointers to current keyword and current command.          *
* Input:                                                               *
*   LABEL    (char)     Name of element bank.                          *
*   KEY      (char)     Name of keyword bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer iln,ipr,isp,nkat
      character*(mcnam) label, key
+ca memdum
+ca option
+ca refer
+ca status
+ca stbuff

*---- Copy keyword to local storage.
      call kwget(lckey, iln, ipr, isp, nkat)

*---- Build new bank (no default values!).
      call aabook(lccmd, label, ipr, isp, lckey, 1)

*---- Decode attributes.
      call aaattr(lq(lckey-2), lccmd, nkat, error)

*---- DEFINE dump option.
      if (error) then
        call aadrop(lccmd)
      else
        call didefi(ldbnk, label, lccmd)
        if (ideffl .eq. 1  .or.  ideffl .eq. 3) then
          call aadump(lccmd)
        endif
        if (ideffl .eq. 2  .or.  ideffl .eq. 3) then
          call dzshow('string', 0, lccmd, 'V', 0, 0, 0, 0)
        endif
      endif

      end
+dk aavalu
      subroutine aavalu
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Execute VALUE command: List values of expressions.                 *
*   Uses the pointers to current keyword and current command.          *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca message
+ca refer
+ca savbuf
+ca zunit
+ca datatype
      integer icat,idata,ncat
      double precision val

      ncat = iq(lccmd+mbat)
      idata = mbat
      isave = iqlog
      do 90 icat = 1, ncat
        if (mod(iq(lccmd+idata+mctyp),10) .ne. 0) then
          call svbegn
          call svlitt('Value of expression "')
          call svattr(lccmd, icat, mtflt)
          call svlitt('" is: ')
          call ucopy(q(lccmd+idata+mcval), val, mwflt)
          call svreal(val)
          call svdump
        endif
        idata = idata + mcsiz
   90 continue

      end
+dk aawarn
      subroutine aawarn(rout, lines, text)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print warning message.                                             *
* Input:                                                               *
*   ROUT      (char)    Calling routine name.                          *
*   LINES     (integer) Number of lines in message.                    *
*   TEXT      (char)    Message.                                       *
*----------------------------------------------------------------------*
+ca aparam
      integer i,leng,lines
      character*(*)     rout, text(lines)
+ca option
+ca status
+ca zunit

      if (warn) then
        call utleng(text(1), leng)
        write (iqlog, 910) rout, text(1)(1:leng)
        do 90 i = 2, lines
          call utleng(text(i), leng)
          write (iqlog, 920) text(i)(1:leng)
   90   continue
        write (iqlog, 930)
        nwarn = nwarn + 1
      endif

  910 format(' '/' ',a,'.',t11,'## Warning ## ',a)
  920 format(t11,a)
  930 format(' ')

      end
+dk aazzzz
+dk bmaaaa
+dk bmbcon
      subroutine bmbcon(e0)
      implicit none
************************************************************************
*
*     Returns energy dependent parameters (used for energy variation)
*     in BEAMIS, common /BMPMRL/ (+CA BMPMCM)
*
* input:
*    E0      energy in eV
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca beam
+ca bmpmcm
+ca memdum
+ca optic0
      integer ierr
      double precision bmeqfa,bmfcn,e0,fac,rhs,se2,siglog,sxi2,ub,xtau

      external bmeqfa, bmfcn

*--- gamma = E/mc**2
      game0 = e0 / amasc2
*--- B_rho
      beamis(74) = e0 / clight
*--- polarization time
      beamis(76) = eight * circ / (five * sqrt(three) *
     +alamda * clight * arad * beamis(3) * game0**5)
*--- radiation loss per turn
      beamis(37) = two * arad * e0 * game0**3 * beamis(2) / p3d6
*--- common factor for damping times following
      fac = (three * amasc2**3 * circ) / (arad * e0**3 * clight)
*--- damping times tau_x, tau_y, tau_e
      beamis(38) = fac / (beamis(2) - beamis(4))
      beamis(39) = fac / beamis(2)
      beamis(40) = fac / (two * beamis(2) + beamis(4))
*--- common factor for energy spread and emittances
      fac = p55d0 * alamda * e0**2 / (p32d0 * sqrt(three) * amasc2
     +**2)
*--- sigma_e
      se2 = fac *  beamis(3) / (two * beamis(2) + beamis(4))
      beamis(41) = sqrt(abs(se2))
*--- E_x_0
      beamis(44) = fac * beamis(5) / (beamis(2) - beamis(4))
*--- sig_x_int, sig_y_int
      sxi2 = abs(beamis(44) * beamis(28))
      beamis(42) = sqrt(sxi2)
      beamis(43) = zero
*--- coupling dependent parameters
      call bmcdep(coupl)
*--- bucket
      if (iq(lq(lbmpm-1)+micmd+mpbuck) .eq. 0)  then
*--- bucket not given
        rhs = half * beamis(40) / tauqs
        call bmfdz1(bmeqfa, rhs, one, fifty, p1dm6, 1000, xtau, ierr)
        beamis(51) = beamis(41) * sqrt(two * xtau)
        bucket = sqrt(two * xtau)
      else
*--- bucket given
        beamis(51) = bucket * beamis(41)
        iubdef(51) = 1
        xtau       = min(half * bucket**2, p17d1)
        tauqs      = beamis(40) / (two * xtau * exp(-xtau))
*--- mark tau_Q as calculated
        idtauq = 0
      endif
      ub = beamis(51) * e0
      siglog = log(beamis(51))
      beamis(52) = (p16d0 / three) * arad**2 * falfa
     +* ((log(four * game0**2) - half) * ( - siglog - five / eight)
     +- p2dm1 + siglog * (half * siglog + pfsig))
      rhs = pi * ub**2 * cvharm * abs(beamis(20))
     +/ (beamis(37) * e0 * p1d6 )
      call bmfdz1(bmfcn, rhs, p1dm8, one, p1dm6, 1000, beamis(53),
     +ierr)

      end
+dk bmbetv
      function bmbetv(x, vec)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*-- Input:                                                             *
*   VEC     (real)   1: k                                              *
*                    2: K                                              *
*                    3: beta                                           *
*                    4: alpha                                          *
*                    5: gamma                                          *
*                                                                      *
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      double precision am11,am12,angle,beta,bmbetv,vec,x
      dimension vec(5)

      angle = x * vec(1)
      if (vec(2) .ge. zero ) then
      am11 = cos(angle)
      am12 = sin(angle) / vec(1)
      else
      am11 = cosh(angle)
      am12 = sinh(angle) / vec(1)
      endif
      beta = am11**2 * vec(3) - two * am11 * am12 * vec(4) + am12**2 *
     +vec(5)
      bmbetv = beta * sqrt(abs(beta))

      end
+dk bmcdep
      subroutine bmcdep(coup)
      implicit none
************************************************************************
*
*     Returns coupling dependent parameters
*     in BEAMIS, common /BMPMRL/ (+CA BMPMCM)
*
*--- input
*    COUP    coupling
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bmpmcm
      double precision coup,tmpb,tmpx,tmpy

      tmpx = beamis(44) / (one + coup**2)
      tmpb = tmpx * beamis(28)
      beamis(47) = sqrt(abs(tmpb))
      tmpy = coup**2 * tmpx * beamis(25) * beamis(29)
     +       / beamis(26)
      beamis(48) = sqrt(abs(tmpy))
      beamis(49) = sqrt(abs(tmpb + (beamis(30) * beamis(41))**2))
      beamis(50) = sqrt(abs(tmpy + (beamis(31) * beamis(41))**2))
      beamis(45) = beamis(47)**2 / beamis(28)
      beamis(46) = beamis(48)**2 / beamis(29)
      iubdef(45) = 0

      end
+dk bmcoup
      subroutine bmcoup(coup)
      implicit none
************************************************************************
*
*     Returns coupling
*
*--- Output:
*    COUP    coupling
*
************************************************************************
      integer mxerr
      double precision aa,b1,bb,coup,f1,f2,f2b,f3,f4,ff,gdq,sjxy,vb,vx,
     +x

+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bmerrc
+ca beam
+ca bmpmcm

      parameter (mxerr = 10)

      gdq = min(beamis(56), beamis(57)) * arad * beamis(29)
     +    / (twopi * bunch * game0 * delq)
      vx = beamis(44) * beamis(28)
      vb = (beamis(30) * beamis(41))**2
      b1 = beamis(29) / beamis(28)
      sjxy = beamis(25) / beamis(26)
      f1 = b1 * vb * vx * sjxy
      f2 = sjxy**2 * b1**2 * vx**2
      f2b = sjxy * b1 * vx**2
      f3 = gdq**2
      f4 = two * b1 * gdq * vx * sjxy
      aa = f1 - f2 - f3 + f4
      bb = f1 + f2b - two * f3 + f4
      ff = bb**2 + four * aa * gdq**2
      x = ( - bb + sqrt(abs(ff))) / (two * aa)
      if (x .ge. zero .and. ff .ge. zero) then
        coup = sqrt(x)
      else
        coup = zero
        if (nerrup .lt. mxerr)  then
          nerrup = nerrup + 1
          call aawarn('BMCOUP', 1,
     +    'Fourth order equation for coupling has no real root.')
        endif
      endif

      end
+dk bmcurr
      subroutine bmcurr(e0, pgiven, igiven)
      implicit none
************************************************************************
*
*     Returns currents, luminosities, particle numbers...
*     in BEAMIS, common /BMPMRL/ (+CA BMPMCM)
*
*--- input
*  E0        energy in eV
*  PGIVEN    TRUE if power given
*  IGIVEN    TRUE if current given
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca beam
+ca bmpmcm
+ca memdum
      integer ierr
      double precision bmzpow,dummy,e0,temp,temp1,temp2
      dimension dummy(2)

      logical pgiven, igiven

      external bmzpow

      if (pgiven)  then
        if (single)  then
          temp1 = beamis(37)
        else
          temp1 = two * beamis(37)
        endif
        temp2
     +  = (power - beamis(37)**2 / (cvleng * cvshnt * beamis(53)**2))
     +  / temp1 + p1dm2
        call bmfdz1(bmzpow, e0, p1dm3, temp2, p1dm6, 1000, beamis(54),
     +  ierr)
        beamis(55) = beamis(54)
        if (ierr .ne. 0)  then
          call aawarn('BMCURR', 2, 'Error when trying to find current'
     +    // ' --- values resulting from this will be wrong.')
        endif
        call bmludq(beamis(54), beamis(56), beamis(58), beamis(60),
     +  beamis(63))
*--- mark delta_Q as calculated
        iubdef(62) = 0
*--- voltage loss due to higher mode losses
        beamis(65) = p1d6 * beamis(33) * beamis(54)
        if (iubdef(36) .eq. 0)  then
*--- voltage not given - calculate
          call bmvolt(e0, beamis(54), beamis(36), beamis(64))
        else
          call bmvdat(beamis(36), e0, beamis(54), beamis(56),
     +    beamis(58))
*--- mark tau_Q as calculated
          idtauq = 0
        endif
        call bmsync(e0)
*--- call BMPOWR to get psi_RF and beta_RF
        call bmpowr(e0, beamis(54), dummy, beamis(70),
     +  beamis(71))
        if (iq(lq(lbmpm-1)+micmd+mpcoup) .eq. 0)  then
          if (beamis(62) .lt. delq)  then
*--- modify coupling because delta_q (calc) < delta_q (given)
            call bmcoup(coupl)
            idcoup = 0
*--- recalculate coupling dependent parameters
            call bmcdep(coupl)
            call bmludq(beamis(54), beamis(56), beamis(58),
     +      beamis(60), beamis(63))
          endif
        endif
*--- come here if power not given
      elseif (igiven)  then
*--- current given
        beamis(54) = beamis(35)
        beamis(55) = beamis(35)
        iubdef(54) = 1
        call bmludq(beamis(54), beamis(56), beamis(58), beamis(60),
     +  beamis(63))
*--- mark delta_Q as calculated
        iubdef(62) = 0
*--- voltage loss due to higher mode losses
        beamis(65) = p1d6 * beamis(33) * beamis(54)
        if (iubdef(36) .eq. 0)  then
*--- voltage not given - calculate
          call bmvolt(e0, beamis(54), beamis(36), beamis(64))
        else
          call bmvdat(beamis(36), e0, beamis(54), beamis(56),
     +    beamis(58))
*--- mark tau_Q as calculated
          idtauq = 0
        endif
        call bmsync(e0)
        call bmpowr(e0, beamis(54), beamis(72), beamis(70),
     +  beamis(71))
        if (iq(lq(lbmpm-1)+micmd+mpcoup) .eq. 0)  then
          if (beamis(62) .lt. delq)  then
*--- modify coupling because delta_q (calc) < delta_q (given)
            call bmcoup(coupl)
            idcoup = 0
*--- recalculate coupling dependent parameters
            call bmcdep(coupl)
            call bmludq(beamis(54), beamis(56), beamis(58),
     +      beamis(60), beamis(63))
          endif
        endif
      else
*--- consider DELQ as given
*    particle numbers:
        temp = twopi * delq * bunch * (beamis(49)
     +  + beamis(50)) * game0 / arad
        beamis(56) = temp * beamis(49) / beamis(28)
        beamis(57) = temp * beamis(50) / beamis(29)
*---  currents:
        beamis(54) = qelect * beamis(24) * beamis(56)
        beamis(55) = qelect * beamis(24) * beamis(57)
        call bmludq(beamis(54), dummy, beamis(58), beamis(60),
     +  beamis(63))
*--- voltage loss due to higher mode losses
        beamis(65) = p1d6 * beamis(33) * min(beamis(54), beamis(55))
        if (iubdef(36) .eq. 0)  then
*--- voltage not given - calculate
          call bmvolt(e0, min(beamis(54), beamis(55)), beamis(36),
     +    beamis(64))
        else
          call bmvdat(beamis(36), e0, min(beamis(54), beamis(55)),
     +    min(beamis(56), beamis(57)), min(beamis(58), beamis(59)))
*--- mark tau_Q as calculated
          idtauq = 0
        endif
        call bmsync(e0)
        call bmpowr(e0, min(beamis(54), beamis(55)), beamis(72),
     +  beamis(70), beamis(71))
      endif

      end
+dk bmeget
      subroutine bmeget(nel, nelret)
      implicit none
************************************************************************
*
*     returns parameters of one element in /OPTIC1/
*
*--- input
*    NEL       # of element requested
*--- output
*    NELRET    # of element returned = MIN(MAX(1,NEL),NBMELM)
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bmpmcm
+ca bankhead
+ca prcgroup
+ca seqflag
+ca seqgroup
+ca memdum
+ca optic0
+ca optic1
+ca refer
      integer i,ienum,iocc,ipos,nel,nelret
      double precision temp

      dimension temp(mnmcav)

      character*(mcnam) elmnam

      nelret = min(max(1,nel), nbmelm)
      ipos   = iq(lbmpm+nelret)
      call utelem(lcseq, ipos, iflgbm, elmnam, iocc, ienum)
*--- get element description
      call diname(ldkey, iq(lq(lcelm+1)+mbnam), chtype)
      chname = elmnam
      call bmgelm(lcelm, temp)
      eleng = temp(1)
      elang = temp(2)
      elak1 = -temp(3)
      elak2 = -temp(4)
      ele1d = temp(6)
      ele2d = temp(7)
*--- get Twiss parameters
      if (nelret .eq. 1)  then
*--- first element - take Twiss parameters from special buffer
        alfx = alfx0
        betx = betx0
        amux = amux0
        alfy = alfy0
        bety = bety0
        amuy = amuy0
        do 10  i = 1, 4
   10   disp(i) = disp0(i)
      else
        ipos   = iq(lbmpm+nelret - 1)
        call twbtsv(3, ipos)
      endif

  999 end
+dk bmenpw
      subroutine bmenpw(ierr)
      implicit none
************************************************************************
*
*     Calculates energy such that power (calc.) = POWER
*
*--- output in common /BMPMCM/, and
*    IERR      0: OK
*              1: POWER not big enough to raise energy, energy unchanged
*              2: max. no. of iteration reached, energy best value
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bmpmcm
      integer ierr,iter,itermx
      double precision ca,cb,cc,ee,epsi,f1,f2,f3,fa,fb,ff,fx,r,u1,u2,u3,
     +u4,x1,x2,x3,xa,xb,xx,xz
      epsi = p1dm3
      itermx = 100
      xa = energv
      xb = two * energv
      call bmvpow(p1d9 * xa, fa)
      call bmvpow(p1d9 * xb, fb)
      if (fa * fb .gt. zero) then
        ierr = 1
        goto 999
      endif
      ierr = 0
      iter = 0
   10 continue
      xz = (xa + xb) / 2
      r = xz - xa
      ee = epsi * (abs(xz) + 1)
      if (r .le. ee) goto 999
      f1 = fa
      x1 = xa
      f2 = fb
      x2 = xb
   20 continue
      iter = iter + 1
      if (iter .gt. itermx) then
        ierr = 2
        goto 900
      endif
      call bmvpow(p1d9 * xz, fx)
      if (fx * fa .gt. zero) then
        xa = xz
        fa = fx
      else
        xb = xz
        fb = fx
      endif
*--- parabola iteration
   30 continue
      u1 = f1 - f2
      u2 = x1 - x2
      u3 = f2 - fx
      u4 = x2 - xz
      if (u2 .eq. zero .or. u4 .eq. zero) go to 10
      f3 = fx
      x3 = xz
      u1 = u1 / u2
      u2 = u3 / u4
      ca = u1 - u2
      cb = (x1 + x2) * u2 - (x2 + xz) * u1
      cc = (x1 - xz) * f1 - x1 * (ca * x1 + cb)
      if (ca .eq. zero) then
        if (cb .eq. zero) go to 10
        xz = - cc / cb
      else
        u3 = cb / (2 * ca)
        u4 = u3**2 - cc / ca
        if (u4 .lt. zero) go to 10
        xz = - u3 + sign(sqrt(u4), xz + u3)
      endif
      if (xz .lt. xa .or. xz .gt. xb) go to 10
      r = min(abs(xz - x3), abs(xz - x2))
      ee = epsi * (abs(xz) + 1)
      if (r .gt. ee) then
        f1 = f2
        x1 = x2
        f2 = f3
        x2 = x3
        go to 20
      endif
      call bmvpow(p1d9 * xz, fx)
      if (fx .eq. zero) goto 900
      if (fx * fa .lt. 0) then
        xx = xz - ee
        if (xx .le. xa) go to 900
        call bmvpow(p1d9 * xx, ff)
        fb = ff
        xb = xx
      else
        xx = xz + ee
        if (xx .ge. xb) go to 900
        call bmvpow(p1d9 * xx, ff)
        fa = ff
        xa = xx
      endif
      if (fx * ff .gt. 0) then
        iter = iter + 2
        if (iter .gt. itermx) then
          ierr = 2
          goto 900
        endif
        f1 = f3
        x1 = x3
        f2 = fx
        x2 = xz
        xz = xx
        fx = ff
        go to 30
      endif
  900 continue
*--- fit terminated
      energv = xz
      enerev = p1d9 * energv

  999 end
+dk bmeqfa
      function bmeqfa(x, rhs)
      implicit none
*---------------------------------------
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      double precision bmeqfa,rhs,x
      bmeqfa = rhs - x * exp( - x)

      end
+dk bmfcn
      function bmfcn(x, rhs)
      implicit none
*---------------------------------------
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      double precision bmfcn,rhs,x
      bmfcn = two * sqrt(one / x**2 - one ) - two * acos(x) - rhs

      end
+dk bmfdz1
      subroutine bmfdz1(f, fconst, a, b, eps, itermx, xz, ierr)
      implicit none
************************************************************************
*
*     Zero finder.
*
*--- input
*    F         function of which zero is to be found, F = F(X, FCONST)
*    FCONST    constants passed to F
*    A         lower limit of search interval
*    B         upper limit of search interval
*    EPS       abs. max. of F required
*    ITERMX    max. no. of iterations
*--- output
*    XZ        zero of F if IERR = 0
*    IERR      0: OK
*              1: F(A, FCONST) * F(B, FCONST) > 0, XZ set to A
*              2: max. no. of iteration reached, XZ best value
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer ierr,iter,itermx
      double precision a,b,ca,cb,cc,ee,eps,epsi,f,f1,f2,f3,fa,fb,fconst,
     +ff,fx,r,u1,u2,u3,u4,x1,x2,x3,xa,xb,xx,xz

      external  f

      dimension fconst(*)

      epsi = max(eps, p1dm15)
      xa = min(a, b)
      xb = max(a, b)
      fa = f(xa, fconst)
      fb = f(xb, fconst)
      if (fa * fb .gt. zero) then
        xz = half * (a + b)
        ierr = 1
        goto 999
      endif
      ierr = 0
      iter = 0
   10 continue
      xz = (xa + xb) / 2
      r = xz - xa
      ee = epsi * (abs(xz) + 1)
      if (r .le. ee) goto 999
      f1 = fa
      x1 = xa
      f2 = fb
      x2 = xb
   20 continue
      iter = iter + 1
      if (iter .gt. itermx) then
        ierr = 2
        goto 999
      endif
      fx = f(xz, fconst)
      if (fx * fa .gt. zero) then
        xa = xz
        fa = fx
      else
        xb = xz
        fb = fx
      endif
*--- parabola iteration
   30 continue
      u1 = f1 - f2
      u2 = x1 - x2
      u3 = f2 - fx
      u4 = x2 - xz
      if (u2 .eq. zero .or. u4 .eq. zero) go to 10
      f3 = fx
      x3 = xz
      u1 = u1 / u2
      u2 = u3 / u4
      ca = u1 - u2
      cb = (x1 + x2) * u2 - (x2 + xz) * u1
      cc = (x1 - xz) * f1 - x1 * (ca * x1 + cb)
      if (ca .eq. zero) then
        if (cb .eq. zero) go to 10
        xz = - cc / cb
      else
        u3 = cb / (2 * ca)
        u4 = u3**2 - cc / ca
        if (u4 .lt. zero) go to 10
        xz = - u3 + sign(sqrt(u4), xz + u3)
      endif
      if (xz .lt. xa .or. xz .gt. xb) go to 10
      r = min(abs(xz - x3), abs(xz - x2))
      ee = epsi * (abs(xz) + 1)
      if (r .gt. ee) then
        f1 = f2
        x1 = x2
        f2 = f3
        x2 = x3
        go to 20
      endif
      fx = f(xz, fconst)
      if (fx .eq. zero) goto 999
      if (fx * fa .lt. 0) then
        xx = xz - ee
        if (xx .le. xa) go to 999
        ff = f(xx, fconst)
        fb = ff
        xb = xx
      else
        xx = xz + ee
        if (xx .ge. xb) go to 999
        ff = f(xx, fconst)
        fa = ff
        xa = xx
      endif
      if (fx * ff .gt. 0) then
        iter = iter + 2
        if (iter .gt. itermx) then
          ierr = 2
          goto 999
        endif
        f1 = f3
        x1 = x3
        f2 = fx
        x2 = xz
        xz = xx
        fx = ff
        go to 30
      endif

  999 end
+dk bmfdz2
      subroutine bmfdz2(f, fconst, a, b, eps, itermx, xz, ierr)
      implicit none
************************************************************************
*
*     Zero finder (straight copy of BMFDZ1 because FORTRAN does not
*     allow recursive calls).
*
*--- input
*    F         function of which zero is to be found, F = F(X, FCONST)
*    FCONST    constants passed to F
*    A         lower limit of search interval
*    B         upper limit of search interval
*    EPS       abs. max. of F required
*    ITERMX    max. no. of iterations
*--- output
*    XZ        zero of F if IERR = 0
*    IERR      0: OK
*              1: F(A, FCONST) * F(B, FCONST) > 0, XZ set to A
*              2: max. no. of iteration reached, XZ best value
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer ierr,iter,itermx
      double precision a,b,ca,cb,cc,ee,eps,epsi,f,f1,f2,f3,fa,fb,fconst,
     +ff,fx,r,u1,u2,u3,u4,x1,x2,x3,xa,xb,xx,xz

      external  f

      dimension fconst(*)

      epsi = max(eps, p1dm15)
      xa = min(a, b)
      xb = max(a, b)
      fa = f(xa, fconst)
      fb = f(xb, fconst)
      if (fa * fb .gt. zero) then
        xz = half * (a + b)
        ierr = 1
        goto 999
      endif
      ierr = 0
      iter = 0
   10 continue
      xz = (xa + xb) / 2
      r = xz - xa
      ee = epsi * (abs(xz) + 1)
      if (r .le. ee) goto 999
      f1 = fa
      x1 = xa
      f2 = fb
      x2 = xb
   20 continue
      iter = iter + 1
      if (iter .gt. itermx) then
        ierr = 2
        goto 999
      endif
      fx = f(xz, fconst)
      if (fx * fa .gt. zero) then
        xa = xz
        fa = fx
      else
        xb = xz
        fb = fx
      endif
*--- parabola iteration
   30 continue
      u1 = f1 - f2
      u2 = x1 - x2
      u3 = f2 - fx
      u4 = x2 - xz
      if (u2 .eq. zero .or. u4 .eq. zero) go to 10
      f3 = fx
      x3 = xz
      u1 = u1 / u2
      u2 = u3 / u4
      ca = u1 - u2
      cb = (x1 + x2) * u2 - (x2 + xz) * u1
      cc = (x1 - xz) * f1 - x1 * (ca * x1 + cb)
      if (ca .eq. zero) then
        if (cb .eq. zero) go to 10
        xz = - cc / cb
      else
        u3 = cb / (2 * ca)
        u4 = u3**2 - cc / ca
        if (u4 .lt. zero) go to 10
        xz = - u3 + sign(sqrt(u4), xz + u3)
      endif
      if (xz .lt. xa .or. xz .gt. xb) go to 10
      r = min(abs(xz - x3), abs(xz - x2))
      ee = epsi * (abs(xz) + 1)
      if (r .gt. ee) then
        f1 = f2
        x1 = x2
        f2 = f3
        x2 = x3
        go to 20
      endif
      fx = f(xz, fconst)
      if (fx .eq. zero) goto 999
      if (fx * fa .lt. 0) then
        xx = xz - ee
        if (xx .le. xa) go to 999
        ff = f(xx, fconst)
        fb = ff
        xb = xx
      else
        xx = xz + ee
        if (xx .ge. xb) go to 999
        ff = f(xx, fconst)
        fa = ff
        xa = xx
      endif
      if (fx * ff .gt. 0) then
        iter = iter + 2
        if (iter .gt. itermx) then
          ierr = 2
          goto 999
        endif
        f1 = f3
        x1 = x3
        f2 = fx
        x2 = xz
        xz = xx
        fx = ff
        go to 30
      endif

  999 end
+dk bmgau1
      function bmgau1(fuser, vec, a, b, eps, ierr)
      implicit none
************************************************************************
*     This is a (modified) copy of DGAUSS, renamed BMGAU1. Necessary
*     because of single / double precision.
*
*     Adaptive Gaussian quadrature.
*
*     BMGAU1 is set equal to the approximate value of the integral of
*     the function FUSER over [A,B], with accuracy parameter EPS.
*     VEC contains the additional user parameters for FUSER.
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer i,ierr
      double precision a,aa,b,bb,bmgau1,c1,c2,const,eps,fuser,s16,s8,u,
     +vec,w,x
      dimension vec(*)
      dimension w(12), x(12)

      external fuser

      data w / 0.10122 85362 90376 259d0,
     1         0.22238 10344 53374 471d0,
     2         0.31370 66458 77887 287d0,
     3         0.36268 37833 78361 983d0,
     4         0.27152 45941 17540 949d-1,
     5         0.62253 52393 86478 929d-1,
     6         0.95158 51168 24927 848d-1,
     7         0.12462 89712 55533 872d0,
     8         0.14959 59888 16576 732d0,
     9         0.16915 65193 95002 538d0,
     a         0.18260 34150 44923 589d0,
     b         0.18945 06104 55068 496d0/
      data x / 0.96028 98564 97536 232d0,
     1         0.79666 64774 13626 740d0,
     2         0.52553 24099 16328 986d0,
     3         0.18343 46424 95649 805d0,
     4         0.98940 09349 91649 933d0,
     5         0.94457 50230 73232 576d0,
     6         0.86563 12023 87831 744d0,
     7         0.75540 44083 55003 034d0,
     8         0.61787 62444 02643 748d0,
     9         0.45801 67776 57227 386d0,
     a         0.28160 35507 79258 913d0,
     b         0.95012 50983 76374 402d-1/
************************************************************************

      bmgau1 = zero
      ierr = 0
      if (b .eq. a) goto 999
      const = p5dm3 / (b - a)
      bb = a
*--- loop
   10 aa = bb
      bb = b
   20 c1 = half * (bb + aa)
      c2 = half * (bb - aa)
      s8 = zero
      do 30 i = 1, 4
        u = c2 * x(i)
        s8 = s8 + w(i) * (fuser(c1 + u, vec) + fuser(c1 - u, vec))
   30 continue
      s8 = c2 * s8
      s16 = zero
      do 40 i = 5, 12
        u = c2 * x(i)
        s16 = s16 + w(i) * (fuser(c1 + u, vec) + fuser(c1 - u, vec))
   40 continue
      s16 = c2 * s16
      if ( abs(s16 - s8) .gt. eps * (1. + abs(s16)) ) then
        if ( one + abs(const * c2) .eq. one) then
          bmgau1 = zero
          ierr = 1
          goto 999
        endif
        bb = c1
        goto 20
      endif
      bmgau1 = bmgau1 + s16
      if (bb .ne. b) go to 10

  999 end
+dk bmgau2
      function bmgau2(fuser, vec, a, b, eps, ierr)
      implicit none
************************************************************************
*     This is a copy of BMGAU1, renamed BMGAU2. Necessary because of
*     double integration.
*
*     Adaptive Gaussian quadrature.
*
*     BMGAU2 is set equal to the approximate value of the integral of
*     the function FUSER over [A,B], with accuracy parameter EPS.
*     VEC contains the additional user parameters for FUSER.
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer i,ierr
      double precision a,aa,b,bb,bmgau2,c1,c2,const,eps,fuser,s16,s8,u,
     +vec,w,x
      dimension vec(*)
      dimension w(12), x(12)

      external fuser

      data w / 0.10122 85362 90376 259d0,
     1         0.22238 10344 53374 471d0,
     2         0.31370 66458 77887 287d0,
     3         0.36268 37833 78361 983d0,
     4         0.27152 45941 17540 949d-1,
     5         0.62253 52393 86478 929d-1,
     6         0.95158 51168 24927 848d-1,
     7         0.12462 89712 55533 872d0,
     8         0.14959 59888 16576 732d0,
     9         0.16915 65193 95002 538d0,
     a         0.18260 34150 44923 589d0,
     b         0.18945 06104 55068 496d0/
      data x / 0.96028 98564 97536 232d0,
     1         0.79666 64774 13626 740d0,
     2         0.52553 24099 16328 986d0,
     3         0.18343 46424 95649 805d0,
     4         0.98940 09349 91649 933d0,
     5         0.94457 50230 73232 576d0,
     6         0.86563 12023 87831 744d0,
     7         0.75540 44083 55003 034d0,
     8         0.61787 62444 02643 748d0,
     9         0.45801 67776 57227 386d0,
     a         0.28160 35507 79258 913d0,
     b         0.95012 50983 76374 402d-1/
************************************************************************

      bmgau2 = zero
      ierr = 0
      if (b .eq. a) goto 999
      const = p5dm3 / (b - a)
      bb = a
*--- loop
   10 aa = bb
      bb = b
   20 c1 = half * (bb + aa)
      c2 = half * (bb - aa)
      s8 = zero
      do 30 i = 1, 4
        u = c2 * x(i)
        s8 = s8 + w(i) * (fuser(c1 + u, vec) + fuser(c1 - u, vec))
   30 continue
      s8 = c2 * s8
      s16 = zero
      do 40 i = 5, 12
        u = c2 * x(i)
        s16 = s16 + w(i) * (fuser(c1 + u, vec) + fuser(c1 - u, vec))
   40 continue
      s16 = c2 * s16
      if ( abs(s16 - s8) .gt. eps * (1. + abs(s16)) ) then
        if ( one + abs(const * c2) .eq. one) then
          bmgau2 = zero
          ierr = 1
          goto 999
        endif
        bb = c1
        goto 20
      endif
      bmgau2 = bmgau2 + s16
      if (bb .ne. b) go to 10

  999 end
+dk bmgcav
      subroutine bmgcav(number, cvp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Return parameters of cavity with element # = NUMBER                *
*   Uses data from BEAM command and current beam line sequence.        *
* Input:                                                               *
*   NUMBER    (int)    element number                                  *
* Output:                                                              *
*   CVP       (real)   cavity parameters:                              *
*--- parameters of cavities                                            *
*                      1 = cavity voltage [MV]                         *
*                      2 = tuning angle [rad/2pi]                      *
*                      3 = frequency [MHz]                             *
*                      4 = length [m]                                  *
*                      5 = beta                                        *
*                      6 = power [MW]                                  *
*                      7 = shunt impedance  [MOhm]                     *
*                      8 = unloaded filling time [micro-sec]           *
*                      9 = harmonic number                             *
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca seqgroup
+ca datatype
+ca bmpmcm
+ca memdum
+ca beam
+ca optic0
+ca refer
      integer ipos,mbetrf,mpg,mshunt,mtfill,number
      double precision cvp

      parameter (mbetrf = mehrmc + mcsiz,
     +           mpg = mbetrf + mcsiz, mshunt = mpg + mcsiz,
     +           mtfill = mshunt + mcsiz)

      dimension cvp(*)

      ipos = iq(lq(lbmpm-2)+number)
      lcelm = lq(ldbnk(3)-iq(lq(lcseq-msdir)+ipos))
      call ucopy(q(lcelm+mevltc), cvp(1), mwflt)
      call ucopy(q(lcelm+melagc), cvp(2), mwflt)
      call ucopy(q(lcelm+melen),  cvp(4), mwflt)
      call ucopy(q(lcelm+mbetrf), cvp(5), mwflt)
      call ucopy(q(lcelm+mpg),    cvp(6), mwflt)
      call ucopy(q(lcelm+mshunt), cvp(7), mwflt)
      call ucopy(q(lcelm+mtfill), cvp(8), mwflt)
      cvp(9) = iq(lcelm+mehrmc)
      cvp(3) = cvp(9) * (betas * clight) / (p1d6 * circ)
      if (cvp(8) .le. zero) cvp(8) = p25d0

  999 end
+dk bmgcmd
      subroutine bmgcmd(ierr)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Returns unpacked BMPM command parameters.                          *
*                                                                      *
*+++ Input and output via common blocks                                *
* Output:                                                              *
*                                                                      *
*   IERR      (integer) =0: OK, >0 : error in command                  *
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bmpmcm
+ca memdum
+ca refer
      integer i,i1,i2,ierr
      double precision tval

      integer    itype(mgcmd), ind(micmd)

      logical    eflag, ldum(mlcmd)

      dimension  tval(mgcmd)

*--- integers
      nint = 0
      intrct = 0
*--- logicals
      synrad = .false.
      clorb  = .false.
      tousch = .false.
      single = .false.
      evary  = .false.
      polwig = .false.
      midarc = .false.
*--- start command decoding
      ierr = 0
*--- get flag whether var. read or not
      call utgtyp(lccmd, itype)
*--- integers
      call utgint(lccmd, 1, micmd, ind)
      if (itype(mpnint) .ne. 0) nint = ind(mpnint)
*--- reals
      dspytl = p1dm3
      call utgflt(lccmd, micmd+1, mrcmd, tval(micmd+1))
      if (itype(micmd+mpdelq) .ne. 0) delq   = tval(micmd+mpdelq)
      if (itype(micmd+mptauq) .ne. 0) tauq   = tval(micmd+mptauq)
      if (itype(micmd+mpbuck) .ne. 0) bucket = tval(micmd+mpbuck)
      if (itype(micmd+mpcoup) .ne. 0) coupl  = tval(micmd+mpcoup)
      if (itype(micmd+mpi4i2) .ne. 0) si4i2  = tval(micmd+mpi4i2)
      if (itype(micmd+mpexda) .ne. 0) exdata = tval(micmd+mpexda)
      if (itype(micmd+mpxbsz) .ne. 0) fxbeam = tval(micmd+mpxbsz)
      if (itype(micmd+mpybsz) .ne. 0) fybeam = tval(micmd+mpybsz)
      if (itype(micmd+mpkhm)  .ne. 0) fctkhm = tval(micmd+mpkhm)
      if (itype(micmd+mpytol) .ne. 0) dspytl = tval(micmd+mpytol)
*--- logicals
      call utglog(lccmd, mrcmd+1, mlcmd, ldum(mrcmd+1))
      if (itype(mrcmd+mpsynr) .ne. 0) synrad = ldum(mrcmd+mpsynr)
      if (itype(mrcmd+mpclor) .ne. 0) clorb  = ldum(mrcmd+mpclor)
      if (itype(mrcmd+mptous) .ne. 0) tousch = ldum(mrcmd+mptous)
      if (itype(mrcmd+mpsing) .ne. 0) single = ldum(mrcmd+mpsing)
      if (itype(mrcmd+mpevar) .ne. 0) evary  = ldum(mrcmd+mpevar)
      if (itype(mrcmd+mpmidc) .ne. 0) midarc = ldum(mrcmd+mpexda)
*--- names
*              empty
*--- ranges
      if (itype(mncmd+mpintr) .ne. 0) then
        call utgrng(lq(lccmd-(mncmd+mpintr)), lcseq, i1, i2, eflag)
        if (eflag)  then
          intrct = 0
        else
          intrct = i1
        endif
      endif
      if (itype(mncmd+mprang) .ne. 0) then
        call utgrng(lq(lccmd-(mncmd+mprang)), lcseq, ilolim, ihilim,
     +  eflag)
        if (eflag)  ierr = 1
      else
        ilolim = 1
        ihilim = 0
      endif
*--- checks of defaults etc.
      if (si4i2 .eq. zero .and. itype(micmd+mpi4i2) .ne. 0) then
        itype(micmd+mpi4i2) = 0
        call aawarn('BMGCMD',1,'Illegal user value I4I2 = 0 ignored.')
      endif
      if (exdata .eq. zero .and. itype(micmd+mpexda) .ne. 0) then
        itype(micmd+mpexda) = 0
        call aawarn('BMGCMD',1,'Illegal user value EXDATA = 0 ignored.')
      endif
      if (bucket .eq. zero .and. itype(micmd+mpbuck) .ne. 0) then
        itype(micmd+mpbuck) = 0
        call aawarn('BMGCMD',1,'Illegal user value BUCKET = 0 ignored.')
      endif
      if (tauq .eq. zero .and. itype(micmd+mptauq) .ne. 0) then
        itype(micmd+mptauq) = 0
        call aawarn('BMGCMD',1,'Illegal user value TAUQ = 0 ignored.')
      endif
      tauqs = sixty * tauq
      if (delq .eq. zero .and. itype(micmd+mpdelq) .ne. 0) then
        itype(micmd+mpdelq) = 0
        call aawarn('BMGCMD',1,'Illegal user value DELQ = 0 ignored.')
      endif
      if (fxbeam .eq. zero .and. itype(micmd+mpxbsz) .ne. 0) then
        itype(micmd+mpxbsz) = 0
        call aawarn('BMGCMD',1,'Illegal user value FX = 0 ignored.')
      endif
      if (fybeam .eq. zero .and. itype(micmd+mpybsz) .ne. 0) then
        itype(micmd+mpybsz) = 0
        call aawarn('BMGCMD',1,'Illegal user value FY = 0 ignored.')
      endif
*--- store ITYPE in bank as 0: not given, 1: given by user
      do 10  i = 1, mgcmd
   10 iq(lq(lbmpm-1)+i) = min(1, itype(i))

  999 end
+dk bmgelm
      subroutine bmgelm(lelm, temp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Return element parameters for BEAMPARAM                            *
* Input:                                                               *
*   LELM(1)   (pointer) Current element bank.                          *
* Output:                                                              *
*   TEMP      (real)    Element parameters
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer isp
      double precision temp,xkick,ykick
      integer           lelm(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca codata
+ca refer

      dimension         temp(9)

      temp(1) = zero
      temp(2) = zero
      temp(3) = zero
      temp(4) = zero
      temp(5) = zero
      temp(6) = zero
      temp(7) = zero
      temp(8) = zero
      temp(9) = zero

*---- Select element type.
        isp = iq(lelm(1)+mbsp)
        go to ( 10,  20,  30,  40,  50,  60,  70,  80,  90, 100,
     +         110, 120, 130, 140, 150, 160, 170, 180, 190, 200,
     +         210, 220, 230, 240, 250, 260, 270, 280, 290, 300,
     +         310, 310, 310, 310, 310, 310, 310, 310, 310, 310), isp

*---- Drift.
   10   continue
*---- Monitor.
  170   continue
  180   continue
  190   continue

*---- Collimator.
  200   continue
  210   continue

*---- Beam instrument.
  240   continue
          call ucopy(q(lelm(1)+melen), temp(1), mwflt)
        go to 500

*---- Rectangular or sector bend.
   20   continue
   30   continue
          call ucopy(q(lelm(1)+melen), temp(1), mwflt)
          call ucopy(q(lelm(1)+meangb), temp(2), mwflt)
          call ucopy(q(lelm(1)+mek1b), temp(3), mwflt)
          call ucopy(q(lelm(1)+mek2b), temp(4), mwflt)
          call ucopy(q(lelm(1)+metltb), temp(5), mwflt)
          call ucopy(q(lelm(1)+mee1b), temp(6), mwflt)
          call ucopy(q(lelm(1)+mee2b), temp(7), mwflt)
          call ucopy(q(lelm(1)+meh1b), temp(8), mwflt)
          call ucopy(q(lelm(1)+meh2b), temp(9), mwflt)
        go to 500

*---- Quadrupole.
   50   continue
          call ucopy(q(lelm(1)+melen), temp(1), mwflt)
          call ucopy(q(lelm(1)+mek1q), temp(3), mwflt)
          call ucopy(q(lelm(1)+metltq), temp(5), mwflt)
        go to 500

*---- Sextupole.
   60   continue
          call ucopy(q(lelm(1)+melen), temp(1), mwflt)
          call ucopy(q(lelm(1)+mek2s), temp(4), mwflt)
          call ucopy(q(lelm(1)+metlts), temp(5), mwflt)
        go to 500

*---- Octupole.
   70   continue
          call ucopy(q(lelm(1)+melen), temp(1), mwflt)
          call ucopy(q(lelm(1)+metlto), temp(5), mwflt)
          call ucopy(q(lelm(1)+mek3o), temp(6), mwflt)
        go to 500

*---- Multipole.
   80   continue
          call ucopy(q(lelm(1)+meklm),         temp(2), mwflt)
          call ucopy(q(lelm(1)+meklm+2*mcsiz), temp(3), mwflt)
          call ucopy(q(lelm(1)+meklm+4*mcsiz), temp(4), mwflt)
          call ucopy(q(lelm(1)+meklm+6*mcsiz), temp(6), mwflt)
          call ucopy(q(lelm(1)+metltm),         temp(5), mwflt)
          call ucopy(q(lelm(1)+metltm+2*mcsiz), temp(7), mwflt)
          call ucopy(q(lelm(1)+metltm+4*mcsiz), temp(8), mwflt)
          call ucopy(q(lelm(1)+metltm+6*mcsiz), temp(9), mwflt)
        go to 500

*---- Solenoid.
   90   continue
          call ucopy(q(lelm(1)+melen), temp(1), mwflt)
          call ucopy(q(lelm(1)+mekss), temp(6), mwflt)
        go to 500

*---- RF cavity.
  100   continue
          call ucopy(q(lelm(1)+melen), temp(1), mwflt)
          call ucopy(q(lelm(1)+mefrqc), temp(6), mwflt)
          call ucopy(q(lelm(1)+mevltc), temp(7), mwflt)
          call ucopy(q(lelm(1)+melagc), temp(8), mwflt)
        go to 500

*---- Electrostatic separator.
  110   continue
          call ucopy(q(lelm(1)+melen), temp(1), mwflt)
          call ucopy(q(lelm(1)+metlte), temp(5), mwflt)
          call ucopy(q(lelm(1)+meflde), temp(6), mwflt)
        go to 500

*---- Coordinate rotations.
  120   continue
  130   continue
          call ucopy(q(lelm(1)+meangr), temp(6), mwflt)
        go to 500

*---- Orbit correctors.
  140   continue
  150   continue
  160   continue
          call ucopy(q(lelm(1)+melen), temp(1), mwflt)

*---- Original setting.
          if (isp .eq. 14) then
            call ucopy(q(lcelm+mekick), xkick, mwflt)
            ykick = 0.0
          else if (isp .eq. 16) then
            xkick = 0.0
            call ucopy(q(lcelm+mekick), ykick, mwflt)
          else
            call ucopy(q(lcelm+mekick), xkick, mwflt)
            call ucopy(q(lcelm+mekick+mcsiz), ykick, mwflt)
          endif

*---- Correction from C.O. correction algorithm.
          if (lccom .ne. 0) then
            call ucopy(q(lccom+1), xcm, 2*mwflt)
          else
            xcm = 0.0
            ycm = 0.0
          endif

*---- Store sum of original setting and correction.
          temp(5) = xcm + xkick
          temp(6) = ycm + ykick
        go to 500

*---- General bend (dipole, quadrupole, and skew quadrupole).
  260 continue
          call ucopy(q(lelm(1)+melen), temp(1), mwflt)
          call ucopy(q(lelm(1)+meangg), temp(2), mwflt)
          call ucopy(q(lelm(1)+mek1g), temp(3), mwflt)
          call ucopy(q(lelm(1)+metltg), temp(5), mwflt)
        go to 500

*---- Other elements.
   40   continue
  220   continue
  230   continue
  250   continue
        goto 500
  270   continue
*---- L-cavity.
        call ucopy(q(lelm(1)+melen), temp(1), mwflt)
        call ucopy(q(lelm(1)+melen+4*mcsiz), temp(6), mwflt)
        call ucopy(q(lelm(1)+melen+2*mcsiz), temp(7), mwflt)
        call ucopy(q(lelm(1)+melen+3*mcsiz), temp(8), mwflt)
        go to 500

  280   continue
  290   continue
  300   continue
  310   continue
  500   continue

      end
+dk bmgetm
      subroutine bmgetm(nvar, x0, const, iter, xf, ierr)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Perform one or two parameter minimization                          *
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer i,ierr,iter,nn,nvar
      double precision a11,a12,a22,b11,b12,b22,bmgx,bmgxxd,bmgxyd,bmgy,
     +bmgyxd,bmgyyd,c1,c2,const,det,deti,dp,ps2,ps2n,vx,vxx,vxy,vy,vyx,
     +vyy,x,x0,xf,xn
      dimension x0(2), xf(2), const(4)
      dimension x(2), xn(2), dp(2)

      ierr = 0
      nn = 0
      do 10 i = 1, 2
        x(i)  = x0(i)
        xf(i) = x0(i)
   10 xn(i) = x0(i)
      if (nvar .eq. 1)  then
*--- minimize for second vcariable only (psi)
        vy = bmgy(xn, const)
        ps2 = vy**2
   20   continue
        nn   = nn + 1
        x(2) = xn(2)
        vyy = bmgyyd(x, const)
        if (abs(vyy) .lt. p1dm9) then
          ierr = 1
          goto 999
        endif
        xn(2) = x(2) - vy / vyy
        vy = bmgy(xn, const)
        ps2n  = vy**2
        if (nn .lt. iter .and. ps2n .lt. ps2) then
          ps2  = ps2n
          x(2) = xn(2)
          goto 20
        elseif (nn .eq. iter) then
          x(2) = xn(2)
        endif
        xf(2) = x(2)
      else
*--- minimize for both variables
        vx = bmgx(x, const)
        vy = bmgy(x, const)
        ps2 = vx**2 + vy**2
   30   continue
        nn  = nn + 1
        vxx = bmgxxd(x, const)
        vxy = bmgxyd(x, const)
        vyx = bmgyxd(x, const)
        vyy = bmgyyd(x, const)
        a11 = vxx**2 + vxy**2
        a12 = vxx * vyx + vxy * vyy
        a22 = vyx**2 + vyy**2
        det = a11 * a22 - a12**2
        if (abs(det)*p1d9 .lt. max(abs(a11), abs(a22), abs(a12))) then

          ierr = 2
          goto 999
        endif
        deti  = one / det
        b11   = a22 * deti
        b12   = -a12 * deti
        b22   = a11 * deti
        c1    = -(vxx * vx + vyx * vy)
        c2    = -(vyx * vx + vyy * vy)
        dp(1) = b11 * c1 + b12 * c2
        dp(2) = b12 * c1 + b22 * c2
        do 40 i = 1, 2
   40   xn(i) = x(i) + dp(i)
        vx = bmgx(xn, const)
        vy = bmgy(xn, const)
        ps2n = vx**2 + vy**2
        if (nn .lt. iter .and. ps2n .lt. ps2) then
          ps2 = ps2n
          do 50 i = 1, 2
   50     x(i) = xn(i)
          goto 30
        elseif (nn .eq. iter) then
          do 60 i = 1, 2
   60     x(i) = xn(i)
        endif
        do 70 i = 1, 2
   70   xf(i) = x(i)
      endif

  999 end
+dk bmgx
      function bmgx(x, const)
      implicit none
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      double precision bmg1,bmg1x,bmg2,bmg2x,bmgx,const,g1v,g2v,x
      dimension x(2), const(4)
      g1v = bmg1(x, const)
      g2v = bmg2(x, const)
      bmgx = two * (bmg1x(x, const) * g1v + bmg2x(x, const) * g2v) * (x
     +(1) - const(4)) - (g1v**2 + g2v**2)

      end
+dk bmgy
      function bmgy(x, const)
      implicit none
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      double precision bmg1,bmg1y,bmg2,bmg2y,bmgy,const,g1v,g2v,x
      dimension x(2), const(4)
      g1v = bmg1(x, const)
      g2v = bmg2(x, const)
      bmgy = x(2) * (g1v**2 + g2v**2) + (one + x(2)**2) * (bmg1y
     +(x, const) * g1v + bmg2y(x, const) * g2v)

      end
+dk bmgxxd
      function bmgxxd(x, const)
      implicit none
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer i
      double precision bmgx,bmgxxd,const,diff,x,xm,xp
      dimension x(2), const(4)
      dimension diff(2), xp(2), xm(2)
      diff(1) = p1dm3
      diff(2) = zero
      do 10  i = 1, 2
        xp(i) = x(i) + diff(i)
        xm(i) = x(i) - diff(i)
   10 continue
      bmgxxd = half * (bmgx(xp, const) - bmgx(xm, const)) / diff(1)

      end
+dk bmgyxd
      function bmgyxd(x, const)
      implicit none
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer i
      double precision bmgy,bmgyxd,const,diff,x,xm,xp
      dimension x(2), const(4)
      dimension diff(2), xp(2), xm(2)
      diff(1) = p1dm3
      diff(2) = zero
      do 10  i = 1, 2
        xp(i) = x(i) + diff(i)
        xm(i) = x(i) - diff(i)
   10 continue
      bmgyxd = half * (bmgy(xp, const) - bmgy(xm, const)) / diff(1)

      end
+dk bmgxyd
      function bmgxyd(x, const)
      implicit none
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer i
      double precision bmgx,bmgxyd,const,diff,x,xm,xp
      dimension x(2), const(4)
      dimension diff(2), xp(2), xm(2)
      diff(1) = zero
      diff(2) = p1dm3
      do 10  i = 1, 2
        xp(i) = x(i) + diff(i)
        xm(i) = x(i) - diff(i)
   10 continue
      bmgxyd = half * (bmgx(xp, const) - bmgx(xm, const)) / diff(2)

      end
+dk bmgyyd
      function bmgyyd(x, const)
      implicit none
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer i
      double precision bmgy,bmgyyd,const,diff,x,xm,xp
      dimension x(2), const(4)
      dimension diff(2), xp(2), xm(2)
      diff(1) = zero
      diff(2) = p1dm3
      do 10  i = 1, 2
        xp(i) = x(i) + diff(i)
        xm(i) = x(i) - diff(i)
   10 continue
      bmgyyd = half * (bmgy(xp, const) - bmgy(xm, const)) / diff(2)

      end
+dk bmg1
      function bmg1(x, const)
      implicit none
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      double precision an,bmg1,const,f1,x
      dimension x(2), const(4)
      if (x(1) .eq. zero)  then
        f1 = one / (one + x(2)**2)
      else
        an = two * (cosh(x(1)) - cos(x(1)*x(2)))
        f1 = x(1) * sinh(x(1)) / an
      endif
      bmg1 = const(1) * x(1) + const(3) * f1

      end
+dk bmg2
      function bmg2(x, const)
      implicit none
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      double precision an,bmg2,const,f2,x
      dimension x(2), const(4)
      if (x(1) .eq. zero)  then
        f2 = x(2) / (one + x(2)**2)
      else
        an = two * (cosh(x(1)) - cos(x(1)*x(2)))
        f2 = x(1) * sin(x(1)*x(2)) / an
      endif
      bmg2 = const(2) * x(1) + const(3) * f2

      end
+dk bmg1x
      function bmg1x(x, const)
      implicit none
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      double precision an,bmg1x,chx,const,cxy,f1x,shx,sxy,x
      dimension x(2), const(4)
      if (x(1) .eq. zero)  then
        f1x = zero
      else
        sxy = sin(x(1)*x(2))
        cxy = cos(x(1)*x(2))
        shx = sinh(x(1))
        chx = cosh(x(1))
        an  = two * (chx - cxy)**2
        f1x = x(1) * (one - x(2) * shx * sxy - chx * cxy)
     +  + shx * (chx - cxy)
        f1x = f1x / an
      endif
      bmg1x = const(1) + const(3) * f1x

      end
+dk bmg2x
      function bmg2x(x, const)
      implicit none
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      double precision an,bmg2x,chx,const,cxy,f2x,shx,sxy,x
      dimension x(2), const(4)
      if (x(1) .eq. zero)  then
        f2x = zero
      else
        sxy = sin(x(1)*x(2))
        cxy = cos(x(1)*x(2))
        shx = sinh(x(1))
        chx = cosh(x(1))
        an  = two * (chx - cxy)**2
        f2x = x(1) * x(2) * (chx * cxy - one)
     +  + sxy * (chx - cxy - x(1) * shx)
        f2x = f2x / an
      endif
      bmg2x = const(2) + const(3) * f2x

      end
+dk bmg1y
      function bmg1y(x, const)
      implicit none
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      double precision an,bmg1y,chx,const,cxy,f1y,shx,sxy,x
      dimension x(2), const(4)
      if (x(1) .eq. zero)  then
        f1y = - two * x(2) / (one + x(2)**2)**2
      else
        sxy = sin(x(1)*x(2))
        cxy = cos(x(1)*x(2))
        shx = sinh(x(1))
        chx = cosh(x(1))
        an  = two * (chx - cxy)**2
        f1y = -x(1)**2 * shx * sxy / an
      endif
      bmg1y = const(3) * f1y

      end
+dk bmg2y
      function bmg2y(x, const)
      implicit none
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      double precision an,bmg2y,chx,const,cxy,f2y,x
      dimension x(2), const(4)
      if (x(1) .eq. zero)  then
        f2y = (one - x(2)**2) / (one + x(2)**2)**2
      else
        cxy = cos(x(1)*x(2))
        chx = cosh(x(1))
        an  = two * (chx - cxy)**2
        f2y = x(1)**2 * (chx * cxy - one) / an
      endif
      bmg2y = const(3) * f2y

      end
+dk bmhavr
      function bmhavr(a, b, c, d, sleng, rho, sig, ang, sang, cang,
     +              dip2, dip3)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Calculates <H>, where                                              *
*   H = (ETA**2 + (BETA*ETAD -BETAD*ETA/2)**2) / BETA                  *
*-- Input:                                                             *
*   A       (real)   ETA                                               *
*   B       (real)   ETAD                                              *
*   C       (real)   BETA                                              *
*   D       (real)   BETAD                                             *
*   SLENG   (real)   element length                                    *
*   RHO     (real)   bending radius                                    *
*   SIG     (real)   sign of 1 - n                                     *
*   ANG     (real)   kl = sqrt(abs((1 - n) / rho**2))*l                *
*   SANG    (real)   sin(ang) or sinh(ang) depending on SIG            *
*   CANG    (real)   ditto cos(ang) or cosh(ang)                       *
*   DIP2    (real)   k**2                                              *
*   DIP3    (real)   k**3                                              *
*                                                                      *
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      double precision a,ang,b,bmhavr,c,cang,d,dip2,dip3,f,f1,f2,f3,rho,
     +sang,sig,sleng,sleng2,sleng3

      sleng2 = sleng**2
      sleng3 = sleng * sleng2
      f = one + d**2 / four
      f1 = a**2 * f / c - a * b * d+b**2 * c
      f2 = (two * sleng / rho) * (sig * ( - a * f / c + b * d / two)
     +* (ang - sang) / (sleng2 * dip3) + sig * ( - a * d / two
     ++ b *c) *(one - cang) / (dip2 * sleng2))

      f3 = (sleng2 / rho**2) * ((f / c) * (three * ang - four *
     +sang + sang * cang) / (two * dip2 * dip3 * sleng3) +
     +(d / two) * (one - cang)**2 / (dip2 * dip2 * sleng3) + c *
     +sig * (ang -cang * sang) / (two * dip3 * sleng3))
      bmhavr = f1 + f2 + f3

      end
+dk bmini1
      subroutine bmini1
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initializes before command decoding.                               *
*                                                                      *
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bmerrc
+ca bmpmcm
+ca bankhead
+ca prcgroup
+ca seqflag
+ca seqgroup
+ca memdum
+ca optic0
+ca refer
      integer i,l,nmax

      character*(mcnam) linnam
      character*(mcrng) rngnam
      character*40      vartex(mnmbmi)

      data (vartex(i), i = 1, 60)/
     +'I1 = int[D/rho]','I2 = int[1/rho**2]','I3 = int[1/abs(rho)**3]',
     +'I4 = int[(1/rho**2+2K)*D/rho]','I5 = int[H/abs(rho)**3]',
     +'I6X = int[K**2*betx]','I6Y = int[K**2*bety]',
     +'I7X = ???','I7Y = ???','I7XY = ???','I8X = ???','I8Y = ???',
     +'I9X = ???','I9Y = ???','ZETMAX','I8 = int[K**2*D**2]',
     +'SJXD = dJx/ddelta','SJYD = dJy/ddelta','SJED = dJe/ddelta',
     +'momentum compaction = I1 / circ','dE/E = -SI4I2 / SJXD',
     +'SI4I2 = I4 / I2','one-turn time [sec]','turn frequ. [Hz]',
     +'JX','JY','JE',
     +'beta_x at IP','beta_y at IP','D_x at IP','D_y at IP',
     +'cav. impedance','higher-mode loss','tau_z','beam current',
     +'RF voltage','radiation loss per turn','damping time tau_x',
     +'damping time tau_y','damping time tau_e','sigma_e',
     +'sig_x_0','sig_y_0','E_x_0','E_x_c','E_y_c','sig_x_c','sig_y_c',
     +'sig_x_T','sig_y_T',
     +'sigma_bucket','sigma_brems','beam-gamma_0',
     +'I_x [A]','I_y [A]','n_x','n_y','L_x','L_y',
     +'delta_q_x'/
      data (vartex(i), i = 61, mnmbmi)/
     +'delta_q_y','delta_q_c','tau_brems','beam_gamma',
     +'higher_mode voltage loss','phi_s',
     +'sig_z','nu_s','f_s','psi_rf','beta_rf','power',
     +'delta_frequ.(DFRF) [MHz]','B_rho [Tm]','Touschek lifetime [sec]',
     +'pol. time [sec]','SQX','SQY','SBX','SBY'/

      nerrsc = 0
      nerrat = 0
      nerrup = 0
      do 10  i = 1, mnmbmi
        iubdef(i) = 0
   10 chbvar(i) = vartex(i)
      do 20  i = 1, mnmcav
   20 iucdef(i) = 0
      radius = circ / twopi
      cvvolt = zero
      cvpsi  = zero
      cvfreq = zero
      cvleng = zero
      cvbtrf = zero
      cvpow  = zero
      cvshnt = twenty
      cvfill = p25d0
*--- get range, # sup.-per., and symm. flag of current line sequence
      call utbeam(lcseq, irg1, irg2, sym, isup, linnam, rngnam)
      if (sym) isup = 2 * isup
      nmax = irg2 + 1 - irg1
*--- book top bank for BMPM in division 1, containing the element pos.
      call mzbook(1, l, lbmpm, 1, 'BMPM', msbmpm, msbmpm, nmax, 0, -1)
*--- result bank
      call mzbook(1, l, lbmrs, 1, 'BMRS', msbmrs, msbmrs, 0, 0, -1)
*--- book bank for flag whether variables on command or not
      call mzbook(1, l, lbmpm, -1, 'FLAG', 0, 0, mgcmd, 0, 0)

  999 end
+dk bmini2
      subroutine bmini2(ierr,jerr)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initializes after command decoding                                 *
*-- Output:                                                            *
*   IERR    (int)    0: OK, 1: element with non-zero tilt,             *
*                    2: non-zero vert. dispersion at interaction pt.   *
*                    3: bet_x = zero, 4: bet_y = zero at int. point    *
*   JERR    (int)    (first) element causing the error                 *
*                                                                      *
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bmpmcm
+ca beam
+ca bankhead
+ca prcgroup
+ca seqflag
+ca seqgroup
+ca memdum
+ca optic0
+ca optic1
+ca refer
      integer i,ienum,ierr,iocc,ipos,jerr,k,l,ltemp,nnn,nrc
      double precision temp

      dimension temp(mnmcav)
      logical bmusrg

      character*(mcnam) elmnam
      character*8       chbnam(msbmrs)
      character * 60    stemp

      data chbnam/'beta_x','beta_y','brad_x','brad_y','sig_x*',
     +'sig_y*','RHOB','EC_synch','PW_synch','PHOTONS','BBARX',
     +'BBARY','PQX','PQY','PBX','PBY'/

      do 1 i = 1, mnmbmi
    1 beamis(i) = zero

*--- set defaults for unspecified variables
      if (iq(lq(lbmpm-1)+micmd+mptauq) .eq. 0) tauq = p6d2
      if (iq(lq(lbmpm-1)+micmd+mpdelq) .eq. 0) delq = p6dm2
      if (iq(lq(lbmpm-1)+micmd+mpxbsz) .eq. 0) fxbeam = one
      if (iq(lq(lbmpm-1)+micmd+mpybsz) .eq. 0) fybeam = one
      if (iq(lq(lbmpm-1)+micmd+mpkhm)  .eq. 0) fctkhm = zero
*--- TAUQ in [sec] rather than [min]
      tauqs  = sixty * tauq
      idcoup = iq(lq(lbmpm-1)+micmd+mpcoup)
      idtauq = iq(lq(lbmpm-1)+micmd+mptauq)
      iubdef(62) = iq(lq(lbmpm-1)+micmd+mpdelq)
      beamis(62) = delq

      ierr = 0
*--- store element numbers, count elements, get interaction point
      nbmelm = 0
      ihirng = 0
      ilorng = 0
      nrc = 0
      do 10  ipos = irg1, irg2
        call utelem(lcseq, ipos, iflgbm, elmnam, iocc, ienum)
        if (iq(lcelm+mbpr) .eq. mpelm)  then
*--- this is an element
          nbmelm = nbmelm + 1
          call bmgelm(lcelm, temp)
          if (temp(3) .ne. zero .and. temp(5) .ne. zero) then
*--- non-zero tilt
            ierr = 1
            jerr = nbmelm
            goto 999
          endif
          if (temp(2) * temp(3) .ne. zero .and. synrad)  then
            call aawarn('BMINI2', 1,
     +      'Gradient magnet suppresses synchrotron radiation.')
            synrad = .false.
          endif
          iq(lbmpm+nbmelm) = ipos
          if (ipos .ge. ilolim .and. ipos .le. ihilim)  then
            if (ilorng .eq. 0)  ilorng = nbmelm
            ihirng = nbmelm
          endif
          if (bmusrg(nbmelm, ilorng, ihirng, iflgbm))  nrc = nrc + 1
*--- RF cavity bank
          if (lq(lbmpm-2) .eq. 0)  then
*--- book bank
            call mzbook(1, l, lbmpm, -2, 'CAVS', 0, 0, 50, 0, -1)
            nbmcav = 0
          endif
          if (iq(lcelm+mbsp) .eq. 10) then
*--- RF cavity
            if (iq(lq(lbmpm-2)-1) .eq. nbmcav)  then
*--- push bank
              ltemp = lq(lbmpm-2)
              call mzpush(0, ltemp, 0, 50, 'I')
            endif
            nbmcav = nbmcav + 1
            iq(lq(lbmpm-2)+nbmcav) = ipos
          endif
        endif
   10 continue
*--- interaction element number
      if (intrct .eq. 0) then
        intrct = nbmelm
        if (iq(lq(lbmpm-1)+mncmd+mpintr) .ne. 0)  then
          call aawarn('BMINI2', 1, 'Invalid IP element set to #END.')
        else
          call aawarn('BMINI2', 1, 'Undefined IP element set to #END.')
        endif
      endif
*--- beta and disp. at interaction point
      call bmeget(intrct, nnn)
      if (disp(3) .gt. dspytl)  then
*--- fatal if vert. disp. is not zero
        ierr = 2
        jerr = intrct
        goto 999
      elseif (betx .eq. zero)  then
*--- fatal if betx = zero
        ierr = 3
        jerr = intrct
        goto 999
      elseif (bety .eq. zero)  then
*--- fatal if bety = zero
        ierr = 4
        jerr = intrct
        goto 999
      endif
*--- print warning if orbit at start not zero
      if (abs(orbit0(1)) + abs(orbit0(3)) .gt. p1dm9)  then
        stemp = 'non-zero orbit at start, x, y:'
        write(stemp(31:), '(2E14.6)')  orbit0(1), orbit0(3)
        call aawarn('BMINI2', 1, stemp)
      endif
*--- one-turn time, and turn frequency
      beamis(23) = circ / (betas * clight)
      beamis(24) = one / beamis(23)
*--- betas and etas at interaction point
      beamis(28) = betx
      beamis(29) = bety
      beamis(30) = disp(1)
      beamis(31) = disp(3)
      cvvolt = zero
      cvleng = zero
      cvpow  = zero
      power = zero
      if (nbmcav .ne. 0)  then
*--- set cavity parameters
*                      1 = cavity voltage [MV]
*                      2 = tuning angle [rad/2pi]
*                      3 = frequency [MHz]
*                      4 = length [m]
*                      5 = beta
*                      6 = power [MW]
*                      7 = shunt impedance  [MOhm]
*                      8 = unloaded filling time [micro-sec]
*                      9 = harmonic number
        do 20  i = 1, nbmcav
          call bmgcav(i, temp)
          if (temp(1) .gt. zero)  then
            cvvolt = cvvolt + temp(1)
            cvleng = cvleng + temp(4)
            cvpow  = cvpow  + temp(6)
            if (temp(4) .gt. zero)  then
              cvpsi  = twopi * temp(2)
              cvbtrf = temp(5)
              cvshnt = temp(7)
              cvfill = temp(8)
              cvfreq = temp(3)
              cvharm = temp(9)
            endif
          endif
   20   continue
        cvvolt = isup * cvvolt
        cvleng = isup * cvleng
        cvpow  = isup * cvpow
        if (cvshnt .gt. zero .and. cvleng .gt. zero ) then
*--- set total power
          power  = cvpow
*--- set flag that cavity values have been defined
          do 30  i = 1, mnmcav
   30     iucdef(i) = 1
*--- keep only active cavities if voltage given
          if (cvvolt .gt. zero)  then
            k = 0
            do 31  i = 1, nbmcav
              call bmgcav(i, temp)
              if (temp(1) .gt. 0 .and. temp(4) .gt. zero
     +        .and. temp(7) .gt. zero)  then
*--- cavity is kept if voltage, length, and impedance > 0
                k = k + 1
                iq(lq(lbmpm-2)+k) =iq(lq(lbmpm-2)+i)
              endif
   31       continue
            if (k .gt. 0)  then
              if (nbmcav .gt. k)  then
                stemp = '      inactive cavities supressed, leaving'
                write(stemp(:4), '(I4)')  nbmcav - k
                write(stemp(44:47), '(I4)')  k
                call aawarn('BMINI2', 1, stemp)
                nbmcav = k
              endif
            endif
          endif
        else
          call aawarn('BMINI2', 1, 'Cavity impedance or length'
     +    // ' not given --- POWER set to zero.')
        endif
      endif
*--- total cavity impedance
      beamis(32) = p1d6 * cvshnt * cvleng
*--- higher mode loss factor
      beamis(33) = p1d6 * beamis(23) * fctkhm / bunch
*--- tau_z
      beamis(34) = p1d6 * beamis(23) / (cvfill * bunch)
      if (midarc .and. .not. single)  beamis(34) = half * beamis(34)
*--- harmonic number
      if (iucdef(9) .eq. 0)
     +cvharm = int(p1d6 * beamis(23) * cvfreq / bunch + half) * bunch
*--- # of crossing points
      if (nint .eq. 0)  nint = two * bunch + p1dm6
*--- current - starting value from MAD
      if (currnt .ne. zero)  then
        iubdef(35) = 1
        beamis(35) = bunch * currnt
      endif
*--- RF voltage - starting value from MAD
      if (cvvolt .ne. zero)  then
        iubdef(36) = 1
        beamis(36) = p1d6 * cvvolt
      endif
*--- cavity phase angle and beta_rf
      if (cvpsi .ne. zero)  then
        iubdef(70) = 1
        beamis(70) = cvpsi
      endif
      if (cvbtrf .ne. zero)  then
        iubdef(71) = 1
        beamis(71) = cvbtrf
      endif
      if (power .gt. zero)  then
        iubdef(72) = 1
        beamis(72) = p1d6 * power
      endif
      if (nrc .gt. 0)  then
*--- book banks for results
        do 40  i = 1, msbmrs
   40   call mzbook(1, l, lbmrs, -i, chbnam(i), 0, 0, mwflt * nrc, 0, 0)
      endif
      if (cvharm .eq. zero)  then
        if (nbmcav .eq. 0)  then
          ierr = 5
        else
          ierr = 6
        endif
      endif
  999 end
+dk bminti
      subroutine bminti
      implicit none
************************************************************************
*
*     Returns beam integrals in BEAMIS, common /BMPMRL/ (+CA BMPMCM)
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bmpmcm
+ca memdum
+ca optic1
      integer i,ierr,iret,l,nrc
      double precision a,a1,a2,a3,a4,a5,alph1x,alph1y,angle,arg,avbetx,
     +avbety,b,b2avs,b3avs,bav32x,bav32y,bbarx,bbary,beta0d,beta1d,
     +bgrad,bmbetv,bmetab,bmgau1,bmhavr,brac,bxbyav,c,cangle,carg,den,
     +eta1d,eta2,etap,fal,feta,fh,fneta,gam,gam1x,gam1y,gamx,gamy,ph1,
     +ph2,rho,rhoinv,rk,rk2,rk3,sangle,sarg,sig,tang,term1,term2,term3,
     +tph1,tph2,vec,w,y,z

      dimension vec(5)

      logical wedge, usrng, bmusrg

      external bmbetv

*--- statement functions

      b2avs(a,b,c) = a**2 + eleng * (-a * b
     +               + eleng * ((two * a * c + b**2) / three
     +               + eleng * (-half * b * c + c**2 * eleng
     +               / five)))

      b3avs(a,b,c) = a**3 + eleng * (-half * three * a**2 * b
     +               + eleng * (a * (a * c + b**2)
     +               + eleng * (-b * (six * a * c + b**2) / four
     +               + eleng * (three * c * (a * c + b**2) / five
     +               + eleng * c**2 * (-half * b
     +               + eleng * c / seven)))))

      bmetab(a,b) = a * sangle / angle
     +              + sig * b * (one - cangle) / (angle * rk)
     +              + sig * (angle - sangle) / (rho * angle * rk2)

*--- reset count for user selected print range
      nrc = 0

      do 20 i = 1, nbmelm
        call bmeget(i, iret)
*--- count user range
        usrng = bmusrg(i, ilorng, ihirng, iflgbm)
        if (usrng)  nrc = nrc + 1
        wedge  = chtype(:5) .eq. 'SBEND'
        if (elang * eleng .ne. zero)  then
          rhoinv = elang / eleng
        else
          rhoinv = zero
        endif
        if (elang .ne. zero) then
          rho   = one / rhoinv
          bgrad = elak1 * rho**2
          if (wedge) then
            ph1 = ele1d
            ph2 = ele2d
          else
            ph1 = elang * half + ele1d
            ph2 = elang * half + ele2d
          endif
          tph1 = tan(ph1)
          tph2 = tan(ph2)
          rk2  = (one - bgrad) * rhoinv**2
*--- keep sign of 1 - n
          sig    = sign(one, rk2)
          rk2 = abs(rk2)
          rk  = sqrt(rk2)
          rk3 = rk * rk2
          angle  = rk * eleng
          if (sig .lt. zero)  then
            sangle = sinh(angle)
            cangle = cosh(angle)
          else
            sangle = sin(angle)
            cangle = cos(angle)
          endif
          beta0d = - two * alfx
          if (wedge) then
*---  Formulae for wedge (sector) magnets
*     -----------------------------------
            feta  = bmetab(disp(1), disp(2))
            fh    = bmhavr(disp(1), disp(2), betx, beta0d, eleng,
     +              rho, sig, angle, sangle, cangle, rk2, rk3)
            fneta = feta * bgrad * rhoinv**3
          else
*---  Formulae for non-normal boundary magnet (rectangular)
*     -----------------------------------------------------
            eta1d = disp(2) + disp(1) * tph1 * rhoinv
            eta2  = disp(1) * cangle + eta1d * sangle / rk + sig
     +      * (one - cangle) * rhoinv / rk2
            beta1d = beta0d + two * betx * tph1 * rhoinv
            feta  = bmetab(disp(1), eta1d)
            fh    = bmhavr(disp(1), eta1d, betx, beta1d, eleng,
     +              rho, sig, angle, sangle, cangle, rk2, rk3)
            fneta = feta * bgrad * rhoinv**3 + (disp(1) * tph1 + eta2
     +      * tph2) / (two * eleng * rho**2)
          endif

          term1 = eleng * feta * rhoinv
          term2 = eleng * rhoinv**2
          term3 = eleng * rhoinv**3
          beamis(1) = beamis(1) + term1
          beamis(2) = beamis(2) + term2
          beamis(3) = beamis(3) + abs(term3)
          beamis(4) = beamis(4) + term1 * rhoinv**2
     +                - two * eleng * fneta
          beamis(5) = abs(term3) * fh + beamis(5)
          beamis(15) = beamis(15) + term3
          if (clorb)  then
*--- calculate sums for closed orbit amp. factors (BMTALL)
            fal = rhoinv * tan (half * elang)
            alph1x = alfx - betx * fal
            alph1y = alfy + bety * fal
            gam1x  = (one + alph1x**2) / betx
            gam1y  = (one + alph1y**2) / bety
            bbarx  = betx - eleng * (alph1x - gam1x * eleng / three )
            bbary  = bety - eleng * (alph1y - gam1y * eleng / three )
            beamis(79) = beamis(79) + bbarx * elang**2
            beamis(80) = beamis(80) + bbary * elang**2
            if (usrng)  then
*--- store BBAR in bank
              l = lq(lbmrs-11) + mwflt * (nrc-1) + 1
              call ucopy(bbarx, q(l), mwflt)
              l = lq(lbmrs-12) + mwflt * (nrc-1) + 1
              call ucopy(bbary, q(l), mwflt)
            endif
          endif
*--- end of IF (ELANG .NE. ZERO)  THEN
        endif

        if (elak1 .ne. zero ) then
*     Calculate integrals I6X  &  I6Y using <BX> & <BY> for quadrupoles
*     Calculate integrals I8X  &  I8Y using <BX> & <BY> for quadrupoles
*     Calculate dJ/ddelta
*     -----------------------------------------------------------------

*--- horizontal

          gam = (one + alfx**2) / betx
          rk2 = rhoinv**2 - elak1
          sig = sign(one, rk2)
          rk = sqrt(abs(rk2))
          arg   = eleng * rk
          angle = two * arg
          if (wedge)  then
            tang = ele1d
          else
            tang = half * elang + ele1d
          endif
          etap = disp(2) + disp(1) * tan(tang) * rhoinv
          if (rk2 .ge. zero ) then
*     KH>0
*     ----
            sangle = sin(angle)
            cangle = cos(angle)
            sarg = sin(arg)
            carg = cos(arg)
          else
*     KH<0
*     ----
            sangle = sinh(angle)
            cangle = cosh(angle)
            sarg = sinh(arg)
            carg = cosh(arg)
          endif
*--- first dJ/ddelta etc.
          w = etap / rk
          y = rhoinv / rk2
          z = disp(1) - y
          a1 = two * w * y
          a2 = two * y * z
          a3 = two * w * z
          brac = sig * a1
     +    + half * arg * (sig * w**2 + z**2 + two * y**2)
     +    - sig * a1 * carg + sarg
     +    * (a2 + half * ((z**2 - sig * w**2) * carg + a3 * sarg))
*--- multiply integral by K**2 and the factor from ds = darg / sk
          beamis(16) = beamis(16) + elak1**2 * brac / rk
*--- now the other integrals
          den = two * rk2 * angle
          avbetx = (betx * rk2 * (sangle + angle) - two * alfx *
     +    rk * ( one - cangle) + gam * (angle - sangle)) / den
          if (usrng)  then
*--- store average betx in bank
            l = lq(lbmrs-1) + mwflt * (nrc-1) + 1
            call ucopy(avbetx, q(l), mwflt)
          endif
          beamis(6) = beamis(6) + rk2**2 * eleng * avbetx
*--- store constant arguments for BMBETV
          vec(1) = rk
          vec(2) = rk2
          vec(3) = betx
          vec(4) = alfx
          vec(5) = gam
          bav32x = bmgau1(bmbetv, vec, zero , eleng, p1dm2, ierr)
     +             / eleng
          if (ierr .ne. 0)  then
            call aawarn('BMINTI', 1,
     +      'BMGAU1: Too high accuray, approximation taken.')
          endif
          beamis(11) = beamis(11) + abs(rk2**3) * eleng * bav32x

*--- vertical

          gam = (one + alfy**2) / bety
          rk2 = elak1
          rk = sqrt(abs(rk2))
          angle = two * eleng * rk
          if (rk2 .ge. zero ) then
*     KV>0
*     ----
            sangle = sin(angle)
            cangle = cos(angle)
          else
*     KV<0
*     ----
            sangle = sinh(angle)
            cangle = cosh(angle)
          endif
          den = two * rk2 * angle
          avbety = (bety * rk2 * (sangle + angle) - two * alfy *
     +    rk * ( one - cangle) + gam * (angle - sangle)) / den
          if (usrng)  then
*--- store average bety in bank
            l = lq(lbmrs-2) + mwflt * (nrc-1) + 1
            call ucopy(avbety, q(l), mwflt)
          endif
          beamis(7) = beamis(7) + rk2**2 * eleng * avbety
          if (clorb)  then
*--- calculate sums for closed orbit amp. factors (BMTALL)
            beamis(77) = beamis(77) + avbetx * (elak1 * eleng)**2
            beamis(78) = beamis(78) + avbety * (elak1 * eleng)**2
          endif
*--- store constant arguments for BMBETV
          vec(1) = rk
          vec(2) = rk2
          vec(3) = bety
          vec(4) = alfy
          vec(5) = gam
          bav32y = bmgau1(bmbetv, vec, zero , eleng, p1dm2, ierr)
     +             / eleng
          if (ierr .ne. 0)  then
            call aawarn('BMINTI', 1,
     +      'BMGAU1: Too high accuray, approximation taken.')
          endif
          beamis(12) = beamis(12) + abs(rk2**3) * eleng * bav32y
        endif
*--- end of IF (ELAK1 .NE. ZERO)  THEN

        if (elak2 .ne. zero ) then

*     Calculate integrals I7X,I7Y,I9X & I9Y using <B> for sextupoles
*     --------------------------------------------------------------
          beamis(8) = beamis(8) + eleng * elak2**2
     +    * b2avs(betx, two * alfx, (one + alfx**2) / betx)
          beamis(13) = beamis(13) + eleng * abs(elak2**3)
     +    * b3avs(betx, two * alfx, (one + alfx**2) / betx)
          beamis(9) = beamis(9) + eleng * elak2**2
     +    * b2avs(bety, two * alfy, (one + alfy**2) / bety)
          beamis(14) = beamis(14) + eleng * abs(elak2**3)
     +    * b3avs(bety, two * alfy, (one + alfy**2) / bety)

*     Calculate integral I7XY using  <BX.BY>  for sextupoles
*     ------------------------------------------------------
          gamx = (one + alfx**2) / betx
          gamy = (one + alfy**2) / bety
          a1 = betx * bety
          a2 = alfx * bety + alfy * betx
          a3 = four * alfx * alfy + bety * gamx + betx * gamy
          a4 = gamx * alfy + gamy * alfx
          a5 = gamx * gamy
          bxbyav = a1 + eleng *(- a2 + eleng * (a3 / three
     +    + eleng * (- half * a4 + eleng * a5 / five)))
          beamis(10) = beamis(10) + eleng * elak2**2 * bxbyav
        endif
*--- end of IF (ELAK2 .NE. ZERO)  THEN

   20 continue

      do 30 i = 1, 16
   30 beamis(i) = beamis(i) * isup
      beamis(15) = p8d2 * beamis(15) / (five * sqrt(three) * beamis(3))

      end
+dk bmipar
      subroutine bmipar
      implicit none
************************************************************************
*
*     Returns beam integral and element-dependent values
*     in BEAMIS, common /BMPMRL/ (+CA BMPMCM), plus coupling
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bmpmcm
+ca memdum
+ca optic0
      double precision c2,f2,f3,f4

      beamis(17) = - two * beamis(16) / beamis(2)
      beamis(18) = zero
      beamis(19) = - beamis(17)
      beamis(20) = beamis(1) / circ
*--- use user value for I4 / I2 if given
      if (iq(lq(lbmpm-1)+micmd+mpi4i2) .ne. 0)  then
        iubdef(22) = 1
        beamis(22) = si4i2
        iubdef(4)  = 1
        beamis(4)  = si4i2 * beamis(2)
      else
        beamis(22) = beamis(4) / beamis(2)
      endif
      iubdef(21) = iubdef(22)
      beamis(21) = - beamis(22) / beamis(17)
*--- JX, JY, JE
      iubdef(25) = iubdef(22)
      beamis(25) = one - beamis(22)
      beamis(26) = one
      iubdef(27) = iubdef(22)
      beamis(27) = two + beamis(22)
*--- DFRF
      beamis(73) = - beamis(21) * cvfreq * beamis(20)
      if (iq(lq(lbmpm-1)+micmd+mpcoup) .eq. 0)  then
*--- coupling not user defined - calculate
        f2 = beamis(5) / (beamis(2) - beamis(4))
        f3 = beamis(3) / (two * beamis(2) + beamis(4))
        f4 = beamis(25) * beamis(28) / ( beamis(26) * beamis(29))
        c2 = (f2 * beamis(28) + f3 * beamis(30)**2)
     +       / (f2 * f4 * beamis(28) - f3 * beamis(30)**2)
        if (c2 .lt. zero)  then
          call aawarn('BMIPAR', 1,
     +    'Square of coupling is < zero, set to zero.')
          coupl = zero
        else
          coupl = sqrt(c2)
        endif
      endif

      end
+dk bmjofs
      function bmjofs(x, vec)
      implicit none
************************************************************************
*
*    Returns the value of J(s)
*
*--- input
*  X    (real)   independent variable
*  VEC  (real)   vector of auxiliary variables
*                (1) = SIGMAB
*                (2) = DELTAP
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      double precision a,a2,a2i,bmjofs,brc,s2,sa,trpi,vec,x,x2

      parameter (trpi = 3.544907701811d0)
*   TRPI = 2 * SQRT(PI)

      dimension vec(2)

      x2  = x**2
      a2  = one + one / x2
      a2i = one / a2
      a   = sqrt(a2)
      sa  = a * vec(1)
      s2  = vec(1)**2
      brc = (one - sa) * ((one + sa) * (one + a2i)**2 + s2 * a2i)
     +      + s2 * (four * x2 + one) * log(sa) / (x2 * (one + x2))
      bmjofs = a * brc * exp( - x2 / vec(2)**2) / (trpi * vec(2))

      end
+dk bmjvav
      function bmjvav(s, vec)
      implicit none
************************************************************************
*
*    Returns the value of <J/V>
*
*--- input
*  S    (real)   independent variable
*  VEC  (real)   vector of auxiliary variables
*                (1) = GAM   (E / mc**2)
*                (2) = AP0D
*                (3) = COUPL
*                (4) = BMSIGE**2 (BEAMIS(41)**2)
*                (5) = E_x_0
*                (6) = SJXY  (BEAMIS(25) / BEAMIS(26))
*                (7) = SIGB  (BEAMIS(51))
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bmpmcm
+ca optic1
      integer i,ierr,n
      double precision a,ajs,al,am11,am12,am13,am21,am22,am23,arg,as,
     +bmgau2,bmjofs,bmjvav,bot,brac,bs,bt,carg,delta,den,etads,etas,
     +gamma,gxs,h,rk,rk2,s,sarg,sigx,sigxd,sigy,sqd,vec,vec2

      dimension vec(7), vec2(2), as(2), bs(2)

      external bmjofs

      do 10  i = 1, 2
        if (i .eq. 1)  then
*--- horizontal
          al  = alfx
          bt  = betx
          rk2 = (elang / s)**2 - elak1
        else
*--- vertical
          al  = alfy
          bt  = bety
          rk2 = elak1
        endif
        gamma = (one + al**2) / bt
        if (abs(rk2) .lt. p1dm8)  then
          am11 = one
          am12 = s
          am13 = half * elang * s
          am21 = zero
          am22 = one
          am23 = elang
        else
          rk = sqrt(abs(rk2))
          arg  = s * rk
          if (rk2 .lt. zero)  then
            carg = cosh(arg)
            sarg = sinh(arg)
          else
            carg = cos(arg)
            sarg = sin(arg)
          endif
          am11 = carg
          am12 = sarg / rk
          am13 = (one - carg) * elang / (s * rk2)
          am21 = - sarg * sign(rk, rk2)
          am22 = carg
          am23 = sarg * elang / (s * rk)
        endif
        as(i) = al * (am11 * am22 + am12 * am21) - bt * am11 * am21 -
     +  gamma * am12 * am22
        bs(i) = bt * am11**2 - two * al * am11 * am12 + gamma * am12**2
        if (i. eq. 1)  then
          etas  = disp(1) * am11 + vec(2) * am12 + am13
          etads = disp(1) * am21 + vec(2) * am22 + am23
        endif
   10 continue
      gxs = (one + as(1)**2) / bs(1)
      bot = one + vec(3)**2
      den = sqrt(bot)
      sigx = sqrt(abs(vec(5) * bs(1) / bot + etas**2 * vec(4)))
      sigy = vec(3) * sqrt(abs(vec(5) * bs(2) * vec(6))) / den
      sigxd = sqrt(abs(vec(5) * gxs / bot + etads**2 * vec(4)))
*--- if (gam * sigxd / sigb) > 100. then an approximation is used
*    for J(s):
      if (vec(1) * sigxd / vec(7) .gt. p1d2) then
        delta = sqrt(three) * vec(1) * sigxd
        sqd = sqrt(one + delta**2)
        brac = log(two / vec(7)) - p23d0 / four + half * log
     +  ((sqd - one ) / (sqd + one )) + (two / delta) * log(delta
     +  + sqd)
        ajs = sqd / delta + brac / (two * delta)
      else
*--- the correct formula is used, involving N INTEGRAL
        vec2(1) = vec(7)
        vec2(2) = sigxd * vec(1)
*--- set upper limit where J(s) < 0.0001
        a = one
        h = one
        n = 0
   20   if (bmjofs(a + h, vec) .gt. p1dm4)  then
          h = two * h
          n = n + 1
          goto 20
        endif
        do 30  i = 1, n
          h = half * h
          if (bmjofs(a + h, vec) .gt. p1dm4)  a = a + h
   30   continue
        a   = max(a, vec2(1)) + h
        ajs = bmgau2(bmjofs, vec2, vec2(1), a, p1dm4, ierr)
      endif
      bmjvav = ajs / (sigx * sigy)

      end
+dk bmludq
      subroutine bmludq(curr, parn, slum, del, tbrems)
      implicit none
************************************************************************
*
*     Returns particle numbers, luminosities, delta_q, and tau_brems
*     as a function of currents.
*
*--- Input:
*     CURR(2)  (real)    x and y currents
*--- Output:
*     PARN(2)  (real)    x and y particle numbers
*     SLUM(2)  (real)    x and y luminosities
*     DEL(3)   (real)    x and y delta_q, and max(x,y)
*     TBREMS   (real)    tau_brems
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca beam
+ca bmpmcm
      integer i
      double precision beti,curr,del,fac,parn,sgt,slum,tbrems

      dimension curr(2), slum(2), parn(2), del(32)
      dimension beti(2), sgt(2)
      equivalence (beti(1), beamis(28)), (sgt(1), beamis(49))

      fac = beamis(24) / (two * twopi * bunch * sgt(1) * sgt(2))
      do 10  i = 1, 2
        parn(i) = curr(i) / (qelect * beamis(24))
        slum(i) = fac * parn(i)**2
        del(i)  = arad * parn(i) * beti(i) / (twopi * bunch * sgt(i)
     +            * (sgt(1) + sgt(2)) * game0)
   10 continue
      del(3) = max(del(1), del(2))
      tbrems = min(parn(1), parn(2)) / (nint * beamis(52)
     +         * min(slum(1), slum(2)))

      end
+dk bmmain
      subroutine bmmain
      implicit none
*+++++++++*+++++++++*+++++++++*+++++++++*+++++++++*+++++++++*+++++++++*++
*
*     BEAMPARAM VERSION 10.0                   December 1989
*
*+++++++++*+++++++++*+++++++++*+++++++++*+++++++++*+++++++++*+++++++++*++
      integer ibmfsu,ierr,jerr,nbuf
      double precision e2

+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca beam
+ca bmpmcm
+ca memdum
+ca message
+ca twlink

      logical pgiven, igiven
*  PGIVEN    TRUE if power given by RF cavity
*  IGIVEN    TRUE if current given by MAD (CURRNT)

      character*(mcnam) tnam

      data ibmfsu/0/

      if (ibmfsu .eq. 0)  then
*--- first call - initialize link area
        call mzlink (0, '/BMPMCM/', lbmpm, lbref1, lbref2)
        ibmfsu = 1
      endif
*--- open Twiss table
      tnam='TWISS'
      nbuf = 1
      call tbopen(tnam, nbuf, ltwfun)
      if (ltwfun .eq. 0)  then
*--- no Twiss table found
        goto 999
      endif
*--- set energy
      energv = en0
*--- set flag that energy is given
      idener = 1
*--- energy in eV
      enerev = p1d9 * energv
*--- h_bar/mc
      alamda = elamda * emass / amass
*--- mc**2 in eV
      amasc2 = amass * p1d9
*--- initialize before command decoding
      call bmini1
*--- get input parameters from command
      call bmgcmd(ierr)
      if (ierr .ne. 0)  then
        call aafail('BMMAIN',1, 'Invalid range in command.')
        goto 900
      endif
*--- initialize after command decoding
      call bmini2(ierr, jerr)
      if (ierr .gt. 0 .and. ierr .le. 4) then
        if (ierr .eq. 1) then
          write (msg, 910) jerr
  910     format('Non-zero tilt, element no. ',i8)
        elseif (ierr .eq. 2) then
          write (msg, 920) dspytl, jerr
  920     format('D_y > DYTOL = ',g12.4,' at IP, element no. ',i8)
        elseif (ierr .eq. 3) then
          write (msg, 930) jerr
  930     format('BETX = zero at IP, element no. ',i8)
        else
          write (msg, 940) jerr
  940     format('BETY = zero at IP, element no. ',i8)
        endif
        call aawarn('BMMAIN', 1, msg)
        goto 900
      endif

*--- calculate beam integrals
      call bminti
*--- calculate beam parameters depending on integrals
      call bmipar
      if (ierr .ne. 0) then
        if (ierr .eq. 5) then
          msg(1) = 'No active cavities, incomplete output.'
        else
          msg(1) = 'Harmonic number = 0, incomplete output.'
        endif
        call aawarn('BMMAIN', 1, msg)
        goto 800
      endif
      if (iq(lq(lbmpm-1)+micmd+mpexda) .ne. 0)  then
*--- choose energy such that E_x_c = EXDATA
        e2 = exdata * p32d0 * p1dm6 * sqrt(three) * amasc2**2
     +       * (beamis(2) - beamis(4)) * (one + coupl**2)
     +       / (p55d0 * alamda * beamis(5))
        enerev = sqrt(abs(e2))
        energv = p1dm9 * enerev
        idener = 0
*--- mark E_x_c as user defined
        iubdef(45) = 1
      elseif (evary)  then
*--- vary energy such that power (calc.) = POWER
        call bmenpw(ierr)
        idener = 0
        if (ierr .eq. 1)  then
          call aawarn('BMMAIN', 1, 'POWER too low for energy increase.')
        elseif (ierr .eq. 2)  then
          call aawarn('BMMAIN', 1, 'energy fit to POWER incomplete.')
        endif
      endif
*--- calculate constants depending on coupling and/or energy
      call bmbcon(enerev)
*--- get currents, luminosities, etc.
      pgiven = power .gt. zero
      igiven = iubdef(35) .gt. 0
      call bmcurr(enerev, pgiven, igiven)
*--- Touschek lifetime etc.
      call bmtall
  800 continue
*--- print final results
      call bmzwrt
*--- store values in common /BEAM/, and in bank
      call bmstor
  900 continue
*--- drop main bank + tree, wipe division
      call mzdrop(0, lbmpm, ' ')
      call mzdrop(0, lbmrs, ' ')
      call mzwipe(1)

  999 end
+dk bmpowr
      subroutine bmpowr(e0, curr, pw, psi, btrf)
      implicit none
*----------------------------------------------------------------------
* Purpose:
*   calculates power as function of energy and current
* Input:
*   E0          (real)  energy [eV]
*   CURR        (real)  current [A]
* Output:
*   PW          (real)  power [W]
*   PSI         (real)  phase angle [rad]
*   BTRF        (real)  beta_rf
*----------------------------------------------------------------------
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca beam
+ca bmpmcm
      integer ierr,iter
      double precision a1,a2,b1,b2,bmrpow,bt,btrf,const,cri,curr,e0,gm,
     +psi,pw,shunt,tauz,tpsi,tpsic,u0pr,vc,vhm,vs,x,x0
      dimension x0(2), x(2), const(4)
      data iter / 20 /

      shunt = beamis(32)
*--- gamma = E/mc**2
      gm = e0 / amasc2
*--- radiation loss per turn
      u0pr = two * arad * e0 * gm**3 * beamis(2) / p3d6
      vs = p1d6 * u0pr
      vc = beamis(36)
      tauz = beamis(34)
      if (single)  then
        cri = curr
      else
        cri = two * curr
      endif
*--- voltage loss due to higher mode losses
      vhm = p1d6 * beamis(33) * curr
      a1 = (vs + vhm) / vc
      a2 = cri * shunt / vc
      b1 = a1 / tauz
      b2 = sqrt(abs(one - a1**2)) / tauz
      const(1) = b1
      const(2) = b2
      const(3) = a2
      const(4) = tauz
      if (cvbtrf .ne. zero)  then
        btrf = cvbtrf
        if (cvpsi .ne. zero)  then
*--- both psi_rf and beta_rf are given by MAD
          psi  = cvpsi
          tpsi = tan(psi)
        else
*--- bet_rf given, minimize for psi_rf only
          bt  = btrf
          tpsic = - cri * shunt * sqrt(abs(vc**2 - vs**2))
     +    / (vc**2 * (1 + bt))
          x0(1) = tauz * (one + bt)
          x0(2) = tpsic
*--- get minimum
          call bmgetm(1, x0, const, iter, x, ierr)
          if (ierr .ne. 0)  then
            tpsi   = tpsic
            psi    = atan(tpsic)
          else
            tpsi   = x(2)
            psi    = atan(x(2))
          endif
        endif
      else
*--- minimize both for psi_rf and beta_rf
        bt = one + cri * shunt * vs / vc**2
        tpsic = - (bt - one ) * sqrt(abs((vc / vs)**2 - one)) /
     +  (bt + one )
        x0(1) = tauz * (one + bt)
        x0(2) = tpsic
*--- get minimum
        call bmgetm(2,x0,const,iter,x,ierr)
        if (ierr .ne. 0)  then
          btrf   = bt
          tpsi   = tpsic
          psi    = atan(tpsic)
        else
          btrf   = x(1) / tauz - one
          tpsi   = x(2)
          psi    = atan(x(2))
        endif
      endif
      x(1) = tauz * (one + btrf)
      x(2) = tpsi
      pw = vc**2 * bmrpow(x, const) / shunt

      end
+dk bmrpow
      function bmrpow(x, const)
      implicit none
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      double precision bmg1,bmg2,bmrpow,const,tauz,x
      dimension x(2), const(4)
      tauz = const(4)
      bmrpow = tauz * (one + x(2)**2) * (bmg1(x, const)**2 + bmg2
     +(x, const)**2) / (four * (x(1) - tauz) )

      end
+dk bmstor
      subroutine bmstor
      implicit none
************************************************************************
*
*     Stores final BEAMPARAM results in common /BEAM/ and in bank
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca seqgroup
+ca message
+ca datatype
+ca bmpmcm
+ca memdum
+ca beam
+ca optic0
+ca refer
      integer i,idir,ileng,ipos
      double precision cvl
      character * (mcnam)  elmnam

*--- damping partition numbers
      do 10  i = 1, 3
   10 pdamp(i) = beamis(24+i)
*--- current
      currnt = min(beamis(54), beamis(55)) / bunch
*--- radiation loss per turn
      u0 = p1dm3 * beamis(37)
*--- number of particles / bunch
      parnum = min(beamis(56), beamis(57)) / bunch
*--- beam sizes
      sigx = beamis(47)
      sigy = beamis(48)
*--- energy spread
      sige = beamis(41)
*--- bunch length [sec]
      sigt = beamis(67)
*--- emittances E_x_c, E_y_c, E_t
      ex = beamis(45)
      ey = beamis(46)
      et = sige * sigt
*--- normalized emittances
      exn = four * betas * gammas * ex
      eyn = four * betas * gammas * ey
*--- energy
      en0 = energv
*--- store /BEAM/ common block variables in bank, ET is given
      ietflg = 1
      call enput
*--- Drop all precomputed maps.
      call aapdrp
*--- cavity voltage and lag
      if (nbmcav .gt. 0)  then
        if (iubdef(36) .eq. 0) then
*--- distribute voltage evenly over cavities
          cvl = p1dm6 * beamis(36) / nbmcav
          do 20  i = 1, nbmcav
            ipos = iq(lq(lbmpm-2)+i)
            idir = iq(lq(lcseq-msdir)+ipos)
            lcelm = lq(ldbnk(3)-idir)
            if (lq(lcelm-3) .ne. 0) then
*--- voltage is defined as an expression - warn user
              call diname(ldbnk, idir, elmnam)
              call utleng(elmnam, ileng)
              msg(1) =
     +        'Voltage defined by expression is redefined in cavity "'
     +        // elmnam(1:ileng) // '".'
              call aawarn('BMSTOR', 1, msg)
            endif
            call utpflt(lcelm, 3, 3, cvl)
   20     continue
        endif
      endif

      end
+dk bmsync
      subroutine bmsync(e0)
      implicit none
************************************************************************
*
*     Returns synchrotron parameters
*     in common /BMPMRL/ (+CA BMPMCM)
*
*--- input
*  E0        energy  [eV]
*
************************************************************************
      integer mxerr
      double precision as,e0

+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bmerrc
+ca bmpmcm

      parameter (mxerr = 10)

*--- phi_s
      if (abs(beamis(64)) .le. one)  then
        as = asin(beamis(64))
      else
        as = half * pi
        if (nerrsc .lt. mxerr)  then
          nerrsc = nerrsc + 1
          call aawarn('BMSYNC', 1, 'x > 1 in asin(x), x = 1 assumed.')
        endif
      endif
      if (beamis(20) .gt. zero)  then
        beamis(66) = pi - as
      else
        beamis(66) = as
      endif
*--- nu_s = synchrotron tune
      beamis(68) = sqrt(abs(cvharm * beamis(20) * cos(beamis(66))
     + * beamis(36) / (twopi * e0 * (one - one / game0**2))))
*--- f_s = synchrotron frequency
      beamis(69) = beamis(68) * beamis(24)
*--- sig_z
      beamis(67) = abs(beamis(20)) * radius * beamis(41) / beamis(68)

      end
+dk bmtall
      subroutine bmtall
      implicit none
************************************************************************
*
*     Calculates Touschek lifetime, synchrotron radiation, closed orbit
*     amplication factors, ...
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca beam
+ca bmpmcm
+ca memdum
+ca optic0
+ca optic1
      integer i,ie,ierr,iret,l,nrc
      double precision avbetx,avbety,bfacx,bfacy,bmgau1,bmjvav,bxbx,
     +bxby,ec,gamax,gamay,pbx,pby,photon,pqx,pqy,pw,qfacx,qfacy,rhob,
     +sigxd,sigyd,snbq,sum,sx2,sx2d,sy2,sy2d,tang,temp,vec

      dimension vec(7)

      logical wedge, usrng, bmusrg

      external bmjvav

*  VEC  (real)   vector of auxiliary variables
*                (1) = GAM   (E / mc**2)
*                (2) = AP0D
*                (3) = COUPL
*                (4) = BMSIGE**2 (BEAMIS(41)**2)
*                (5) = E_x_0
*                (6) = SJXY  (BEAMIS(25) / BEAMIS(26))
*                (7) = SIGB  (BEAMIS(51))

      vec(1) = enerev / amasc2
      vec(3) = coupl
      vec(4) = beamis(41)**2
      vec(5) = beamis(44)
      vec(6) = beamis(25) / beamis(26)
      vec(7) = beamis(51)
      ierr = 0

*--- reset user range count for elements
      nrc = 0
*--- reset Touschek sum
      sum  = zero
*--- factors
      qfacx = sqrt(beamis(77) * isup) / sin(pi * qx)
      qfacy = sqrt(beamis(78) * isup) / sin(pi * qy)
      bfacx = sqrt(beamis(79) * isup) / sin(pi * qx)
      bfacy = sqrt(beamis(80) * isup) / sin(pi * qy)
      do 10 i = 1, nbmelm
        call bmeget(i, iret)
*--- count user range
        usrng = bmusrg(i, ilorng, ihirng, iflgbm)
        if (usrng)  nrc = nrc + 1
*--- Touschek lifetime
        if (eleng .gt. zero .and. tousch)  then
          wedge  = chtype(:5) .eq. 'SBEND'
          if (wedge)  then
            tang = ele1d
          else
            tang = half * elang + ele1d
          endif
          vec(2) = disp(2) + disp(1) * tan(tang) * elang / eleng
          sum = sum + bmgau1(bmjvav, vec, zero, eleng, p1dm4, ie)
          ierr = max(ierr, ie)
        endif
        sx2 = vec(5) * betx + vec(4) * disp(1)**2
        sy2 = half * vec(5) * vec(6) * bety
        sx2d = sx2 * (one + alfx**2) / betx**2 + vec(4) * disp(2)**2
        sy2d = sy2 * (one + alfy**2) / bety**2
        if (usrng)  then
          l = lq(lbmrs-3) + mwflt * (nrc-1) + 1
          call ucopy(fxbeam * sqrt(sx2), q(l), mwflt)
          l = lq(lbmrs-4) + mwflt * (nrc-1) + 1
          call ucopy(fybeam * sqrt(sy2), q(l), mwflt)
          l = lq(lbmrs-5) + mwflt * (nrc-1) + 1
          call ucopy(sqrt(sx2d), q(l), mwflt)
          l = lq(lbmrs-6) + mwflt * (nrc-1) + 1
          call ucopy(sqrt(sy2d), q(l), mwflt)
        endif
        if (synrad)  then
          if (elang .ne. zero .or. elak1 .ne. zero)  then
            if( elang .eq. zero)  then
              rhob = one / (abs(elak1) * sqrt(sx2 + sy2))
              snbq = pfacnq * p1d3 / qelect
            else
              rhob = eleng / abs(elang)
              snbq = pfacnb * p1d3 / qelect
            endif
            ec = p15d5 * clight * hbar * vec(1)**3 / rhob
            pw = twothd * arad * amasc2 * vec(1)**4
     +           * min(beamis(54), beamis(55)) / rhob**2
            photon = p1dm6 * pw * snbq / ec**2
          else
            ec     = zero
            rhob   = zero
            pw     = zero
            photon = zero
          endif
          if (usrng)  then
            gamax = (one + alfx**2) / betx**2
            gamay = (one + alfy**2) / bety**2
            sigxd = sqrt(sx2 * gamax + beamis(41) * disp(2)**2)
            sigyd = sqrt(sy2 * gamay)
            l = lq(lbmrs-5) + mwflt * (nrc-1) + 1
            call ucopy(sigxd, q(l), mwflt)
            l = lq(lbmrs-6) + mwflt * (nrc-1) + 1
            call ucopy(sigyd, q(l), mwflt)
            l = lq(lbmrs-7) + mwflt * (nrc-1) + 1
            call ucopy(rhob, q(l), mwflt)
            l = lq(lbmrs-8) + mwflt * (nrc-1) + 1
            call ucopy(ec, q(l), mwflt)
            l = lq(lbmrs-9) + mwflt * (nrc-1) + 1
            call ucopy(pw, q(l), mwflt)
            l = lq(lbmrs-10) + mwflt * (nrc-1) + 1
            call ucopy(photon, q(l), mwflt)
          endif
        endif
        if (clorb .and. usrng)  then
          l = lq(lbmrs-1) + mwflt * (nrc-1) + 1
          call ucopy(q(l), avbetx, mwflt)
          l = lq(lbmrs-2) + mwflt * (nrc-1) + 1
          call ucopy(q(l), avbety, mwflt)
          l = lq(lbmrs-11) + mwflt * (nrc-1) + 1
          call ucopy(q(l), bxbx, mwflt)
          l = lq(lbmrs-12) + mwflt * (nrc-1) + 1
          call ucopy(q(l), bxby, mwflt)
          if (elang .ne. zero .or. elak1 .ne. zero)  then
            if (elang .eq. zero)  then
*--- quadrupole
              pqx = abs(qfacx * sqrt(avbetx))
              pqy = abs(qfacy * sqrt(avbety))
              pbx = abs(bfacx * sqrt(avbetx))
              pby = abs(bfacy * sqrt(avbety))
            elseif (elak1 .eq. zero)  then
*--- normal bending magnet (K = 0)
              pqx = abs(qfacx * sqrt(bxbx))
              pqy = abs(qfacy * sqrt(bxby))
              pbx = abs(bfacx * sqrt(bxbx))
              pby = abs(bfacy * sqrt(bxby))
            else
*--- gradient magnet (K # 0)
              pqx = abs(qfacx * sqrt(avbetx))
              pqy = abs(qfacy * sqrt(avbety))
              pbx = abs(bfacx * sqrt(bxbx))
              pby = abs(bfacy * sqrt(bxby))
            endif
            l = lq(lbmrs-13) + mwflt * (nrc-1) + 1
            call ucopy(pqx, q(l), mwflt)
            l = lq(lbmrs-14) + mwflt * (nrc-1) + 1
            call ucopy(pqy, q(l), mwflt)
            l = lq(lbmrs-15) + mwflt * (nrc-1) + 1
            call ucopy(pbx, q(l), mwflt)
            l = lq(lbmrs-16) + mwflt * (nrc-1) + 1
            call ucopy(pby, q(l), mwflt)
          endif
        endif
   10 continue
      if (tousch)  then
        if (ierr .ne. 0)  then
          call aawarn('BMTALL', 1,
     +    'Touschek integral - too high accuray, approximation taken.')
        endif
        temp = isup * sum / (eight * sqrt(pi) * beamis(67) * circ)
        beamis(75) = (vec(1) * beamis(51))**2 * bunch
     +  / (four * arad**2 * clight * temp * min(beamis(56), beamis(57)))
      endif

      end
+dk bmusrg
      logical function bmusrg(iel, ilo, iup, iflag)
      implicit none
************************************************************************
*
*     Returns .TRUE. if element is selected for printing.
*
*--- input
*  IEL       BMPM element number
*  ILO       BMPM lower range for print
*  ILU       BMPM upper range for print
*  IFLAG     flag from UTELEM with element print flags
*
************************************************************************
+ca aparam
+ca seqflag
      integer iel,iflag,ilo,iup,jbit
      bmusrg = iel .ge. ilo .and. iel .le. iup
     +         .or. jbit(iflag, mprnt) .ne. 0
      end
+dk bmvdat
      subroutine bmvdat(volt, e0, curr, snxy, slxy)
      implicit none
************************************************************************
*
*     Returns voltage dependent parameters (called if voltage given by
*     MAD) in common /BMPMRL/ (+CA BMPMCM)
*
*--- input
*  VOLT      voltage [V]
*  E0        energy in eV
*  CURR      current
*  SNXY      particle number
*  SLXY      luminosity
*
************************************************************************
      integer mxerr
      double precision curr,e0,fac1,fac2,slxy,snxy,u0,volt,x,xtau

+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bmerrc
+ca bmpmcm

      parameter (mxerr = 10)

*--- total voltage loss
      u0  = p1d6 * (beamis(37) + curr * beamis(33))
*--- beam_gamma
      beamis(64) = u0 / volt
      if (abs(beamis(64)) .le. one)  then
        x = beamis(64)
      else
        x = one
        if (nerrat .lt. mxerr)  then
          nerrat = nerrat + 1
          call aawarn('BMVDAT', 1, 'x > 1 in acos(x), x = 1 assumed.')
        endif
      endif
      fac1 = two * (sqrt(abs(one / x**2 - one))
     +       - acos(x))
      fac2 = u0 / (pi * e0 * abs(beamis(20)) * cvharm)
*--- bucket half_hight
      beamis(51) = sqrt(abs(fac1 * fac2))
      bucket = beamis(51) / beamis(41)
      xtau   = min(sixty, half * bucket**2)
      tauqs  = beamis(40) / (two * xtau * exp(-xtau))

      end
+dk bmvolt
      subroutine bmvolt(e0, curr, volt, bmgam)
      implicit none
************************************************************************
*
*     Returns voltage and beam_gamma
*
*--- input
*  E0        energy  [eV]
*  CURR      current
*--- Output:
*  VOLT      voltage [V]
*  BMGAM     beam_gamma
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bmpmcm
      integer ierr
      double precision bmfcn,bmgam,curr,e0,rhs,u0,volt

      external bmfcn

*--- total voltage loss
      u0  = p1d6 * (beamis(37) + beamis(33) * curr)
*--- right-hand side of equation
      rhs = pi * e0 * beamis(51)**2 * cvharm * abs(beamis(20)) / u0
      call bmfdz2(bmfcn, rhs, p1dm8, one, p1dm6, 1000, bmgam, ierr)
      volt = u0 / bmgam
      if (ierr. ne. 0)  then
        call aawarn('BMVOLT', 1,
     +  'Error in voltage calculation, set to zero.')
      endif

      end
+dk bmvpow
      subroutine bmvpow(e0, pdiff)
      implicit none
************************************************************************
*
*     Returns power (cal.) -power(given) as a function of energy only
*
*--- Input:
*    E0        energy [eV]
*
*--- Output:
*    PDIFF     power(calc) - power(given)
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bmpmcm
      double precision e0,pdiff

      call bmbcon(e0)
      call bmcurr(e0, .false., .false.)
      pdiff = beamis(72) - p1d6 * power

      end
+dk bmzfmt
      subroutine bmzfmt(sfin, ii1, ii2, vec, sfout)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   make format (1P,E... or 0P,G...) depending on values               *
* Input:                                                               *
*   SFIN        (char)  format with "$" for missing descriptors        *
*   II1         (int)   n1 in En1.n2                                   *
*   II2         (int)   n2 in En1.n2                                   *
*   VEC         (real)  vector of values to be printed, as many as $'s *
* Output:                                                              *
*   SFOUT       (char)  final format                                   *
*----------------------------------------------------------------------*
+ca aparam
      integer i1,i2,i3,ii1,ii2,index,ip1,ip2,k,l,len,n
      double precision vec
      dimension        vec(*)
      character*(*)     sfin, sfout
      character         sl*8, slc*8, temp*40

      l   = len(sfin)
      n   = 0
      ip1 = 0
      ip2 = 0
      i1  = ii1
      i2  = min(ii2, i1 - 6)
      if (i2 .eq. i1 - 6)  then
        i3 = i2
      else
         i3 = i2 + 1
      endif
      sl  = '(G  .  )'
      write (sl(3:4),' (I2)')  i1
      write (sl(6:7), '(I2)')  i3

   10 continue
      k = index(sfin(ip1+1:),'$')
      if (k .gt. 0)  then
        sfout(ip2+1:) = sfin(ip1+1:)
        ip2 = ip2 + k -1
        n   = n + 1
        temp = ' '
        slc = sl
        write (temp, sl)  vec(n)
        if (index(temp, 'E') .eq. 0)  then
          sfout(ip2+1:) = '0P,' // slc(2:7)
        else
          write (slc(6:7), '(I2)')  i2
          sfout(ip2+1:) = '1P,E' // slc(3:7)
        endif
        ip2 = ip2 + 9
        ip1 = ip1 + k
        if (ip1 .lt. l)  goto 10
      endif
      sfout(ip2+1:) = sfin(ip1+1:)

      end
+dk bmzpow
      function bmzpow(curr, e0)
      implicit none
************************************************************************
*
*     Returns power (cal.) -power(given) as function of energy and
*     current
*
*--- Input:
*    CURR      current
*    E0        energy [eV]
*
*--- function value: power (calc.) - power (given)
*
************************************************************************
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bmpmcm
      double precision bmzpow,btrf,curr,e0,psi,pw

      beamis(54) = curr
      beamis(55) = curr
      if (iubdef(36) .eq. 0)  then
*--- voltage not given - calculate
        call bmvolt(e0, beamis(54), beamis(36), beamis(64))
      else
        call bmvdat(beamis(36), e0, beamis(54), beamis(56),
     +  beamis(58))
*--- mark tau_Q as calculated
        idtauq = 0
      endif
      call bmpowr(e0, curr, pw, psi, btrf)
      bmzpow = pw - p1d6 * power

      end
+dk bmzwrt
      subroutine bmzwrt
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print final results.                                               *
*                                                                      *
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca bankhead
+ca beam
+ca bmpmcm
+ca maxlin
+ca memdum
+ca optic0
+ca optic1
+ca prcgroup
+ca seqflag
+ca seqgroup
+ca refer
+ca zunit
      integer i,iret,iup,j,k,kbunch,l,mmpar,nharm,nline,nnn,npage,nrc
      double precision vec

      parameter (mmpar = 21)

      dimension vec(mmpar)

      integer ip(mmpar)

      logical usrng, dprint, bmusrg

      character*120     sline
      character * 160   sfmt1, sfmt2, sfout
      character * 60    stempt
      character*12      sltp(mmpar), sltx1(15), sltx2(9), sltx3(15),
     +                  sltx4(5), sltx5(3), sltx6(12), sltx7(3)
      character*13      sttp(mmpar), sttx1(15), sttx2(9), sttx3(15),
     +                  sttx4(5), sttx5(3), sttx6(12), sttx7(3)
      character*3       chuse(0:2), chint(8)

      data sfmt1 / '(1X, A12, '' = '', $, '' '', A13, A12, '' = '', $,
     +'' '', A13, A12, '' = '', $, '' '', A13)' /
      data sfmt2 / '(1X, A12, '' = '', I7,4X, '' '', A13, A12, '' = '',
     +$, '' '', A13, A12, '' = '', $, '' '', A13)' /

      data sltx1 /
     +'         Q_x', '     beta_x*', '       etax*',
     +'         Q_y', '     beta_y*', '       etay*',
     +'       alpha', '    circumf.', '         t_0',
     +'         J_x', '         J_y', '         J_e',
     +' dJ_x/(dE/E)', '        dE/E', '       df_RF'/
      data sttx1 /
     +' ', '[m]', '[m]', ' ', '[m]', '[m]', ' ', '[m]','[sec/turn]',
     +5 * ' ', '[Hz]'/
      data sltx2 /
     +'      energy', '    coupling', '     delta_Q',
     +'          U0', '       sig_E', '       B*rho',
     +'       tau_x', '       tau_y', '       tau_E'/
      data sttx2 /
     +'[GeV]',' ',' ','[MeV/turn]','dE/E','[Tm]',3 * '[sec]'/
      data sltx3 /
     +'       E_x_0', '       E_x_c', '       E_y_c',
     +'     sig_x_0', '     sig_x_c', '     sig_x_T',
     +'     sig_y_0', '     sig_y_c', '     sig_y_T',
     +'         L_x', '         n_x', '         I_x',
     +'         L_y', '         n_y', '         I_y'/
      data sttx3 /
     +3 * 'pi [micro-m]', 6 * '[mm]',
     +'[1/cm**2 sec]', 'per beam', '[A] / bunch',
     +'[1/cm**2 sec]', 'per beam', '[A] / bunch'/
      data sltx4 /
     +'     k_bunch', '     tau_pol', '   tau_brems',
     +'       n_int', 'pol_infinit.'/
      data sttx4 /
     +' ', '[min]', '[min]', ' ', 'percent'/
      data sltx5 /
     +'    f_RF/f_0', '    volt._RF', '        f_RF'/
      data sttx5 /
     +' ', '[MV]' ,'[MHz]'/
      data sltx6 /
     +'         phi', '         Q_s', '   f_synchr.',
     +'   sig_buck.', '       sig_s', '       tau_Q',
     +'  shunt imp.', '    L_cavity', '      t_fill',
     +'       power', '        K_hm', '    Touschek'/
      data sttx6 /
     +'[degrees]', ' ', '[kHz]', ' ', '[mm]', '[min]', '[MOhm/m]',
     +'[m]', '[microsec]', '[MW]', '[V/pC]', '[min]'/
      data sltx7 /
     +'     beta_RF', '         psi', '      bucket'/
      data sttx7 /
     +' ','[degrees]', ' '/

      data chuse / '(C)', '(D)', ' ' /
      data chint / 'I1', 'I2', 'I3', 'I4', 'I5', 'I6X', 'I6Y', 'I8' /

      dprint = iqlog .ne. iqpr2

*--- page and line count for print file
      npage = 1
      call prpage(iqpr2)
      write (iqpr2, 10070) ' BMPM output', npage
      call prline(iqpr2)
*--- print beam integrals
      do 10  i = 1, 8
        vec(i) = beamis(i)
        ip(i) = 2
   10 continue
      vec(8) = beamis(16)
      ip(4) = iq(lq(lbmpm-1)+micmd+mpi4i2)
      write (iqpr2, 10000) (chuse(ip(i)), chint(i), i = 1, 8)
      write (iqpr2, 10010) (vec(i), i = 1, 8)
      if (dprint)  then
        write (iqlog, 10000) (chuse(ip(i)), chint(i), i = 1, 8)
        write (iqlog, 10010) (vec(i), i = 1, 8)
      endif
*--- machine parameters
      do 20  i = 1, 15
        sltp(i) = sltx1(i)
        sttp(i) = sttx1(i)
   20 continue
      sltp(10)(7:9) = chuse(iubdef(25))
      sltp(12)(7:9) = chuse(iubdef(27))
      vec(1) = qx
      vec(2) = beamis(28)
      vec(3) = beamis(30)
      vec(4) = qy
      vec(5) = beamis(29)
      vec(6) = beamis(31)
      vec(7) = beamis(20)
      vec(8) = circ
      vec(9) = beamis(23)
      vec(10) = beamis(25)
      vec(11) = beamis(26)
      vec(12) = beamis(27)
      vec(13) = beamis(17)
      vec(14) = beamis(21)
      vec(15) = p1d6 * beamis(73)
      if (single) then
        sline = ' Global machine parameters ' // '(one beam), '
     +  // ' and local parameters at interaction point:'
      else
        sline = ' Global machine parameters ' // '(two beams),'
     +  // ' and local parameters at interaction point:'
      endif
      write (iqpr2, '(/A/)') sline
      if (dprint)  write (iqlog, '(/A/)') sline
      do 21  j = 1, 15, 3
        call bmzfmt(sfmt1, 11, 4, vec(j), sfout)
        write (iqpr2, sfout)  (sltp(i), vec(i), sttp(i), i = j, j + 2)
        if (dprint)
     +  write (iqlog, sfout)  (sltp(i), vec(i), sttp(i), i = j, j + 2)
   21 continue
*--- skip part of output if no cavities
      if (cvharm .eq. 0.)  goto 89
*--- beam parameters, part1
      do 30  i = 1, 9
        sltp(i) = sltx2(i)
        sttp(i) = sttx2(i)
   30 continue
      sltp(1)(4:6) = chuse(idener)
      sltp(2)(2:4) = chuse(idcoup)
      sltp(3)(3:5) = chuse(iubdef(62))
      vec(1) = energv
      vec(2) = coupl
      vec(3) = beamis(62)
      vec(4) = beamis(37)
      vec(5) = beamis(41)
      vec(6) = beamis(74)
      vec(7) = beamis(38)
      vec(8) = beamis(39)
      vec(9) = beamis(40)
      sline = ' Beam parameters and luminosities:'
      write (iqpr2, '(/A/)') sline
      if (dprint)  write (iqlog, '(/A/)') sline
      do 31  j = 1, 9, 3
        call bmzfmt(sfmt1, 11, 4, vec(j), sfout)
        write (iqpr2, sfout)  (sltp(i), vec(i), sttp(i), i = j, j + 2)
        if (dprint)
     +  write (iqlog, sfout)  (sltp(i), vec(i), sttp(i), i = j, j + 2)
   31 continue
*--- beam parameters, part2
      do 40  i = 1, 15
        sltp(i) = sltx3(i)
        sttp(i) = sttx3(i)
   40 continue
      sltp(2)(5:7)  = chuse(iubdef(45))
      sltp(12)(7:9) = chuse(iubdef(54))
      vec(1) = p1d6 * beamis(44)
      vec(2) = p1d6 * beamis(45)
      vec(3) = p1d6 * beamis(46)
      vec(4) = p1d3 * beamis(42)
      vec(5) = p1d3 * beamis(47)
      vec(6) = p1d3 * beamis(49)
      vec(7) = p1d3 * beamis(43)
      vec(8) = p1d3 * beamis(48)
      vec(9) = p1d3 * beamis(50)
      vec(10) = p1dm4 * beamis(58)
      vec(11) = beamis(56)
      vec(12) = beamis(54) / bunch
      vec(13) = p1dm4 * beamis(59)
      vec(14) = beamis(57)
      vec(15) = beamis(55) / bunch
      write (iqpr2, *) ' '
      if (dprint)  write (iqlog, *) ' '
      do 41  j = 1, 15, 3
        call bmzfmt(sfmt1, 11, 4, vec(j), sfout)
        write (iqpr2, sfout)  (sltp(i), vec(i), sttp(i), i = j, j + 2)
        if (dprint)
     +  write (iqlog, sfout)  (sltp(i), vec(i), sttp(i), i = j, j + 2)
   41 continue
*--- beam parameters, part3
      do 50  i = 1, 5
        sltp(i) = sltx4(i)
        sttp(i) = sttx4(i)
   50 continue
      kbunch = bunch + half
      vec(2) = beamis(76) / sixty
      vec(3) = beamis(63) / sixty
      vec(5) = beamis(15)
      write (iqpr2, *) ' '
      if (dprint)  write (iqlog, *) ' '
      call bmzfmt(sfmt2, 11, 4, vec(2), sfout)
      write (iqpr2, sfout)  sltp(1), kbunch, sttp(1),
     +(sltp(i), vec(i), sttp(i), i = 2, 3)
      if (dprint)  write (iqlog, sfout)  sltp(1), kbunch, sttp(1),
     +(sltp(i), vec(i), sttp(i), i = 2, 3)
      call bmzfmt(sfmt2, 11, 4, vec(5), sfout)
      write (iqpr2, sfout)  sltp(4), nint, sttp(4),
     +sltp(5), vec(5), sttp(5)
      if (dprint)  write (iqlog, sfout)  sltp(4), nint, sttp(4),
     +sltp(5), vec(5), sttp(5)
*--- RF parameters, part1
      do 60  i = 1, 3
        sltp(i) = sltx5(i)
        sttp(i) = sttx5(i)
   60 continue
      sltp(2)(2:4) = chuse(iubdef(36))
      nharm  = cvharm + half
      vec(2) = p1dm6 * beamis(36)
      vec(3) = cvfreq
      sline =
     +' RF related parameters (for a total of      cavities):'
      write(sline(40:43), '(I4)') nbmcav
      write (iqpr2, '(/A/)') sline
      if (dprint)  write (iqlog, '(/A/)') sline
      call bmzfmt(sfmt2, 11, 4, vec(2), sfout)
      write (iqpr2, sfout)  sltp(1), nharm, sttp(1),
     +(sltp(i), vec(i), sttp(i), i = 2, 3)
      if (dprint)  write (iqlog, sfout)  sltp(1), nharm, sttp(1),
     +(sltp(i), vec(i), sttp(i), i = 2, 3)
*--- RF parameters, part2
      do 70  i = 1, 12
        sltp(i) = sltx6(i)
        sttp(i) = sttx6(i)
   70 continue
      sltp(4)(1:3) = chuse(iubdef(51))
      sltp(6)(4:6) = chuse(idtauq)
      sltp(10)(5:7) = chuse(iubdef(72))
      vec(1) =rtodeg *  beamis(66)
      vec(2) = beamis(68)
      vec(3) = p1dm3 * beamis(69)
      vec(4) = beamis(51)
      vec(5) = p1d3 * beamis(67)
      vec(6) = tauqs / sixty
      vec(7) = cvshnt
      vec(8) = cvleng
      vec(9) = cvfill
      vec(10) = p1dm6 * beamis(72)
      vec(11) = fctkhm

      vec(12) = beamis(75) / sixty
      if (tousch)  then
        iup = 12
      else
        iup = 11
      endif
      do 71  j = 1, 12, 3
        call bmzfmt(sfmt1, 11, 4, vec(j), sfout)
        k = min(j+2, iup)
        write (iqpr2, sfout)  (sltp(i), vec(i), sttp(i), i = j, k)
        if (dprint)
     +  write (iqlog, sfout)  (sltp(i), vec(i), sttp(i), i = j, k)
   71 continue
*--- RF parameters, part3
      do 80  i = 1, 3
        sltp(i) = sltx7(i)
        sttp(i) = sttx7(i)
   80 continue
      sltp(1)(3:5) = chuse(iubdef(71))
      sltp(2)(7:9) = chuse(iubdef(70))
      sltp(3)(4:6) = chuse(iubdef(51))
      vec(1) = beamis(71)
      vec(2) = rtodeg * beamis(70)
      vec(3) = bucket
      call bmzfmt(sfmt1, 11, 4, vec(1), sfout)
      write (iqpr2, sfout)  (sltp(i), vec(i), sttp(i), i = 1, 3)
      if (dprint)  then
        write (iqlog, sfout)  (sltp(i), vec(i), sttp(i), i = 1, 3)
        write (iqlog, *) ' '
      endif
   89 continue
      if (ilorng .le. ihirng)  then
*--- element print-out
        nline = maxlin
        nrc = 0
        do 90  i = 1, nbmelm
          call bmeget(i, iret)
          usrng = bmusrg(i, ilorng, ihirng, iflgbm)
          if (usrng)  then
            if (nline + 1 .ge. maxlin)  then
              write(iqpr2, *) ' '
              npage = npage + 1
              call prpage(iqpr2)
              write (iqpr2, 10070) ' BMPM output', npage
              call prline(iqpr2)
              sline = ' '
              if (clorb)  then
                sline(17:) =
     +          '    PQX        PQY        PBX        PBY    '
              endif
              if (synrad)  then
                sline(61:) =
     +          '   rho       EC[keV]  power[W/m]  photons[/m*s*keV]'
              endif
              if (fxbeam .eq. one .and. fybeam .eq. one)  then
                stempt = ' '
              else
                stempt = ' attention - sig_x and sig_y factors:'
                write(stempt(41:), '(2G10.3)') fxbeam, fybeam
              endif
              write (iqpr2, 10040)  stempt
              nline = 4
              if (clorb .or. synrad)  then
                write(iqpr2, '(A)')  sline
                nline = nline + 1
              endif
              write(iqpr2, *) ' '
              nline = nline + 1
            endif
            call bmeget(i, nnn)
            nrc = nrc + 1
            do 100  j = 3, 10
              l = lq(lbmrs-j) + mwflt * (nrc-1) + 1
              call ucopy (q(l), vec(j-2), mwflt)
  100       continue
            do 110  j = 13, msbmrs
              l = lq(lbmrs-j) + mwflt * (nrc-1) + 1
              call ucopy (q(l), vec(j-4), mwflt)
  110       continue
            write(iqpr2, 10050) i, chname(:8), disp(1), disp(2),
     +      betx, bety, alfx, alfy, (vec(j), j = 1, 4)
            nline = nline + 1
            if (synrad .or. clorb)  then
              sline = ' '
              k = 11
              do 120  j = 1, 8
                k = k + 11
                sline(k:k) = '-'
  120         continue
              if (clorb .and. vec(9) .ne. zero)  then
                write (sline(17:), 10060) (vec(j), j = 9, 12)
              endif
              if (synrad .and. vec(5) .ne. zero)  then
                write (sline(61:), 10060) (vec(j), j = 5, 8)
              endif
              write (iqpr2, '(A)')  sline
              nline = nline + 1
            endif
          endif
   90   continue
      endif
10000 format(/' Synchrotron integrals:' // 8(5x, 2a3, 3x))
10010 format(1x, 1p, 8e14.4)
10040 format(//' Element range print-out:', a//
     +'   no.  name        eta        eta''      beta_x  ',
     +'   beta_y    alpha_x    alpha_y    sig_x      sig_y    ',
     +' sig_x''[rad]  sig_y''[rad]')
10050 format(1x, i5, 2x, a8, 1p, 10e11.4)
10060 format(1p, 4e11.4)
10070 format(a,t122,'page',i6)

      end
+dk bmzzzz
+dk coaaaa
+dk cocorr
      subroutine cocorr
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Complete closed orbit correction by MICADO algorithm.              *
*   Optionally also corrects dispersion.                               *
* CORRECT command:                                                     *
*   ERROR     (real)    Closed orbit quality desired.                  *
*   NCORR     (integer) Number of correctors allowed.                  *
*   NITER     (integer) Number of iterations allowed.                  *
*   C1LIST    (name)    Corrector list desired before correction.      *
*   C2LIST    (name)    Corrector list desired after correction.       *
*   M1LIST    (name)    Monitor list desired before correction.        *
*   M2LIST    (name)    Monitor list desired after correction.         *
*----------------------------------------------------------------------*
+ca aparam
+ca codata
+ca colink
+ca refer
+ca status
+ca zunit
+ca thrcom
      integer i,ilc1,ilc2,ilm1,ilm2,jiter,jpl,jplmax,jplmin,niter,nkick,
     +nlist,nok
      double precision adltol,drms,rrms,zero

      parameter         (nlist = 3, zero = 0.0d0)

      character*(mcnam) dlist(nlist), clist(4), cplane
      character*1       plane(2)
      dimension         drms(2), rrms(2)
      integer           ilist(2)
      logical           ok
      dimension adltol(6)

      data dlist        / 'NONE', 'USED', 'ALL' /
      data plane        / 'x', 'y' /

      data adltol / 1.d-3, 1.d-5, 1.d-3, 1.d-5, 1.d0, 1.d-1 /

*---- set flag for calls from COCORR
      adcofl = .true.
*---- Check main beam line.
      call lnchck('CORRECT', error)
      if (error) go to 800

*---- Extract data.
      qual = 1.0d-6
      call utgflt(lccmd, 1, 1, qual)

      ilist(1) = 0
      ilist(2) = 1
      call utgint(lccmd, 2, 3, ilist)
      nkick = ilist(1)
      niter = ilist(2)

      clist(1) = ' '
      clist(2) = ' '
      clist(3) = ' '
      clist(4) = ' '
      call utgnam(lccmd, 4, 7, clist)
      call utlook(clist(1), dlist, nlist, ilc1)
      call utlook(clist(2), dlist, nlist, ilc2)
      call utlook(clist(3), dlist, nlist, ilm1)
      call utlook(clist(4), dlist, nlist, ilm2)

      weight(1) = 0.0
      weight(2) = 0.0
      call utgflt(lccmd, 8, 9, weight)

      cplane = ' '
      call utgnam(lccmd, 10, 10, cplane)
      jplmin = 1
      jplmax = 2
      if (cplane .eq. 'X') then
        jplmax = 1
      else if (cplane .eq. 'Y') then
        jplmin = 2
      endif
*---- Threader count and tolerances
      nditer = 10000
      ndccnt = 0
      adthfl = .false.
      adwofl = .false.
      do 10 i = 1,6
   10 adtol(i) = adltol(i)
      call utgflt(lccmd, 11, 16, adtol)
      call utglog(lccmd, 17, 17, adthfl)
      call utglog(lccmd, 18, 18, adwofl)
      call utgint(lccmd, 19, 19, nditer)
*---- Set up corrector and monitor table.
      call cotble(error)
      if (error) go to 800

*---- Find closed orbit.
      call tmturn(lcseq, zero, error)
      if (error) go to 800

*---- Fill in monitor readings and dispersion.
      call cofill
      if (error) go to 800

*---- Suppress calculation, if no iterations wanted.
      if (niter .le. 0) then
        call copkik(max(ilc1, ilc2), '(no correction made)')
        call copdis(max(ilm1, ilm2), '(no correction made)', rrms, drms)

*---- Print corrector and monitor tables before correction.
      else
        call copkik(ilc1, '(before correction)')
        call copdis(ilm1, '(before correction)', rrms, drms)

*---- Iteration loop for non-linear problem.
        do 100 jiter = 1, niter
          nok = 0
          do 90 jpl = jplmin, jplmax
            if (weight(jpl) .eq. zero) then
              write (iqlog, 910) jiter, plane(jpl)
              call colorb(nkick, jpl, ok)
            else
              write (iqlog, 920) jiter, plane(jpl), weight(jpl)
              call coldis(nkick, jpl, ok)
            endif
            if (ok) nok = nok + jpl
   90     continue
          if (nok .eq. 3) go to 200

*---- Find new closed orbit and monitor readings.
          call tmturn(lcseq, zero, error)
          if (error) go to 800

*---- Fill in monitor readings and dispersion.
          call cofill
          if (error) go to 800
  100   continue

*---- Print corrector and monitor tables after correction.
  200   continue
        call copkik(ilc2, '(after correction)')
        call copdis(ilm2, '(after correction)', rrms, drms)
        write (iqlog, 930) niter, rrms, drms
      endif
      error = .false.
  800 continue
*---- reset flag for calls from COCORR
      adcofl = .false.

  910 format(' '/t11,'Beginning orbit iteration ',i4,' for plane ',a1,
     +       '.')
  920 format(' '/t11,'Beginning orbit and dispersion iteration ',i3,
     +       ' for plane ',a1,','/
     +       t11,'Weight for dispersion = ',f12.6)
  930 format(t11,'Remaining r.m.s. values after iteration ',i4,':'/
     +       t11,'Orbit:     ',t31,'<x> =  ',e16.6,' mm,',
     +       t71,'<y> =  ',e16.6,' mm.'/
     +       t11,'Dispersion:',t31,'<Dx> = ',e16.6,' m,',
     +       t71,'<Dy> = ',e16.6,' m.'/' ')

      end
+dk cofill
      subroutine cofill
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Fill in orbit and dispersion for monitor positions.                *
*   Assumes closed orbit to be known beforehand.                       *
* Important common data:                                               *
*             /MAPELM/  Element transfer map.                          *
*             /MAPTRN/  One turn transfer map.                         *
*             /OPTIC0/  Initial values.                                *
*             /OPTIC1/  Current values.                                *
*   LCELM     /REFER/   Current element bank.                          *
*   LCALI     /REFER/   Current misalignment pointer.                  *
*   LCFLD     /REFER/   Current field error pointer.                   *
*   LCSEQ     /REFER/   Current beam line sequence bank.               *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca seqflag
+ca beam
+ca codata
+ca mapelm
+ca maptrn
+ca optic0
+ca optic1
+ca range
+ca refer
+ca status
      integer icode,ienum,iflag,iocc,ipos,isp,jbyt
      double precision el,fact,ten

      parameter         (ten = 10.0d0)

      logical           fmap
      character*(mcnam) elmnam

*---- Initial orbit and dispersion.
      if (lcseq .eq. 0) go to 9999
      call ucopy(orbit0, orbit, 6*mwflt)
      call twdisp(rt, rt(1,6), disp)
      disp(5) = 0.0
      disp(6) = 1.0
      if (error) go to 9999
      suml = 0.0

*---- Loop through element sequence.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        icode = jbyt(iflag,1,mcode)

*---- Physical element.
        if (icode .eq. 1) then

*---- Misalignent at entrance.
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            call m66byv(re, disp, disp)
          endif

*---- Fill in values at beam position monitors.
          isp = iq(lcelm+mbsp)
          if (isp .ge. 17  .and. isp .le. 19) then
            call ucopy(q(lcelm+melen), el, mwflt)
            if (lccom .ne. 0) then

*---- Read errors.
              if (lcali .ne. 0) then
                call ucopy(q(lcali+6*mwflt+1), xcm, 4*mwflt)
              else
                xcm = 0.0
                ycm = 0.0
                dxcm = 0.0
                dycm = 0.0
              endif

*---- Actual position w.r.t. monitor centre plus read error.
*     Suppress if monitor reads only one plane.
              fact = (el / 2.0) * (1.0 - orbit(6) / betas)
              if (isp .le. 18) then
                xcm = orbit(1) + fact * orbit(2) + xcm
                dxcm = disp(1) + fact * disp(2) + dxcm
              else
                xcm = 0.0
                dxcm = 0.0
              endif
              if (isp .ge. 18) then
                ycm = orbit(3) + fact * orbit(4) + ycm
                dycm = disp(3) + fact * disp(4) + dycm
              else
                ycm = 0.0
                dycm = 0.0
              endif
              call ucopy(xcm, q(lccom+1), 4*mwflt)
            endif
          endif

*---- Transfer through element.
          call tmmap(.true., .true., orbit, fmap, el, ek, re, te)
          if (fmap) call m66byv(re, disp, disp)

*---- Misalignment at exit.
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            call m66byv(re, disp, disp)
          endif

*---- Entrance of line.
        else if (icode .eq. 2) then
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            call m66byv(re, disp, disp)
          endif

*---- Exit of line.
        else
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            call m66byv(re, disp, disp)
          endif
        endif
   90 continue

 9999 end
+dk cofkik
      subroutine cofkik(ipos, istat, ncount, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Activate or deactivate orbit corrector.                            *
* Input:                                                               *
*   IPOS      (integer) Bias of position within bank.                  *
*   ISTAT     (integer) Flag to activate/deactivate.                   *
* Input/output:                                                        *
*   NCOUNT(2) (integer) Count monitors affected.                       *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ipos,isp,istat
      integer           ncount(2)
      logical           eflag
+ca memdum
+ca bankhead
+ca seqgroup
+ca refer

      eflag = .false.
      lscom = lq(lcseq-mscom)
      lsdir = lq(lcseq-msdir)
      if (ipos .gt. 0  .and.  ipos .le. iq(lsdir-1)) then
        lccom = lq(lscom-ipos)
        if (lccom .ne. 0) then
          lcelm = lq(ldbnk(3)-iq(lsdir+ipos))
          isp = iq(lcelm+mbsp)
          if (isp .eq. 14  .or.  isp .eq. 15) then
            call sbit(istat, iq(lccom), 5)
            ncount(1) = ncount(1) + 1
          endif
          if (isp .eq. 15  .or.  isp .eq. 16) then
            call sbit(istat, iq(lccom), 6)
            ncount(2) = ncount(2) + 1
          endif
        endif
      endif

      end
+dk cofmon
      subroutine cofmon(ipos, istat, ncount, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Activate or deactivate monitor.                                    *
* Input:                                                               *
*   IPOS      (integer) Bias of position within bank.                  *
*   ISTAT     (integer) Flag to activate/deactivate.                   *
* Input/output:                                                        *
*   NCOUNT(2) (integer) Count monitors affected.                       *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ipos,isp,istat
      integer           ncount(2)
      logical           eflag
+ca memdum
+ca bankhead
+ca seqgroup
+ca refer

      eflag = .false.
      lscom = lq(lcseq-mscom)
      lsdir = lq(lcseq-msdir)
      if (ipos .gt. 0  .and.  ipos .le. iq(lsdir-1)) then
        lccom = lq(lscom-ipos)
        if (lccom .ne. 0) then
          lcelm = lq(ldbnk(3)-iq(lsdir+ipos))
          isp = iq(lcelm+mbsp)
          if (isp .eq. 17  .or.  isp .eq. 18) then
            call sbit(istat, iq(lccom), 3)
            call sbit(istat, iq(lccom), 5)
            ncount(1) = ncount(1) + 1
          endif
          if (isp .eq. 18  .or.  isp .eq. 19) then
            call sbit(istat, iq(lccom), 4)
            call sbit(istat, iq(lccom), 6)
            ncount(2) = ncount(2) + 1
          endif
        endif
      endif

      end
+dk cogdis
      subroutine cogdis(jpl, read, disp, beta, amu, nm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Extract monitor reading and optical functions for one plane.       *
* Input:                                                               *
*   JPL       (integer) Plane desired.                                 *
* Output:                                                              *
*   READ(*)   (real)    Array of readings.                             *
*   DISP(*)   (real)    Array of dispersion values.                    *
*   BETA(*)   (real)    Array of beta functions.                       *
*   AMU(*)    (real)    Array of phases.                               *
*   NM        (integer) Number of active monitors found.               *
*----------------------------------------------------------------------*
+ca aparam
      integer jbit,jpl,nm
      double precision amu,beta,disp,read
      dimension         read(*), disp(*), beta(*), amu(*)
+ca memdum
+ca seqgroup
+ca codata
+ca refer

      nm = 0
      lccom = lq(lcseq-msmon)
   10 if (lccom .ne. 0) then
        if (jbit(iq(lccom),jpl+4) .ne. 0) then
          call ucopy(q(lccom+1), xcm, iq(lccom-1))
          nm = nm + 1
          if (jpl .eq. 1) then
            read(nm) = xcm
            disp(nm) = dxcm
            beta(nm) = betxcm
            amu(nm)  = amuxcm
          else
            read(nm) = ycm
            disp(nm) = dycm
            beta(nm) = betycm
            amu(nm)  = amuycm
          endif
        endif
        lccom = lq(lccom-1)
        go to 10
      endif

      end
+dk cogkik
      subroutine cogkik(jpl, set, beta, amu, nc)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Extract corrector settings and lattice functions for one plane.    *
* Input:                                                               *
*   JPL       (integer) Plane desired.                                 *
* Output:                                                              *
*   SET(*)    (real)    Array of settings.                             *
*   BETA(*)   (real)    Array of beta functions.                       *
*   AMU(*)    (real)    Array of phases.                               *
*   NC        (integer) Number of actice correctors found.             *
*----------------------------------------------------------------------*
+ca aparam
      integer jbit,jpl,nc
      double precision amu,beta,set
      dimension         set(*), beta(*), amu(*)
+ca memdum
+ca seqgroup
+ca codata
+ca refer

      nc = 0
      lccom = lq(lcseq-mscor)
   10 if (lccom .ne. 0) then
        if (jbit(iq(lccom),jpl+4) .ne. 0) then
          call ucopy(q(lccom+1), xcm, iq(lccom-1))
          nc = nc + 1
          if (jpl .eq. 1) then
            set(nc) = xcm
            beta(nc) = betxcm
            amu(nc) = amuxcm
          else
            set(nc) = ycm
            beta(nc) = betycm
            amu(nc) = amuycm
          endif
        endif
        lccom = lq(lccom-1)
        go to 10
      endif

      end
+dk cogmon
      subroutine cogmon(jpl, read, beta, amu, nm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Extract monitor reading and optical functions for one plane.       *
* Input:                                                               *
*   JPL       (integer) Plane desired.                                 *
* Output:                                                              *
*   READ(*)   (real)    Array of readings.                             *
*   BETA(*)   (real)    Array of beta functions.                       *
*   AMU(*)    (real)    Array of phases.                               *
*   NM        (integer) Number of active monitors found.               *
*----------------------------------------------------------------------*
+ca aparam
      integer jbit,jpl,nm
      double precision amu,beta,read
      dimension         read(*), beta(*), amu(*)
+ca memdum
+ca seqgroup
+ca codata
+ca refer

      nm = 0
      lccom = lq(lcseq-msmon)
   10 if (lccom .ne. 0) then
        if (jbit(iq(lccom),jpl+2) .ne. 0) then
          call ucopy(q(lccom+1), xcm, iq(lccom-1))
          nm = nm + 1
          if (jpl .eq. 1) then
            read(nm) = xcm
            beta(nm) = betxcm
            amu(nm) = amuxcm
          else
            read(nm) = ycm
            beta(nm) = betycm
            amu(nm) = amuycm
          endif
        endif
        lccom = lq(lccom-1)
        go to 10
      endif

      end
+dk cogues
      subroutine cogues
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Set initial guess for closed orbit search, COGUESS command.        *
* Attriutes:                                                           *
*   X         (real)                                                   *
*   PX        (real)                                                   *
*   Y         (real)                                                   *
*   PY        (real)                                                   *
*   T         (real)                                                   *
*   PT        (real)                                                   *
*----------------------------------------------------------------------*
+ca aparam
+ca coesti
+ca option
+ca refer
+ca zunit

      call utgflt(lccmd, 1, 7, coest)
      call utglog(lccmd, 8, 8, optflg(20))
      write (iqlog, 910) coest, cotol, optflg(20)

  910 format(' '/' New estimate for the closed orbit:'/1x,6f12.6/
     +       ' New tolerance: ',1x,e16.6, '  automatic =', l2/' ')

      end
+dk coldis
      subroutine coldis(nkick, jpl, ok)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Perform least squares correction on closed orbit for one plane.    *
* Input:                                                               *
*   NKICK     (integer) Number of kickers to be used at most (0 = all).*
*   JPL       (integer) Number of plane; 1: x, 2: y.                   *
* Output:                                                              *
*   OK        (logical) Success flag.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer ia,ib,ibc,ibm,imc,imm,ip,ir,isave,iter,iw1,iw2,ix,jm,jpl,
     +nc,ncd,nkick,nm,nmd
      double precision drms,rms,rrms
      logical           ok
+ca memdum
+ca seqgroup
+ca codata
+ca refer
+ca wstack
+ca zunit

      logical           symm

*---- If no correctors or no monitors for this plane, skip.
      ncd = ncor(jpl)
      nmd = nmon(jpl)
      ok = .false.
      if (ncd * nmd .eq. 0) then
        ok = .true.

*---- Allocate working space.
      else
        isave = iwork
        ia    = isave + 1
        ib    = ia  + 2 * nmd * ncd
        ibm   = ib  + 2 * nmd
        imm   = ibm + 2 * nmd
        ix    = imm + nmd
        ibc   = ix  + ncd
        imc   = ibc + ncd
        ip    = imc + ncd
        iwork = ip  + ncd - 1
        ir    = ibm
        iw1   = ibc
        iw2   = imc
        if (iwork .gt. nwork) then
          call mzwork(0, dq(1), dq(iwork+1), 2)
          nwork = iwork
        endif

*---- Get monitor readings.
        symm = iq(lcseq+msym) .ne. 0
        call cogdis(jpl, dq(ib), dq(ib+nmd), dq(ibm), dq(imm), nm)

*---- Errors before correction.
        drms = 0.0
        rrms = 0.0
        do 10 jm = 1, nm
          drms = drms + dq(ib+nmd+jm-1)**2
          rrms = rrms + dq(ib+jm-1)**2
          dq(ib+nm+jm-1) = dq(ib+nmd+jm-1) * weight(jpl)
   10   continue
        rms  = sqrt((rrms+drms*weight(jpl)**2)/float(max(nm,1)))
        drms = sqrt(drms/float(max(nm,1)))
        rrms = sqrt(rrms/float(max(nm,1)))
        write (iqlog, 910) drms, rrms*1000.0

*---- Check need for correction.
        if (rms .le. qual) then
          write (iqlog, 920)
          ok = .true.

*---- Get corrector settings.
        else
          call cogkik(jpl, dq(ix), dq(ibc), dq(imc), nc)

*---- Set up influence matrix.
          call comdis(symm, jpl, dq(ia), nm, nc, dq(ibm),
     +                dq(imm), dq(ibc), dq(imc))

*---- Solve for this plane.
          iter = nkick
          call htlsq(dq(ia), dq(ib), 2*nm, nc, qual, iter,
     +               dq(ix), dq(ip), dq(ir), dq(iw1), dq(iw2))

*---- Modify correctors.
          call coskik(jpl, dq(ix))

*---- Expected remaining r.m.s. error.
          drms = 0.0
          rrms = 0.0
          do 30 jm = 1, nm
            drms = drms + dq(ir+nm+jm-1)**2
            rrms = rrms + dq(ir+jm-1)**2
   30     continue
          drms = sqrt(drms/float(max(nm,1))) / weight(jpl)
          rrms = sqrt(rrms/float(max(nm,1)))
          write (iqlog, 930) drms, rrms * 1000.0
        endif

*---- Release working space.
        iwork = isave
      endif

  910 format(t45,'dispersion',t68,'orbit'/
     +       t11,'R.m.s. errors before MICADO:',t41,f12.6,' m',
     +       t61,f12.6,' mm')
  920 format(t11,'No correction made.'/' ')
  930 format(t11,'Expected r.m.s. errors after:',t41,f12.6,' m',
     +       t61,f12.6,' mm'/' ')

      end
+dk colorb
      subroutine colorb(nkick, jpl, ok)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Perform least squares correction on closed orbit.                  *
* Input:                                                               *
*   NKICK     (integer) Number of kickers to be used at most (0 = all).*
*   JPL       (integer) Number of the plane; 1: x, 2: y.               *
* Output:                                                              *
*   OK        (logical) Success flag.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer ia,ib,ibc,ibm,imc,imm,ip,ir,isave,iter,iw1,iw2,ix,jm,jpl,
     +nc,ncd,nkick,nm,nmd
      double precision rrms
      logical           ok
+ca memdum
+ca seqgroup
+ca codata
+ca refer
+ca wstack
+ca zunit

      logical           symm

*---- If no correctors or no monitors for this plane, skip.
      ncd = ncor(jpl)
      nmd = nmon(jpl)
      ok = .false.
      if (ncd * nmd .eq. 0) then
        ok = .true.

*---- Allocate working space.
      else
        isave = iwork
        ia    = isave + 1
        ib    = ia  + nmd * ncd
        ibm   = ib  + nmd
        imm   = ibm + nmd
        ix    = imm + nmd
        ibc   = ix  + ncd
        imc   = ibc + ncd
        ip    = imc + ncd
        iwork = ip  + ncd - 1
        ir    = ibm
        iw1   = ibc
        iw2   = imc
        if (iwork .gt. nwork) then
          call mzwork(0, dq(1), dq(iwork+1), 2)
          nwork = iwork
        endif

*---- Get monitor readings.
        symm = iq(lcseq+msym) .ne. 0
        call cogmon(jpl, dq(ib), dq(ibm), dq(imm), nm)

*---- Errors before correction.
        rrms = 0.0
        do 10 jm = 1, nm
          rrms = rrms + dq(ib+jm-1)**2
   10   continue
        rrms = sqrt(rrms/float(max(nm,1)))
        write (iqlog, 910) rrms * 1000.0

*---- Check need for correction.
        if (rrms .le. qual) then
          write (iqlog, 920)
          ok = .true.

*---- Get corrector settings.
        else
          call cogkik(jpl, dq(ix), dq(ibc), dq(imc), nc)

*---- Set up influence matrix.
          call comorb(symm, jpl, dq(ia), nm, nc, dq(ibm),
     +                dq(imm), dq(ibc), dq(imc))

*---- Solve for this plane.
          iter = nkick
          call htlsq(dq(ia), dq(ib), nm, nc, qual, iter,
     +      dq(ix), dq(ip), dq(ir), dq(iw1), dq(iw2))

*---- Modify correctors.
          call coskik(jpl, dq(ix))

*---- Expected remaining r.m.s. error.
          rrms = 0.0
          do 30 jm = 1, nm
            rrms = rrms + dq(ir+jm-1)**2
   30     continue
          rrms = sqrt(rrms/float(max(nm,1)))
          write (iqlog, 930) rrms * 1000.0
        endif

*---- Release working space.
        iwork = isave
      endif

  910 format(t11,'R.m.s. orbit errors before correction:',
     +       t61,f12.6,' mm')
  920 format(t11,'No correction made.'/' ')
  930 format(t11,'Expected r.m.s. orbit error after MICADO:',
     +       t61,f12.6,' mm'/' ')

      end
+dk comain
      subroutine comain(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Control routine for orbit corrections.                             *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca colink
+ca stflag
+ca wstack
      integer icoflg,ipr,isp

      data icoflg       / 0 /

*---- Initialize working space pointers for use by COLORB and COLDIS.
      iwork = 0
      nwork = 0

*---- Initialize link area.
      if (icoflg .eq. 0) then
        call mzlink(0, '/COLINK/', lcotab, lcotab, lcoelm)
        icoflg = 1
      endif

*---- User-defined code.
      if (isp .lt. 1  .or.  isp .gt. 20) then
        call usercm(ipr, isp)

*---- CORRECT --- Complete C.O. Correction including dispersion.
      else if (isp .eq. 1) then
        call cocorr

*---- GETORBIT --- Read monitor readings on a TFS file.
      else if (isp .eq. 2) then
        call cormon

*---- PUTORBIT --- Write monitor readings on a TFS file.
      else if (isp .eq. 3) then
        call cowmon

*---- GETKICK --- Read corrector settings on a TFS file.
      else if (isp .eq. 4) then
        call corkik

*---- PUTKICK --- Write corrector settings on a TFS file.
      else if (isp .eq. 5) then
        call cowkik

*---- MICADO --- Perform one MICADO step.
      else if (isp .eq. 6) then
        call comica

*---- GETDISP --- Read dispersion readings on a TFS file.
      else if (isp .eq. 7) then
        call cordis

*---- PUTDISP --- Write dispersion readings on a TFS file.
      else if (isp .eq. 8) then
        call cowdis

*---- USEKICK --- Activate/deactivate correctors.
      else if (isp .eq. 9) then
        call coukik

*---- USEMONITOR --- Activate/deactivate monitors.
      else if (isp .eq. 10) then
        call coumon

*---- COGUESS --- Enter starting vector + tolerance for c.o. calc.
      else if (isp .eq. 11) then
        call cogues
      endif

*---- Reset working space pointers.
      call mzwork(0, dq(1), dq(1), - 1)
      iwork = 0
      nwork = 0

      end
+dk comdis
      subroutine comdis(symm, jpl, a, nm, nc, betm, amum, betc, amuc)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Set up influence matrix for dispersion and orbit correction.       *
*   Uses thin lens approximation for all elements.                     *
* Input:                                                               *
*   SYMM      (logical) Symmetry flag.                                 *
*   JPL       (integer) 1: horizontal, 2: vertical.                    *
*   NM        (integer) Number of monitors.                            *
*   NC        (integer) Number of correctors.                          *
*   BETM(*)   (real)    Beta functions at monitors.                    *
*   AMUM(*)   (real)    Monitor phases.                                *
*   BETC(*)   (real)    Beta functions at correctors.                  *
*   AMUC(*)   (real)    Corrector phases.                              *
* Output:                                                              *
*   A(NDIM,*) (real)    Influence matrix.                              *
*----------------------------------------------------------------------*
+ca aparam
      integer ic,im,isave,isp,jc,jm,jpl,nc,nm
      double precision a,amuc,amue,amum,betc,betm,cosecq,data,facce,
     +faccm,facem,force,half,halfq
      logical           symm
      dimension         a(2*nm,nc), betm(*), amum(*), betc(*), amuc(*)
+ca memdum
+ca bankhead
+ca seqgroup
+ca codata
+ca refer
+ca wstack

      parameter         (half = 0.5d0)

      dimension         data(4)

      if (jpl .eq. 1) then
        halfq = halfqx
      else
        halfq = halfqy
      endif
      cosecq = half / sin(halfq)

*---- Fill block for influence on orbit, clear block for dispersion.
      do 10 jc = 1, nc
      do 10 jm = 1, nm
        faccm = cos(abs(amum(jm)-amuc(jc))-halfq)
        if (symm) then
          faccm = faccm + cos(amum(jm)+amuc(jc)-halfq)
        endif
        a(jm,jc) = faccm * sqrt(betm(jm)*betc(jc)) * cosecq
        a(nm+jm,jc) = 0.0
   10 continue

*---- Allocate working space.
      isave = iwork
      ic    = isave
      im    = ic + nc
      iwork = im + nm
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Loop over elements affecting dispersion.
      lccom = lq(lcseq-mselm)
   20 if (lccom .ne. 0) then
        call ucopy(q(lccom+1), xcm, iq(lccom-1))

*---- Extract element data.
        lcelm = lq(lccom-2)
        isp   = iq(lcelm+mbsp)
        akl   = 0.0
        data(1) = 0.0
        data(2) = 0.0
        data(3) = 0.0
        data(4) = 0.0

*---- Quadrupole or thin multipole.
        if (isp .eq. 5) then
          call utgflt(lcelm, 2, 4, data)
          if (data(3) .eq. 0.0) akl = data(1) * data(2)

*---- Sextupole.
        else if (isp .eq. 6) then
          call utgflt(lcelm, 2, 4, data)
          if (data(3) .eq. 0.0) akl = - dxcm * data(1) * data(2)

*---- Multipole.
        else if (isp .eq. 8) then
          call utgflt(lcelm, 4, 7, data)
          if (data(2) .eq. 0.0) akl = data(1)
          if (data(4) .eq. 0.0) akl = akl - dxcm * data(3)
        endif
        if (jpl .eq. 1) then
          force = + betxcm * akl
          amue  =   amuxcm
        else
          force = - betycm * akl
          amue  =   amuycm
        endif

*---- Influence of correctors on elements.
*     omitting the factor sqrt(beta(elm)).
        do 30 jc = 1, nc
          facce = cos(abs(amuc(jc)-amue)-halfq)
          if (symm) then
            facce = facce + cos(amuc(jc)+amue-halfq)
          endif
          dq(ic+jc) = facce * cosecq * force
   30   continue

*---- Influence of elements on monitors,
*     omitting the factor sqrt(beta(elm)).
        do 40 jm = 1, nm
          facem = cos(abs(amue-amum(jm))-halfq)
          if (symm) then
            facem = facem + cos(amue+amum(jm)-halfq)
          endif
          dq(im+jm) = facem * cosecq
   40   continue

*---- Add to block for influence on dispersion.
        do 60 jc = 1, nc
          do 50 jm = 1, nm
            a(nm+jm,jc) = a(nm+jm,jc) + dq(im+jm) * dq(ic+jc)
   50     continue
   60   continue

*---- Next element.
        lccom = lq(lccom-1)
        go to 20
      endif

*---- Multiply by scale factors.
      do 70 jc = 1, nc
      do 70 jm = 1, nm
        a(nm+jm,jc) = weight(jpl) * (a(nm+jm,jc) *
     +                sqrt(betm(jm) * betc(jc)) - a(jm,jc))
   70 continue

*---- Release working store.
      iwork = isave

      end
+dk comica
      subroutine comica
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Closed orbit correction by Micado algorithm, given monitor reads.  *
* MICADO command:                                                      *
*   ERROR     (real)    Tolerance for MICADO algorithm.                *
*   NCORR     (integer) Number of correctors allowed.                  *
*   C2LIST    (name)    Corrector list desired after correction.       *
*   M2LIST    (name)    Monitor list desired after correction.         *
*   HWEIGHT   (real)    Weight for horizontal dispersion correction.   *
*   VWEIGHT   (real)    Weight for vertical dispersion correction.     *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca seqgroup
+ca codata
+ca colink
+ca refer
+ca status
+ca zunit
      integer ilc2,ilm1,jpl,jplmax,jplmin,nkick,nlist
      double precision drms,one,rrms,zero

      parameter         (nlist = 3, zero = 0.0d0, one = 1.0d0)
      character*(mcnam) dlist(nlist), clist(2), cplane
      character*1       plane(2)
      dimension         drms(2), rrms(2)
      logical           ok

      data dlist        / 'NONE', 'USED', 'ALL' /
      data plane        / 'X', 'Y' /

*---- Check main beam line.
      call lnchck('MICADO', error)
      if (error) go to 9999
      lscom = lq(lcseq-mscom)
      call ncopy(iq(lscom+1), ncor, 2)
      call ncopy(iq(lscom+3), nmon, 2)
      call ucopy(q(lscom+5), halfqx, 2*mwflt)

*---- Extract data.
      qual = zero
      call utgflt(lccmd, 1, 1, qual)

      nkick = 0
      call utgint(lccmd, 2, 2, nkick)

      clist(1) = ' '
      clist(2) = ' '
      call utgnam(lccmd, 3, 4, clist)
      call utlook(clist(1), dlist, nlist, ilc2)
      call utlook(clist(2), dlist, nlist, ilm1)

      weight(1) = zero
      weight(2) = zero
      call utgflt(lccmd, 5, 6, weight)

      cplane = ' '
      call utgnam(lccmd, 7, 7, cplane)
      jplmin = 1
      jplmax = 2
      if (cplane .eq. 'X') then
        jplmax = 1
      else if (cplane .eq. 'Y') then
        jplmin = 2
      endif

*---- Check presence of corrector and monitor table.
      if (lq(lcseq-mscom) .eq. 0) then
        call aafail('COMICA', 1, 'No monitor readings available.')
        go to 9999
      endif

*---- Print values before correction.
      call copkik(1, '(before correction)')
      call copdis(ilm1, '(before correction)', rrms, drms)

*---- Compute new corrector settings.
      do 90 jpl = jplmin, jplmax
        if (weight(jpl) .eq. zero) then
          write (iqlog, 910) plane(jpl)
          call colorb(nkick, jpl, ok)
        else
          write (iqlog, 920) plane(jpl), weight(jpl)
          call coldis(nkick, jpl, ok)
        endif
   90 continue

*---- Print corrector and monitor tables after correction.
      call copkik(ilc2, '(after correction)')

  910 format(' '/t11,'Beginning orbit correction for plane ',a1,'.')
  920 format(' '/
     +       t11,'Beginning orbit and dispersion correction for plane ',
     +       a1,','/
     +       t11,'Weight for dispersion = ',f12.6)

 9999 end
+dk comorb
      subroutine comorb(symm, jpl, a, nm, nc, betm, amum, betc, amuc)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Set up influence matrix for closed orbit correction.               *
* Input:                                                               *
*   SYMM      (logical) Symmetry flag.                                 *
*   JPL       (integer) 1: horizontal, 2: vertical.                    *
*   NM        (integer) Number of monitors.                            *
*   NC        (integer) Number of correctors.                          *
*   BETM(*)   (real)    Beta functions at monitors.                    *
*   AMUM(*)   (real)    Monitor phases.                                *
*   BETC(*)   (real)    Beta functions at correctors.                  *
*   AMUC(*)   (real)    Corrector phases.                              *
* Output:                                                              *
*   A(NDIM,*) (real)    Influence matrix.                              *
*----------------------------------------------------------------------*
+ca aparam
+ca codata
      integer jc,jm,jpl,nc,nm
      double precision a,amuc,amum,betc,betm,cosecq,faccm,half,halfq
      logical           symm
      dimension         a(nm,nc), betm(*), amum(*), betc(*), amuc(*)

      parameter         (half = 0.5d0)

      if (jpl .eq. 1) then
        halfq = halfqx
      else
        halfq = halfqy
      endif
      cosecq = half / sin(halfq)

      do 10 jc = 1, nc
      do 10 jm = 1, nm
        faccm = cos(abs(amum(jm)-amuc(jc))-halfq)
        if (symm) then
          faccm = faccm + cos(amum(jm)+amuc(jc)-halfq)
        endif
        a(jm,jc) = faccm * sqrt(betm(jm)*betc(jc)) * cosecq
   10 continue

      end
+dk copdis
      subroutine copdis(list, title, rrms, drms)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print table of dispersion and orbit at all monitors.               *
* Input:                                                               *
*   LIST      (integer) Level of output desired.                       *
*   TITLE     (char)    Table type header.                             *
* Output:                                                              *
*   RRMS:     (real)    R.m.s. orbit error.                            *
*   DRMS:     (real)    R.m.s. dispersion error.                       *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,iflag,ihdcnt,ihdmax,ihdmin,ihrcnt,ihrmax,ihrmin,iocc,
     +ipos,istat,ivdcnt,ivdmax,ivdmin,ivrcnt,ivrmax,ivrmin,jbyt,lenhed,
     +list,nline,npage,number
      double precision drms,hdmax,hdmin,hdsum,hrmax,hrmin,hrsum,
     +rrms,utwopi,vdmax,vdmin,vdsum,vrmax,vrmin,vrsum
      character*(*)     title
      dimension         rrms(2), drms(2)
+ca memdum
+ca seqflag
+ca seqgroup
+ca codata
+ca refer
+ca zunit

      parameter         (lenhed = 6)
+ca maxlin
+ca pi
      parameter         (utwopi = 1.0 / (2.0 * pi))

      character*(mcnam) monnam, linnam
      character*(mcnam) ahdmax, ahdmin, ahrmax, ahrmin
      character*(mcnam) avdmax, avdmin, avrmax, avrmin
      character*4       orbeff, diseff
      logical           dishor, disver, orbhor, orbver, print

      if (lq(lcseq-msmon) .eq. 0) go to 9999
      ihdcnt = 0
      ihrcnt = 0
      ivdcnt = 0
      ivrcnt = 0

      hdmin = + 1.e10
      hdmax = - 1.e10
      hdsum = 0.0
      ihdmin = 0
      ihdmax = 0
      ahdmax = ' '
      ahdmin = ' '

      vdmin = + 1.e10
      vdmax = - 1.e10
      vdsum = 0.0
      ivdmin = 0
      ivdmax = 0
      avdmax = ' '
      avdmin = ' '

      hrmin = + 1.e10
      hrmax = - 1.e10
      hrsum = 0.0
      ihrmin = 0
      ihrmax = 0
      ahrmax = ' '
      ahrmin = ' '

      vrmin = + 1.e10
      vrmax = - 1.e10
      vrsum = 0.0
      ivrmin = 0
      ivrmax = 0
      avrmax = ' '
      avrmin = ' '

*---- Print page header.
      npage = 1
      call prpage(iqpr2)
      call uhtoc(q(lcseq+msbn), mcnam, linnam, mcnam)
      write (iqpr2, 910) title, linnam, npage
      nline = 2

*---- If listing, print sub-header.
      print = list .ge. 3
      if (list .gt. 1) then
        call prline(iqpr2)
        write (iqpr2, 920)
        call prline(iqpr2)
        nline = lenhed
      endif

*---- Loop through monitor table.
      lccom = lq(lcseq-msmon)
   10 if (lccom .ne. 0) then
        call ucopy(q(lccom+1), xcm, iq(lccom-1))

*---- Fetch element information.
        ipos   = iq(lccom-5)
        idir   = iq(lq(lcseq-msdir)+ipos)
        iflag  = iq(lq(lcseq-msflg)+ipos)
        number = iq(lq(lcseq-msnum)+ipos)
        iocc   = jbyt(iflag,mocc1,mocc2)
        call diname(ldbnk, idir, monnam)

*---- Monitor status.
        orbhor = .false.
        orbver = .false.
        orbeff = 'off'
        dishor = .false.
        disver = .false.
        diseff = 'off'
        istat = jbyt(iq(lccom),3,2)
        if (istat .eq. 1) then
          orbhor = .true.
          orbeff = 'x'
        else if (istat .eq. 2) then
          orbver = .true.
          orbeff = 'y'
        else if (istat .eq. 3) then
          orbhor = .true.
          orbver = .true.
          orbeff = 'x/y'
        endif
        istat = jbyt(iq(lccom),5,2)
        if (istat .eq. 1) then
          dishor = .true.
          diseff = 'x'
        else if (istat .eq. 2) then
          disver = .true.
          diseff = 'y'
        else if (istat .eq. 3) then
          dishor = .true.
          disver = .true.
          diseff = 'x/y'
        endif

*---- Extremal and r.m.s. values.
        if (dishor) then
          ihdcnt = ihdcnt + 1
          if (dxcm .lt. hdmin) then
            hdmin = dxcm
            ihdmin = iocc
            ahdmin = monnam
          endif
          if (dxcm .gt. hdmax) then
            hdmax = dxcm
            ihdmax = iocc
            ahdmax = monnam
          endif
          hdsum = hdsum + dxcm**2
        endif
        if (orbhor) then
          ihrcnt = ihrcnt + 1
          if (xcm .lt. hrmin) then
            hrmin = xcm
            ihrmin = iocc
            ahrmin = monnam
          endif
          if (xcm .gt. hrmax) then
            hrmax = xcm
            ihrmax = iocc
            ahrmax = monnam
          endif
          hrsum = hrsum + xcm**2
        endif
        if (disver) then
          ivdcnt = ivdcnt + 1
          if (dycm .lt. vdmin) then
            vdmin = dycm
            ivdmin = iocc
            avdmin = monnam
          endif
          if (dycm .gt. vdmax) then
            vdmax = dycm
            ivdmax = iocc
            avdmax = monnam
          endif
          vdsum = vdsum + dycm**2
        endif
        if (orbver) then
          ivrcnt = ivrcnt + 1
          if (ycm .lt. vrmin) then
            vrmin = ycm
            ivrmin = iocc
            avrmin = monnam
          endif
          if (ycm .gt. vrmax) then
            vrmax = ycm
            ivrmax = iocc
            avrmax = monnam
          endif
          vrsum = vrsum + ycm**2
        endif

*---- Partial print only?
        if (list .eq. 2) then
          print = dishor .or. disver .or. orbhor .or. orbver
        endif

*---- Print.
        if (print) then
          if (nline .ge. maxlin) then
            npage = npage + 1
            call prpage(iqpr2)
            write (iqpr2, 910) title, linnam, npage
            call prline(iqpr2)
            write (iqpr2, 920)
            call prline(iqpr2)
            nline = lenhed
          endif
          nline = nline + 1
          write (iqpr2, 930) number, monnam, iocc, scm,
     +      xcm*1000.0, dxcm, betxcm, amuxcm*utwopi, orbeff,
     +      ycm*1000.0, dycm, betycm, amuycm*utwopi, diseff
        endif
        lccom = lq(lccom-1)
        go to 10
      endif

*---- Summary lines.
      drms(1) = sqrt(hdsum / float(max(1, ihdcnt)))
      drms(2) = sqrt(vdsum / float(max(1, ivdcnt)))
      hrmin = hrmin * 1000.0
      hrmax = hrmax * 1000.0
      rrms(1) = sqrt(hrsum / float(max(1, ihrcnt))) * 1000.0
      vrmin = vrmin * 1000.0
      vrmax = vrmax * 1000.0
      rrms(2) = sqrt(vrsum / float(max(1, ivrcnt))) * 1000.0

*---- Print summary.
      call prline(iqpr2)
      write (iqpr2, 940) ihrcnt, ivrcnt, ihdcnt, ivdcnt, nmon,
     +                   hdmin, ahdmin, ihdmin, vdmin, avdmin, ivdmin,
     +                   hdmax, ahdmax, ihdmax, vdmax, avdmax, ivdmax,
     +                   drms,
     +                   hrmin, ahrmin, ihrmin, vrmin, avrmin, ivrmin,
     +                   hrmax, ahrmax, ihrmax, vrmax, avrmax, ivrmax,
     +                   rrms
      call prline(iqpr2)

  910 format(' Orbit and dispersion at monitors ',a,' for beam line ',
     +       a,t122,'page',i6)
  920 format(' Number  name   occur.      position',
     +       6x,'xread',9x,'Dx',12x,'betx',10x,'mux',11x,'effect'/
     +       42x,'yread',9x,'Dy',12x,'bety',10x,'muy'/
     +       28x,'[m]',11x,'[mm]',10x,2('[m]',11x),'[2*pi]')
  930 format(' ',i6,2x,a8,i5,5f14.6,6x,'orbit:      ',a4/
     +       36x,4f14.6,6x,'dispersion: ',a4)
  940 format(t34,'horizontal',t84,'vertical'/
     +       ' Orbit monitors used:',t25,i8,t75,i8/
     +       ' Dispersion monitors used:',t25,i8,t75,i8/
     +       ' Total monitors:',t25,i8,t75,i8/
     +       ' Minimum dispersion:',
     +       t25,f15.6,' m  at ',a,' [',i5,']',
     +       t75,f15.6,' m  at ',a,' [',i5,']'/
     +       ' Maximum dispersion:',
     +       t25,f15.6,' m  at ',a,' [',i5,']',
     +       t75,f15.6,' m  at ',a,' [',i5,']'/
     +       ' R.m.s. dispersion:',t25,f15.6,' m',t75,f15.6,' m'/
     +       ' Minimum readings:',
     +       t25,f15.6,' mm at ',a,' [',i5,']',
     +       t75,f15.6,' mm at ',a,' [',i5,']'/
     +       ' Maximum readings:',
     +       t25,f15.6,' mm at ',a,' [',i5,']',
     +       t75,f15.6,' mm at ',a,' [',i5,']'/
     +       ' R.m.s. readings:',t25,f15.6,' mm',t75,f15.6,' mm')

 9999 end
+dk copkik
      subroutine copkik(list, title)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print table of all correctors in the machine.                      *
* Input:                                                               *
*   LIST      (integer) Level of output desired.                       *
*   TITLE     (char)    Table type header.                             *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,iflag,iocc,ipos,istat,jbyt,lenhed,list,maxh,maxv,
     +nline,npage,number,numh,numv
      double precision habs,hmax,hrms,utwopi,vabs,vmax,vrms
      character*(*)     title
+ca memdum
+ca seqflag
+ca seqgroup
+ca codata
+ca colink
+ca refer
+ca zunit

      parameter         (lenhed = 6)
+ca maxlin
+ca pi
      parameter         (utwopi = 1.0 / (2.0 * pi))

      character*(mcnam) cornam, linnam, hmaxnm, vmaxnm
      character*4       effect
      logical           hor,    print,  ver

      if (lq(lcseq-mscom) .eq. 0) go to 9999
      numh = 0
      hmax = 0.0
      hrms = 0.0
      maxh = 0
      hmaxnm = ' '
      numv = 0
      vmax = 0.0
      vrms = 0.0
      maxv = 0
      vmaxnm = ' '

*---- Print page header.
      npage = 1
      call prpage(iqpr2)
      call uhtoc(q(lcseq+msbn), mcnam, linnam, mcnam)
      write (iqpr2, 910) title, linnam, npage
      nline = 2

*---- If listing, print sub-header.
      print = list .ge. 3
      if (list .gt. 1) then
        call prline(iqpr2)
        write (iqpr2, 920)
        call prline(iqpr2)
        nline = lenhed
      endif

*---- Loop on correctors.
      lccom = lq(lcseq-mscor)
   10 if (lccom .ne. 0) then
        call ucopy(q(lccom+1), xcm, iq(lccom-1))

*---- Fetch element information.
        ipos   = iq(lccom-5)
        idir   = iq(lq(lcseq-msdir)+ipos)
        iflag  = iq(lq(lcseq-msflg)+ipos)
        number = iq(lq(lcseq-msnum)+ipos)
        iocc   = jbyt(iflag,mocc1,mocc2)
        call diname(ldbnk, idir, cornam)

*---- Corrector effect.
        hor = .false.
        ver = .false.
        istat = jbyt(iq(lccom),5,2)
        if (istat .eq. 0) then
          effect = 'off'
        else if (istat .eq. 1) then
          effect = 'x'
          hor = xcm .ne. 0.0
        else if (istat .eq. 2) then
          effect = 'y'
          ver = ycm .ne. 0.0
        else
          effect = 'x/y'
          hor = xcm .ne. 0.0
          ver = ycm .ne. 0.0
        endif

*---- Maximum and r.m.s. value.
        if (hor) then
          numh = numh + 1
          habs = abs(xcm)
          hrms = hrms + habs**2
          if (habs .gt. hmax) then
            hmax = habs
            maxh = iocc
            hmaxnm = cornam
          endif
        endif
        if (ver) then
          numv = numv + 1
          vabs = abs(ycm)
          vrms = vrms + vabs**2
          if (vabs .gt. vmax) then
            vmax = vabs
            maxv = iocc
            vmaxnm = cornam
          endif
        endif

*---- Active correctors only?
        if (list .eq. 2) print = hor .or. ver

*---- Print.
        if (print) then
          if (nline .ge. maxlin) then
            npage = npage + 1
            call prpage(iqpr2)
            write (iqpr2, 910) title, linnam, npage
            call prline(iqpr2)
            write (iqpr2, 920)
            call prline(iqpr2)
            nline = lenhed
          endif
          nline = nline + 1
          write (iqpr2, 930) number, cornam, iocc, scm,
     +                       xcm*1000.0, ycm*1000.0, betxcm, betycm,
     +                       amuxcm*utwopi, amuycm*utwopi, effect
        endif
        lccom = lq(lccom-1)
        go to 10
      endif

*---- Summary lines.
      hmax = hmax * 1000.0
      hrms = sqrt(hrms / float(max(1, numh))) * 1000.0
      vmax = vmax * 1000.0
      vrms = sqrt(vrms / float(max(1, numv))) * 1000.0
      call prline(iqpr2)
      write (iqpr2, 940) numh, ncor(1), numv, ncor(2),
     +                   hmax, hmaxnm, maxh, vmax, vmaxnm, maxv,
     +                   hrms, vrms
      call prline(iqpr2)

  910 format(' Corrector strengths ',a,' for beam line ',a,
     +       t122,'page',i6)
  920 format(' Number  name   occur.      position      xcorr',9x,
     +       'ycorr',9x,'betx',10x,'bety',10x,'mux',11x,'muy',10x,
     +       'effect'/
     +       28x,'[m]',11x,2('[mrad]',8x),2('[m]',11x),2('[2*pi]',8x))
  930 format(' ',i6,2x,a8,i5,7f14.6,5x,a4)
  940 format(t34,'horizontal',t84,'vertical'/
     +       ' Correctors used:',
     +       t25,i8,' (of ',i8,')',t75,i8,' (of ',i8,')'/
     +       ' Maximum strengths:',
     +       t25,f15.6,' mrad at ',a,' [',i5,']',
     +       t75,f15.6,' mrad at ',a,' [',i5,']'/
     +       ' R.m.s. strengths:',t25,f15.6,' mrad',t75,f15.6,' mrad')

 9999 end
+dk copmon
      subroutine copmon(list, title, rms)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print table of all monitors in the machine.                        *
* Input:                                                               *
*   LIST      (integer) Level of output desired.                       *
*   TITLE     (char)    Table type header.                             *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,iflag,iocc,ipos,istat,jbyt,lenhed,list,maxh,maxv,
     +minh,minv,nline,npage,number,numh,numv
      double precision hmax,hmin,hrms,hsum,rms,utwopi,vmax,vmin,
     +vrms,vsum
      character*(*)     title
+ca memdum
+ca seqflag
+ca seqgroup
+ca codata
+ca refer
+ca zunit

      parameter         (lenhed = 6)
+ca maxlin
+ca pi
      parameter         (utwopi = 1.0 / (2.0 * pi))

      character*(mcnam) monnam, linnam, hmaxnm, hminnm, vmaxnm, vminnm
      character*4       effect
      logical           hor,    print,  ver

      if (lq(lcseq-msmon) .eq. 0) go to 9999
      hmin = + 1.e10
      hmax = - 1.e10
      hsum = 0.0
      numh = 0
      minh = 0
      maxh = 0
      hmaxnm = ' '
      hminnm = ' '
      vmin = + 1.e10
      vmax = - 1.e10
      vsum = 0.0
      numv = 0
      minv = 0
      maxv = 0
      vmaxnm = ' '
      vminnm = ' '

*---- Print page header.
      npage = 1
      call prpage(iqpr2)
      call uhtoc(q(lcseq+msbn), mcnam, linnam, mcnam)
      write (iqpr2, 910) title, linnam, npage
      nline = 2

*---- If listing, print sub-header.
      print = list .ge. 3
      if (list .gt. 1) then
        call prline(iqpr2)
        write (iqpr2, 920)
        call prline(iqpr2)
        nline = lenhed
      endif

*---- Loop through monitor table.
      lccom = lq(lcseq-msmon)
   10 if (lccom .ne. 0) then
        call ucopy(q(lccom+1), xcm, iq(lccom-1))

*---- Fetch element information.
        ipos   = iq(lccom-5)
        idir   = iq(lq(lcseq-msdir)+ipos)
        iflag  = iq(lq(lcseq-msflg)+ipos)
        number = iq(lq(lcseq-msnum)+ipos)
        iocc   = jbyt(iflag,mocc1,mocc2)
        call diname(ldbnk, idir, monnam)

*---- Monitor status.
        hor = .false.
        ver = .false.
        istat = jbyt(iq(lccom),3,2)
        effect = 'off'
        if (istat .eq. 1) then
          hor = .true.
          effect = 'x'
        else if (istat .eq. 2) then
          ver = .true.
          effect = 'y'
        else if (istat .eq. 3) then
          hor = .true.
          ver = .true.
          effect = 'x/y'
        endif

*---- Extremal and r.m.s. values.
        if (hor) then
          numh = numh + 1
          if (xcm .lt. hmin) then
            hmin = xcm
            minh = iocc
            hminnm = monnam
          endif
          if (xcm .gt. hmax) then
            hmax = xcm
            maxh = iocc
            hmaxnm = monnam
          endif
          hsum = hsum + xcm**2
        endif
        if (ver) then
          numv = numv + 1
          if (ycm .lt. vmin) then
            vmin = ycm
            minv = iocc
            vminnm = monnam
          endif
          if (ycm .gt. vmax) then
            vmax = ycm
            maxv = iocc
            vmaxnm = monnam
          endif
          vsum = vsum + ycm**2
        endif

*---- Partial print only?
        if (list .eq. 2) print = hor .or. ver

*---- Print.
        if (print) then
          if (nline .ge. maxlin) then
            npage = npage + 1
            call prpage(iqpr2)
            write (iqpr2, 910) title, linnam, npage
            call prline(iqpr2)
            write (iqpr2, 920)
            call prline(iqpr2)
            nline = lenhed
          endif
          nline = nline + 1
          write (iqpr2, 930) number, monnam, iocc, scm,
     +                       xcm*1000.0, ycm*1000.0, betxcm, betycm,
     +                       amuxcm*utwopi, amuycm*utwopi, effect
        endif
        lccom = lq(lccom-1)
        go to 10
      endif

*---- Summary lines.
      hmin = hmin * 1000.0
      hmax = hmax * 1000.0
      hrms = sqrt(hsum / float(max(1, numh))) * 1000.0
      vmin = vmin * 1000.0
      vmax = vmax * 1000.0
      vrms = sqrt(vsum / float(max(1, numv))) * 1000.0
      rms = max(hrms, vrms)

*---- Print summary.
      call prline(iqpr2)
      write (iqpr2, 940) numh, nmon(1), numv, nmon(2),
     +                   hmin, hminnm, minh, vmin, vminnm, minv,
     +                   hmax, hmaxnm, maxh, vmax, vmaxnm, maxv,
     +                   hrms, vrms
      call prline(iqpr2)

  910 format(' Monitor readings ',a,' for beam line ',a,
     +       t122,'page',i6)
  920 format(' Number  name   occur.      position      xread',9x,
     +       'yread',9x,'betx',10x,'bety',10x,'mux',11x,'muy',10x,
     +       'effect'/
     +       28x,'[m]',11x,2('[mm]',10x),2('[m]',11x),2('[2*pi]',8x))
  930 format(' ',i6,2x,a8,i5,7f14.6,5x,a4)
  940 format(t34,'horizontal',t84,'vertical'/
     +       ' Monitors used:',
     +       t25,i8,' (of ',i8,')',t75,i8,' (of ',i8,')'/
     +       ' Minimum readings:',
     +       t25,f15.6,' mm at ',a,' [',i5,']',
     +       t75,f15.6,' mm at ',a,' [',i5,']'/
     +       ' Maximum readings:',
     +       t25,f15.6,' mm at ',a,' [',i5,']',
     +       t75,f15.6,' mm at ',a,' [',i5,']'/
     +       ' R.m.s. readings:',t25,f15.6,' mm',t75,f15.6,' mm')

 9999 end
+dk cordis
      subroutine cordis
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Get dispersion reading from a TFS file.                            *
* GETDISP command:                                                     *
*   FILENAME  (string)  TFS file name to be read.                      *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca seqflag
+ca seqgroup
+ca message
+ca codata
+ca colink
+ca refer
+ca status
+ca tbpara
      integer ibias1,ibias2,ibias3,ibias4,idir,iform1,iform2,iform3,
     +iform4,ileng,istat,iunit,jrow,nrow

      character*(mcfil) filnam
      character*(mcnam) monnam, rednam, tabnam

      data tabnam       / '*DISP TABLE*' /

*---- Check main beam line.
      call lnchck('GETDISP', error)
      if (error) go to 800

*---- Retrieve file name.
      filnam = 'dispersion'
      call utgstr(lccmd, 1, 1, filnam)

*---- Set up corrector and monitor table.
      call cotble(error)
      if (error) go to 800

*---- Read table in TFS format.
      call flopen(filnam, 'SRFD', 0, 0, iunit, error)
      if (error) go to 800
      call tbrtfs(tabnam, iunit)
      call flname(iunit, filnam)
      call flclos(iunit, error)
      if (error) go to 800

*---- Check table format.
      call tbopen(tabnam, 1, lcotab)
      call tbcol(lcotab, 'PUNAME', iform1, ibias1)
      if (iform1 .ne. 5) then
        write (msg, 910) 'PUNAME', 'string'
        call aafail('CORDIS', 1, msg)
      endif
      call tbcol(lcotab, 'DX', iform2, ibias2)
      if (iform2 .lt. 3  .or.  iform2 .gt. 4) then
        write (msg, 910) 'DX', 'real'
        call aafail('CORDIS', 1, msg)
      endif
      call tbcol(lcotab, 'DY', iform3, ibias3)
      if (iform3 .lt. 3  .or.  iform3 .gt. 4) then
        write (msg, 910) 'DY', 'real'
        call aafail('CORDIS', 1, msg)
      endif
      call tbcol(lcotab, 'STATUS', iform4, ibias4)
      if (iform4 .lt. 1  .or.  iform4 .gt. 2) then
        write (msg, 910) 'STATUS', 'integer'
        call aafail('CORDIS', 1, msg)
      endif
      if (error) go to 800

*---- Set all monitor to inactive status and clear dispersion.
      lccom = lq(lcseq-msmon)
   10 if (lccom .ne. 0) then
        call sbyt(0, iq(lccom), 5, 2)
        call uzero(q(lccom+2*mwflt+1), 1, 2*mwflt)
        lccom = lq(lccom-1)
        go to 10
      endif

*---- Load monitor readings into data structure.
      nrow = iq(lcotab+mtbrow)
      do 90 jrow = 1, nrow
        call tbset(lcotab, jrow, 1, lcobuf)
        call uhtoc(q(lcobuf+ibias1+1), mcwrd, rednam, mcnam)

*---- Search MICADO tables for monitor.
        lccom = lq(lcseq-msmon)
   20   if (lccom .ne. 0) then
          call ucopy(q(lccom+1), xcm, 4*mwflt)
          idir = iq(lq(lcseq-msdir)+iq(lccom-5))
          call diname(ldbnk, idir, monnam)

*---- If same name, store dispersion reading.
          if (monnam .eq. rednam) then
            if (iform2 .eq. 3) then
              dxcm = q(lcobuf+ibias2+1)
            else
              call ucopy(q(lcobuf+ibias2+1), dxcm, mwflt)
            endif
            if (iform3 .eq. 3) then
              dycm = q(lcobuf+ibias3+1)
            else
              call ucopy(q(lcobuf+ibias3+1), dycm, mwflt)
            endif

*---- Activate monitor for orbit and store data.
            istat = iq(lcobuf+ibias4+1)
            if (istat .eq. 0) then
              call sbyt(iq(lccom), iq(lccom), 5, 2)
              call ucopy(xcm, q(lccom+1), 4*mwflt)
            endif
            go to 90
          endif

*---- Skip to next corrector.
          lccom = lq(lccom-1)
          go to 20
        endif

*---- Monitor not found.
        call utleng(rednam, ileng)
        msg(1) = 'Monitor "' // rednam(1:ileng)
     +  // '" not found in beam line.'
        call aawarn('CORDIS', 1, msg)
   90 continue

*---- Drop table.
      msg(1) = 'Dispersion readings read on file: ' // filnam
      call aainfo('CORDIS', 1, msg)
  800 continue
      if (lcotab .ne. 0) call tbdrop(lcotab)

  910 format('Cannot find column "',a,'" with ',a,' format.')

      end
+dk corkik
      subroutine corkik
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Read most recent corrector settings from a TFS file.               *
* GETKICK command:                                                     *
*   FILENAME  (string)  TFS file name to be read.                      *
*   PLANE     (name)    Plane(s) to be read: 'X', 'Y', 'BOTH'.         *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca expgroup
+ca seqflag
+ca seqgroup
+ca vargroup
+ca message
+ca codata
+ca colink
+ca refer
+ca status
+ca tbpara
      integer ibias1,ibias2,ibias3,idir,iflag,iform1,iform2,iform3,
     +ileng,iocc,ipos,iunit,jbit,jbyt,jrow,nrow
      double precision xkick,ykick

      character*(mcfil) filnam
      character*(mcnam) cornam, kiknam, plane, rednam, tabnam
      character*(mcnam) tmpnam
      logical           adding, direct

      data tabnam       / '*SETTINGS TABLE*' /

*---- Check main beam line.
      call lnchck('GETKICK', error)
      if (error) go to 800

*---- Retrieve file name.
      filnam = 'setting'
      call utgstr(lccmd, 1, 1, filnam)

*---- Retrieve plane name.
      plane = 'BOTH'
      call utgnam(lccmd, 2, 2, plane)

*---- Retrieve increment flag.
      adding = .false.
      call utglog(lccmd, 3, 3, adding)

*---- Retrieve "direct name" flag
      direct = .false.
      call utglog(lccmd, 4, 4, direct)

*---- Set up corrector and monitor table.
      call cotble(error)
      if (error) go to 800

*---- Read table in TFS format.
      call flopen(filnam, 'SRFD', 0, 0, iunit, error)
      if (error) go to 800
      call tbrtfs(tabnam, iunit)
      call flname(iunit, filnam)
      call flclos(iunit, error)
      if (error) go to 800

*---- Check table format.
      call tbopen(tabnam, 1, lcotab)
      call tbcol(lcotab, 'STR_NAME', iform1, ibias1)
      if (iform1 .ne. 5) then
        write (msg, 910) 'STR_NAME', 'string'
        call aafail('CORKIK', 1, msg)
      endif
      if (plane .eq. 'X') then
        call tbcol(lcotab, 'DK_N', iform2, ibias2)
        if (iform2 .lt. 3  .or.  iform2 .gt. 4) then
          write (msg, 910) 'DK_N', 'real'
          call aafail('CORKIK', 1, msg)
        endif
        iform3 = 0
      else if (plane .eq. 'Y') then
        iform2 = 0
        call tbcol(lcotab, 'DK_N', iform3, ibias3)
        if (iform3 .lt. 3  .or.  iform3 .gt. 4) then
          write (msg, 910) 'DK_N', 'real'
          call aafail('CORKIK', 1, msg)
        endif
      else
        call tbcol(lcotab, 'DK_N_H', iform2, ibias2)
        if (iform2 .lt. 3  .or.  iform2 .gt. 4) then
          write (msg, 910) 'DK_N_H', 'real'
          call aafail('CORKIK', 1, msg)
        endif
        call tbcol(lcotab, 'DK_N_V', iform3, ibias3)
        if (iform3 .lt. 3  .or.  iform3 .gt. 4) then
          write (msg, 910) 'DK_N_V', 'real'
          call aafail('CORKIK', 1, msg)
        endif
      endif
      if (error) go to 800

*---- Set all correctors to zero increment.
      if (.not. adding) then
        lccom = lq(lcseq-mscor)
   10   if (lccom .ne. 0) then
          if (plane .eq. 'X') then
            call sbit0(iq(lccom), 3)
            call uzero(q(lccom+1), 1, mwflt)
          else if (plane .eq. 'Y') then
            call sbit0(iq(lccom), 4)
            call uzero(q(lccom+mwflt+1), 1, mwflt)
          else
            call sbyt(0, iq(lccom), 3, 2)
            call uzero(q(lccom+1), 1, 2*mwflt)
          endif
          lccom = lq(lccom-1)
          go to 10
        endif
      endif

*---- Drop precomputed maps.
      newmap = .true.

*---- Load corrector settings into data structure.
      nrow = iq(lcotab+mtbrow)
      do 90 jrow = 1, nrow
        call tbset(lcotab, jrow, 1, lcobuf)
        call uhtoc(q(lcobuf+ibias1+1), mcwrd, rednam, mcnam)

*---- Search corrector table for this name.
        lccom = lq(lcseq-mscor)
   20   if (lccom .ne. 0) then

*---- Fetch corrector name.
          ipos  = iq(lccom-5)
          idir  = iq(lq(lcseq-msdir)+ipos)
          iflag = iq(lq(lcseq-msflg)+ipos)
          iocc  = jbyt(iflag,mocc1,mocc2)
          call diname(ldbnk, idir, cornam)
          lcelm = lq(ldbnk(3)-idir)
          lcexp = lq(lcelm-3)
          if (lcexp .eq. 0) then
            call utocnm(cornam, iocc, kiknam)
          else if (iq(lcexp-2) .ne. 1  .or.
     +      iq(lcexp+mxop) .ne. -2  .or.  lq(lcexp-1) .eq. 0) then
            call utocnm(cornam, iocc, kiknam)
          else
            call uhtoc(q(lq(lcexp-1)+mvbank), mcwrd, kiknam, mcnam)
          endif

*---- If same name, store settings.
          if (direct)  then
            tmpnam = cornam
          else
            tmpnam = kiknam
          endif
          if (tmpnam .eq. rednam) then
            call ucopy(q(lccom+1), xcm, 2*mwflt)
            if (jbit(iq(lccom),1) .ne. 0) then
              if (iform2 .eq. 3) then
                xkick = q(lcobuf+ibias2+1)
              else if (iform2 .eq. 4) then
                call ucopy(q(lcobuf+ibias2+1), xkick, mwflt)
              endif
              xcm = xcm + xkick
            endif
            if (jbit(iq(lccom),2) .ne. 0) then
              if (iform3 .eq. 3) then
                ykick = q(lcobuf+ibias3+1)
              else if (iform3 .eq. 4) then
                call ucopy(q(lcobuf+ibias3+1), ykick, mwflt)
              endif
              ycm = ycm + ykick
            endif

*---- Activate corrector, set used, and store data.
            call sbyt(iq(lccom), iq(lccom), 5, 2)
            call sbyt(iq(lccom), iq(lccom), 3, 2)
            call ucopy(xcm, q(lccom+1), 2*mwflt)
            go to 90
          endif

*---- Skip to next corrector.
          lccom = lq(lccom-1)
          go to 20
        endif

*---- Failing to find name in table.
        call utleng(rednam, ileng)
        msg(1) = 'Corrector "' // rednam(1:ileng)
     +  // '" not found in beam line.'
        call aawarn('CORKIK', 1, msg)
   90 continue

*---- Drop table.
      msg(1) = 'Kicker settings read on file: ' // filnam
      call aainfo('CORKIK', 1, msg)
  800 continue
      if (lcotab .ne. 0) call tbdrop(lcotab)

  910 format('Cannot find column "',a,'" with ',a,' format.')

      end
+dk cormon
      subroutine cormon
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Get closed orbit reading from a TFS file.                          *
* GETORBIT command:                                                    *
*   FILENAME  (string)  TFS file name to be read.                      *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca seqflag
+ca seqgroup
+ca message
+ca codata
+ca colink
+ca refer
+ca status
+ca tbpara
      integer ibias1,ibias2,ibias3,ibias4,idir,iform1,iform2,iform3,
     +iform4,ileng,istat,iunit,jrow,nrow

      character*(mcfil) filnam
      character*(mcnam) monnam, rednam, tabnam

      data tabnam       / '*ORBIT TABLE*' /

*---- Check main beam line.
      call lnchck('GETORBIT', error)
      if (error) go to 800

*---- Retrieve file name.
      filnam = 'orbit'
      call utgstr(lccmd, 1, 1, filnam)

*---- Set up corrector and monitor table.
      call cotble(error)
      if (error) go to 800

*---- Read table in TFS format.
      call flopen(filnam, 'SRFD', 0, 0, iunit, error)
      if (error) go to 800
      call tbrtfs(tabnam, iunit)
      call flname(iunit, filnam)
      call flclos(iunit, error)
      if (error) go to 800

*---- Check table format.
      call tbopen(tabnam, 1, lcotab)
      call tbcol(lcotab, 'PUNAME', iform1, ibias1)
      if (iform1 .ne. 5) then
        write (msg, 910) 'PUNAME', 'string'
        call aafail('CORMON', 1, msg)
      endif
      call tbcol(lcotab, 'X', iform2, ibias2)
      if (iform2 .lt. 3  .or.  iform2 .gt. 4) then
        write (msg, 910) 'X', 'real'
        call aafail('CORMON', 1, msg)
      endif
      call tbcol(lcotab, 'Y', iform3, ibias3)
      if (iform3 .lt. 3  .or.  iform3 .gt. 4) then
        write (msg, 910) 'Y', 'real'
        call aafail('CORMON', 1, msg)
      endif
      call tbcol(lcotab, 'STATUS', iform4, ibias4)
      if (iform4 .lt. 1  .or.  iform4 .gt. 2) then
        write (msg, 910) 'STATUS', 'integer'
        call aafail('CORMON', 1, msg)
      endif
      if (error) go to 800

*---- Set all monitor to inactive status and clear orbit.
      lccom = lq(lcseq-msmon)
   10 if (lccom .ne. 0) then
        call sbyt(0, iq(lccom), 3, 2)
        call uzero(q(lccom+1), 1, 2*mwflt)
        lccom = lq(lccom-1)
        go to 10
      endif

*---- Load monitor readings into data structure.
      nrow = iq(lcotab+mtbrow)
      do 90 jrow = 1, nrow
        call tbset(lcotab, jrow, 1, lcobuf)
        call uhtoc(q(lcobuf+ibias1+1), mcwrd, rednam, mcnam)

*---- Search MICADO tables for monitor.
        lccom = lq(lcseq-msmon)
   20   if (lccom .ne. 0) then
          idir = iq(lq(lcseq-msdir)+iq(lccom-5))
          call diname(ldbnk, idir, monnam)

*---- If same name, store orbit reading.
          if (monnam .eq. rednam) then
            if (iform2 .eq. 3) then
              xcm = q(lcobuf+ibias2+1) / 1000.0
            else
              call ucopy(q(lcobuf+ibias2+1), xcm, mwflt)
              xcm = xcm / 1000.0
            endif
            if (iform3 .eq. 3) then
              ycm = q(lcobuf+ibias3+1) / 1000.0
            else
              call ucopy(q(lcobuf+ibias3+1), ycm, mwflt)
              ycm = ycm / 1000.0
            endif

*---- Activate monitor for dispersion and store data.
            istat = iq(lcobuf+ibias4+1)
            if (istat .eq. 0) then
              call sbyt(iq(lccom), iq(lccom), 3, 2)
              call ucopy(xcm, q(lccom+1), 2*mwflt)
            endif
            go to 90
          endif

*---- Skip to next corrector.
          lccom = lq(lccom-1)
          go to 20
        endif

*---- Monitor not found.
        call utleng(rednam, ileng)
        msg(1) = 'Monitor "' // rednam(1:ileng)
     +    // '" not found in beam line.'
        call aawarn('CORMON', 1, msg)
   90 continue

*---- Drop table.
      msg(1) = 'Monitor readings read on file: ' // filnam
      call aainfo('CORMON', 1, msg)
  800 continue
      if (lcotab .ne. 0) call tbdrop(lcotab)

  910 format('Cannot find column "',a,'" with ',a,' format.')

      end
+dk coskik
      subroutine coskik(jpl, set)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Change corrector settings for one plane.                           *
* Input:                                                               *
*   JPL       (integer) 1 = horizontal, 2 = vertical.                  *
*   SET       (real)    Array of changes.                              *
*----------------------------------------------------------------------*
+ca aparam
      integer jbit,jpl,nc
      double precision set
      dimension         set(*)
+ca memdum
+ca seqgroup
+ca codata
+ca option
+ca refer
+ca status

*---- Set corrector increments.
      nc = 0
      lccom = lq(lcseq-mscor)
   10 if (lccom .ne. 0) then
        if (jbit(iq(lccom),jpl+4) .ne. 0) then
          call ucopy(q(lccom+1), xcm, 2*mwflt)
          nc = nc + 1
          if (jpl .eq. 1) then
            xcm = xcm - set(nc)
          else
            ycm = ycm - set(nc)
          endif
          call sbit1(iq(lccom),jpl+2)
          call ucopy(xcm, q(lccom+1), 2*mwflt)
        endif
        lccom = lq(lccom-1)
        go to 10
      endif

*---- Drop precomputed maps.
      if (lcseq .ne. 0) then
        if (lq(lcseq-msmap) .ne. 0) then
          if (debug) then
            call aainfo('COSKIK', 1,
     +      'Dropping TRANSPORT map for main beam line.')
          endif
          call mzdrop(0, lq(lcseq-msmap), 'L')
        endif
        if (lq(lcseq-mslie) .ne. 0) then
          if (debug) then
            call aainfo('COSKIK', 1,
     +      'Dropping Lie algebraic map for main beam line.')
          endif
          call mzdrop(0, lq(lcseq-mslie), 'L')
        endif
      endif

      end
+dk cotble
      subroutine cotble(eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Set up table of all correctors and monitors in the machine.        *
*   Reference optics ignores imperfections, but keeps radiation.       *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iflag,ipos,isp,jbyt,mcom,nd,nl
      double precision denx,deny,el,el2,one,ta,tb,two,twopi,zero
      logical           eflag
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca seqflag
+ca seqgroup
+ca beam
+ca codata
+ca colink
+ca mapelm
+ca optic0
+ca optic1
+ca refer
+ca stflag

+ca pi
      parameter         (twopi = 2.0d0 * pi)
      parameter         (zero  = 0.0d0, one = 1.0d0, two = 2.0d0)
      parameter         (mcom  = 9 * mwflt)

      logical           dosave(maxdof), fmap

*---- Set to ignore all effects but cavities and radiation.
      do 10 i = 1, maxdof
        dosave(i) = doflag(i)
        doflag(i) = .false.
   10 continue

*---- The flags have changed, drop precomputed maps.
      call aapdrp

*---- Test for presence of corrector and monitor table.
      eflag = .false.
      nd = 2 * mwflt + 4
      if (lq(lcseq-mscom) .ne. 0) then
        lscom = lq(lcseq-mscom)
        call ncopy(iq(lscom+1), ncor, 2)
        call ncopy(iq(lscom+3), nmon, 2)
        call ucopy(q(lscom+5), halfqx, 2*mwflt)
        go to 800
      endif
      call aainfo('COTBLE', 1,
     +            'Building tables for MICADO algorithm.')

*---- Initial conditions for ideal lattice functions.
      call tmrefe(lcseq)
      if (iq(lcseq+msym) .ne. 0) call tmmksm(.false.)
      call twbtin(lcseq, .false., eflag)
      if (eflag) go to 800
      halfqx = atan2(sinmux,cosmux) / two
      halfqy = atan2(sinmuy,cosmuy) / two

*---- Initialize.
      ncor(1) = 0
      ncor(2) = 0
      nmon(1) = 0
      nmon(2) = 0

*---- Copy initial optical functions.
      betx = betx0
      alfx = alfx0
      amux = zero
      bety = bety0
      alfy = alfy0
      amuy = zero
      call ucopy(disp0, disp, 6*mwflt)

*---- Book pointer bank.
      nl = iq(lsdir-1)
      lcocor = 0
      lcomon = 0
      lcoelm = 0
      call mzbook(2, lscom, lcseq, -mscom, 'COTB', nl, nl, nd, 2, 0)

*---- Loop on complete working beam line.
      suml = 0.0
      lcali = 0
      lcfld = 0
      do 90 ipos = 1, nl
        iflag = iq(lq(lcseq-msflg)+ipos)
        lcelm = lq(ldbnk(3)-iq(lq(lcseq-msdir)+ipos))

*---- Element: find transfer matrix.
        if (jbyt(iflag,1,mcode) .eq. 1) then
          lccom = 0
          call tmmap(.false., .false., orbit, fmap, el, ek, re, te)
          isp = iq(lcelm+mbsp)
          akl = 0.0

*---- Quadrupole or thin multipole.
          if (isp .eq. 5  .or.  isp .eq. 8) then
            call mzbook(0, lccom, lscom, -ipos, 'DELM', 2, 0,
     +                  mcom, mreal, 0)
            iq(lccom-5) = ipos
            lq(lccom-2) = lcelm
            if (lcoelm .ne. 0) then
              lq(lcoelm-1) = lccom
            else
              lq(lcseq-mselm) = lccom
            endif
            lcoelm = lccom
            xcm   = 0.0
            ycm   = 0.0

*---- Quadrupole: Interpolate functions at centre
*     (no need for dispersion).
            if (isp .eq. 5) then
              call ucopy(q(lcelm+melen), el, mwflt)
              el2    = el / 2.
              scm    = suml + el2
              tb     = (re(1,1) + one) * betx - re(1,2) * alfx
              denx   = re(1,1) + re(2,2) + two
              betxcm = (tb**2 + re(1,2)**2) / (denx * betx)
              amuxcm = amux + atan2(re(1,2), tb)
              tb     = (re(3,3) + one) * bety - re(3,4) * alfy
              deny   = re(3,3) + re(4,4) + two
              betycm = (tb**2 + re(3,4)**2) / (deny * bety)
              amuycm = amuy + atan2(re(3,4), tb)

*---- Multipole.
            else
              scm    = suml
              betxcm = betx
              betycm = bety
              amuxcm = amux
              amuycm = amuy
              dxcm   = disp(1)
              dycm   = disp(3)
            endif
            call ucopy(xcm, q(lccom+1), mcom)

*---- Sextupole.
          else if (isp .eq. 6) then
            call mzbook(0, lccom, lscom, -ipos, 'DELM', 2, 0,
     +                  mcom, mreal, 0)
            iq(lccom-5) = ipos
            lq(lccom-2) = lcelm
            if (lcoelm .ne. 0) then
              lq(lcoelm-1) = lccom
            else
              lq(lcseq-mselm) = lccom
            endif
            lcoelm = lccom
            xcm   = 0.0
            ycm   = 0.0

*---- Interpolate functions at centre.
            call ucopy(q(lcelm+melen), el, mwflt)
            el2    = el / 2.
            scm    = suml + el2
            betxcm = ((betx - el2 * alfx)**2 + el2**2) / betx
            betycm = ((bety - el2 * alfy)**2 + el2**2) / bety
            amuxcm = amux + atan2(el2, betx - el2 * alfx)
            amuycm = amuy + atan2(el2, bety - el2 * alfy)
            dxcm   = disp(1) + el2 * disp(2)
            dycm   = disp(3) + el2 * disp(4)
            call ucopy(xcm, q(lccom+1), mcom)

*---- Corrector or monitor?
          else if (isp .ge. 14  .and.  isp .le. 19) then
            call ucopy(q(lcelm+melen), el, mwflt)
            el2    = el / two
            scm    = suml + el2
            xcm    = 0.0
            ycm    = 0.0
            dxcm   = 0.0
            dycm   = 0.0
            betxcm = ((betx - el2 * alfx)**2 + el2**2) / betx
            betycm = ((bety - el2 * alfy)**2 + el2**2) / bety
            amuxcm = amux + atan2(el2, betx - el2 * alfx)
            amuycm = amuy + atan2(el2, bety - el2 * alfy)

*---- Element is corrector (ISP = 14 ... 16).
            if (isp .le. 16) then
              call mzbook(0, lccom, lscom, -ipos, 'DCOR', 1, 0,
     +                    mcom, mreal, 0)
              iq(lccom-5) = ipos
              if (lcocor .ne. 0) then
                lq(lcocor-1) = lccom
              else
                lq(lcseq-mscor) = lccom
              endif
              lcocor = lccom
              if (isp .le. 15) then
                ncor(1) = ncor(1) + 1
                call sbit1(iq(lccom), 1)
              endif
              if (isp .ge. 15) then
                ncor(2) = ncor(2) + 1
                call sbit1(iq(lccom), 2)
              endif

*---- Set corrector active and copy data.
              call sbyt(iq(lccom), iq(lccom), 5, 2)
              call ucopy(xcm, q(lccom+1), mcom)

*---- Element is monitor (ISP = 17 ... 19).
            else
              call mzbook(0, lccom, lscom, -ipos, 'DMON', 1, 0,
     +                    mcom, mreal, 0)
              iq(lccom-5) = ipos
              if (lcomon .ne. 0) then
                lq(lcomon-1) = lccom
              else
                lq(lcseq-msmon) = lccom
              endif
              lcomon = lccom
              if (isp .le. 18) then
                nmon(1) = nmon(1) + 1
                call sbit1(iq(lccom), 1)
              endif
              if (isp .ge. 18) then
                nmon(2) = nmon(2) + 1
                call sbit1(iq(lccom), 2)
              endif

*---- Set monitor active for orbit and dispersion and copy data.
              call sbyt(iq(lccom), iq(lccom), 3, 2)
              call sbyt(iq(lccom), iq(lccom), 5, 2)
              call ucopy(xcm, q(lccom+1), mcom)
            endif
          endif

*---- Advance through element.
          if (fmap) then
            tb   = re(1,1)*betx - re(1,2)*alfx
            ta   = re(2,1)*betx - re(2,2)*alfx
            alfx = - (tb*ta + re(1,2)*re(2,2)) / betx
            betx = (tb**2 + re(1,2)**2) / betx
            amux = amux + atan2(re(1,2),tb)
            tb   = re(3,3)*bety - re(3,4)*alfy
            ta   = re(4,3)*bety - re(4,4)*alfy
            alfy = - (tb*ta + re(3,4)*re(4,4)) / bety
            bety = (tb**2 + re(3,4)**2) / bety
            amuy = amuy + atan2(re(3,4),tb)
            call m66byv(re, disp, disp)
            suml = suml + el
          endif
        endif
   90 continue
      call ncopy(ncor, iq(lscom+1), 2)
      call ncopy(nmon, iq(lscom+3), 2)
      call ucopy(halfqx, q(lscom+5), 2*mwflt)

*---- Restore status flags.
  800 continue
      do 810 i = 1, maxdof
        doflag(i) = dosave(i)
  810 continue
      dokick = .true.

*---- The flags have changed, drop precomputed maps.
      call aapdrp

      end
+dk coukik
      subroutine coukik
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Activate/deactivate selected correctors.                           *
* USEKICK command:                                                     *
*   STATUS    (logical) Flag to activate or deactivate.                *
*   MODE      (name)    May be ALL, USED, UNUSED, or blank.            *
*   RANGE     (range)   Range to limit correctors to be changed.       *
*   CLASS     (name)    Class of elements to be affected in RANGE.     *
*   PATTERN   (string)  Regular expression to limit choice.            *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca datatype
+ca seqgroup
+ca message
+ca range
+ca refer
+ca status
      integer imode,istat,jbit,jpl,l,mclass,mmode,mpatt,mrange,mstat

      parameter         (mstat  = 1, mmode  = 2)
      parameter         (mrange = 3, mclass = 4, mpatt  = 5)

      external          cofkik
      character*(mcnam) mode, dict(4), class
      character*(mcstr) patt
      character*1       plane(2)
      integer           ncount(2)
      logical           done, status

      data dict         / 'ALL', 'USED', 'UNUSED', ' ' /
      data plane        / 'X', 'Y' /

*---- Check main beam line.
      call lnchck('COUKIK', error)
      if (error) go to 9999

*---- Get data for range.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Set up corrector and monitor table.
      call cotble(error)
      if (error) go to 9999

*---- Fetch option flags.
      status = .false.
      mode = ' '
      call utglog(lccmd, mstat, mstat, status)
      call utgnam(lccmd, mmode, mmode, mode)

*---- Decode MODE attribute.
      call utlook(mode, dict, 4, imode)
      if (imode .eq. 0) then
        call utleng(mode, l)
        call aawarn('COUKIK', 1,
     +    'Unknown value "MODE = ' // mode(1:l) // '" ignored.')
      endif

*---- Encode flags to arguments for COFKIK.
      istat = 0
      if (status) istat = 1

*---- Clear counts of correctors affected.
      ncount(1) = 0
      ncount(2) = 0

*---- "MODE=ALL" affects all correctors for this plane.
      if (imode .eq. 1) then
        do 40 jpl = 1, 2
          lccom  = lq(lcseq-mscor)
   30     if (lccom .ne. 0) then
            if (jbit(iq(lccom),jpl) .ne. 0) then
              call sbit(istat, iq(lccom), jpl+4)
              ncount(jpl) = ncount(jpl) + 1
            endif
            lccom = lq(lccom-1)
            go to 30
          endif
   40   continue

*---- "MODE=USED" option affects all correctors used for this plane.
      else if (imode .eq. 2) then
        do 60 jpl = 1, 2
          lccom = lq(lcseq-mscor)
   50     if (lccom .ne. 0) then
            if (jbit(iq(lccom),jpl)   .ne. 0  .and.
     +          jbit(iq(lccom),jpl+2) .ne. 0) then
              call sbit(istat, iq(lccom), jpl+4)
              ncount(jpl) = ncount(jpl) + 1
            endif
            lccom = lq(lccom-1)
            go to 50
          endif
   60   continue

*---- "MODE=UNUSED" affects all correctors not used for this plane.
      else if (imode .eq. 3) then
        do 80 jpl = 1, 2
          lccom = lq(lcseq-mscor)
   70     if (lccom .ne. 0) then
            if (jbit(iq(lccom), jpl)   .ne. 0  .and.
     +          jbit(iq(lccom), jpl+2) .eq. 0) then
              call sbit(istat, iq(lccom), jpl+4)
              ncount(jpl) = ncount(jpl) + 1
            endif
            lccom = lq(lccom-1)
            go to 70
          endif
   80   continue

*---- Use RANGE, CLASS and PATTERN.
      else
        class = ' '
        patt  = ' '
        call utgnam(lccmd, mclass, mclass, class)
        call utgstr(lccmd, mpatt,  mpatt,  patt)
        lcatt = lq(lccmd-mrange)
        call ensrng(lcatt, class, patt, cofkik, istat, ncount, done)
      endif

*---- Write message on number of correctors affected.
      do 120 jpl = 1, 2
        if (status) then
          write (msg(jpl), 910) ncount(jpl), plane(jpl)
        else
          write (msg(jpl), 920) ncount(jpl), plane(jpl)
        endif
  120 continue
      call aainfo('COUKIK', 2, msg)

  910 format(i8,' corrector(s) activated for plane ',a1,'.')
  920 format(i8,' corrector(s) deactivated for plane ',a1,'.')

 9999 end
+dk coumon
      subroutine coumon
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Activate/deactivate selected monitors.                             *
* USEMONITOR command:                                                  *
*   STATUS    (logical) Flag to activate or deactivate.                *
*   MODE      (name)    May be ALL or blank.                           *
*   RANGE     (range)   Range to limit monitors to be changed.         *
*   CLASS     (name)    Class of elements to be affected in RANGE.     *
*   PATTERN   (string)  Regular expression to limit choice.            *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca datatype
+ca seqgroup
+ca message
+ca range
+ca refer
+ca status
      integer imode,istat,jbit,jpl,l,mclass,mmode,mpatt,mrange,mstat

      parameter         (mstat  = 1, mmode  = 2)
      parameter         (mrange = 3, mclass = 4, mpatt  = 5)

      external          cofmon
      character*(mcnam) mode, dict(2), class
      character*(mcstr) patt
      character*1       plane(2)
      integer           ncount(2)
      logical           done, status

      data dict         / 'ALL', ' ' /
      data plane        / 'X', 'Y' /

*---- Check main beam line.
      call lnchck('COUMON', error)
      if (error) go to 9999

*---- Get data for range.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Set up corrector and monitor table.
      call cotble(error)
      if (error) go to 9999

*---- Fetch options.
      status = .false.
      mode = ' '
      call utglog(lccmd, mstat, mstat, status)
      call utgnam(lccmd, mmode, mmode, mode)

*---- Decode MODE attribute.
      call utlook(mode, dict, 2, imode)
      if (imode .eq. 0) then
        call utleng(mode, l)
        call aawarn('COUKIK', 1,
     +    'Unknown value "MODE = ' // mode(1:l) // '" ignored.')
      endif

*---- Encode flags to arguments for COFMON.
      istat = 0
      if (status) istat = 1

*---- Clear counts of monitors affected.
      ncount(1) = 0
      ncount(2) = 0

*---- "MODE=ALL" affects all monitors for this plane.
      if (imode .eq. 1) then
        do 40 jpl = 1, 2
          lccom  = lq(lcseq-msmon)
   30     if (lccom .ne. 0) then
            if (jbit(iq(lccom),jpl) .ne. 0) then
              call sbit(istat, iq(lccom), jpl+2)
              call sbit(istat, iq(lccom), jpl+4)
              ncount(jpl) = ncount(jpl) + 1
            endif
            lccom = lq(lccom-1)
            go to 30
          endif
   40   continue

*---- Use RANGE, CLASS and PATTERN.
      else
        class = ' '
        patt  = ' '
        call utgnam(lccmd, mclass, mclass, class)
        call utgstr(lccmd, mpatt,  mpatt,  patt)
        lcatt = lq(lccmd-mrange)
        call ensrng(lcatt, class, patt, cofmon, istat, ncount, done)
      endif

*---- Write message on number of  monitors affected.
      do 90 jpl = 1, 2
        if (status) then
          write (msg(jpl), 910) ncount(jpl), plane(jpl)
        else
          write (msg(jpl), 920) ncount(jpl), plane(jpl)
        endif
   90 continue
      call aainfo('COUMON', 2, msg)

  910 format(i8,' monitor(s) activated for plane ',a,'.')
  920 format(i8,' monitor(s) deactivated for plane ',a,'.')

 9999 end
+dk cowdis
      subroutine cowdis
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find closed orbit and write a TFS table of dispersion readings.    *
* PUTDISP command:                                                     *
*   FILENAME  (string)  TFS file name to be written.                   *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca seqgroup
+ca message
+ca codata
+ca colink
+ca mchpar
+ca option
+ca refer
+ca status
      integer idir,iunit,jbit,jrow,mcol,ncol,nrow
      double precision zero

      parameter         (mcol = 4, zero = 0.0d0)
      character*(mcfil) filnam
      character*(mcnam) monnam, tabnam, cnam(mcol)
      integer           icfrm(mcol)

      data cnam         / 'PUNAME', 'DX', 'DY', 'STATUS' /
      data tabnam       / '*DISP TABLE*' /

*---- Check main beam line.
      call lnchck('PUTDISP', error)
      if (error) go to 9999

*---- Set up corrector and monitor table.
      call cotble(error)
      if (error) go to 9999

*---- Find closed orbit and monitor readings.
      call tmturn(lcseq, zero, error)
      if (error) go to 9999

*---- Fill in monitor readings and dispersion.
      call cofill
      if (error) go to 9999

*---- Retrieve file name.
      filnam = 'dispersion'
      call utgstr(lccmd, 1, 1, filnam)
      if (filnam .eq. ' ') go to 9999

*---- Build internal table.
      nrow  = 0
      lccom = lq(lcseq-msmon)
   10 if (lccom .ne. 0) then
        nrow  = nrow + 1
        lccom = lq(lccom-1)
        go to 10
      endif
      lccom = lq(lcseq-msmon)
      ncol = mcol
      icfrm(1) = 5
      icfrm(2) = 3
      if (double) icfrm(2) = mreal
      icfrm(3) = icfrm(2)
      icfrm(4) = 1
      call tbcrea(tabnam, 1, nrow, ncol, cnam, icfrm, 1, lcotab)
      call tbpdsc(lcotab, 'TYPE', 5, 0, zero, 'DISPERSION')
      do 90 jrow = 1, nrow
        call tbset(lcotab, jrow, 3, lcobuf)
        call ucopy(q(lccom+1), xcm, iq(lccom-1))
        idir = iq(lq(lcseq-msdir)+iq(lccom-5))
        call diname(ldbnk, idir, monnam)
        call uctoh(monnam, iq(lcobuf+1), mcwrd, mcnam)
        if (jbit(iq(lccom),5) .eq. 0) dxcm = 0.0
        if (jbit(iq(lccom),6) .eq. 0) dycm = 0.0
        if (double) then
          call ucopy(dxcm, q(lcobuf+mwnam+1), 2*mwflt)
          iq(lcobuf+mwnam+2*mwflt+1) = 0
        else
          q(lcobuf+mwnam+1) = dxcm
          q(lcobuf+mwnam+2) = dycm
          iq(lcobuf+mwnam+3) = 0
        endif
        lccom = lq(lccom-1)
   90 continue
      call tbclos(lcotab)

*---- Write table in TFS format.
      call flopen(filnam, 'SWFD', 0, 0, iunit, error)
      if (.not. error) then
        call tbwtfs(tabnam, iunit)
        call flname(iunit, filnam)
        call flclos(iunit, error)
        if (.not. error) then
          msg(1) = 'Dispersion readings written on file: ' // filnam
          call aainfo('COWDIS', 1, msg)
        endif
      endif
      call tbopen(tabnam, 0, lcotab)
      call tbdrop(lcotab)

 9999 end
+dk cowkik
      subroutine cowkik
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Write most recent corrector settings to a TFS file.                *
* PUTKICK command:                                                     *
*   FILENAME  (string)  TFS file name to be written.                   *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca expgroup
+ca seqflag
+ca seqgroup
+ca vargroup
+ca message
+ca codata
+ca colink
+ca option
+ca refer
+ca status
      integer idir,iflag,ileng,iocc,ipos,iunit,jbit,jbyt,jpl,jrow,ncol,
     +nrow
      double precision zero

      character*(mcfil) filnam
      character*(mcnam) cornam, kiknam, tabnam, cnam(3)
      character*(mcnam) tmpnam
      character*(mcnam) plane, pnam(3)
      integer           icfrm(3)
      logical direct

      data pnam         / 'X', 'Y', 'BOTH' /
      data tabnam       / '*SETTINGS TABLE*' /

*---- Check main beam line.
      call lnchck('PUTKICK', error)
      if (error) go to 9999

*---- Retrieve file name.
      filnam = 'setting'
      call utgstr(lccmd, 1, 1, filnam)

*---- Retrieve desired plane.
      plane = 'BOTH'
      call utgnam(lccmd, 2, 2, plane)
      call utleng(plane, ileng)
      call utlook(plane(1:ileng), pnam, 3, jpl)
      if (jpl .eq. 0) then
        call aawarn('COWKIK', 1, 'Unknown plane code "' //
     +    plane(1:ileng) // '", "BOTH" assumed.')
        jpl = 3
      endif

*---- Retrieve "direct name" flag
      direct = .false.
      call utglog(lccmd, 3, 3, direct)

*---- Check presence of corrector and monitor table.
      if (lq(lcseq-mscom) .eq. 0) then
        call aawarn('COWKIK', 1, 'Kicker settings not yet available.')

*---- Build internal table.
      else
        nrow  = 0
        lccom = lq(lcseq-mscor)
   10   if (lccom .ne. 0) then
          nrow  = nrow + 1
          lccom = lq(lccom-1)
          go to 10
        endif

        cnam(1) = 'STR_NAME'
        icfrm(1) = 5
        icfrm(2) = 3
        if (double) icfrm(2) = mreal
        if (jpl .eq. 3) then
          cnam(2) = 'DK_N_H'
          cnam(3) = 'DK_N_V'
          ncol = 3
          icfrm(3) = icfrm(2)
        else
          cnam(2) = 'DK_N'
          ncol = 2
        endif
        call tbcrea(tabnam, 1, nrow, ncol, cnam, icfrm, 1, lcotab)
        if (jpl .eq. 1) then
          call tbpdsc(lcotab, 'TYPE', 5, 0, zero, 'H_SETTING')
        else if (jpl .eq. 2) then
          call tbpdsc(lcotab, 'TYPE', 5, 0, zero, 'V_SETTING')
        else
          call tbpdsc(lcotab, 'TYPE', 5, 0, zero, 'SETTING')
        endif

*---- Loop on all correctors.
        lccom = lq(lcseq-mscor)
        do 90 jrow = 1, nrow
          call ucopy(q(lccom+1), xcm, iq(lccom-1))
          if (jpl .eq. 2  .or.  jbit(iq(lccom),3) .eq. 0) xcm = 0.0
          if (jpl .eq. 1  .or.  jbit(iq(lccom),4) .eq. 0) ycm = 0.0

*---- If non-zero corrector strength, build buffer.
          if (xcm .ne. 0.0  .or.  ycm .ne. 0.0) then
            ipos  = iq(lccom-5)
            idir  = iq(lq(lcseq-msdir)+ipos)
            iflag = iq(lq(lcseq-msflg)+ipos)
            iocc  = jbyt(iflag,mocc1,mocc2)
            call diname(ldbnk, idir, cornam)
            lcelm = lq(ldbnk(3)-idir)
            lcexp = lq(lcelm-3)
            if (lcexp .eq. 0) then
              call utocnm(cornam, iocc, kiknam)
            else if (iq(lcexp-2) .ne. 1  .or.
     +        iq(lcexp+mxop) .ne. -2  .or.  lq(lcexp-1) .eq. 0) then
              call utocnm(cornam, iocc, kiknam)
            else
              call uhtoc(q(lq(lcexp-1)+mvbank), mcwrd, kiknam, mcnam)
            endif

*---- Store to table.
            call tbset(lcotab, jrow, 3, lcobuf)
            if (direct) then
              tmpnam = cornam
            else
              tmpnam = kiknam
            endif
            call uctoh(tmpnam, iq(lcobuf+1), mcwrd, mcnam)
            if (jpl .eq. 1) then
              if (double) then
                call ucopy(xcm, q(lcobuf+mwnam+1), mwflt)
              else
                q(lcobuf+mwnam+1) = xcm
              endif
            else if (jpl .eq. 2) then
              if (double) then
                call ucopy(ycm, q(lcobuf+mwnam+1), mwflt)
              else
                q(lcobuf+mwnam+1) = ycm
              endif
            else
              if (double) then
                call ucopy(xcm, q(lcobuf+mwnam+1), 2*mwflt)
              else
                q(lcobuf+mwnam+1) = xcm
                q(lcobuf+mwnam+2) = ycm
              endif
            endif
          endif
          lccom = lq(lccom-1)
   90   continue
        call tbclos(lcotab)

*---- Write table in TFS format.
        call flopen(filnam, 'SWFD', 0, 0, iunit, error)
        if (.not. error) then
          call tbwtfs(tabnam, iunit)
          call flname(iunit, filnam)
          call flclos(iunit, error)
          if (.not. error) then
            msg(1) = 'Kicker settings written on file: ' // filnam
            call aainfo('COWKIK', 1, msg)
          endif
        endif

*---- Drop table.
        call tbopen(tabnam, 0, lcotab)
        call tbdrop(lcotab)
      endif

 9999 end
+dk cowmon
      subroutine cowmon
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find closed orbit and write a TFS table of monitor readings.       *
* PUTORBIT command:                                                    *
*   FILENAME  (string)  TFS file name to be written.                   *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca seqgroup
+ca message
+ca codata
+ca colink
+ca mchpar
+ca option
+ca refer
+ca status
      integer idir,iunit,jbit,jrow,mcol,ncol,nrow
      double precision zero

      parameter         (mcol = 4, zero = 0.0d0)
      character*(mcfil) filnam
      character*(mcnam) monnam, tabnam, cnam(mcol)
      integer           icfrm(mcol)

      data cnam         / 'PUNAME', 'X', 'Y', 'STATUS' /
      data tabnam       / '*ORBIT TABLE*' /

*---- Check main beam line.
      call lnchck('PUTORBIT', error)
      if (error) go to 9999

*---- Set up corrector and monitor table.
      call cotble(error)
      if (error) go to 9999

*---- Find closed orbit and monitor readings.
      call tmturn(lcseq, zero, error)
      if (error) go to 9999

*---- Fill in monitor readings and dispersion.
      call cofill
      if (error) go to 9999

*---- Retrieve file name.
      filnam = 'orbit'
      call utgstr(lccmd, 1, 1, filnam)
      if (filnam .eq. ' ') go to 9999

*---- Build internal table.
      nrow  = 0
      lccom = lq(lcseq-msmon)
   10 if (lccom .ne. 0) then
        nrow  = nrow + 1
        lccom = lq(lccom-1)
        go to 10
      endif
      lccom = lq(lcseq-msmon)
      ncol = mcol
      icfrm(1) = 5
      icfrm(2) = 3
      if (double) icfrm(2) = mreal
      icfrm(3) = icfrm(2)
      icfrm(4) = 1
      call tbcrea(tabnam, 1, nrow, ncol, cnam, icfrm, 1, lcotab)
      call tbpdsc(lcotab, 'TYPE', 5, 0, zero, 'ORBIT')
      do 90 jrow = 1, nrow
        call tbset(lcotab, jrow, 3, lcobuf)
        call ucopy(q(lccom+1), xcm, iq(lccom-1))
        xcm = xcm * 1000.0
        ycm = ycm * 1000.0
        idir = iq(lq(lcseq-msdir)+iq(lccom-5))
        call diname(ldbnk, idir, monnam)
        call uctoh(monnam, iq(lcobuf+1), mcwrd, mcnam)
        if (jbit(iq(lccom),3) .eq. 0) xcm = 0.0
        if (jbit(iq(lccom),4) .eq. 0) ycm = 0.0
        if (double) then
          call ucopy(xcm, q(lcobuf+mwnam+1), 2*mwflt)
          iq(lcobuf+mwnam+2*mwflt+1) = 0
        else
          q(lcobuf+mwnam+1) = xcm
          q(lcobuf+mwnam+2) = ycm
          iq(lcobuf+mwnam+3) = 0
        endif
        lccom = lq(lccom-1)
   90 continue
      call tbclos(lcotab)

*---- Write table in TFS format.
      call flopen(filnam, 'SWFD', 0, 0, iunit, error)
      if (.not. error) then
        call tbwtfs(tabnam, iunit)
        call flname(iunit, filnam)
        call flclos(iunit, error)
        if (.not. error) then
          msg(1) = 'Monitor readings written on file: ' // filnam
          call aainfo('COWMON', 1, msg)
        endif
      endif
      call tbopen(tabnam, 0, lcotab)
      call tbdrop(lcotab)

 9999 end
+dk cozzzz
+dk dcaaaa
+dk dcattr
      subroutine dcattr(itype, lbank, ifrst, ilast, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode an attribute and store it in a data bank.                   *
*   Optionally, the datum is copied according to NREPT.                *
* Input:                                                               *
*   ITYPE    (integer)  Data type code.                                *
*   LBANK(1) (pointer)  Data bank pointer.                             *
*   IFRST    (integer)  First attribute number.                        *
*   ILAST    (integer)  Highest attribute number allowed.              *
* Output:                                                              *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer idata,ieval,iexpr,ifrst,ilast,ilink,iseen,itype,ival,
     +jdata,jlink,jrept,nint,nrept
      double precision rval,rval1,rval2,rval3
      integer           lbank(*)
      logical           eflag
+ca memdum
+ca bankhead
+ca cmdgroup
+ca dclink
+ca stbuff
+ca datatype

      logical           lval

*---- Decode repeat count.
      ldcbnk = lbank(1)
      eflag = .false.
      call dcrept(nrept)
      if (ifrst + nrept - 1 .gt. ilast) then
        call rdwarn('DCATTR', 1,
     +  'Repeat count too large --- reset to dimension limit.')
        nrept = ilast - ifrst + 1
      endif
      ilink = ifrst
      idata = mbat + mcsiz * (ilink - 1)

*---- Branch by data type to read further.
*            NAM  INT  FLT  DEF  LOG  STR  LIN  RNG  CST  VAR
      go to (100, 200, 300, 300, 400, 500, 600, 700, 800, 900), itype
      go to 9999

*---- 1.  Name.
  100 continue
        call dcname(ilink, idata, eflag)
      go to 1000

*---- 2.  Integer.
  200 continue
        call rdint(ival, eflag)
        iseen = 10 * mtint
        if (.not. eflag) iseen = 10 * mtint + 1
        iq(ldcbnk+idata+mctyp) = iseen
        iq(ldcbnk+idata+mcval) = ival
      go to 1000

*---- 3, 4.  Real, deferred.
  300 continue
        ieval = itype - 1
        call exread(ieval, rval1, iexpr)
        if (token(jtok) .eq. ':') then
          if (iexpr .ne. 1) go to 350
          if (itype .eq. mtdef) then
            call rdfail('DCATTR', 1,
     +      '"start:end:step" not allowed for deferred data.')
          else
            jtok = jtok + 1
            call exread(2, rval2, iexpr)
            if (iexpr .ne. 1) go to 350
            call rdtest(':', eflag)
            if (eflag) go to 9999
            jtok = jtok + 1
            call exread(2, rval3, iexpr)
            if (iexpr .ne. 1) go to 350
            if (rval3 .eq. 0.0) then
              call rdfail('DCATTR', 1,
     +        '"start:end:step": "step" must not be zero.')
            else
              nrept = nint((rval2 - rval1) / rval3)
              if (ifrst + nrept .gt. ilast) then
                call rdfail('DCATTR', 1,
     +          '"start:end:step" causes array overflow.')
              else
                do 310 jrept = 0, nrept
                  rval = rval1 + jrept * rval3
                  call exmake(ldcbnk, ilink, idata + mcval, rval, 1)
                  iq(ldcbnk+idata+mctyp) = 10 * mtflt + iexpr
                  idata = idata + mcsiz
                  ilink = ilink + 1
  310           continue
              endif
            endif
          endif
        else
          do 320 jrept = 1, nrept
            call exmake(ldcbnk, ilink, idata + mcval, rval1, iexpr)
            iq(ldcbnk+idata+mctyp) = 10 * mtflt + iexpr
            idata = idata + mcsiz
            ilink = ilink + 1
  320     continue
        endif
        ifrst = ilink
      go to 9999

*---- Invalid use of colon.
  350 continue
      if (iexpr .ne. 0) then
        call rdfail('DCATTR', 1,
     +  '"start:end:step" must not contain variable expression.')
      endif
      go to 9999

*---- 5.  Logical.
  400 continue
        call rdlogc(lval, eflag)
        iseen = 10 * mtlog
        if (.not. eflag) iseen = 10 * mtlog + 1
        iq(ldcbnk+idata+mctyp) = iseen
        ival = 0
        if (lval) ival = 1
        iq(ldcbnk+idata+mcval) = ival
      go to 1000

*---- 6. String.
  500 continue
        call dcstrg(ilink, idata, eflag)
      go to 1000

*---- 7. Line, or other relation.
  600 continue
        call dcbeam(ilink, idata, eflag)
      go to 1000

*---- 8. Place, or range limits.
  700 continue
        call dcrang(ilink, idata, eflag)
      go to 1000

*---- 9. Constraint.
  800 continue
        call dccons(ilink, idata, eflag)
      go to 1000

*---- 10. Variable.
  900 continue
        call dcvref(ilink, idata, eflag)

*---- Store repeated values.
 1000 continue
      jlink = ilink + 1
      jdata = idata + mcsiz
      do 1010 jrept = 2, nrept
        call ucopy(q(ldcbnk+idata+1), q(ldcbnk+jdata+1), mcsiz)
        ldcatt = lq(ldcbnk-ilink)
        if (ldcatt .ne. 0) then
          call mzcopy(2, ldcatt, 2, ldcbnk, -jlink, 'Z')
        endif
        jlink = jlink + 1
        jdata = jdata + mcsiz
 1010 continue
      ifrst = jlink

 9999 end
+dk dcbeam
      subroutine dcbeam(ilink, idata, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode reference to beam line.                                     *
* Input:                                                               *
*   NREPT    (integer)  Repeat count.                                  *
*   LDCBNK   /DCLINK/   Data bank pointer.                             *
*   ILINK    (integer)  Bias for pointer to sub-bank.                  *
*   IDATA    (integer)  Bias for data block.                           *
* Output:                                                              *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer idata,idir,ikey,ilink,leng,nseq
      logical           eflag
+ca memdum
+ca bankhead
+ca cmdgroup
+ca dclink
+ca refer
+ca stbuff
+ca datatype

      character*(mcnam) label
      data nseq         / 0 /

*---- Drop previous reference, if any.
      eflag = .false.
      ldcatt = lq(ldcbnk-ilink)
      if (ldcatt .ne. 0) call aadrop(ldcatt)
      iq(ldcbnk+idata+mctyp) = 10 * mtlin

*---- List in parentheses.
      if (token(jtok) .eq. '(') then

*---- Lift dummy line bank and link it to LINE keyword.
        call difind(ldkey, 'LINE', ikey, ldckey)
        nseq = nseq + 1
        write (label, '(''*LIN.'',I2.2,''*'')') nseq
        call lnmake(ldcatt, ldckey)

*---- Decode beam line list.
        call dclist(ldcatt, eflag)

*---- If error detected, drop dummy line bank.
        if (eflag) then
          call aadrop(ldcatt)

*---- If all OK, link dummy line bank to data bank.
        else
          call direfe(ldbnk, label, idir)
          lq(ldbnk(3)-idir) = ldcatt
          iq(ldcatt+mbnam) = idir
          iq(ldcbnk+idata+mctyp) = 10 * mtlin + 3
          iq(ldcbnk+idata+mcval) = idir
        endif

*---- Read beam line name.
      else
        call rdword(label, leng)
        if (leng .eq. 0) then
          call rdfail('DCBEAM', 1, 'Beam line or list expected.')
          eflag = .true.

*---- Directory index for name reference.
        else
          call direfe(ldbnk, label, idir)
          iq(ldcbnk+idata+mcval) = idir

*---- Actual argument list.
          if (token(jtok) .eq. '(') then
            call difind(ldkey, 'LINE', ikey, ldckey)
            call lnmake(ldcatt, ldckey)
            call dclist(ldcatt, eflag)

*---- If all OK, link actual argument list to data bank.
            if (.not. eflag) then
              call zshunt(0, ldcatt, ldcbnk, -ilink, 0)
              iq(ldcbnk+idata+mctyp) = 10 * mtlin + 2
            endif

*---- No actual argument list.
          else
            iq(ldcbnk+idata+mctyp) = 10 * mtlin + 1
          endif
        endif
      endif

      end
+dk dccons
      subroutine dccons(ilink, idata, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode constraint data type.                                       *
* Input:                                                               *
*   LDCBNK   /DCLINK/   Data bank pointer.                             *
*   ILINK    (integer)  Bias for pointer to sub-bank.                  *
*   IDATA    (integer)  Bias for data block.                           *
* Output:                                                              *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,idata,iexpr,ilink,index,ioper,iput,itype,j,nd
      double precision rval
      logical           eflag
+ca memdum
+ca cmdgroup
+ca dclink
+ca stbuff
+ca zunit
+ca datatype

*---- Lift constraint bank, if not done already.
      eflag = .false.
      ldcatt = lq(ldcbnk-ilink)
      if (ldcatt .eq. 0) then
        nd = 2 * mcsiz + 2
        call mzbook(2, ldcatt, ldcbnk, -ilink, 'CONS', 2, 2, nd, 7, 0)
        iq(ldcatt+1) = 16 * 1 + 2
        ibias = 2
        do 10 j = 1, 2
          iq(ldcatt+ibias+mcf1) = 16 * 1 + 2
          iq(ldcatt+ibias+mcf2) = 16 * mwnam + mreal
          ibias = ibias + mcsiz
   10   continue
      endif
      itype = iq(ldcatt+2)

*---- "=", "<", or ">" valid.
      ioper = index('=><', token(jtok-1))

*---- "=", Equality constraint.
  100 continue
        if (ioper .eq. 1) then
          if (itype .ne. 0) then
            call rdfail('DCCONS', 1, 'Inconsistent constraint.')
            itype = 0
          else
            itype = 4
            iput = 1
          endif

*---- ">", Minimum constraint.
        else if (ioper .eq. 2) then
          if (itype .eq. 1  .or.  itype .ge. 3) then
            call rdfail('DCCONS', 1, 'Inconsistent constraint.')
            itype = 0
          else
            itype = itype + 1
            iput = 1
          endif

*---- "<", Maximum constraint.
        else if (ioper .eq. 3) then
          if (itype .ge. 2) then
            call rdfail('DCCONS', 1, 'Inconsistent constraint.')
            itype = 0
          else
            itype = itype + 2
            iput = 2
          endif

*---- Invalid operator.
        else
          call rdfail('DCCONS', 1,
     +    'Constraint relational "=", "<", or ">" expected.')
          itype = 0
        endif

*---- Decode constraint value.
        call exread(2, rval, iexpr)
        if (iexpr .eq. 0) then
          itype = 0
        else
          ibias = 2 + (iput - 1) * mcsiz
          call exmake(ldcatt, iput, ibias + mcval, rval, iexpr)
          iq(ldcatt+ibias+mctyp) = 10 * mtflt + iexpr
        endif
        ioper = index('=><', token(jtok))
      if (ioper .gt. 0) then
        jtok = jtok + 1
        go to 100
      endif

*---- Store constraint type, or drop constraint in case of error.
  200 continue
      if (itype .ne. 0) then
        iq(ldcatt+2) = itype
        iq(ldcbnk+idata+mctyp) = 10*mtcon + itype
      else
        call aadrop(ldcatt)
        iq(ldcbnk+idata+mctyp) = 10*mtcon
      endif

      end
+dk dcform
      subroutine dcform(lline, if1, if2, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode formal argument list.                                       *
*   The formals bank is linked to link 1 of the current command.       *
* Input:                                                               *
*   LLINE(1) (pointer)  Beam line list bank.                           *
*   IF1, IF2 (integer)  First and last character of formal list.       *
* Output:                                                              *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer if1,if2,ileng,jform,jmark,jt,leng,nd,nform
      integer           lline(1)
      logical           eflag
+ca memdum
+ca message
+ca dclink
+ca stbuff

      character*(mcnam) frmnam, oldnam
      logical           sflag

*---- Any argument list?
      ldclin = lline(1)
      eflag = .false.
      if (if1 .ne. 0  .and.  token(if1) .eq. '(') then

*---- Count formals names.
        nform = 1
        do 10 jt = if1, if2
          if (token(jt) .eq. ',') nform = nform + 1
   10   continue

*---- Lift bank for formals names.
        nd = nform * mwnam
        call mzbook(2, ldcfrm, ldclin, -1, 'FORM', 0, 0, nd, 5, 0)
        nform = 0
        jmark = jtok
        jtok = if1

*---- Argument name.
  100   continue
          jtok = jtok + 1
          sflag = .false.
          call rdword(frmnam, leng)
          if (leng .eq. 0) then
            call rdfail('DCFORM', 1, 'Formal argument name expected.')
            sflag = .true.

*---- Test for correct delimiter.
          else if (token(jtok).ne.',' .and. token(jtok).ne.')') then
            call rdfail('DCFORM', 1, '"," or ")" expected.')
            sflag = .true.

*---- Reject duplicate arguments.
          else
            do 110 jform = 1, nform, mwnam
              call uhtoc(q(ldcfrm+jform), mcwrd, oldnam, mcnam)
              if (oldnam .eq. frmnam) then
                call utleng(frmnam, ileng)
                msg(1) = 'Duplicate formal argument "'// frmnam(1:ileng)
     +          // '" encountered.'
                call rdfail('DCFORM', 1, msg)
                sflag = .true.
                go to 120
              endif
  110       continue

*---- Add formal name to list.
            call uctoh(frmnam, iq(ldcfrm+nform+1), mcwrd, mcnam)
            nform = nform + mwnam
  120       continue
          endif

*---- Error recovery.
          if (sflag) then
            call rdfind(',);')
            eflag = .true.
          endif
        if (token(jtok) .eq. ',') go to 100

*---- Restore place in input statement.
        jtok = jmark
      endif

      end
+dk dcindx
      subroutine dcindx(index1, index2, index3, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode subscript list.                                             *
* Output:                                                              *
*   INDEX1, INDEX2, INDEX3 (integer)   Decoded subscripts (default=1). *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer index1,index2,index3
      logical           eflag
+ca stbuff

      eflag = .false.
      index1 = 1
      index2 = 1
      index3 = 1
      if (token(jtok) .eq. '(') then
        jtok = jtok + 1
        call rdint(index1, eflag)
        if (eflag) go to 9999
        if (token(jtok) .eq. ',') then
          jtok = jtok + 1
          call rdint(index2, eflag)
          if (eflag) go to 9999
          if (token(jtok) .eq. ',') then
            jtok = jtok + 1
            call rdint(index3, eflag)
            if (eflag) go to 9999
          endif
        endif
        if (token(jtok) .eq. ',') then
          call rdfail('DCINDX', 1, 'At most 3 dimensions allowed.')
          eflag = .true.
        else if (token(jtok) .ne. ')') then
          call rdfail('DCINDX', 1, '"," or ")" expected.')
          eflag = .true.
        else
          jtok = jtok + 1
        endif
      endif

 9999 end
+dk dcinit
      subroutine dcinit
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initialize decoder.                                                *
*----------------------------------------------------------------------*
+ca aparam
+ca dclink
      integer idcflg

      data idcflg       / 0 /

      if (idcflg .eq. 0) then
        call mzlink(0, '/DCLINK/', ldcatt, ldcatt, ldclin)
        idcflg = 1
      endif

      end
+dk dclist
      subroutine dclist(lline, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode a beam line list.                                           *
*   The pointer to the current formals list must be set before calling *
*   this routine (possibly zero).                                      *
* Input:                                                               *
*   LLINE(1) (pointer)  Beam line list bank.                           *
*   IDATA    (integer)  Bias for data block.                           *
* Output:                                                              *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer icall,icell,ichar,icode,idirep,iform,ifree,ihead,iref,
     +irep,jform,leng,ml,nform
      integer           lline(*)
      logical           eflag
+ca memdum
+ca bankhead
+ca lingroup
+ca message
+ca chcode
+ca dclink
+ca refer
+ca stbuff

      character*(mcnam) elmnam, frmnam
      logical           sflag
      parameter         (ml = 100)

*---- Opening parenthesis.
      ldclin = lline(1)
      ldcfrm = lq(ldclin-1)
      eflag = .false.
      if (token(jtok) .ne. '(') then
        msg(1) = 'A beam line member should be an element,'
        msg(2) = 'a beam line name or a list in parentheses.'
        call rdfail('DCLIST', 2, msg)
        eflag = .true.
        go to 9999
      endif

*---- Reserve space for header information.
      ifree = iq(ldclin+mlhd)

*---- Prepare dummy lists for formals (look like sublists).
      if (lq(ldclin-1) .ne. 0) then
        nform = iq(lq(ldclin-1)-1)
        do 50 jform = 1, nform, mwnam
          if (ifree + 2*mlsiz .gt. iq(ldclin-1)) then
            call mzpush(0, ldclin, 0, ml*mlsiz, 'I')
          endif
          icell = ifree + mlsiz
          iq(ldclin+ifree+mltyp) = 2
          iq(ldclin+ifree+mlnxt) = icell
          iq(ldclin+ifree+mlprv) = icell
          iq(ldclin+icell+mlnxt) = ifree
          iq(ldclin+icell+mlprv) = ifree
          ifree = ifree + 2*mlsiz
   50   continue
        iq(ldclin+mlf1) = iq(ldclin+mlhd)
        iq(ldclin+mlf2) = ifree - 1
        iq(ldclin+mlhd) = ifree
      endif

*---- Initialize.
      icell = 0
      icall = 1
      icode = 1

*---- Procedure "DECODE LIST".
  100 continue

*---- Make header cell for current list.
        if (ifree + mlsiz .gt. iq(ldclin-1)) then
          call mzpush(0, ldclin, 0, ml*mlsiz, 'I')
        endif
        iq(ldclin+ifree+mltyp) = icode
        iq(ldclin+ifree+mlnxt) = ifree
        iq(ldclin+ifree+mlprv) = ifree
        ihead = ifree
        ifree = ifree + mlsiz

*---- Stack information to resume an outer list, if any.
        iq(ldclin+ihead+mlref) = icell
        iq(ldclin+ihead+mlact) = icall

*---- Set current cell.
        icell = ihead

*---- Append member cell.
  110   continue
        jtok = jtok + 1
        if (ifree + mlsiz .gt. iq(ldclin-1)) then
          call mzpush(0, ldclin, 0, ml*mlsiz, 'I')
        endif
        ihead = iq(ldclin+icell+mlnxt)
        iq(ldclin+ifree+mlnxt) = ihead
        iq(ldclin+ihead+mlprv) = ifree
        iq(ldclin+icell+mlnxt) = ifree
        iq(ldclin+ifree+mlprv) = icell
        icell = ifree
        ifree = ifree + mlsiz

*---- Reflection?
        if (token(jtok) .eq. '-') then
          jtok = jtok + 1
          idirep = -1
        else
          idirep = 1
        endif

*---- Repetition?
        if (ichtyp(ichar(token(jtok))) .le. 9) then
          call rdint(irep, sflag)
          if (sflag) go to 210
          call rdtest('*', sflag)
          if (sflag) go to 210
          jtok = jtok + 1
          idirep = idirep * irep
        endif
        iq(ldclin+icell+mlrep) = idirep

*---- Sublist?
        if (token(jtok) .ne. '(') go to 150
          icall = 2
          icode = 2
          go to 100
  120   continue
        iq(ldclin+icell+mlref) = ihead
        iq(ldclin+icell+mltyp) = 4
        go to 200

*---- Decode identifier.
  150   continue
        call rdword(elmnam, leng)
        if (leng .eq. 0) then
          msg(1) = 'A beam line member should be an element,'
          msg(2) = 'a beam line name or a list in parentheses.'
          call rdfail('DCLIST', 2, msg)
          go to 210
        endif

*---- Formal argument?
        if (ldcfrm .ne. 0) then
          nform = iq(ldcfrm-1)
          iform = iq(ldclin+mlf1)
          do 160 jform = 1, nform, mwnam
            call uhtoc(q(ldcfrm+jform), mcwrd, frmnam, mcnam)
            if (frmnam .eq. elmnam) then
              iq(ldclin+icell+mltyp) = 4
              iq(ldclin+icell+mlref) = iform
              go to 200
            endif
            iform = iform + 2*mlsiz
  160     continue
        endif

*---- Ordinary name.
        call direfe(ldbnk, elmnam, iref)
        iq(ldclin+icell+mltyp) = 6
        iq(ldclin+icell+mlref) = iref

*---- Actual argument list?
        if (token(jtok) .ne. '(') go to 190
          icall = 3
          icode = 1
          go to 100
  170     continue
          iq(ldclin+icell+mltyp) = 7
          iq(ldclin+icell+mlact) = ihead
  190   continue

*---- Comma or right parenthesis?
  200   continue
        if (token(jtok) .eq. ',') go to 110
        if (token(jtok) .eq. ')') go to 250
        call rdtest(',)', sflag)

*---- Error recovery.
  210   continue
        call rdfind('(),;')
        eflag = eflag .or. sflag

*---- Another member?
  250 continue
      if (token(jtok) .eq. ',') go to 110

*---- End of list?
      if (token(jtok) .eq. ')') then
        jtok = jtok + 1

*---- Move to header of current list.
        ihead = iq(ldclin+icell+mlnxt)

*---- Unstack information for outer list.
        icell = iq(ldclin+ihead+mlref)
        icall = iq(ldclin+ihead+mlact)
        iq(ldclin+ihead+mlref) = 0
        iq(ldclin+ihead+mlact) = 0
        go to (300, 120, 170), icall
      endif

*---- End of beam line list. Release unused space and link area.
  300 continue
      call mzpush(0, ldclin, 0, ifree - iq(ldclin-1), 'I')
      lline(1) = ldclin

 9999 end
+dk dcname
      subroutine dcname(ilink, idata, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode name data type.                                             *
* Input:                                                               *
*   LDCBNK   /DCLINK/   Data bank pointer.                             *
*   ILINK    (integer)  Bias for pointer to sub-bank.                  *
*   IDATA    (integer)  Bias for data block.                           *
* Output:                                                              *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer idata,ilink,iseen,leng
      logical           eflag
+ca memdum
+ca cmdgroup
+ca dclink
+ca stbuff
+ca datatype

      character*(mcnam) name

      call rdword(name, leng)
      if (leng .gt. 0) then
        eflag = .false.
        iseen = 10 * mtnam + 1
      else
        call rdfail('DCNAME', 1, 'Name expected.')
        eflag = .true.
        iseen = 10 * mtnam
        name = ' '
      endif

*---- Store decoded name.
      iq(ldcbnk+idata+mctyp) = iseen
      call uctoh(name, iq(ldcbnk+idata+mcval), mcwrd, mcnam)

      end
+dk dcrang
      subroutine dcrang(ilink, idata, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode observation point(s) or range.                              *
* Input:                                                               *
*   LDCBNK   /DCLINK/   Data bank pointer.                             *
*   ILINK    (integer)  Bias for pointer to sub-bank.                  *
*   IDATA    (integer)  Bias for data block.                           *
* Output:                                                              *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ichar,icode1,icode2,idata,idir1,idir2,ilink,index1,index2,
     +leng1,leng2
      logical           eflag
+ca memdum
+ca cmdgroup
+ca message
+ca chcode
+ca dclink
+ca stbuff
+ca refer
+ca datatype

      character*(mcnam) elnam1, elnam2
      logical           dvflag, hash,   select, sflag

*---- Drop any previous 'range' bank.
      eflag = .false.
      ldcatt = lq(ldcbnk-ilink)
      if (ldcatt .ne. 0) call aadrop(ldcatt)

*---- Initialize.
      dvflag = .false.
      hash = .false.
      select = .false.
      index1 = 0
      index2 = 0
      icode2 = 0
      idir1 = 0
      idir2 = 0

*==== Start of range.
*---- Hash sign "#", followed by "S", "E", "F", "L", or integer.
      if (token(jtok) .eq. '#') then
        jtok = jtok + 1
        hash = .true.
        if (token(jtok) .eq. 'S') then
          jtok = jtok + 1
          icode1 = 1
        else if (token(jtok) .eq. 'E') then
          jtok = jtok + 1
          icode1 = 2
        else if (token(jtok) .eq. 'F') then
          jtok = jtok + 1
          icode1 = 3
        else if (token(jtok) .eq. 'L') then
          jtok = jtok + 1
          icode1 = 4
        else
          call rdint(index1, sflag)
          if (sflag) go to 890
          icode1 = 5
        endif

*---- Integer alone.
      else if (ichtyp(ichar(token(jtok))) .le. 9) then
        call rdint(index1, sflag)
        if (sflag) go to 890
        icode1 = 5

*---- Name, optionally followed by square bracket.
      else
        call rdword(elnam1, leng1)
        if (leng1 .eq. 0) go to 810
        icode1 = 6
        call direfe(ldbnk, elnam1(1:leng1), idir1)

*---- May be "select" type range.
        select = .true.
        if (token(jtok) .eq. '[') then
          jtok = jtok + 1
          call rdint(index1, sflag)
          if (sflag) go to 890
          index2 = index1
          if (token(jtok) .eq. '/') then
            jtok = jtok + 1
            call rdint(index2, sflag)
            if (sflag) go to 890
            if (index1 .gt. index2) go to 820
            dvflag = .true.
          endif
          if (token(jtok) .ne. ']') go to 830
          jtok = jtok + 1
        endif
      endif

*==== End of range.
      if (token(jtok) .eq. '/') then
        if (dvflag) go to 840
        jtok = jtok + 1
        dvflag = .true.

*---- Cannot be "select" type range.
        select = .false.

*---- Hash sign "#", followed by "S", "E", "F", "L", or integer.
        if (token(jtok) .eq. '#') then
          jtok = jtok + 1
          if (token(jtok) .eq. 'S') then
            jtok = jtok + 1
            icode2 = 1
          else if (token(jtok) .eq. 'E') then
            jtok = jtok + 1
            icode2 = 2
          else if (token(jtok) .eq. 'F') then
            jtok = jtok + 1
            icode2 = 3
          else if (token(jtok) .eq. 'L') then
            jtok = jtok + 1
            icode2 = 4
          else
            call rdint(index2, sflag)
            if (sflag) go to 890
            icode2 = 5
          endif

*---- Integer alone.
        else if (ichtyp(ichar(token(jtok))) .le. 9) then
          call rdint(index2, sflag)
          if (sflag) go to 890
          icode2 = 5

*---- Name, or "#?/S", "#?/E", "#?/F", or "#?/L".
        else
          call rdword(elnam2, leng2)
          if (leng2 .le. 0) go to 810
          if (hash  .and.  elnam2 .eq. 'S') then
            icode2 = 1
          else if (hash  .and.  elnam2 .eq. 'E') then
            icode2 = 2
          else if (hash  .and.  elnam2 .eq. 'F') then
            icode2 = 3
          else if (hash  .and.  elnam2 .eq. 'L') then
            icode2 = 4
          else
            icode2 = 6
            call direfe(ldbnk, elnam2(1:leng2), idir2)
            if (token(jtok) .eq. '[') then
              jtok = jtok + 1
              call rdint(index2, sflag)
              if (sflag) go to 890
              if (token(jtok) .ne. ']') go to 830
              jtok = jtok + 1
            endif
          endif
        endif
      endif

*---- Set code for "select" range.
      if (select) then
        icode1 = 7
        icode2 = 7
        idir2 = idir1

*---- Fill in second group, if no slash seen.
      else if (.not. dvflag) then
        index2 = index1
        icode2 = icode1
        idir2 = idir1
      endif

*---- Lift 'range' bank.
      call mzbook(2, ldcatt, ldcbnk, -ilink, 'RANG', 0, 0, 6, 2, 0)
      iq(ldcatt+1) = icode1
      iq(ldcatt+2) = idir1
      iq(ldcatt+3) = index1
      iq(ldcatt+4) = icode2
      iq(ldcatt+5) = idir2
      iq(ldcatt+6) = index2
      iq(ldcbnk+idata+mctyp) = 10 * mtrng + 1
      go to 9999

*---- Name expected.
  810 continue
      call rdfail('DCRANG', 1, '"#" or name expected.')
      go to 890

*---- Indices out of order.
  820 continue
      write (msg, 910) index1, index2
  910 format('Bad index order ',i8,'/',i8)
      call rdfail('DCRANG', 1, msg)
      go to 890

*---- Missing "]".
  830 continue
      call rdfail('DCRANG', 1, 'Missing closing bracket "]".')
      go to 890

*---- Invalid "/".
  840 continue
      call rdfail('DCRANG', 1, '"/" not allowed here.')

*---- Return error flag set.
  890 continue
      iq(ldcbnk+idata+mctyp) = 10 * mtrng

 9999 end
+dk dcrept
      subroutine dcrept(nrept)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode repeat count:   "nrepeat \* data".                          *
*   Use \* to kill ambiguity with * in expressions.                    *
* Output:                                                              *
*   NREPT    (integer)  Repeat count.                                  *
*----------------------------------------------------------------------*
+ca aparam
+ca chcode
+ca stbuff
      integer ichar,idig,jtmp,nrep,nrept

+ca bslash

      jtmp = jtok
      nrep = 0

*---- Try to read repeat count.
   10 continue
        idig = ichtyp(ichar(token(jtmp)))
        if (idig .ge. 10) go to 20
        nrep = 10 * nrep + idig - 1
        jtmp = jtmp + 1
      go to 10
   20 continue

*---- Expect "number \*" or "number ~" if value is repeat count.
      if (jtmp .le. jtok) then
        nrept = 1
      else if (token(jtmp).eq.bslash .and. token(jtmp+1).eq.'*') then
        jtok = jtmp + 2
        nrept = nrep
      else if (token(jtmp) .eq. '~') then
        jtok = jtmp + 1
        nrept = nrep
      else
        nrept = 1
      endif

      end
+dk dcstrg
      subroutine dcstrg(ilink, idata, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode string and lift string bank.                                *
* Input:                                                               *
*   LDCBNK   /DCLINK/   Data bank pointer.                             *
*   ILINK    (integer)  Bias for pointer to sub-bank.                  *
*   IDATA    (integer)  Bias for data block.                           *
* Output:                                                              *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer idata,ileng,ilink,nd
      logical           eflag
+ca memdum
+ca cmdgroup
+ca dclink
+ca datatype

      character*(mcstr)   string

      eflag = .false.
      call rdword(string, ileng)

*---- Drop any old string bank.
      ldcatt = lq(ldcbnk-ilink)
      if (ldcatt .ne. 0) then
        call mzdrop(0, ldcatt, '.')
        iq(ldcbnk+idata+mctyp) = 10 * mtstr
      endif

*---- If string is not empty, lift string bank and return results.
      if (ileng .gt. 0) then
        nd = (ileng - 1) / mcwrd + 1
        call mzbook(2, ldcatt, ldcbnk, -ilink, 'STRG', 0, 0, nd, 5, 0)
        call uctoh(string, iq(ldcatt+1), mcwrd, ileng)
        iq(ldcbnk+idata+mctyp) = 10 * mtstr + 1
        iq(ldcbnk+idata+mcval) = ileng
      endif

      end
+dk dcvref
      subroutine dcvref(ilink, idata, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode variable data type for "VARY", "SET", "ASK", etc.           *
* Input:                                                               *
*   LDCBNK   /DCLINK/   Data bank pointer.                             *
*   ILINK    (integer)  Bias for pointer to sub-bank.                  *
*   IDATA    (integer)  Bias for data block.                           *
* Output:                                                              *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer idata,ilink,index1,index2,index3,iseen,leng
      logical           eflag
+ca memdum
+ca cmdgroup
+ca vargroup
+ca dclink
+ca refer
+ca stbuff
+ca datatype

      character*(mcnam) bnknam, atrnam

*---- Drop any previous variable reference.
      eflag = .false.
      lcvar = lq(ldcbnk-ilink)
      if (lcvar .ne. 0) call aadrop(lcvar)

*---- Initialize.
      bnknam = ' '
      atrnam = ' '

*---- Read bank name.
      call rdword(bnknam, leng)
      if (leng .eq. 0) then
        call rdfail('DCVREF', 1, 'Variable name expected.')
        eflag = .true.
        go to 9999
      endif

*---- "[" marks bank attribute.
      if (token(jtok) .eq. '[') then
        jtok = jtok + 1

*---- Read attribute name.
        call rdword(atrnam, leng)
        if (leng .eq. 0) then
          call rdfail('DCVREF', 1, 'Attribute name expected.')
          eflag = .true.
          go to 9999
        endif
        call dcindx(index1, index2, index3, eflag)
        if (eflag) go to 9999
        if (token(jtok) .ne. ']') then
          call rdfail('DCVREF', 1, 'Closing bracket "]" missing.')
          eflag = .true.
          go to 9999
        endif
        jtok = jtok + 1
        iseen = 2

*---- Parameter reference.
      else
        iseen = 1
        index1 = 0
        index2 = 0
        index3 = 0
      endif

*---- Lift variable reference bank and link to variable table.
      call mzbook(2, lcvar, ldcbnk, -ilink, 'VREF', 1, 0, mvsiz, 7, 0)
      call exlkvr

*---- Fill in data.
      iq(lcvar+mvf1) = 16 * 2 * mwnam + 5
      call uctoh(bnknam, iq(lcvar+mvbank), mcwrd, mcnam)
      call uctoh(atrnam, iq(lcvar+mvattr), mcwrd, mcnam)
      iq(lcvar+mvf2) = 16 * 6 + 2
      iq(lcvar+mvseen) = iseen
      iq(lcvar+mvind1) = index1
      iq(lcvar+mvind2) = index2
      iq(lcvar+mvind3) = index3

*---- Return reference type.
      iq(ldcbnk+idata+mctyp) = 10 * mtvar + iseen

 9999 end
+dk dczzzz
+dk diaaaa
+dk diadd
      subroutine diadd(ldir, label, index, idir)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Add entry for LABEL in directory structure LDIR.                   *
* Input:                                                               *
*   LDIR(4)  (pointer)  Directory links.                               *
*   LABEL    (char)     Label to be found.                             *
*   INDEX    (integer)  Index for lexicographical insertion.           *
* Output:                                                              *
*   IDIR     (integer)  Directory index.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,idir,index,j,last,mi
      integer           ldir(4)
      character*(*)     label
+ca memdum

      character*(mcnam) word

*---- Add LABEL to directory.
      word = label
      last = iq(ldir(3)+1)
      if (last .ge. iq(ldir(1)-1)) then
        mi = iq(ldir(3)+2)
        call mzpush(0, ldir(1),  0,       mi, 'I')
        call mzpush(0, ldir(2),  0, mwnam*mi, 'I')
        call mzpush(0, ldir(3), mi,        0, 'I')
        call mzpush(0, ldir(4),  0,       mi, 'I')
      endif
      do 10 j = last, index, -1
        iq(ldir(1)+j+1) = iq(ldir(1)+j)
   10 continue
      idir = last + 1
      ibias = mwnam * last + 1
      iq(ldir(3)+1) = idir
      iq(ldir(1)+index) = idir
      word = label
      call uctoh(word, iq(ldir(2)+ibias), mcwrd, mcnam)

      end
+dk didefi
      subroutine didefi(ldir, label, lbank)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Add LABEL to directory structure LDIR and store bank pointer.      *
*   The full length of LABEL is considered for searches.               *
*   Call relevant routines to drop invalidated data.                   *
* Input:                                                               *
*   LDIR(4)  (pointer)  Directory links.                               *
*   LABEL    (char)     Label to be found.                             *
*   LBANK(1) (pointer)  Pointer to bank to be defined.                 *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,ileng,iln,index,ipr,jbyt,jpr
      integer           ldir(4), lbank(*)
      character*(mcnam) label
+ca memdum
+ca bankhead
+ca markbits
+ca prcgroup
+ca message
+ca dilink
+ca refer
+ca status

      character*(mcnam) oldkey, newkey

*---- Search directory.
      ldinew = lbank(1)
      call dilook(ldir, label, index, idir)

*---- If valid entry found or created, test for possible redefinition.
      if (idir .ne. 0) then
        ldiold = lq(ldir(3)-idir)
        if (ldiold .ne. 0) then
          ipr = iq(ldiold+mbpr)
          iln = iq(ldiold+mbln)
          jpr = iq(ldinew+mbpr)

*---- Keyword commands must not be redefined.
          call utleng(label, ileng)
          if (ipr .eq. mpkey) then
            write (msg, 910) label(1:ileng), iln
  910       format('Trying to redefine master keyword "',a,'",'/
     +             'old version (defined in line ',i6,') kept.')
            call aafail('DIDEFI', 2, msg)
            call aadrop(ldinew)
            go to 9999

*==== Replacement of a protected name is not allowed.
          else if (jbyt(iq(ldiold),mxcls,2) .ne. 0  .and.
     +             iq(ldiold+mbnam) .eq. idir) then
            write (msg, 920) label(1:ileng), iq(ldiold+mbln)
  920       format('Trying to redefine protected name "',a,'",'/
     +             'old version (defined in line ',i6,') kept.')
            call aafail('DIDEFI', 2, msg)
            call aadrop(ldinew)
            go to 9999

*---- Replacing a parameter definition.
          else if (ipr .eq. mppar  .and.  jpr .eq. mppar) then
            if (iln .ne. 0) then
              write (msg, 930) 'parameter', label(1:ileng), iln
  930         format('Redefining ',a,' value "',a,'",'/
     +               'previous definition occurred in line',i6,'.')
              call aawarn('DIDEFI', 2, msg)
            endif

*---- Replacing a string definition.
          else if (ipr .eq. mpstr  .and.  jpr .eq. mpstr) then
            if (iln .ne. 0) then
              write (msg, 930) 'string', label(1:ileng), iln
              call aawarn('DIDEFI', 2, msg)
            endif

*---- Replacing beam line/element. If structure changes, drop expansion.
*     Messages are generated in AASMOD.
          else if ((ipr .eq. mpelm  .or.  ipr .eq. mplin)  .and.
     +             (jpr .eq. mpelm  .or.  jpr .eq. mplin)) then
            call aasmod(idir, ldiold, ldinew)
            if (error) go to 9999

*---- Replacing command or subroutine.
          else if (ipr .ge. mpsub  .and.  jpr .ge. mpsub) then
            if (label .ne. ' ') then
              write (msg, 940) label(1:ileng), iln
  940         format('Redefining subroutine or command "',a,'",'/
     +               'previous definition occurred in line',i6,'.')
              call aawarn('DIDEFI', 2, msg)
            endif

*---- Replacement changes category of item.
          else
            call diname(ldkey, iq(lq(ldiold+1)+mbnam), oldkey)
            call diname(ldkey, iq(lq(ldinew+1)+mbnam), newkey)
            write (msg, 950) label(1:ileng), oldkey, newkey, iln
  950       format('Trying to change category of label "',a,'";'/
     +             'old definition was: ',a/
     +             'new definition is:  ',a/
     +             'old version (defined in line',i6,') kept.')
            call aafail('DIDEFI', 4, msg)
            go to 9999
          endif

*---- Drop old data bank, unless it represents an element class.
          if (ldiold .ne. ldinew) then
            if (jbyt(iq(ldiold),mxcls,2) .eq. 0) call aadrop(ldiold)
          endif
        endif

*---- If not yet defined, add new entry.
      else
        call diadd(ldir, label, index, idir)
      endif

*---- Link bank to directory entry.
      lq(ldir(3)-idir) = ldinew
      iq(ldinew+mbnam) = idir

 9999 end
+dk didrop
      subroutine didrop(ldir, label)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Drop LABEL from directory structure LDIR.                          *
* Input:                                                               *
*   LDIR(4)  (pointer)  Directory links.                               *
*   LABEL    (char)     Label to be found.                             *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,index
      integer           ldir(4)
      character*(mcnam) label
+ca memdum

      call dilook(ldir, label, index, idir)
      if (idir .ne. 0) lq(ldir(3)-idir) = 0

      end
+dk difind
      subroutine difind(ldir, label, idir, lbank)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Return bank pointer stored for LABEL in directory structure LDIR.  *
*   If LABEL is less than MCNAM characters, it may be abbreviation.    *
* Input:                                                               *
*   LDIR(4)  (pointer)  Directory links.                               *
*   LABEL    (char)     Label to be found.                             *
* Output:                                                              *
*   IDIR     (integer)  Directory index.                               *
*   LBANK(1) (pointer)  Pointer to data bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,index
      integer           ldir(4), lbank(*)
      character*(*)     label
+ca memdum

*---- Return directory index.
      call dilook(ldir, label, index, idir)

*---- Return bank pointer.
      if (idir .eq. 0) then
        lbank(1) = 0
      else
        lbank(1) = lq(ldir(3)-idir)
      endif

      end
+dk dilook
      subroutine dilook(ldir, label, index, idir)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Return index for LABEL in directory structure LDIR.                *
*   If LABEL is less than MCNAM characters, it may be abbreviation.    *
* Input:                                                               *
*   LDIR(4)  (pointer)  Directory links.                               *
*   LABEL    (char)     Label to be found.                             *
* Output:                                                              *
*   INDEX    (integer)  Index for lexicographic insertion.             *
*   IDIR     (integer)  Directory index.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,idir,imax,imin,index,labl,last,len
      integer           ldir(4)
      character*(*)     label
+ca memdum

      character*(mcnam) test, word

*---- Initial values.
      test = label
      labl = len(label)
      imin = 1
      last = iq(ldir(3)+1)
      imax = last
      idir = 0
*---- Search loop.
   10 if (imax .ge. imin) then
        index = (imin + imax) / 2
        idir = iq(ldir(1)+index)
        ibias = mwnam * (idir - 1) + 1
        call uhtoc(q(ldir(2)+ibias), mcwrd, word, mcnam)
        if (word .gt. test) then
          imax = index - 1
          go to 10
        else if (word .lt. test) then
          imin = index + 1
          go to 10
        endif

*---- If there is no exact match, try abbreviation.
      else
        index = imin
        idir = 0
        if (labl .ge. 4) then
          if (labl .lt. mcnam  .and.  index .le. last) then
            idir = iq(ldir(1)+index)
            ibias = mwnam * (idir - 1) + 1
            call uhtoc(q(ldir(2)+ibias), mcwrd, word, mcnam)
            if (word(1:labl) .eq. label) then
              if(index .lt. last) then
                ibias = mwnam * (iq(ldir(1)+index+1) - 1) + 1
                call uhtoc(q(ldir(2)+ibias), mcwrd, word, mcnam)
                if (word(1:labl) .eq. label) idir = 0
              endif
            else
              idir = 0
            endif
          endif
        endif
      endif

      end
+dk dimake
      subroutine dimake(mi, iroot, ldir)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Build a directory structure.                                       *
* Input:                                                               *
*   MI        (integer) Initial capacity of directory, and increment.  *
*   IROOT     (integer) Bias in master bank.                           *
*   LDIR(4)   (pointer) Directory links.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer idiflg,iroot,mi,nd
      integer           ldir(4)
+ca memdum
+ca dilink
+if doom
      logical dmuse
+ei
      data idiflg       / 0 /

      if (idiflg .eq. 0) then
        call mzlink(0, '/DILINK/', ldinew, ldinew, ldiold)
        idiflg = 1
      endif

+if doom
      if (.not. dmuse())  then
+ei
*---- Index for binary search.
      call mzbook(2, ldir(1), lroot, -iroot, 'INDX', 0, 0, mi, 2, 0)

*---- Bank names.
      nd = mwnam * mi
      call mzbook(2, ldir(2), lroot, -iroot-1, 'NAME', 0, 0, nd, 5, 0)

*---- Bank pointers.
      call mzbook(2, ldir(3), lroot, -iroot-2, 'PNTR', mi, 0, 3, 2, 0)
      iq(ldir(3)+2) = mi

*---- Occurrence counts.
      call mzbook(2, ldir(4), lroot, -iroot-3, 'OCCR', 0, 0, mi, 2, 0)
+if doom
      endif
+ei
      end
+dk dimark
      subroutine dimark(ldir)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Mark end of dictionary in a directory structure.                   *
* Input:                                                               *
*   LDIR(4)   (pointer) Directory links.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer           ldir(4)
+ca memdum

      iq(ldir(3)+3) = iq(ldir(3)+1)

      end
+dk diname
      subroutine diname(ldir, idir, label)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Get LABEL for entry IDIR in directory structure LDIR.              *
* Input:                                                               *
*   LDIR(4)  (pointer)  Directory links.                               *
*   IDIR     (integer)  Directory index.                               *
* Output:                                                              *
*   LABEL    (char)     Label to be found.                             *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,idir
      integer           ldir(4)
      character*(mcnam) label
+ca memdum

      if (idir .ne. 0) then
        ibias = mwnam * (idir - 1) + 1
        call uhtoc(q(ldir(2)+ibias), mcwrd, label, mcnam)
      else
        label = ' '
      endif

      end
+dk direfe
      subroutine direfe(ldir, label, idir)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Return index for LABEL in directory structure LDIR.                *
*   If not found, a new entry is created and its index returned.       *
*   If LABEL is less than MCNAM characters, it may be abbreviation.    *
* Input:                                                               *
*   LDIR(4)  (pointer)  Directory links.                               *
*   LABEL    (char)     Label to be found.                             *
* Output:                                                              *
*   IDIR     (integer)  Directory index.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,index
      integer           ldir(4)
      character*(*)     label

      call dilook(ldir, label, index, idir)
      if (idir .eq. 0) call diadd(ldir, label, index, idir)

      end
+dk dizzzz
+dk dmaaaa
+dk dmact
+if doom
      logical function dmact()
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Returns true if d.b. currently active, else false
*----------------------------------------------------------------------*
+ca aparam
+ca dmcommon

      dmact = actdoom .eq. 661227
      end
+ei
+dk dmbeam
+if doom
      subroutine dmbeam
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   stores an object with the BEAM command parameters
*----------------------------------------------------------------------*
+ca aparam
+ca beam
+ca refer
+ca dmcommon
      integer nalerr,nalstore,ncorrect,ncorstore,nflerr,nflstore,
     +nmonitor,nmonstore,lastact
      common / dm2comm /
     +nalerr,nalstore,ncorrect,ncorstore,nflerr,nflstore,
     +nmonitor,nmonstore,lastact
* character array:
*     PRTNAM            Alphanumeric particle name.
* double precision array: see bsequnam to gammas in cd beam
      integer i, keylist,lchar,lin,mlbdmb,mpart1,mpart2,n,nc,nz
      double precision temp
      parameter (mpart1=15, mpart2=36, mlbdmb = mpart1+mpart2)
      character * (mcnam)  tname, parent, tseqnam(mttact)
      character * 48 ttname
      dimension temp(mlbdmb)
      integer doom_nadd
      data keylist / 0 /

*   save number of currently active
      lastact = currseq
* loop over sequences, store sequences and beam parameters
      do i = 1, liftseq
        call get_active(seqnames(i), 'DMBEAM')
        call dmpsequ
        tname = prtnam
        lin = mcnam
        n = mlbdmb
        nz = 0
        call ucopy(amass, temp, mpart1*mwflt)
        call ucopy(sigx, temp(mpart1+1), mpart2*mwflt)
        call doom_compress(tname, lin, lchar)
        ttname = 'BEAM.' // sequnam
        call doom_store(ttname, keylist, nz, n, lchar, nz, temp,
     +  tname)
      enddo
*  fill USE object with sequence names
*--- add an object SEQUENCE_LIST with all USEd sequence names
      if (liftseq .gt. 0)  then
      do i = 1, liftseq
        tseqnam(i) = seqnames(i)
      enddo
        tname = 'SEQUENCE_LIST '
        parent = 'USE '
        n = liftseq
        nc = mcnam
        call doom_sobj(tname, nz, parent, parent,
     +  nz, nz, n, nc, n, dm_dbl, tseqnam)
*--- add to directory
        if (ndirec .eq. maxbuff)  then
          print *, '<<< DOOM >>> fatal: DIRECTORY size ',
     +    maxbuff, ' reached'
          stop
        endif
        nc = mcnam
        n = doom_nadd(tname, director, ndirec, nc)
        ndirec = n
      endif
      end
+ei
+dk dmclose
+if doom
      subroutine dmclose
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Closes the database
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca seqflag
+ca prcgroup
+ca seqgroup
+ca strgroup
+ca message
+ca header
+ca refer
+ca status
+ca stflag
+ca zunit
+ca dmcommon
      logical dmact

      if (dmact())  then
        if (.not.(noupdate .or. scan))  then
          if (nfsave .eq. 2)  then
*--- set flag to prevent re-opening
            clsdoom = 380226
          endif
*--- store multipole error references
          call dmmult
*--- store BEAM command parameters, and used sequences
          call dmbeam
*--- store directory
          call dmpdir
        endif
*--- print summary
        call dmpsumm
        call doom_close()
        actdoom = 0
*--- set current time for comparison after re-open
        call doom_time(dltime)
      endif
      end
+ei
+dk dmcmnd
+if doom
      subroutine dmcmnd(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode DOOM commands                                               *
* Input:                                                               *
*   IPR       (integer) Process code.                                  *
*   ISP       (integer) Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca header
+ca message
      integer ipr,isp
+ca refer
+ca dmcommon
      integer i,iflag,len,mdopts,nc,nz
      parameter (mdopts = 8)
      logical lflag(mdopts)
      integer itype(mdopts+2)
      logical dmuse, dmact
      integer doom_debug
      character * 80 ttitle

      if (ipr .eq. 25 .and. isp .eq. 1)  then
        do 10  i = 1, mdopts
          lflag(i) = .false.
   10   continue
      call utgtyp(lccmd, itype)
*--- logicals
        call utglog(lccmd, 1, mdopts, lflag)
        if (lflag(1))  then
*--- DOOM OPEN: open and load modified object
          if (dmact())  then
            call aawarn('USERCM', 1,
     +      'DOOM d.b. already open, command ignored')
          elseif (clsdoom .eq. 380226)  then
            call aawarn('USERCM', 1,
     +      'DOOM d.b. closed for good, command ignored')
          else
            call dmopen
            call dmmain(nshutin+1)
          endif
        elseif (lflag(2))  then
*--- DOOM CLOSE: close and save all objects + root tree
          if (.not.dmact())  then
            call aawarn('USERCM', 1,
     +      'DOOM d.b. not open, command ignored')
          else
            call dmmain(2)
            call dmclose
          endif
        elseif (lflag(3))  then
*--- DOOM SHUT: close temporarily
          if (.not.dmact())  then
            call aawarn('USERCM', 1,
     +      'DOOM d.b. not open, command ignored')
          else
            nshutin = 10
            call dmmain(2)
            call dmshut
          endif
        endif
        if (lflag(4))  then
*--- DOOM STRICT: suppress EPIO and other table files
          strict = lflag(4)
        endif
        if (lflag(5))  then
*--- DOOM TIME: keep current time for future comparisons
          call doom_time(dltime)
        endif
        if (itype(6) .ne. 0)  then
*--- DOOM TREE: dump tree at closure
          tree = lflag(6)
          if (tree)  then
            nfsave = 2
          else
            nfsave = 1
          endif
        endif
*--- DOOM NOUPDATE: prevent any update of the database
        if (itype(7) .ne. 0)  then
          noupdate = lflag(7)
          if (noupdate)  then
            i = 1
          else
            i = 0
          endif
          call doom_snoup(i)
        endif
*--- get title if any
        if (lflag(8))  then
          nz = 0
          nc = len(ctitle)
          ttitle = ' '
          call doom_gstring('TITLE ', nz, nc, ttitle)
          if (nc .gt. 0)  then
            ctitle = ttitle
            print *, '<<< DOOM >>> new title stored in MAD-8:'
            print '(a)', ctitle
          endif
        endif
        if (itype(mdopts+1) .ne. 0)  then
*--- DOOM DEBUG: set debug level
          iflag = 1
          call utgint(lccmd, mdopts+1, mdopts+1, iflag)
          call doom_setvar('debug_flag ', iflag)
        endif
        if (itype(mdopts+2) .ne. 0)  then
*--- DOOM CREATE="filename"
          if (dmuse())  then
            call aawarn('USERCM', 1,
     +      'DOOM d.b. already present, command ignored')
          else
            call utgstr(lccmd, mdopts+2, mdopts+2, doom_name)
            tree = .true.
            newdb = 123456
            call dminit
            call dmmain(1)
          endif
        endif
        call doom_getvar('debug_flag ', doom_debug)
        if (doom_debug .gt. 3) print *, 'USERCM dltime = ', dltime
      else
        write (msg, 910) ipr, isp
        call rdwarn('USERCM', 1, msg)
      endif
  910 format('Unknown command, PR =',i5,', SP =',i5,'.')
      end
+ei
+dk dmgalerr
+if doom
      subroutine dmgalerr(nalmod)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Restores the alignment errors for all elements of a sequence
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca memdum
+ca bankhead
+ca seqflag
+ca prcgroup
+ca seqgroup
+ca strgroup
+ca message
+ca header
+ca refer
+ca stflag
+ca zunit
+ca dmcommon
      integer icode,ienum,iflag,iocc,ipos,jbyt,nalerr,nalmod,nd,
     +nl,nst
      double precision al_errors,dndic
      integer listal(3)
      character*(mcnam) loc_nam
      dimension al_errors(6)
      logical dmact
      data listal / 2, m_align, 0 /

      if (.not.dmact())  goto 999
      call uhtoc(q(lcseq+msbn), mcwrd, seqname, mcnam)
      print *,
     +'<<< DOOM >>> restoring alignment errors for sequence: ',
     +seqname
      nalerr = 0
      nalmod = 0
*---- Lift error banks, if not already done.
      lsdir = lq(lcseq-msdir)
      lsali = lq(lcseq-msali)
      if (lsali .eq. 0) then
        nl = iq(lsdir-1)
        call mzbook(2, lsali, lcseq, -msali, 'EALI', nl, nl, 0, 2, 0)
      endif
      do 10  ipos = iq(lcseq+msr1), iq(lcseq+msr2)
        call utelem(lcseq, ipos, iflag, loc_nam, iocc, ienum)
        icode = jbyt(iflag,1,mcode)
        if (icode .eq. 1 .and. loc_nam(1:1) .ne. '[')  then
*--- check for existence and modification flag
          listal(3) = iocc
          call doom_gtime_env('USE ', loc_nam, listal, dndic)
          if (dndic .lt. zero)  goto 10
          nalerr = nalerr + 1
          if (dndic .le. dltime)  goto 10
          nst = 6
          nd = nst * mwflt
          if (lq(lsali-ipos) .eq. 0)
     +    call mzbook(2, lcali, lsali, -ipos, 'EALI', 0, 0, nd,
     +    mreal, 0)
          call vzero(al_errors, 12)
          call doom_galign(loc_nam, iocc, nst, al_errors)
*--- mark as loaded from DOOM and not modified
          call sbit1(iq(lcali), mxdoom)
          call sbit0(iq(lcali), mxdmod)
          if (nst .gt. 0)  then
            nd = nst * mwflt
            call ucopy(al_errors, q(lcali+1), nd)
            nalmod = nalmod + 1
          endif
        endif
   10 continue
      print *,
     +'         >>> elements with alignment errors (modified): ',
     +nalerr, ' (', nalmod, ')'
  999 end
+ei
+dk dmgcorm
+if doom
      subroutine dmgcorm
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Restores the corrector and monitor settings for a sequence
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca memdum
+ca bankhead
+ca seqflag
+ca prcgroup
+ca seqgroup
+ca strgroup
+ca message
+ca header
+ca refer
+ca stflag
+ca zunit
+ca dmcommon
      integer icode,ienum,iflag,iocc,ipos,itp,jbyt,ncorrect,
     +ncorrmod,nd,nmonimod,nmonitor,nst
      double precision corr_set,dndic
      integer listco(3), listcm(3)
      character*(mcnam) loc_nam
      dimension corr_set(2)
      logical dmact
      data listco / 2, m_corr, 0 /
      data listcm / 2, m_moni, 0 /

      if (.not.dmact() .or. lcseq .eq. 0)  goto 999
      lscom = lq(lcseq-mscom)
      if (lscom .eq. 0)  goto 999
      call uhtoc(q(lcseq+msbn), mcwrd, seqname, mcnam)
      print *,
     +'<<< DOOM >>> restoring correctors/monitors for sequence: ' //
     +seqname
      ncorrect = 0
      ncorrmod = 0
      nmonitor = 0
      nmonimod = 0
      do 10  ipos = iq(lcseq+msr1), iq(lcseq+msr2)
        call utelem(lcseq, ipos, iflag, loc_nam, iocc, ienum)
        icode = jbyt(iflag,1,mcode)
        lccom = lq(lscom-ipos)
        if (icode .eq. 1 .and. lccom .ne. 0
     +  .and. loc_nam(1:1) .ne. '[')  then
          itp = iq(lcelm+mbsp)
          if (itp .ge. 14 .and. itp. le. 16)  then
*--- kicker
*--- check for existence and modification flag
            listco(3) = iocc
            call doom_gtime_env('USE ', loc_nam, listco, dndic)
            if (dndic .lt. zero)  goto 10
            ncorrect = ncorrect + 1
            if (dndic .le. dltime)  goto 10
            nst = 2
            nd = min(iq(lccom-1),nst * mwflt)
            call doom_gcorrect(loc_nam, iocc, iq(lccom), corr_set)
*--- mark as loaded from DOOM and not modified
            call sbit1(iq(lccom), mxdoom)
            call sbit0(iq(lccom), mxdmod)
            call ucopy(corr_set, q(lccom+1), nd)
            ncorrmod = ncorrmod + 1
          elseif (itp .ge. 17 .and. itp. le. 19)  then
*--- monitor
*--- check for existence and modification flag
            listcm(3) = iocc
            call doom_gtime_env('USE ', loc_nam, listcm, dndic)
            if (dndic .lt. zero)  goto 10
            nmonitor = nmonitor + 1
            if (dndic .le. dltime)  goto 10
            nst = 2
            nd =  min(iq(lccom-1),nst * mwflt)
            call doom_gmonitor(loc_nam, iocc, iq(lccom), corr_set)
*--- mark as loaded from DOOM and not modified
            call sbit1(iq(lccom), mxdoom)
            call sbit0(iq(lccom), mxdmod)
            call ucopy(corr_set, iq(lccom+1), nd)
            nmonimod = nmonimod + 1
          endif
        endif
   10 continue
      print *,
     +'         >>> corrector settings (modified): ',
     +ncorrect, ' (', ncorrmod, ')'
      print *,
     +'         >>> monitor settings (modified): ',
     +nmonitor, ' (', nmonimod, ')'
  999 end
+ei
+dk dmgdir
+if doom
      subroutine dmgdir(idrflg)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Reads directory and all parents of elements -> ldbnk
*   Reads USE and related sequence, parameters
*-- Input:
*   idrflg  (int)    if = 1 first load, else update
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca header
+ca refer
+ca dmcommon
      integer i,idrflg,isrc,j,key_list,level,mlev,n,n1,nc,npar,
     +ntype
      double precision dndic
      parameter (mlev = 100)
      character * (mcnam) dname, parent, type, name, tn(mlev), tp(mlev)
      character * (mcnam+4) name4
      integer doom_debug

      key_list = 0
      dname = 'DIRECTORY'
      n = mcnam
      nc = maxbuff
      call doom_gdirect(dname, nc, n, director)
      if (nc .lt. 0)  then
        ndirec = 0
        goto 999
      endif
      ndirec = nc
      call doom_getvar('debug_flag ', doom_debug)
      if (doom_debug .gt. 1)  then
        print '(a,a)', 'restoring object ', dname
        print '(4a17)', (director(j), j = 1, ndirec)
      endif
      do 30 i = 1, ndirec
        n = mcnam
        name4 = director(i)
        call doom_gparent(name4, key_list, n, parent, npar)
        if (npar .lt. 0)  then
          print *, '<<< DOOM >>> fatal: DIRECTORY member ',
     +    director(i), ' not found'
          stop
        endif
        call doom_gtype(name4, key_list, n, type, ntype)
        if (ntype .lt. 0)  then
          print *, '<<< DOOM >>> fatal: DIRECTORY member ',
     +    director(i), ' not found'
          stop
        endif
        call doom_getvar('debug_flag ', doom_debug)
        if (doom_debug .gt. 2)
     +  print '(a, 3a17)', 'object + parent + type: ', director(i),
     +  parent, type
        if (type .eq. ' ')  then
          print *, '<<< DOOM >>> warning: object: ',
     +    director(i), ' has no type, skipped'
        elseif (type .eq. 'VARIABLE' .and. parent .eq. 'REAL_VARIABLE'
     +  .or.    type .eq. 'CONSTANT' .and. parent .eq. 'REAL_CONSTANT')
     +  then
*--- variable or constant (parameter)
          call dmgparm(director(i), type, idrflg)
        elseif (type .eq. 'USE')  then
          if (idrflg .eq. 1)  then
*--- USE command for this sequence
            usename = director(i)
            n = 0
            n1 = 1
            nc = mcnam
            call doom_robj(director(i), n, parent, parent,
     +      n, n, n1, nc, n, dm_dbl, seqname)
          endif
        elseif (type .eq. 'ELEMENT')  then
*--- element - if not in table, put all parents in front
          level = 0
          name = director(i)
   10     continue
          call difind(ldbnk, name, isrc, lccmd)
          if (lccmd .gt. 0)  then
            call difind(ldkey, name, isrc, lckey)
            if (lckey .gt. 0)  goto  20
            call doom_gtime(name, key_list, dndic)
            if (dndic .le. dltime)  goto  20
          endif
          if (level .eq. mlev)  then
            print *, '<<< DOOM >>> fatal: parent buffer full at: ',
     +      level
            stop
          endif
          level = level + 1
          tn(level) = name
          call doom_gparent(tn(level), key_list, n, name, npar)
          if (npar .lt. 0 .or. name .eq. ' ')  then
            print *, '<<< DOOM >>> fatal: element: ',
     +      tn(level), ' has no parent'
            stop
          endif
          tp(level) = name
          goto 10
   20     continue
          do j = level, 1, -1
            call dmgelm(tn(j), tp(j))
          enddo
        endif
   30 continue
  999 end
+ei
+dk dmgelm
+if doom
      subroutine dmgelm(label, class)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Restore data for one element bank from DOOM and link to MAD-8
* Input:
*   label (char)  element name
*   class (char)  class (parent) name
*----------------------------------------------------------------------*
* Important mod HG 14.10.99:
* invert signs of skew components (dipole->multipole)
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca maxmul
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
      integer i,i1,i2,ibias,ikey,iln,ipr,isp,isrc,mbetrf,mpg,mshunt,
     +mtfill,n,na,nb,ncat,nkat
      double precision angle,cosa,dndic,parnum,ratio,sina
      parameter (mbetrf = mehrmc + mcsiz,
     +           mpg = mbetrf + mcsiz, mshunt = mpg + mcsiz,
     +           mtfill = mshunt + mcsiz)
+ca prcgroup
+ca codata
+ca keyword
+ca refer
+ca datatype
+ca markbits
+ca dmcommon
      logical dmact
      character*(mcnam) label, class
      character * (mcnam) ellns
      integer key_list(2)
      integer doom_debug
      integer larg(maxcom), largbd(20), largcl(14), largqu(16),
     +largsx(18), largoc(20), largss(8), largcv(12), largel(7),
     +largcvl(6), largrt(7), larggb(16), largbb(18), largbb6(23)
      data largbd / 2, 0, 5, 6, 9, 10, 7, 0, 11, 12,
     +              3, 0, 0, 0, 4, 0, 8, 0, 13, 0 /
      data largcl / 2, 11 * 0, 3, 4 /
      data largqu / 2, 5 * 0, 4, 7 * 0, 3, 0 /
      data largsx / 2, 5 * 0, 4, 9 * 0, 3, 0 /
      data largoc / 2, 5 * 0, 4, 11 * 0, 3, 0 /
      data largss / 2, 6 * 0, 3 /
* largcv: l,volt,,,(freq),lag,,betrf,pg,shunt,tfill,harmon
      data largcv / 2, 3, 0, 0, 5, 4, 0, 7, 8, 9, 10, 6 /
* largcvl: l,volt,,,freq,lag
      data largcvl / 2, 4, 0, 0, 6, 5/
      data largel / 2, 0, 3, 0, 0, 0, 4 /
      data largrt / 2, 0, 0, 0, 0, 0, 3 /
      data larggb / 2, 0, 5, 6, 9, 10, 7, 0, 11, 12,
     +              3, 0, 0, 0, 4, 8 /
      data largbb / 12 * 0, 5, 6, 3, 4, 7, 0 /
      data largbb6 /0, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
     +              17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27 /
      data key_list / 0, 0 /

      if (.not.dmact())  goto 999
      ellns = label
*--- check for existence and modification time
      n = 0
      call doom_gtime(ellns, key_list, dndic)
*--- quit if not modified
      call doom_getvar('debug_flag ', doom_debug)
      if (doom_debug .gt. 3)
     +print *, 'dmgelm: ', ellns, ' dndic, dltime: ', dndic, dltime
      if (dndic .lt. zero)  then
        call aawarn('dmgelm', 1,
     +      'element ' // ellns // 'not found in DOOM.')
        goto 999
      endif
      if (dndic .le. dltime)  goto 999
      elload = elload + 1
*--- exact match with element name ?
      call difind(ldbnk, label, isrc, lccmd)
      if (lccmd .eq. 0)  then
*---- Exact match with keyword or class name.
        call difind(ldkey, class, ikey, lckey)
        if (lckey .ne. 0) then
          if (iq(lckey+mbpr) .eq. mpelm) lccls = lq(lckey-3)
        else
          call difind(ldbnk, class, isrc, lccls)
          if (lccls .ne. 0) then
            lckey = lq(lccls+1)
          endif
        endif
        if (lckey .eq. 0)  then
          print *, '<<< DOOM >>> fatal: class ', class, ' not found'
          stop
        endif
        call kwget(lckey, iln, ipr, isp, nkat)
*---- build new element bank if required.
        call aabook(lccmd, label, ipr, isp, lckey, 1)
*---- find class object, if not already known.
        if (lccls .eq. 0) lccls = lq(lckey-3)

*---- do NOT copy attributes of class since each element complete
        ncat = iq(lccls+mbat)

*---- link to class object.
        call sbit1(iq(lccls), mxcls)
        lq(lccmd-ncat-mbecls) = lccls
        call didefi(ldbnk, label, lccmd)
      endif
      idleng = maxcom
      icleng = mxdmxp
      call vzero(dmvals, 2 * maxcom)
      call doom_gfelem(ellns, idleng, icleng, isvflg, dmvals, dmsave)
      call doom_getvar('debug_flag ', doom_debug)
      if (doom_debug .gt. 2)
     +print '(a)', 'ellns: ' //ellns // ' dmsave: ' // dmsave(:icleng)
      isp = iq(lccmd+mbsp)
      if (idleng .eq. 0) then
        idleng = 1
        dmvals(1) = zero
      endif

      go to ( 10,  20,  30,  40,  50,  60,  70,  80,  90, 100,
     +       110, 120, 130, 140, 150, 160, 170, 180, 190, 200,
     +       210, 220, 230, 240, 250, 260, 270, 280, 290, 300,
     +       310, 310, 310, 310, 310, 310, 310, 310, 310, 310), isp

*---- drift.
   10 continue
*---- monitors.
  170 continue
  180 continue
  190 continue
*---- beam instrument.
  240 continue
      larg(1) = 2
      idleng = 1
      call dmgelp(lccmd, larg, idleng)
      go to 500
*---- collimators.
  200 continue
  210 continue
      idleng = 14
      call dmgelp(lccmd, largcl, idleng)
      go to 500
*---- rectangular bend (part 1) - get k_0 etc. for straight length
   20 continue
      if (dmvals(1) .ne. zero .and. dmvals(11) .ne. zero)  then
        ratio = dmvals(11) / (2 * sin(dmvals(11)/2))
        do 21  i = 14, 20
          dmvals(i-1) = dmvals(i-1) * ratio
   21   continue
      endif
*---- rectangular bend (part 2) or sector bend.
   30 continue
      if (dmvals(7) .ne. zero)  then
        cosa = cos(dmvals(7))
        sina = sin(dmvals(7))
        do 31  i = 14, 20, 2
          if (cosa .ne. zero)  then
            dmvals(i-1) = dmvals(i-1) / cosa
          else
            dmvals(i-1) = -dmvals(i) / sina
          endif
          dmvals(i)   = zero
   31   continue
      endif
      idleng = 20
      call dmgelp(lccmd, largbd, idleng)
      go to 500

*---- quadrupole.
   50 continue
      if (dmvals(7) .ne. zero)  then
        cosa = cos(2*dmvals(7))
        sina = sin(2*dmvals(7))
        if (abs(cosa) .gt. abs(sina)) then
          dmvals(15) = dmvals(15) / cosa
        else
          dmvals(15) = -dmvals(16) / sina
        endif
      endif
      idleng = 16
      call dmgelp(lccmd, largqu, idleng)
      go to 500

*---- sextupole.
   60 continue
      if (dmvals(7) .ne. zero)  then
        cosa = cos(3*dmvals(7))
        sina = sin(3*dmvals(7))
        if (abs(cosa) .gt. abs(sina)) then
          dmvals(17) = dmvals(17) / cosa
        else
          dmvals(18) = -dmvals(18) / sina
        endif
      endif
      idleng = 18
      call dmgelp(lccmd, largsx, idleng)
      go to 500

*---- octupole.
   70 continue
      if (dmvals(7) .ne. zero)  then
        cosa = cos(4*dmvals(7))
        sina = sin(4*dmvals(7))
        if (abs(cosa) .gt. abs(sina)) then
          dmvals(19) = dmvals(19) / cosa
        else
          dmvals(20) = -dmvals(20) / sina
        endif
      endif
      idleng = 20
      call dmgelp(lccmd, largoc, idleng)
      go to 500

*---- multipole.
   80 continue
*--- radiation length into length - MAD-8 only knows thin multipoles
      call ucopy(dmvals(12), iq(lccmd+melen), mwflt)
*--- dmvals(12+2*j+1): component 2*j,  dmvals(12+2*j+2): tilt angle
      do i = 14, idleng, 2
        if (dmvals(i-1) .ne. zero .or. dmvals(i) .ne. zero) then
*---- changed sign of dmvals(i)  16.4.98
*---- back to previous - sign of tilt now changed in dictionary 3.8.00
          angle = atan2(dmvals(i), dmvals(i-1))
          dmvals(i-1) = sign(sqrt(dmvals(i-1)**2 + dmvals(i)**2), angle)
          if (angle .gt. zero)  angle = angle - pi
          dmvals(i) = angle * 2 / (i-12)
        endif
      enddo
      na = min(2 * maxmul + 2, iq(lccmd + mbat))
      nb = min(2 * maxmul + 2, idleng-10)
      if (nb .gt. na) then
        call mzpush(0, lccmd, 0, nb-na, ' ')
        iq(lccmd + mbat) = nb
      endif
      call utpflt(lccmd, 3, nb, dmvals(13))
      go to 500

*---- solenoid.
   90 continue
      idleng = 8
      call dmgelp(lccmd, largss, idleng)
      go to 500

*---- rf cavity.
  100 continue
      idleng = 12
      call dmgelp(lccmd, largcv, idleng)
*--- harmon is integer !
      ibias = mbat + 5 * mcsiz
      iq(lccmd+ibias+mcval) = dmvals(12)
      i = mod(iq(lccmd+ibias+mctyp), 10)
      iq(lccmd+ibias+mctyp) = 10 * mtint + i
      go to 500

*---- electrostatic separator.
  110 continue
      if (dmvals(7) .ne. zero)  then
        cosa = cos(dmvals(7))
        sina = sin(dmvals(7))
        if (cosa .ne. zero)  then
          dmvals(3) = dmvals(3) / cosa
        else
          dmvals(3) = dmvals(4) / sina
        endif
        dmvals(4) = zero
      endif
      idleng = 7
      call dmgelp(lccmd, largel, idleng)
      go to 500

*---- coordinate rotations.
  120 continue
  130 continue
      idleng = 7
      call dmgelp(lccmd, largrt, idleng)
      go to 500

*---- orbit correctors.
  140 continue
  150 continue
  160 continue
*---- original setting.
      do 161 i = 1, 14
  161 larg(i) = 0
      larg(1)  = 2
      if (isp .eq. 14) then
        larg(13) = 3
      else if (isp .eq. 16) then
        larg(14) = 3
      else
        larg(13) = 3
        larg(14) = 4
      endif
      idleng = 14
      call dmgelp(lccmd, larg, idleng)
      go to 500

*---- general bend (dipole, quadrupole, and skew quadrupole).
  260 continue
      if (dmvals(7) .ne. zero)  then
        call aawarn('dmgelm', 1,
     +      'tilt ignored in general bend: ' // ellns)
      endif
      idleng = 16
      call dmgelp(lccmd, larggb, idleng)
      go to 500

*---- Matrix
   40 continue
*---- length of element.
      i2 = 2
      call utpflt(lccmd, i2, i2, dmvals(1))
      i1 = i2 + 1
      i2 = i2 + 6
      call utpflt(lccmd, i1, i2, dmvals(2))
      i1 = i2 + 1
      i2 = i2 + 36
      call utpflt(lccmd, i1, i2, dmvals(8))
      i1 = i2 + 1
      i2 = i2 + 216
      call utpflt(lccmd, i1, i2, dmvals(44))
      go to 500
*--- beam-beam
  220 continue
      idleng = 18
      parnum = dmvals(18)
      call dmgelp(lccmd, largbb, idleng)
      go to 500
  270 continue
*--- lcavity
      idleng = 6
      call dmgelp(lccmd, largcvl, idleng)
      go to 500
*---- other elements.
  230 continue
  250 continue
  280 continue
  290 continue
  300 continue
  310 continue
      idleng = 2
      call dmgelp(lccmd, larg, idleng)
  500 continue
*--- mark as loaded from DOOM and not modified
      call sbit1(iq(lccmd), mxdoom)
      call sbit0(iq(lccmd), mxdmod)
  999 end
+ei
+dk dmgelp
+if doom
      subroutine dmgelp(lcmd, larg, narg)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Retrieve element value and expression and link to MAD-8
* Input:
*   lcmd(1)   (pointer)   Current element bank.
*   larg      (int array) parameter reference for DOOM fields
*   narg      (int)       length of larg
*   in /dmcommon/ : dmvals = values, dmsave = par. strings (sep = '|')
*                   isvflg = 1 or 2 (value or parameter)
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca maxmul
      integer i,ibias,icat,iexcal,iseen,narg
      double precision zzz
      integer           lcmd(1), larg(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca refer
+ca stbuff
+ca datatype
+ca dmcommon

      data iexcal / 0 /
      do  i = 1, narg
        icat = larg(i)
        if (icat .ne. 0)  then
          ibias = mbat + (icat - 1) * mcsiz
          if (isvflg(i). eq. 2)  then
            call dmgstr(i, icleng, dmsave, ntok, token)
            if (ntok .gt. 0)  then
              call dmpsqu(ntok, token)
              jtok = 1
              ntok = ntok + 1
              token(ntok) = ','
              zzz = zero
              call exread(2, zzz, iseen)
              iexcal = iexcal + 1
              call exmake(lcmd, icat, ibias+mcval, dmvals(i), iseen)
            endif
          endif
   10     continue
          call ucopy(dmvals(i), iq(lcmd(1)+ibias+mcval), mwflt)
          iq(lcmd(1)+ibias+mctyp) = 10 * mtflt + isvflg(i)
        endif
      enddo
      end
+ei
+dk dmgferr
+if doom
      subroutine dmgferr(nflmod)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Restores the field errors for all elements of a sequence
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca memdum
+ca maxmul
+ca bankhead
+ca seqflag
+ca prcgroup
+ca cmdgroup
+ca elmgroup
+ca seqgroup
+ca strgroup
+ca message
+ca header
+ca refer
+ca stflag
+ca zunit
+ca dmcommon
      integer icode,ienum,iflag,iocc,ipos,jbyt,nd,ndold,nflerr,
     +nflmod,nl,nst
      double precision dndic,f_errors,radl
      integer listfl(3)
      character*(mcnam) loc_nam
      dimension f_errors(2*(maxmul+1))
      logical dmact
      data listfl / 2, m_field, 0 /

      if (.not.dmact())  goto 999
      call uhtoc(q(lcseq+msbn), mcwrd, seqname, mcnam)
      print *, '<<< DOOM >>> restoring field errors for sequence: ',
     +seqname
      nflerr = 0
      nflmod = 0
*---- Lift error banks, if not already done.
      lsdir = lq(lcseq-msdir)
      lsfld = lq(lcseq-msfld)
      if (lsfld .eq. 0) then
        nl = iq(lsdir-1)
        call mzbook(2, lsfld, lcseq, -msfld, 'EFLD', nl, nl, 0, 2, 0)
      endif
      do 10  ipos = iq(lcseq+msr1), iq(lcseq+msr2)
        call utelem(lcseq, ipos, iflag, loc_nam, iocc, ienum)
        icode = jbyt(iflag,1,mcode)
        if (icode .eq. 1 .and. loc_nam(1:1) .ne. '[')  then
*--- check for existence and modification flag
          listfl(3) = iocc
          call doom_gtime_env('USE ', loc_nam, listfl, dndic)
          if (dndic .lt. zero)  goto 10
          nflerr = nflerr + 1
          if (dndic .le. dltime)  goto 10
          nst = 2 * (maxmul+1)
          call vzero(f_errors, 2 * nst)
          call doom_gfield(loc_nam, iocc, nst, f_errors)
          if (nst .le. 0)  goto 10
          nd = nst * mwflt
          lcfld = lq(lsfld-ipos)
          if (lcfld .ne. 0)  then
            ndold = iq(lcfld-1)
            if (ndold .lt. nd)
     +      call mzpush(0, lq(lsfld-ipos), 0, nd-ndold, ' ')
          else
            call mzbook(2, lcfld, lsfld, -ipos, 'EFLD', 0, 0, nd,
     +      mreal, 0)
          endif
*--- radiation length
          call ucopy(q(lcelm+melen), radl, mwflt)
          call ucopy(f_errors, q(lcfld+1), nd)
*--- mark as loaded from DOOM and not modified
          call sbit1(iq(lcfld), mxdoom)
          call sbit0(iq(lcfld), mxdmod)
          nflmod = nflmod + 1
        endif
   10 continue
      print *,
     +'         >>> elements with field     errors (modified): ',
     +nflerr, ' (', nflmod, ')'
  999 end
+ei
+dk dmgline
+if doom
      subroutine dmgline(label, line, length)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Get next line from string in object "label"
* Input:
*   label (char)     name of object
* Output:
*   line  (char)     next line (blank lines are skipped)
*   length (int)     0 for no more (EOF), else last non-blank
*----------------------------------------------------------------------*
+ca aparam
+ca dmcommon
      integer length
      character * (*) label, line
      character * (mcnam) line_buff
      data line_buff /'empty'/

      if (line_buff(:5) .eq. 'empty')  then
        line_buff = label
        call doom_rline(line_buff)
      elseif (line_buff .ne. label)  then
        print *, '<<< DOOM >>> fatal: only one line buffer allowed'
        stop
      endif
      call doom_gline(line_buff, line, length)
      end
+ei
+dk dmgparm
+if doom
      subroutine dmgparm(label, type, idrflg)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Get parameter from DOOM and link it to MAD-8 structure
* Input:
*   label (char)     name of parameter
*   type  (char)     CONSTANT or PARAMETE
*   idrflg  (int)    if = 1 first load, else update
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca message
+ca option
+ca keyword
+ca refer
+ca datatype
+ca status
+ca stbuff
+ca dmcommon
      integer i,idrflg,ieval,iexpr,ifrst,ikey,iln,ipr,isp,lcpar,
     +nkat
      double precision dndic,rval
      character * (mcnam+4) lname
      character*(mcnam) label, class, type
      character * 8 ltype
      logical dmact
      integer key_list(2)
      integer doom_debug
      data key_list / 0, 0 /

      if (.not.dmact())  goto 999
      if (type .eq. 'CONSTANT')  then
        ltype = type
      else
        ltype = 'PARAMETE'
      endif
*---- Retrieve keyword bank
      call difind(ldkey, ltype, ikey, lckey)
      if (lckey .eq. 0)  then
        print *, '<<< DOOM >>> fatal: keyword CONSTANT or '
     +  //'PARAMETER not found'
        stop
      endif
      call kwget(lckey, iln, ipr, isp, nkat)
      call aabook(lcpar, label, ipr, isp, lckey, 1)
*--- check for existence and modification flag
      lname = label
      call doom_gtime(lname, key_list, dndic)
      if (dndic .lt. zero)  then
        call aawarn('dmgparm', 1,
     +      'parameter ' // lname // 'not found in DOOM.')
        goto 999
      endif
*--- quit if not modified or constant
      call doom_getvar('debug_flag ', doom_debug)
      if (doom_debug .gt. 3) then
        print *, 'dmgparm: ', lname, ' dndic, dltime: ', dndic, dltime
      endif
      if (dndic .le. dltime)  goto 999
      if (ltype .eq. 'CONSTANT' .and. idrflg .ne. 1)  then
        call aawarn('dmgparm', 1,
     +      'attempt to redefine CONSTANT: ' // lname)
        goto 999
      endif
      parload = parload + 1
      class = ltype
      if (doom_debug .gt. 3)  then
        print *, 'dmgparm: label, class, iln, ipr, isp, nkat: ',
     +  label, class, iln, ipr, isp, nkat
      endif
      ntok = lentok
      call doom_gparam(lname, iexpr, rval, ntok, token)
      call dmpsqu(ntok, token)
      if (doom_debug .gt. 3)  then
        print *, 'dmgparm: iexpr, rval, ntok: ', iexpr, rval, ntok
        print '(80a1)', (token(i), i = 1, ntok)
      endif
      jtok = 1
      ieval = 2
      if (iexpr .gt. 1) then
        call exread(ieval, rval, iexpr)
        if (doom_debug .gt. 2)  then
          print *, 'dmgparm: rval, iexpr: ', rval, iexpr
        endif
      else
        token(1) = ';'
      endif
      ifrst = 1
      lccmd = lcpar
      call exmake(lccmd, ifrst, mbat + mcval, rval, iexpr)
      iq(lccmd+mbat+mctyp) = 10 * mtflt + iexpr
*--- mark as loaded from DOOM and not modified
      call sbit1(iq(lccmd), mxdoom)
      call sbit0(iq(lccmd), mxdmod)

*---- if error detected, drop data bank, else link it to directory.
      if (error) then
        call aawarn('dmgparm', 1,
     +      'parameter ' // lname // ' :illegal expression')
        call aadrop(lccmd)
      else
        call didefi(ldbnk, label, lccmd)
      endif

*---- define dump option.
      if (.not. error) then
        if (ideffl .eq. 1 .or. ideffl .eq. 3) then
          call aadump(lccmd)
        endif
        if (ideffl .eq. 2 .or. ideffl .eq. 3) then
          call dzshow('parameter', 0, lccmd, 'v', 0, 0, 0, 0)
        endif
      endif

  999 end
+ei
+dk dmgsequ
+if doom
      subroutine dmgsequ(label)
      implicit none
*----------------------------------------------------------------------*
* purpose:
*   create a beam line sequence.
*   magnets and their central positions are given,
*   the drift spaces in between are generated by this routine.
* input:
*   label     (char)    name for generated sequence.
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer i,idata,idir,ikey,iln,imark,index,ipr,isp,k,leng,l_2,mdi,
     +mpi,n,nelem,nkat
      double precision dndic,temp
      character*(mcnam) label
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca markbits
+ca prcgroup
+ca message
+ca lnlink
+ca option
+ca stbuff
+ca refer
+ca status
+ca dmcommon
      integer doom_debug
      dimension temp(20)
      logical dmact
      character*(mcnam) clsnam, elmnam, class
      parameter         (mdi = 500, mpi = mwflt * mdi)
      integer key_list(2)
      data key_list / 1, 106 /

      if (.not.dmact())  goto 999
*--- check for existence and modification time
      n = 0
      call doom_gtime(label, key_list, dndic)
*--- quit if not modified
      call doom_getvar('debug_flag ', doom_debug)
      if (doom_debug .gt. 3)
     +print *, 'dmgsequ: ', label, ' dndic, dltime: ', dndic, dltime
      if (dndic .lt. zero)  then
        call aawarn('dmgsequ', 1,
     +      'sequence ' // label // 'not found in DOOM.')
        goto 999
      endif
      if (dndic .le. dltime)  goto 999
      error = .false.
      class = 'SEQUENCE'
*---- lift bank, link it to keyword, and mark it as modified.
      call difind(ldkey, class, ikey, lckey)
      if (lckey .eq. 0) then
        print *, '<<< DOOM >>> fatal: keyword SEQUENCE not found'
        stop
      endif
      call kwget(lckey, iln, ipr, isp, nkat)
      call aabook(llneat, label, ipr, isp, lckey, 1)

*---- push command bank to make room for mdi element positions.
      call mzpush(0, llneat, mdi, mpi + 1, 'I')
      iq(llneat+mbat+mcsiz+1) = 16 * mpi + mreal
      idata = mbat + mcsiz + 2

*---- book bank for directory index table.
*     link 1 is reserved for sequence flag bank.
      call mzbook(2, llnedr, llneat, -1, 'SDIR', 1, 1, mdi + 1, 2, 0)
      nelem = 1
      nsleng = maxseql
      l_2 = mcnam
      call doom_gsequ(label, nsleng, l_2, elm_nam, occt, s_pos)
      if (nsleng .lt. 0)  then
        print *, '<<< DOOM >>> fatal: sequence ', label, ' not found'
        stop
      endif
      call doom_getvar('debug_flag ', k)
      if (k .gt. 1)  then
        print 10001, label, nsleng, s_pos(nsleng)
      endif
      if (k .gt. 2)  then
        print '(''name'', t18, ''occurence'', t29, ''centre'')'
      endif
      seqload = seqload + 1
      do i = 1, nsleng
        if (k .gt. 2)  then
          print '(a, i10, 1p, d12.4)', elm_nam(i), occt(i), s_pos(i)
        endif
        elmnam = elm_nam(i)
        clsnam = elmnam
*---- look up class name.
        call utleng(clsnam, leng)
        call difind(ldbnk, clsnam(1:leng), idir, lccls)
        if (index(elmnam, '$') .ne. 0) then
          continue
        elseif (lccls .eq. 0) then
          msg(1) = 'unknown class name "' // clsnam(1:leng)
     +    // '" skipped.'
          call aawarn('dmgseq', 1, msg)
*---- must be beam element.
        elseif (iq(lccls+mbpr) .eq. mpelm) then
          call bmgelm(lccls, temp)
          nelem = nelem + 1
          if (nelem .gt. iq(llnedr-1)) then
            call mzpush(0, llnedr, 0,   mdi, 'I')
            call mzpush(0, llneat, mdi, mpi, 'I')
          endif
*---- position value is simple value
          call exmake(llneat, nelem, idata, s_pos(i), 1)
          idata = idata + mwflt

*---- set flag for allowable copy.
          call sbit1(iq(lccls), mxals)

*---- store directory index.
          iq(llnedr+nelem) = idir
        endif
      enddo
      if (temp(1) .ne. zero)  then
*---- Append end marker.
        call difind(ldbnk, 'END', imark, lcelm)
        if (imark .eq. 0) then
          call difind(ldkey, 'MARKER', ikey, lckey)
          call kwget(lckey, iln, ipr, isp, nkat)
          call direfe(ldbnk, 'END ', imark)
          lq(ldbnk(3)-imark) = lq(lckey-3)
        endif
        call ucopy(s_pos(nsleng), q(llneat+idata), mwflt)
        nelem = nelem + 1
        iq(llnedr+nelem) = imark
      endif
*---- if all ok, define this sequence.
*     do not drop excessive space; may be used in sequence editor.
      if (error) then
        call lndrop(llneat)
      else
        iq(llnedr+1) = nelem
        call didefi(ldbnk, label, llneat)
*--- store mark as loaded from DOOM and not modified (after enuse)
        sqlmark = 0
        call sbit1(sqlmark, mxdoom)
        call sbit0(sqlmark, mxdmod)
      endif

10001 format(/'restoring sequence ', a, ' no. elements', i6,
     +  ' length = ', 1p, d12.4/)
  999 end
+ei
+dk dmgstr
+if doom
      subroutine dmgstr(nsp, nup, strin, nch, strout)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   extracts string from packed string array, sep. char. = '|'
*   nsp = string # looked for
*----------------------------------------------------------------------*
+ca aparam
      integer i,k,kc,nch,nsp,nup
      character * (*) strin
      character * 1 strout(*)

      nch = 0
*--- skip nsp-1 times '|'
      kc = 0
      if (nsp .gt. 1)  then
        do k = 1, nup
          if (strin(k:k) .eq. '|')  kc = kc + 1
          if (kc .eq. nsp - 1)  goto 10
        enddo
        goto 999
      endif
   10 continue
      do i = k+1, nup
        if(strin(i:i) .eq. '|')  goto 999
        nch = nch + 1
        strout(nch) = strin(i:i)
      enddo
  999 end
+ei
+dk dmifile
+if doom
      subroutine dmifile(filename)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Stores the d.b. filename in common
* Input:
*   filename   (char)
*----------------------------------------------------------------------*
+ca aparam
+ca header
+ca refer
+ca dmcommon
      character *(*)   filename

      doom_name = filename
      end
+ei
+dk dminit
+if doom
      subroutine dminit
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Opens the DOOM database, sets the dmuse flag, sets doom time
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca header
+ca refer
+ca dmcommon
      integer nalerr,nalstore,ncorrect,ncorstore,nflerr,nflstore,
     +nmonitor,nmonstore,lastact
      common / dm2comm /
     +nalerr,nalstore,ncorrect,ncorstore,nflerr,nflstore,
     +nmonitor,nmonstore,lastact
      integer nnn

      nnn = 0
      call doom_setvar('debug_flag ', nnn)
      indoom = 740614
      seqstore = 0
      elstore = 0
      elload = 0
      parstore = 0
      parload = 0
      dltime = 0
      nshutin = 0
      nmult = 0
      nalerr = 0
      nflerr = 0
      ncorrect = 0
      nmonitor = 0
      nalstore = 0
      nflstore = 0
      ncorstore = 0
      nmonstore = 0
      noupdate = .false.
*--- skipfl set to false by dmshut to always store para. + elements
      skipfl = .true.
*--- nfsave = 1: do not save, =2: save tree at closure (doom tree)
      if (tree)  then
        nfsave = 2
      else
        nfsave = 1
      endif
      call dmopen
      usename = ' '
      seqname = ' '
      opt_name = ' '
      end
+ei
+dk dmlsqu
+if doom
      subroutine dmlsqu(nl, cl)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   replace [...] by ->...
* Input:
*   nl  (int)           length of cl
* I/O:
*   cl  (char*1 array)  array to be modified
*----------------------------------------------------------------------*
+ca aparam
      integer i,k,nl
      character*1 cl(*)

      k = nl + 1
      do 10  i = nl, 1, -1
        if (cl(i) .ne. ']')  then
          if (cl(i) .eq. '[')  then
            k = k - 2
            cl(k) = '-'
            cl(k+1) = '>'
          else
            k = k - 1
            cl(k) = cl(i)
          endif
        endif
   10 continue
      end
+ei
+dk dmmain
+if doom
      subroutine dmmain(iproc)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Saves + restores selected part(s) of structure in DOOM
*--- Input:
*    iproc   process code: 1 reload, 2 store
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca memdum
+ca bankhead
+ca prcgroup
+ca cmdgroup
+ca datatype
+ca seqgroup
+ca strgroup
+ca message
+ca header
+ca option
+ca refer
+ca status
+ca zunit
+ca dmcommon
      integer icat,idir,ikey,iln,ipr,iproc,isp,jbit,lll,ncat,
     +nkat,nalmod,nflmod
      logical dmact
      logical warn_keep
      integer doom_newdb
      character * (mcnam) class

      if (.not.dmact())  goto 999
      warn_keep = warn
      warn = .false.
*--- load request
      if (mod(iproc, 10) .eq. 1)  then
        if (doom_newdb() .ne. 0)  goto 999
        if (iproc .lt. 10)  then
          if (seqname .ne. ' ')  then
            call dmgsequ(seqname)
          endif
        else
          call dmgdir(2)
        endif
        call exfill
        if (.not. error) then
*---- order and evaluate expressions.
          call exordr
          if (.not. error) then
            call exupdt
          endif
        endif
*---- Propagate change flags in data structure.
        call aapmod
*---- Load in BEAM common from BEAM bank.
        call enget
        if (seqname .ne. ' ' .and. iproc .lt. 10)  then
          class = 'USE'
          call difind(ldkey, class, ikey, lckey)
          if (lckey .eq. 0)  then
            print *, '<<< DOOM >>> fatal: key ',
     +      class, ' not found'
            stop
          endif
          call kwget(lckey, iln, ipr, isp, nkat)
*---- build new keyword bank
          call aabook(lccmd, class, ipr, isp, lckey, 1)
*---- find class object, if not already known.
          if (lccls .eq. 0) lccls = lq(lckey-3)
*---- copy attributes of class.
          ncat = iq(lccls+mbat)
          do  icat = 1, ncat
            call aacopy(lccls, icat, lccmd)
          enddo
          iq(lccmd+mbat+mctyp) = 10 * mtlin + 1
          call difind(ldbnk, seqname, iq(lccmd+mbat+mcval), lll)
          call enuse
          if (lcseq .gt. 0)  iq(lcseq) = sqlmark
          call doom_setenv('USE ', usename)
        endif
        if (lcseq .ne. 0)  then
*--- restore errors for elements in current sequence
          call dmgalerr(nalmod)
          call dmgferr(nflmod)
          if (nalmod .gt. 0 .or. nflmod .gt. 0)  then
*--- create table for correctors and monitors
            error = .false.
            call cotble(error)
            if (error)  then
              print *, '<<< DOOM >>> warning: machine unstable'
              error = .false.
              goto 10
            endif
          endif
*--- restore corrector and monitor values
          call dmgcorm
        endif
   10   continue
        print *, '<<< DOOM >>> restore: # sequ.s, #elements,',
     +  ' # param.: ', seqload, elload, parload
        seqload = 0
        elload = 0
        parload = 0
*--- reset all doom-mod flags
        do idir = iq(ldbnk(3)+3) + 1, iq(ldbnk(3)+1)
          lccls = lq(ldbnk(3)-idir)
          if (lccls .ne. 0) call sbit0(iq(lccls), mxdmod)
        enddo
*--- store request
      elseif (.not.(noupdate .or. scan))  then
*---- fill in variable references.
        error = .false.
        call exfill
        if (.not. error) then
*---- order and evaluate expressions.
          call exordr
          if (.not. error) then
            call exupdt
          endif
        endif
*---- save parameter and element definitions.
        do 210 idir = iq(ldbnk(3)+3) + 1, iq(ldbnk(3)+1)
          lccls = lq(ldbnk(3)-idir)
          if (lccls .ne. 0) then
*--- skip if loaded from d.b. and not modified
            if (skipfl .and. jbit(iq(lccls),mxdoom) .eq. 1 .and.
     +      jbit(iq(lccls),mxdmod) .eq. 0) go to 210
            ipr   = iq(lccls+mbpr)
            isp   = iq(lccls+mbsp)
            if (ipr .eq. mppar) then
*--- parameter
              call dmpparm(lccls)
            elseif (ipr .eq. mpelm .and. lccls
     +      .ne. lq(lq(lccls+1)-3)) then
*--- element
              call dmpdefn(idir)
            elseif (ipr .eq. mpenv .and. isp .eq. 2) then
*--- beta0 bank
              call dmpbeta(lccls)
            endif
          endif
  210   continue
        do idir = iq(ldbnk(3)+3) + 1, iq(ldbnk(3)+1)
          lccls = lq(ldbnk(3)-idir)
          if (lccls .ne. 0) then
            ipr   = iq(lccls+mbpr)
            if (ipr .eq. mppar .or.
     +      (ipr .eq. mpelm .and. lccls .ne. lq(lq(lccls+1)-3)))
     +      then
              call sbit1(iq(lccls), mxdoom)
              call sbit0(iq(lccls),mxdmod)
            endif
          endif
        enddo
      endif
      warn = warn_keep
  999 end
+ei
+dk dmmult
+if doom
      subroutine dmmult
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   stores an object with the multipole reference radii and orders
*----------------------------------------------------------------------*
+ca aparam
+ca dmcommon
      integer keylist,lchar,lin
      data keylist / 0 /

      if (nmult .gt. 0)  then
        lin = nmult * mcnam
        call doom_compress(multname, lin, lchar)
        call doom_store('MULTREFS_MAD ', keylist,
     +  nmult, nmult, lchar, multord, refmult, multname)
      endif
      end
+ei
+dk dmopen
+if doom
      subroutine dmopen
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   opens the DOOM database
*----------------------------------------------------------------------*
+ca aparam
+ca header
+ca refer
+ca dmcommon
      integer leng
      logical dmuse, dmact
      integer doom_newdb

      if (dmuse() .and..not.dmact())  then
        call doom_open(doom_name)
        if (newdb .eq. 123456 .and. doom_newdb() .eq. 0)  then
          call utleng(doom_name, leng)
          print *, '<<< DOOM >>> fatal: d.b. >>> ', doom_name(:leng),
     +    ' <<< is not empty (DOOM CREATE)'
          stop
        endif
        actdoom = 661227
      endif
      end
+ei
+dk dmopt1
+if doom
      subroutine dmopt1(tname, kflag, ntab, ctab, iform)
      implicit none
*----------------------------------------------------------------------*
*--- initial routine for optics tables (TWISS, TWISS3, OPTICS)
*
*--- input: tname             table name
*           kflag             "position" flag: 3 centre, else end
*           ntab              no. of column names in ctab, or:
*                             -1: TWISS, -2: TWISS3, -3: EIGEN
*           ctab              selected column names
*           iform             column format
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca dmcommon
      integer i,kflag,n,ntab
      character *(mcnam) tname, ctab(*)
      integer iform(*)
      character * (mcnam) tb_names(mtwcol,3)
      integer tb_size(3)
      data tb_size / 29, 43, mtwcol /
      data (tb_names(i,1), i = 1, 29)
     +  / 'S',
     +    'BETX',   'ALFX',   'MUX',    'BETY',   'ALFY',   'MUY',
     +    'X',      'PX',     'Y',      'PY',
     +    'DX',     'DPX',    'DY',     'DPY',
     +    'WX',     'PHIX',   'DMUX',   'WY',     'PHIY',   'DMUY',
     +    'DDX',    'DDPX',   'DDY',    'DDPY',
     +    'R(1,1)', 'R(2,1)', 'R(1,2)', 'R(2,2)'                   /
      data (tb_names(i,2), i = 1, 43)
     +  / 'S',
     +    'XCO',   'PXCO',  'YCO',   'PYCO',  'TCO',   'PTCO',
     +    'DX',    'DPX',   'DY',    'DPY',   'DT',    'DPT',
     +    'BETX1', 'BETY1', 'BETT1',
     +    'BETX2', 'BETY2', 'BETT2',
     +    'BETX3', 'BETY3', 'BETT3',
     +    'ALFX1', 'ALFY1', 'ALFT1',
     +    'ALFX2', 'ALFY2', 'ALFT3',
     +    'ALFX3', 'ALFY3', 'ALFT3',
     +    'GAMX1', 'GAMY1', 'GAMT1',
     +    'GAMX2', 'GAMY2', 'GAMT2',
     +    'GAMX3', 'GAMY3', 'GAMT3',
     +    'MU1',   'MU2',   'MU3' /
      data (tb_names(i,3), i = 1, mtwcol)
     +  / 'S',
     +    'XCO',  'PXCO', 'YCO',  'PYCO', 'TCO',  'PTCO',
     +    'E11',  'E21',  'E31',  'E41',  'E51',  'E61',
     +    'E12',  'E22',  'E32',  'E42',  'E52',  'E62',
     +    'E13',  'E23',  'E33',  'E43',  'E53',  'E63',
     +    'E14',  'E24',  'E34',  'E44',  'E54',  'E64',
     +    'E15',  'E25',  'E35',  'E45',  'E55',  'E65',
     +    'E16',  'E26',  'E36',  'E46',  'E56',  'E66',
     +    'MU1',  'MU2',  'MU3' /
      opt_name = tname
      lcc_optsum = 0
      lcc_row = 0
      ntw_warn = 0
      opt_row = 0
      if (kflag .eq. 3)  then
        pos_flag = 2
      else
        pos_flag = 3
      endif
      call doom_setvar('twiss_count ', lcc_optsum)
      if (ntab .lt. 0)  then
        n = -ntab
        opt_col = tb_size(n)
        do i = 1, opt_col
          opt_table(i) = tb_names(i,n)
        enddo
      else
        opt_col = 0
        do i = 1, ntab
          if (iform(i) .lt. 5)  then
            opt_col = opt_col + 1
            opt_table(opt_col) = ctab(i)
          endif
        enddo
        if (opt_col .eq. 0)  then
          call aawarn('dmopt1', 1, 'empty DOOM optics table ignored')
        endif
      endif
      end
+ei
+dk dmopt2
+if doom
      subroutine dmopt2(ntab, itab, iform, table)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   fills an optics table (TWISS, TWISS3, OPTICS)
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca beam
+ca optic1
+ca dmcommon
*
*--- input: ntab              no. of column names in ctab, or:
*                             -1: TWISS, -2: TWISS3
*           itab              reference pointers for values (OPTICS)
*           iform             column format                 (OPTICS)
*           table             value table                   (OPTICS)
      integer i,j,k,n,ns,ntab
      double precision table
      integer itab(*), iform(*)
      dimension table(*)
      character * 32 text
      data text / 'optics buffer cut at row: ' /

      ns = opt_row * opt_col
      opt_row = opt_row + 1
      lcc_row = max(lcc_row, opt_row)
      elm_nam(opt_row) = currname
      occt(opt_row) = currocct
      if (ns+opt_col .gt. mtw_leng)  then
        if (ntw_warn .eq. 0)  then
          ntw_warn = 1
          write(text(27:32), '(i6)')  opt_row
          call aawarn('dmopt2', 1, text)
        endif
      elseif (ntab .lt. 0)  then
        n = -ntab
        if (n .eq. 1)  then
*--- Twiss
          optics_tb(ns+ 1) = suml
          optics_tb(ns+ 2) = betx
          optics_tb(ns+ 3) = alfx
          optics_tb(ns+ 4) = amux / twopi
          optics_tb(ns+ 5) = bety
          optics_tb(ns+ 6) = alfy
          optics_tb(ns+ 7) = amuy / twopi
          optics_tb(ns+ 8) = orbit(1)
          optics_tb(ns+ 9) = orbit(2)
          optics_tb(ns+10) = orbit(3)
          optics_tb(ns+11) = orbit(4)
          optics_tb(ns+12) = disp(1)
          optics_tb(ns+13) = disp(2)
          optics_tb(ns+14) = disp(3)
          optics_tb(ns+15) = disp(4)
          optics_tb(ns+16) = wx
          optics_tb(ns+17) = phix / twopi
          optics_tb(ns+18) = dmux / twopi
          optics_tb(ns+19) = wy
          optics_tb(ns+20) = phiy / twopi
          optics_tb(ns+21) = dmuy / twopi
          optics_tb(ns+22) = ddisp(1)
          optics_tb(ns+23) = ddisp(2)
          optics_tb(ns+24) = ddisp(3)
          optics_tb(ns+25) = ddisp(4)
          optics_tb(ns+26) = rmat(1,1)
          optics_tb(ns+27) = rmat(2,1)
          optics_tb(ns+28) = rmat(1,2)
          optics_tb(ns+29) = rmat(2,2)
        elseif (n .eq. 2)  then
*--- Twiss3
          optics_tb(ns+ 1) = suml
          ns = ns + 1
          do i = 1, 6
            optics_tb(ns+i)   = orbit(i)
            optics_tb(ns+i+6) = disp(i)
          enddo
          ns = ns + 12
          j = 0
          do  i = 1, 3
            do  k = 1, 3
              j = j + 1
              optics_tb(ns+j)    = dmbet(k,i)
              optics_tb(ns+j+9)  = dmalf(k,i)
              optics_tb(ns+j+18) = dmgam(k,i)
            enddo
          enddo
          ns = ns + 27
          do  i = 1, 3
            optics_tb(ns+i) = dmamu(i)
          enddo
        elseif (n .eq. 3)  then
*--- Eigen
          optics_tb(ns+ 1) = suml
          ns = ns + 1
          do i = 1, 6
            optics_tb(ns+i)   = orbit(i)
          enddo
          ns = ns + 6
          do i = 1, 36
            optics_tb(ns+i)   = dmemat(i)
          enddo
          ns = ns + 36
          do i = 1, 3
            optics_tb(ns+i)   = dmamu(i)
          enddo
        endif
      else
*--- Optics
        j = 0
        do i = 1, ntab
          if (iform(i) .lt. 5)  then
            j = j + 1
            optics_tb(ns+j) = table(itab(i))
          endif
        enddo
      endif
      end
+ei
+dk dmopt3
+if doom
      subroutine dmopt3(ntab)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   store an optics table in DOOM, keep summary, reset
*----------------------------------------------------------------------*
+ca aparam
+ca seqgroup
+ca beam
+ca memdum
+ca refer
+ca dmcommon
+ca twdata
      character*48 tname
      integer i,ns,ntab
      call uhtoc(q(lcseq+msbn), mcwrd, seqname, mcnam)
      if (opt_name .eq. 'OPTICS')  then
        tname = 'OPTICS.' // seqname
      else
        tname = opt_name
      endif
      ns = -ntab
      if (opt_row .gt. 0)  then
*--- store in doom
        call doom_ptbody(tname, seqname, opt_col, opt_row,
     +                   mcnam, elm_nam, occt, optics_tb)
        opt_row = 0
        ntw_warn = 0
        lcc_optsum = lcc_optsum + 1
        if (ns .lt. 2)  then
*--- save summary table
          optics_summ( 1,lcc_optsum) = deltas
          optics_summ( 2,lcc_optsum) = alfa
          optics_summ( 3,lcc_optsum) = gamtr
          optics_summ( 4,lcc_optsum) = qx
          optics_summ( 5,lcc_optsum) = qy
          optics_summ( 6,lcc_optsum) = xix
          optics_summ( 7,lcc_optsum) = xiy
          optics_summ( 8,lcc_optsum) = sigxco
          optics_summ( 9,lcc_optsum) = sigyco
          optics_summ(10,lcc_optsum) = xcomax
          optics_summ(11,lcc_optsum) = ycomax
          optics_summ(12,lcc_optsum) = bxmax
          optics_summ(13,lcc_optsum) = bymax
          optics_summ(14,lcc_optsum) = dxmax
          optics_summ(15,lcc_optsum) = dymax
          optics_summ(16,lcc_optsum) = sigdx
          optics_summ(17,lcc_optsum) = sigdy
        else
          do i = 1, 17
            optics_summ(i,lcc_optsum) = 0.d0
          enddo
        endif
      endif
      end
+ei
+dk dmopt4
+if doom
      subroutine dmopt4
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   store optics summary table
*----------------------------------------------------------------------*
+ca aparam
+ca seqgroup
+ca memdum
+ca refer
+ca dmcommon
+ca twdata
      character *(mcnam) prep_list(max_opt)
      character*48 tname
      integer positions(max_opt)
      if (opt_name .eq. 'OPTICS')  then
        tname = 'OPTICS.' // seqname
      else
        tname = opt_name
      endif
      call uhtoc(q(lcseq+msbn), mcwrd, seqname, mcnam)
      if (opt_row .gt. 0)  then
*--- store last table in doom
        call doom_ptbody(tname, seqname, opt_col, opt_row,
     +                   mcnam, elm_nam, occt, optics_tb)
      endif
*--- prepare names table
      call doom_prtab(opt_table, opt_col, mcnam, prep_list, positions)
      call doom_pthead(tname, seqname, ndelta, lcc_row,
     +mtwscol, optics_summ, opt_col, pos_flag, prep_list, positions)
      end
+ei
+dk dmpbeta
+if doom
      subroutine dmpbeta(lbank)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Save data for one beta0 bank in DOOM
* Input:
*   LBANK(1)    (pointer) Bank pointer.
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer i,ibias,isp,j,l,lastnb,ncat,ncnt,nl,nn,nw,nz
      integer           lbank(1)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca keyword
+ca refer
+ca datatype
+ca dmcommon

      logical dmact
      integer doom_nadd
      character*(mcnam) label, tmp

      if (.not.dmact())  goto 999
      ncat = iq(lbank(1)+mbat)
      isp = iq(lbank(1)+mbsp)
      if (isp .eq. 2) then
        nz = 0
        isvcnt = 0
        nw = 0
*---- Retrieve label and keyword definition.
        call diname(ldbnk, iq(lbank(1)+mbnam), label)
        ncnt = (iq(lbank(1)-1) - mbat) / mcsiz
        call utgflt(lbank(1), 1, ncnt, dmvals)
        do i = 1, ncnt
          ibias = mbat + nw * mcsiz
          call uhtoc(q(lbank(1)+ibias+mcval), mcwrd, tmp, mcnam)
          l = lastnb(tmp)
          dmsave(isvcnt+1:isvcnt+l) = tmp
          isvcnt = isvcnt + l
          dmsave(isvcnt+1:isvcnt+1) = '|'
          isvcnt = isvcnt + 1
          do j = 1, mcf2
            isvflg(mcf2*nw+j) = iq(lbank(1)+ibias+j)
          enddo
          nw = nw + 1
        enddo
        nn = mcf2*nw
        call doom_store(label, nz, nn, ncnt, isvcnt, isvflg, dmvals,
     +  dmsave)
        call doom_ptype(label, nz, 'BETA0 ')
*--- add to directory
        nl = mcnam
        if (ndirec .eq. maxbuff)  then
          print *, '<<< DOOM >>> fatal: DIRECTORY size ',
     +    maxbuff, ' reached'
          stop
        endif
        nn = doom_nadd(label, director, ndirec, nl)
        ndirec = nn
      endif
  999 end
+ei
+dk dmpdefn
+if doom
      subroutine dmpdefn(idir)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Save data for one data bank (element or command) in DOOM
* Input:
*   idir    (int)    position in directory bank
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer idir,jdir,ncat
      integer           lbank(1), lparent(1)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca keyword
+ca refer
+ca option
+ca datatype
      logical dmact
      character*(mcnam) label, parent

      if (.not.dmact())  goto 999
*---- Retrieve label and keyword definition.
      lbank(1) = lq(ldbnk(3)-idir)
      call diname(ldbnk, idir, label)
      if (.not.(iq(lbank(1)+mbsp) .eq. 1  .and.
     +label(1:1) .eq. '['  .and.  label(8:) .eq. ']')) then
        jdir  = iq(lbank(1)+mbnam)
        if (jdir .eq. idir)  then
          ncat = iq(lbank(1)+mbat)
          lparent(1) = lq(lbank(1)-ncat-mbecls)
*---- parent name.
          call diname(ldbnk, iq(lparent(1)+mbnam), parent)
        else
          call diname(ldbnk, jdir, parent)
        endif
        call dmpelm(lbank, label, parent)
      endif
  999 end
+ei
+dk dmpdir
+if doom
      subroutine dmpdir
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Stores DIRECTORY
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca header
+ca refer
+ca stbuff
+ca dmcommon
      integer j,n,nn
      character * (mcnam) dname
      integer doom_debug

      dname = 'DIRECTORY'
      call doom_getvar('debug_flag ', doom_debug)
      if (doom_debug .gt. 1)  then
        print '(a,a)', 'storing object ', dname
        print '(4a17)', (director(j), j = 1, ndirec)
      endif
      n = 0
      nn = mcnam
      call doom_pdirect(dname, ndirec, nn, director)
      end
+ei
+dk dmpelm
+if doom
      subroutine dmpelm(lelm, ellns, parent)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Enter element in DOOM
* Input:
*   LELM(1)   (pointer) Current element bank.
*   ellns     (char)    element name
*----------------------------------------------------------------------*
* Important mod HG 14.10.99:
* invert signs of skew components (dipole->multipole)
*----------------------------------------------------------------------*
*  element definition: (F: Fortran, C: C/C++)
*  d.p. array
*  word / e_type = 1            = 2                               = 3
      integer i,i1,i2,ibias,idlast,ipr,isp,na,nl,nn
      double precision angle,cosa,ratio,sina

*  1    l      [m]          l [m]                             l [m]
*  2    rhoinv [1/m]        volt [MV]                          kick
*  3    e1                  ex [MV/m]                           .
*  4    e2                  ey [MV/m]                           .
*  5    h1                  freq [MHz]                          .
*  6    h2                  lag [2 Pi]                          .
*  7    tilt                tilt                               kick
*  8    ks                  betrf                            8-43: rm
*  9    hgap [m]            pg {MW]                         44-259: tm
* 10    fint [Tm]           shunt [MOhm/m]
* 11    angle = K_0*l       tfill [micro sec]
* 12    lrad                harmon
* 13    k0 or k0*l (l=0)    xsize (coll.) or xma (beam-beam)
* 14    k0s or k0s*l        ysize (coll.) or yma (beam_beam)
* 15    k1 or k1*l (l=0)    sigx
* 16    k1s or k1s*l        sigy
* 17    k2 or k2*l          fractional charge
* 18    k2s  etc.           # particles opposite beam

* int array: as d.p. array, containing expression flag:
* ex_flag = 1   value
* ex_flag > 1   expression
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca maxmul
+ca beam
      integer           lelm(1)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca codata
+ca refer
+ca dmcommon

      character * (mcnam) ellns, parent
      logical dmact
      integer doom_nadd
      integer larg(maxcom), largbd(20), largcl(14), largqu(16),
     +largsx(18), largoc(20), largss(8), largcv(12), largel(7),
     +largcvl(6), largrt(7), larggb(16), largbb(18), largbb6(23)
      save idlast
      data idlast/ maxcom /
      data largbd / 2, 0, 5, 6, 9, 10, 7, 0, 11, 12,
     +              3, 0, 0, 0, 4, 0, 8, 0, 13, 0 /
      data largcl / 2, 11 * 0, 3, 4 /
      data largqu / 2, 5 * 0, 4, 7 * 0, 3, 0 /
      data largsx / 2, 5 * 0, 4, 9 * 0, 3, 0 /
      data largoc / 2, 5 * 0, 4, 11 * 0, 3, 0 /
      data largss / 2, 6 * 0, 3 /
* largcv: l,volt,,,(freq),lag,,betrf,pg,shunt,tfill,harmon
      data largcv / 2, 3, 0, 0, 5, 4, 0, 7, 8, 9, 10, 6 /
* largcvl: l,volt,,,freq,lag
      data largcvl / 2, 4, 0, 0, 6, 5/
      data largel / 2, 0, 3, 0, 0, 0, 4 /
      data largrt / 2, 0, 0, 0, 0, 0, 3 /
      data larggb / 2, 0, 5, 6, 9, 10, 7, 0, 11, 12,
     +              3, 0, 0, 0, 4, 8 /
      data largbb / 12 * 0, 5, 6, 3, 4, 7, 0 /
      data largbb6 /0, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
     +              17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27 /

      if (.not.dmact())  goto 999
*--- initialize expression list
      isvcnt = 0
*---- select element type.
      isp = iq(lelm(1)+mbsp)
*--- default number of attributes and doom type
      idleng = 1
      ipr = 5
      do 1 i = 1, idlast
    1 dmvals(i) = zero

      go to ( 10,  20,  30,  40,  50,  60,  70,  80,  90, 100,
     +       110, 120, 130, 140, 150, 160, 170, 180, 190, 200,
     +       210, 220, 230, 240, 250, 260, 270, 280, 290, 300,
     +       310, 310, 310, 310, 310, 310, 310, 310, 310, 310), isp

*---- drift.
   10 continue
*---- monitors.
  170 continue
  180 continue
  190 continue
*---- beam instrument.
  240 continue
      larg(1) = 2
      idleng = 1
      call dmpelp(lelm, larg, idleng)
      go to 500
*---- collimators.
  200 continue
  210 continue
      idleng = 14
      call dmpelp(lelm, largcl, idleng)
      go to 500

*---- rectangular bend (part 1)
   20 continue
      idleng = 20
      call dmpelp(lelm, largbd, idleng)
      if (dmvals(1) .ne. zero .and. dmvals(11) .ne. zero) then
        dmvals(13) = dmvals(11) / dmvals(1)
        dmvals(2) = abs(dmvals(13))
        ratio = 2 * sin(dmvals(11)/2) / dmvals(11)
        do i = 14, 20, 2
          dmvals(i-1) = dmvals(i-1) * ratio
        enddo
      else
        dmvals(13) = dmvals(11)
        ratio = 1
      endif
      goto 31
*---- sector bend or rect. bend (part 2).
   30 continue
      idleng = 20
      call dmpelp(lelm, largbd, idleng)
      ratio = 1
      if (dmvals(1) .ne. zero) then
        dmvals(13) = dmvals(11) / dmvals(1)
        dmvals(2) = abs(dmvals(13))
      else
        dmvals(13) = dmvals(11)
      endif
   31 continue
      dmvals(2) = ratio * dmvals(2)
      if (dmvals(7) .ne. zero)  then
        cosa = cos(dmvals(7))
        sina = sin(dmvals(7))
        do i = 14, 20, 2
          dmvals(i)   = sina * dmvals(i-1)
          dmvals(i-1) = cosa * dmvals(i-1)
        enddo
      endif
      go to 500

*---- quadrupole.
   50 continue
      idleng = 16
      call dmpelp(lelm, largqu, idleng)
      if (dmvals(7) .ne. zero)  then
        cosa = cos(2*dmvals(7))
        sina = sin(2*dmvals(7))
*--- minus sign to compensate minus sign in dictionary HG 11.12.01
        dmvals(16) = -sina * dmvals(15)
        dmvals(15) = cosa * dmvals(15)
      endif
      go to 500

*---- sextupole.
   60 continue
      idleng = 18
      call dmpelp(lelm, largsx, idleng)
      if (dmvals(7) .ne. zero)  then
        cosa = cos(3*dmvals(7))
        sina = sin(3*dmvals(7))
*--- minus sign to compensate minus sign in dictionary HG 11.12.01
        dmvals(18) = -sina * dmvals(17)
        dmvals(17) = cosa * dmvals(17)
      endif
      go to 500

*---- octupole.
   70 continue
      idleng = 20
      call dmpelp(lelm, largoc, idleng)
      if (dmvals(7) .ne. zero)  then
        cosa = cos(4*dmvals(7))
        sina = sin(4*dmvals(7))
        dmvals(20) = sina * dmvals(19)
        dmvals(19) = cosa * dmvals(19)
      endif
      go to 500

*---- multipole.
   80 continue
*--- MAD-8 only knows thin multipoles
      do  i = 1, 11
        larg(i) = 0
      enddo
*--- angle + ko*l
      larg(11) = 3
*--- radiation length
      larg(12)  = 2
*--- dmvals(12+2*j+1): component 2*j,  dmvals(12+2*j+2): tilt angle
      na = min(2 * maxmul + 2, iq(lelm(1) + mbat))
      do 82 i = 3, na
   82 larg(i+10) = i
      idleng = na + 10
      call dmpelp(lelm, larg, na+10)
      do 83 i = 2, na-2, 2
        i2 = i / 2
        if (dmvals(i+12) .ne. zero) then
          angle = i2 * dmvals(i+12)
          cosa = cos(angle)
          sina = sin(angle)
*---- changed sign of dmvals(i+12)  16.4.98
*---- back to previous - sign of tilt now changed in dictionary 3.8.00
          dmvals(i+12) = sina * dmvals(i+11)
          dmvals(i+11) = cosa * dmvals(i+11)
        endif
   83 continue
      go to 500

*---- solenoid.
   90 continue
      idleng = 8
      call dmpelp(lelm, largss, idleng)
      go to 500

*---- rf cavity.
  100 continue
      idleng = 12
      call dmpelp(lelm, largcv, idleng)
*--- harmon is integer !
      ibias = mbat + 5 * mcsiz
      dmvals(12) = iq(lelm(1)+ibias+mcval)
      go to 500

*---- electrostatic separator.
  110 continue
      idleng = 7
      call dmpelp(lelm, largel, idleng)
      if (dmvals(7) .ne. zero)  then
        cosa = cos(dmvals(7))
        sina = sin(dmvals(7))
        dmvals(4) = sina * dmvals(3)
        dmvals(3) = cosa * dmvals(3)
      endif
      go to 500

*---- coordinate rotations.
  120 continue
  130 continue
      idleng = 7
      call dmpelp(lelm, largrt, idleng)
      go to 500

*---- orbit correctors.
  140 continue
  150 continue
  160 continue
*---- original setting.
      do 161 i = 1, 14
  161 larg(i) = 0
      larg(1)  = 2
      if (isp .eq. 14) then
        larg(13) = 3
      else if (isp .eq. 16) then
        larg(14) = 3
      else
        larg(13) = 3
        larg(14) = 4
      endif
      idleng = 14
      call dmpelp(lelm, larg, idleng)
      go to 500

*---- general bend (dipole, quadrupole, and skew quadrupole).
  260 continue
      idleng = 16
      call dmpelp(lelm, larggb, idleng)
      if (dmvals(7) .ne. zero)  then
        call aawarn('dmpelm', 1,
     +      'tilt ignored in general bend: ' // ellns)
      endif
      go to 500

*---- Matrix
   40 continue
      i2 = 1
      larg(1) = 2
*---- element kick
      i1 = i2 + 1
      i2 = i2 + 6
      do  i = i1, i2
        larg(i) = i+1
      enddo
*---- matrix
      i1 = i2 + 1
      i2 = i2 + 36
      do  i = i1, i2
        larg(i) = i+1
      enddo
*---- map
      i1 = i2 + 1
      i2 = i2 + 216
      do  i = i1, i2
        larg(i) = i+1
      enddo
      idleng = i2
      call dmpelp(lelm, larg, idleng)
      go to 500
*--- beam-beam
  220 continue
      idleng = 18
      call dmpelp(lelm, largbb, idleng)
      dmvals(18) = parnum
      isvflg(18) = 1
      go to 500
  270 continue
*--- lcavity
      idleng = 6
      call dmpelp(lelm, largcvl, idleng)
      go to 500
*---- other elements.
  230 continue
  250 continue
  280 continue
  290 continue
  300 continue
  310 continue
      larg(1) = 2
      idleng = 1
      call dmpelp(lelm, larg, idleng)
  500 continue
      call doom_pfelem(ellns, isp, parent, idleng, isvcnt, isvflg,
     +dmvals, dmsave)
      elstore = elstore + 1
*--- add to directory
      nl = mcnam
      if (ndirec .eq. maxbuff)  then
        print *, '<<< DOOM >>> fatal: DIRECTORY size ',
     +  maxbuff, ' reached'
        stop
      endif
      nn = doom_nadd(ellns, director, ndirec, nl)
      ndirec = nn
  999 end
+ei
+dk dmpelp
+if doom
      subroutine dmpelp(lcmd, larg, narg)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Store element value and expression
* Input:
*   lcmd(1)   (pointer)   Current element bank.
*   larg      (int array) parameter reference for DOOM fields
*   narg      (int)       length of larg
* Output:
*   in /dmcommon/ : dmvals = values, dmsave = par. strings (sep = '|')
*                   isvflg = 1 or 2 (value or parameter)
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca maxmul
      integer i,ibias,icat,narg
      integer           lcmd(1), larg(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca refer
+ca datatype
+ca dmcommon

      do 10  i = 1, narg
        icat = larg(i)
        isvflg(i) = 0
        if (icat .ne. 0)  then
          ibias = mbat + (icat - 1) * mcsiz
          if (iq(lcmd(1)+ibias+mctyp) .gt. 10 * mtflt  .and.
     +    iq(lcmd(1)+ibias+mctyp) .le. 10 * mtflt + 3) then
            lcexp = lq(lcmd(1)-icat)
            if (lcexp .gt. 0)  then
              call dmsvex(lcexp)
              isvflg(i) = 2
            else
              isvflg(i) = 1
            endif
            call ucopy(q(lcmd(1)+ibias+mcval), dmvals(i), mwflt)
          endif
        endif
        dmsave(isvcnt+1:isvcnt+1) = '|'
        isvcnt = isvcnt + 1
   10 continue
      end
+ei
+dk dmpferr
+if doom
      subroutine dmpferr(name, iocc, nst, radl, f_errors)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Store multipole field errors
* Input:
*   name      (char)       element name
*   iocc      (int)        occurrence count
*   nst       (int)        no. of errors
*   radl      (real)       radiation length
*   f_errors  (real array) field errors
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer i,iocc,nct,nst
      double precision f_errors,radl
      character *(*)  name
      dimension f_errors(*)

      nct = 0
      do i = 1, nst/2
        if (f_errors(2*i-1) .ne. zero .or. f_errors(2*i) .ne. zero) then
          nct = 2*i
        endif
      enddo
      if (nct .gt. 0) call doom_pfield(name, iocc, nct, f_errors)
      end
+ei
+dk dmpparm
+if doom
      subroutine dmpparm(lbank)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Save data for one parameter bank in DOOM
* Input:
*   LBANK(1)    (pointer) Bank pointer.
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer iexpr,isp,ncat,nl,nn
      double precision rval
      integer           lbank(1)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca keyword
+ca refer
+ca datatype
+ca dmcommon

      logical dmact
      integer doom_nadd
      character*(mcnam) label

      if (.not.dmact())  goto 999
      ncat = iq(lbank(1)+mbat)
      isp = iq(lbank(1)+mbsp)
      if (isp .ne. 3) then
*---- Retrieve label and keyword definition.
        call diname(ldbnk, iq(lbank(1)+mbnam), label)
        isvcnt = 0
*---- constant (isp=1) or parameter (isp=2)
        lcexp = lq(lbank(1)-1)
        if (lcexp .ne. 0) then
          call dmsvex(lcexp)
          iexpr = 2
        else
          iexpr = 1
        endif
        iexpr = 10 * isp + iexpr
        call utgflt(lbank, 1, 1, rval)
        dmsave(isvcnt+1:isvcnt+1) = '|'
        isvcnt = isvcnt + 1
        call dmlsqu(isvcnt, dmsave)
        call doom_pparam(label, iexpr, rval, isvcnt, dmsave)
        parstore = parstore + 1
*--- add to directory
        nl = mcnam
        if (ndirec .eq. maxbuff)  then
          print *, '<<< DOOM >>> fatal: DIRECTORY size ',
     +    maxbuff, ' reached'
          stop
        endif
        nn = doom_nadd(label, director, ndirec, nl)
        ndirec = nn
      endif
  999 end
+ei
+dk dmprseq
+if doom
      subroutine dmprseq(table, tleng, posf, elname, elocc, elpos,
     +posdim)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Prepares a flat sequence (names, occ. counts, position)
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca memdum
+ca maxmul
+ca bankhead
+ca seqflag
+ca cmdgroup
+ca elmgroup
+ca prcgroup
+ca seqgroup
+ca strgroup
+ca message
+ca header
+ca refer
+ca stflag
+ca zunit
+ca dmcommon
      integer icode,ienum,iflag,iocc,ipos,jbyt
      double precision elpos,fact,s,temp,tpos
      integer tleng, posdim, posf, elocc(*)
      dimension elpos(posdim,*)
      character * (mcnam) table
      character * (mcnam) elname(*)
      character * (mcnam) lcc_nam, lm_nam
      character * (mcnam+4) loc_nam
      dimension temp(20)

      lcc_seq = 0
      s = zero
      fact = posf - 1
      do  ipos = iq(lcseq+msr1), iq(lcseq+msr2)
        call utelem(lcseq, ipos, iflag, lcc_nam, iocc, ienum)
        loc_nam = lcc_nam
        icode = jbyt(iflag,1,mcode)
        if (icode .eq. 1)  then
          call bmgelm(lcelm, temp)
          tpos = s + 0.5d0 * fact * temp(1)
          s = s + temp(1)
        else
          tpos = s
          lm_nam = loc_nam
          if (icode .eq. 2)  then
            loc_nam = 'BEGIN$' // lm_nam
          else
            loc_nam = 'END$' // lm_nam
          endif
        endif
        if (icode .ne. 1 .or. loc_nam(1:1) .ne. '[')  then
          if (lcc_seq .eq. tleng)  then
           call aawarn('dmprseq', 1,
     +     'table ' // table // ' for sequence ' // seqname // 'cut.')
           goto 999
          endif
          lcc_seq = lcc_seq + 1
          elname(lcc_seq) = loc_nam
          elocc(lcc_seq) = iocc
          elpos(1,lcc_seq) = tpos
        endif
      enddo
  999 end
+ei
+dk dmpsequ
+if doom
      subroutine dmpsequ
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Saves a sequence table + the alignment and field errors
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca memdum
+ca maxmul
+ca bankhead
+ca seqflag
+ca cmdgroup
+ca elmgroup
+ca prcgroup
+ca seqgroup
+ca strgroup
+ca message
+ca header
+ca refer
+ca stflag
+ca zunit
+ca dmcommon
      integer kkk
      integer nalerr,nalstore,ncorrect,ncorstore,nflerr,nflstore,
     +nmonitor,nmonstore,lastact
      common / dm2comm /
     +nalerr,nalstore,ncorrect,ncorstore,nflerr,nflstore,
     +nmonitor,nmonstore,lastact
      logical svdof(maxdof)

      integer i,icode,ienum,iflag,iocc,ipos,itp,jbit,jbyt,l_2,n,n0,n1,
     +nc,nd,nl,nn,nst
      double precision al_errors,corr_set,f_errors,radl
      character * (mcnam) lcc_nam, parent
      character * (mcnam+4) loc_nam
      logical dmact, sq_store
      integer doom_nadd
      dimension corr_set(2), al_errors(6), f_errors(2*(maxmul+1))

      if (.not.dmact())  goto 999
      if (lcseq .eq. 0)  goto 999
*--- skip sequence store proper if loaded from d.b. and not modified
      sq_store = jbit(iq(lcseq),mxdoom) .eq. 0 .or.
     +           jbit(iq(lcseq),mxdmod) .eq. 1
      call uhtoc(q(lcseq+msbn), mcwrd, seqname, mcnam)
      print *, '<<< DOOM >>> used sequence: ', seqname
      do i = 1, maxdof
        svdof(i) = doflag(i)
        doflag(i) = .true.
      enddo
      n0 = 0
*--- store element name, occ. count, position in tables
      call dmprseq('Sequence', maxseql, 2, elm_nam, occt, s_pos, 1)
      do ipos = iq(lcseq+msr1), iq(lcseq+msr2)
        call utelem(lcseq, ipos, iflag, lcc_nam, iocc, ienum)
        loc_nam = lcc_nam
        icode = jbyt(iflag,1,mcode)
        if (icode .ne. 1 .or. loc_nam(1:1) .ne. '[')  then
          itp = iq(lcelm+mbsp)
*--- alignment errors - skip if not modified
          if (lcali .ne. 0)  then
            nalerr = nalerr + 1
            if (jbit(iq(lcali),mxdoom) .eq. 0 .or.
     +      jbit(iq(lcali),mxdmod) .eq. 1)  then
              call sbit0(iq(lcali), mxdmod)
              call sbit1(iq(lcali), mxdoom)
              call ucopy(q(lcali+1), al_errors, 6*mwflt)
              nst = 6
              call doom_palign(loc_nam, iocc, nst, al_errors)
              nalstore = nalstore + 1
            endif
          endif
*--- (multipole) field errors - skip if not modified
          if (lcfld .ne. 0)  then
            nflerr = nflerr + 1
            if (jbit(iq(lcfld),mxdoom) .eq. 0 .or.
     +      jbit(iq(lcfld),mxdmod) .eq. 1)  then
              call sbit0(iq(lcfld),mxdmod)
              call sbit1(iq(lcfld), mxdoom)
              nst = iq(lcfld-1)/mwflt
              if (nst .gt. 0)  then
                call ucopy(q(lcfld+1), f_errors, nst*mwflt)
*--- radiation length
                call ucopy(q(lcelm+melen), radl, mwflt)
                call dmpferr(loc_nam, iocc, nst, radl, f_errors)
                nflstore = nflstore + 1
              endif
            endif
          endif
*--- corrector and monitor settings - skip if not modified
          if (lccom .ne. 0)  then
            if (itp .ge. 14 .and. itp. le. 16)  then
*--- kicker
              ncorrect = ncorrect + 1
              if (jbit(iq(lccom),mxdoom) .eq. 0 .or.
     +        jbit(iq(lccom),mxdmod) .eq. 1)  then
                call sbit0(iq(lccom),mxdmod)
                call sbit1(iq(lccom), mxdoom)
                nd = min(2 * mwflt, iq(lccom-1))
                if (nd .gt. 0)  then
                  nst  = nd / mwflt
                  call ucopy(q(lccom+1), corr_set, nd)
                  if (corr_set(1) .ne. zero
     +            .or. corr_set(2) .ne. zero)  then
                    call doom_pcorrect(loc_nam, iocc, iq(lccom),
     +              corr_set)
                    ncorstore = ncorstore + 1
                  endif
                endif
              endif
            elseif (itp .ge. 17 .and. itp. le. 19)  then
*--- monitor
              nmonitor = nmonitor + 1
              if (jbit(iq(lccom),mxdoom) .eq. 0 .or.
     +        jbit(iq(lccom),mxdmod) .eq. 1)  then
                call sbit0(iq(lccom),mxdmod)
                call sbit1(iq(lccom), mxdoom)
                nd = min(2 * mwflt, iq(lccom-1))
                if (nd .gt. 0)  then
                  nst  = nd / mwflt
                  call ucopy(q(lccom+1), corr_set, nd)
                  if (corr_set(1) .ne. zero
     +            .or. corr_set(2) .ne. zero)  then
                    call doom_pmonitor(loc_nam, iocc, iq(lccom),
     +              corr_set)
                    nmonstore = nmonstore + 1
                  endif
                endif
              endif
            endif
          endif
        endif
      enddo
      if (sq_store)  then
        l_2 = mcnam
        call doom_psequ(seqname, lcc_seq, l_2, elm_nam, occt, s_pos)
        seqstore = seqstore + 1
        if (seqnames(lastact) .eq. sequnam)  then
*--- add an object UNNAMED_USE with the last USEd sequence name
          loc_nam = 'UNNAMED_USE '
          parent = 'USE '
          n = 0
          n1 = 1
          nc = mcnam
          call doom_sobj(loc_nam, n, parent, parent,
     +    n, n, n1, nc, n, dm_dbl, seqname)
*--- add to directory
          if (ndirec .eq. maxbuff)  then
            print *, '<<< DOOM >>> fatal: DIRECTORY size ',
     +      maxbuff, ' reached'
            stop
          endif
          nl = mcnam
          nn = doom_nadd(loc_nam, director, ndirec, nl)
          ndirec = nn
        endif
      endif
      do i = 1, maxdof
        doflag(i) = svdof(i)
      enddo
  999 end
+ei
+dk dmpsumm
+if doom
      subroutine dmpsumm
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Saves a sequence table + the alignment and field errors
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca memdum
+ca maxmul
+ca bankhead
+ca seqflag
+ca cmdgroup
+ca elmgroup
+ca prcgroup
+ca seqgroup
+ca strgroup
+ca message
+ca header
+ca refer
+ca stflag
+ca zunit
+ca dmcommon
      integer nalerr,nalstore,ncorrect,ncorstore,nflerr,nflstore,
     +nmonitor,nmonstore,lastact
      common / dm2comm /
     +nalerr,nalstore,ncorrect,ncorstore,nflerr,nflstore,
     +nmonitor,nmonstore,lastact

      print *,'         >>> elements with alignment errors (stored): ',
     +nalerr, ' (', nalstore, ')'
      print *,'         >>> elements with field     errors (stored): ',
     +nflerr, ' (', nflstore, ')'
      print *,'         >>> total # correctors             (stored): ',
     +ncorrect, ' (', ncorstore, ')'
      print *,'         >>> total # monitors               (stored): ',
     +nmonitor, ' (', nmonstore, ')'
      print *,
     +'<<< DOOM >>> save: # sequ.s, #elements, # param.: ',
     +seqstore, elstore, parstore
      end
+ei
+dk dmpsqu
+if doom
      subroutine dmpsqu(nl, cl)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   replace ->... by [...]
* Input:
*   nl  (int)           length of cl
* I/O:
*   cl  (char*1 array)  array to be modified
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer i,ifl,index,k,nl
      character*1 cl(*)
      character cns*64
      data cns/'0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRST
     +UVWXYZ._'/

      i = 0
      k = 0
      ifl = 0
   10 i = i + 1
      k = k + 1
      if (cl(i) .eq. '-' .and. cl(i+1) .eq. '>')  then
          i = i + 1
          cl(k) = '['
          ifl = 1
      else
        if (ifl .ne. 0 .and. index(cns, cl(i)) .eq. 0)  then
          cl(k) = ']'
          k = k + 1
          ifl = 0
        endif
        cl(k) = cl(i)
      endif
      if (i .lt. nl)  goto 10
      if (k .lt. nl)  cl(k+1) = ']'
      end
+ei
+dk dmread
+if doom
      subroutine dmread(label, key, if1, if2)
      implicit none
*----------------------------------------------------------------------*
* purpose:                                                             *
*   read and decode a command.                                         *
*   returns pointer to current keyword,                                *
*   and optionally to current command.                                 *
* output:                                                              *
*   label    (char)     command label.                                 *
*   key      (char)     command keyword.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer icmd,if1,if2,ikey,isrc,jcase,jform,leng1,leng2
      character*(mcnam) label,  key
+ca memdum
+ca bankhead
+ca prcgroup
+ca refer
+ca stbuff
      character*8       toks
      equivalence       (toks, token(1))

      logical           eflag
      character*(mcnam) word1, word2

*---- initialize.
      label = ' '
      key = ' '
      if1 = 0
      if2 = 0
      jcase = 0
      jform = 0

*==== phase 1. decode possible label and keyword.
*---- command must begin with an identifier.
      call rdword(word1, leng1)
      if (leng1 .eq. 0) then
        call rdfail('dmread', 1,
     +  'command should begin with a label or a keyword.')
        go to 9999
      endif

*---- formal argument list.
      if (token(jtok) .eq. '(') then
        call rdform(if1, if2, eflag)
        if (eflag) go to 9999
        jform = 1
      endif

*---- ":" marks first name as label.
      if (token(jtok) .eq. ':') then
        jtok = jtok + 1

*---- ":=" marks statement as a parameter definition.
        if (token(jtok) .eq. '=') then
          jcase = 3
        else

*---- a keyword must follow the ":".
          call rdword(word2, leng2)
          if (leng2 .eq. 0) then
            call rdfail('dmread', 1, 'keyword expected after ":".')
          else
            jcase = 2
          endif
        endif

*---- "=" marks statement as a parameter definition.
      else if (token(jtok) .eq. '=') then
        jcase = 3

*---- "," or ';': keyword only or label only.
      else if (token(jtok) .eq. ','  .or.  token(jtok) .eq. ';') then
        jcase = 1

*---- all other characters are illegal at this point.
      else
        call rdfail('dmread', 1, 'end of statement ";" expected.')
        go to 9999
      endif

*==== phase 2. find command keyword.
      lckey = 0
      lccmd = 0
      lccls = 0

*---- jcase = 1. one word only; decide if keyword or label.
      if (jcase .eq. 1) then

*---- exact match with keyword or stored command.
        call difind(ldkey, word1, ikey, lckey)
        if (lckey .ne. 0) then
          if (iq(lckey+mbpr) .eq. mpelm) lccmd = lq(lckey-3)
        else
          call difind(ldbnk, word1, icmd, lccmd)
          if (lccmd .ne. 0) then
            lckey = lq(lccmd+1)

*---- approximate match with keyword or stored command.
          else
            call difind(ldkey, word1(1:leng1), ikey, lckey)
            if (lckey .ne. 0) then
              if (iq(lckey+mbpr) .eq. mpelm) lccmd = lq(lckey-3)
            else
              call difind(ldbnk, word1(1:leng1), icmd, lccmd)
              if (lccmd .ne. 0) then
                lckey = lq(lccmd+1)
              endif
            endif
          endif
        endif

*---- jcase = 2. two words; decide if second is keyword or class.
      else if (jcase .eq. 2) then
        label = word1

*---- exact match with keyword or class name.
        call difind(ldkey, word2, ikey, lckey)
        if (lckey .ne. 0) then
          if (iq(lckey+mbpr) .eq. mpelm) lccls = lq(lckey-3)
        else
          call difind(ldbnk, word2, isrc, lccls)
          if (lccls .ne. 0) then
            lckey = lq(lccls+1)

*---- approximate match with keyword or class name.
          else
            call difind(ldkey, word2(1:leng2), ikey, lckey)
            if (lckey .ne. 0) then
              if (iq(lckey+mbpr) .eq. mpelm) lccls = lq(lckey-3)
            else
              call difind(ldbnk, word2(1:leng2), isrc, lccls)
              if (lccls .ne. 0) then
                lckey = lq(lccls+1)
              endif
            endif
          endif
        endif

*---- jcase = 3. find parameter keyword.
      else if (jcase .eq. 3) then
        label = word1
        call difind(ldkey, 'PARAMETE', ikey, lckey)
      endif

*---- check if a keyword was recognized.
      if (lckey .eq. 0) then
        call rdfail('dmread', 1, 'no command keyword found.')

*---- test for redundant formal argument list.
      else
        if (jform .ne. 0) then
          if (iq(lckey+mbpr).ne.mplin .or. iq(lckey+mbsp).ne.1) then
            call rdwarn('dmread', 1, 'redundant formal argument list.')
          endif
        endif
        call diname(ldkey, ikey, key)
        if (lccmd .ne. 0) call diname(ldbnk, icmd, label)
      endif

 9999 end
+ei
+dk dmsect1
+if doom
      subroutine dmsect1
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Initializes sector map storage
*----------------------------------------------------------------------*
+ca aparam
+ca dmcommon
      dm_suml = 0.d0
      end
+ei
+dk dmsect2
+if doom
      subroutine dmsect2(suml, elmnam, iocc, ek, rt, tt)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Initializes sector map storage
*----------------------------------------------------------------------*
+ca aparam
+ca dmcommon
      double precision suml, ek(6), rt(6,6), tt(6,6,6)
      integer iocc, n, nz, keylist(3), lastnb
      character *(mcnam) elmnam
      character * 48 ttname
      dmvals(1) = suml - dm_suml
      dm_suml = suml
      call ucopy(ek, dmvals(2), 6 * mwflt)
      call ucopy(rt, dmvals(8), 36 * mwflt)
      call ucopy(tt, dmvals(44), 216 * mwflt)
      keylist(1) = 2
      keylist(2) = 116
      keylist(3) = iocc
      nz = 0
      n = 259
      ttname = elmnam(:lastnb(elmnam)) // '.' // seqname
      call doom_store(ttname, keylist, nz, n, nz, nz, dmvals, ttname)
      call doom_ptype(ttname, keylist, 'MAP ')
      end
+ei
+dk dmshut
+if doom
      subroutine dmshut
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Shuts the database (no tree save)
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca seqflag
+ca prcgroup
+ca seqgroup
+ca strgroup
+ca message
+ca header
+ca refer
+ca status
+ca stflag
+ca zunit
+ca dmcommon
      integer leng,nunloc
      logical dmact, errorf

      if (dmact())  then
*--- store BEAM command parameters
        call dmbeam
        call doom_close()
        actdoom = 0
        skipfl = .false.
*--- set current time for comparison after re-open
        call doom_time(dltime)
*--- write current d.b. name to file
        call flopen('current.doom', 'SWFD', 0, 0, nunloc, errorf)
        if (.not. errorf)  then
          call utleng(doom_name, leng)
          write(nunloc,'(a)')  doom_name(:leng)
          call flclos(nunloc, errorf)
        endif
      endif
      end
+ei
+dk dmsvex
+if doom
      subroutine dmsvex(lexp)
      implicit none
*----------------------------------------------------------------------*
* purpose:
*   Save complete expression in char variable
* input:
*   lexp(1)   (pointer) pointer to expression bank.
* output: in /dmcommon/dmsave
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer i,ioplev,iopr,iopr1,ip,jp,lp
      double precision rval
      integer           lexp(1)
+ca memdum
+ca expgroup
+ca exstak
+ca fundef
+ca refer
+ca dmcommon

      integer           istack(maxstk), lstack(maxstk)
      character*4       cstack(maxstk)
      character*1       c1

*---- expression limits excluding 'put'.
      level = 1
      istack(level) = 1
      lstack(level) = iq(lexp(1)-2)
      cstack(level) = '    '

*==== procedure "save expression".
  100 continue
        ip = istack(level)
        lp = lstack(level)
        iopr = iq(lexp(1)+(lp-1)*mxsiz+mxop)

*---- single operand?
        if (ip .eq. lp) then

*---- reference.
          if (iopr .le. -2) then
            lcvar = lq(lexp(1)-ip)
            call dmsvvr(lcvar)

*---- constant.
          else if (iopr .eq. -1) then
            call ucopy(q(lexp(1)+(lp-1)*mxsiz+mxval), rval, mwflt)
            call dmsvrl(rval)

*---- argument-less function.
          else if (narg(iopr) .eq. 0) then
            call dmsvnm(funnam(iopr))
            dmsave(isvcnt+1:isvcnt+2) = '()'
            isvcnt = isvcnt + 2

*---- illegal item.
          else
            call aafail('dmsvex', 1, 'invalid expression seen:')
            call exdump(lexp)
            isvcnt = -1
            go to 9999
          endif

*---- the last item (lp) must be an operator.
        else if (ip .lt. lp) then
          if (iopr .le. 0) then
            call aafail('dmsvex', 1, 'invalid expression seen:')
            call exdump(lexp)
            isvcnt = -1
            go to 9999

*---- unary operator: operand is (ip to lp-1).
          else if (narg(iopr) .eq. 1) then
            istack(level) = lp + 1
            if (level .ge. maxstk) go to 800
            level = level + 1
            istack(level) = ip
            lstack(level) = lp - 1
            cstack(level) = '    '
            c1 = funnam(iopr)(1:1)

*---- unary plus or minus sign.
            if (c1 .eq. '-'  .or. c1 .eq. '+') then
            dmsave(isvcnt+1:isvcnt+2) = c1
            isvcnt = isvcnt + 1

*---- function name.
            else
              call dmsvnm(funnam(iopr))
            endif

*---- write parentheses only if required.
            iopr1 = iq(lexp(1)+(lp-2)*mxsiz+mxop)
            if (ipre(iopr1) .le. ipre(iopr)) then
              dmsave(isvcnt+1:isvcnt+2) = '('
              isvcnt = isvcnt + 1
              cstack(level) = ')   '
            endif
            go to 100

*---- binary operator: search backward to find end of first operand.
          else if (narg(iopr) .eq. 2) then
            ioplev = 0
            do 110 jp = lp, ip, -1
              iopr = iq(lexp(1)+(jp-1)*mxsiz+mxop)
              if (iopr .le. 0) then
                ioplev = ioplev - 1
                if (ioplev .eq. 0) go to 120
              else if (narg(iopr) .eq. 2) then
                ioplev = ioplev + 1
              endif
  110       continue

*---- operands not found.
            call aafail('dmsvex', 1, 'invalid expression seen:')
            call exdump(lexp)
            isvcnt = -1
            go to 9999

*---- operands found: (ip to jp-1) and (jp to lp-1).
  120       continue
            istack(level) = lp + 1
            if (level .ge. maxstk) go to 800
            level = level + 1
            istack(level) = jp
            lstack(level) = lp - 1
            cstack(level) = '    '
            if (level .ge. maxstk) go to 800
            level = level + 1
            istack(level) = ip
            lstack(level) = jp - 1
            cstack(level) = '    '

*---- binary operator: deal with operator precedence to decide about ().
            iopr = iq(lexp(1)+(lp-1)*mxsiz+mxop)
            if (ifun(iopr) .eq. 1) then
              cstack(level)(2:2) = funnam(iopr)(1:1)
              iopr1 = iq(lexp(1)+(jp-2)*mxsiz+mxop)
              if (ipre(iopr1) .lt. ipre(iopr)) then
                dmsave(isvcnt+1:isvcnt+2) = '('
                isvcnt = isvcnt + 1
                cstack(level)(1:1) = ')'
              endif
              iopr1 = iq(lexp(1)+(lp-2)*mxsiz+mxop)
              call ucopy(q(lexp(1)+(lp-2)*mxsiz+mxval), rval, mwflt)
              if (ipre(iopr1) .le. ipre(iopr)  .or.
     +            iopr1 .eq. -1  .and.  rval .lt. zero) then
                cstack(level)(3:3) = '('
                cstack(level-1) = ')   '
              endif

*---- function with two arguments.
            else
              call dmsvnm(funnam(iopr))
              dmsave(isvcnt+1:isvcnt+2) = '('
              isvcnt = isvcnt + 1
              cstack(level) = ',   '
              cstack(level-1) = ')   '
            endif
            go to 100
          endif
        endif

*---- end of expression: unstack parentheses and/or operators.
        do 130 i = 1, 4
          c1 = cstack(level)(i:i)
          if (c1 .ne. ' ') then
            dmsave(isvcnt+1:isvcnt+2) = c1
            isvcnt = isvcnt + 1
          endif
  130   continue
        level = level - 1
      if (level .gt. 0) go to 100
      go to 9999

*---- stack overflow.
  800 continue
      call aafail('dmsvex', 1, 'expression stack overflow.')

 9999 end
+ei
+dk dmsvin
+if doom
      subroutine dmsvin(ival)
      implicit none
*----------------------------------------------------------------------*
* purpose:
*   format an integer value for save of view command.
* input:
*   ival      (integer) value to be formatted.
*----------------------------------------------------------------------*
+ca aparam
+ca dmcommon
      integer ival,js,ns

      character*10      string

*---- encode integer.
      write (string, '(i10)') ival

*---- save number string.
      do 10 js = 1, 10
        if (string(js:js) .ne. ' ') go to 20
   10 continue
   20 continue
      ns = 11 - js
      dmsave(isvcnt+1:isvcnt+ns) = string(js:10)
      isvcnt = isvcnt + ns

      end
+ei
+dk dmsvnm
+if doom
      subroutine dmsvnm(name)
      implicit none
*----------------------------------------------------------------------*
* purpose:
*   save a name for save or view command.
*   also treats labels with special characters.
* input:
*   name      (char)    name to be written.
*----------------------------------------------------------------------*
+ca aparam
      integer ichar,index,js,ks,ls,mc,ns
      character*(mcnam) name
+ca dmcommon
+ca chcode

      logical           quotes
      character*1       c1
      parameter         (mc = 2 * mcnam)
      character*(mc)    string

*---- normal name, or special character at start?
      quotes = ichtyp(ichar(name(1:1))) .ne. 10
      string(1:1) = name(1:1)

*---- loop through characters of name, inserting escapes as needed.
      ls = 1
      ns = 1
      call utleng(name, ks)
      do 10 js = 2, ks
        c1 = name(js:js)
        if (ichtyp(ichar(c1)).gt.10 .and. index('.''_', c1).eq.0) then
          quotes = .true.
        endif
        ls = ls + 1
        string(ls:ls) = c1
        if (c1 .eq. '"') then
          ls = ls + 1
          string(ls:ls) = c1
        endif
        if (c1 .ne. ' ') ns = ls
   10 continue

      if (quotes) then
        dmsave(isvcnt+1:isvcnt+1) = '"'
        isvcnt = isvcnt + 1
      endif
      dmsave(isvcnt+1:isvcnt+ns) = string(1:ns)
      isvcnt = isvcnt + ns
      if (quotes) then
        dmsave(isvcnt+1:isvcnt+1) = '"'
        isvcnt = isvcnt + 1
      endif

      end
+ei
+dk dmsvrl
+if doom
      subroutine dmsvrl(rval)
      implicit none
*----------------------------------------------------------------------*
* purpose:
*   format a real value for save or view command.
* input:
*   rval      (real)    value to be written.
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca dmcommon
      integer iexp,js,ls,ns
      double precision rval

      character*25      string
      character*5       expo

*---- special case for zero.
      if (rval .eq. zero) then
        dmsave(isvcnt+1:isvcnt+3) = '0.0'
        isvcnt = isvcnt + 3
*---- is scaling required?
      else
        if (abs(rval) .lt. 100.0  .and.  abs(rval) .gt. 0.01) then
          iexp = 0
        else
          iexp = log10(abs(rval))
          rval  = rval * ten**(-iexp)
        endif
        write (string(1:20), '(f20.12)') rval

*---- drop trailing zeros.
        do 10 ls = 20, 10, -1
          if (string(ls:ls) .ne. '0') go to 20
   10   continue
        ls = 9
   20   continue

*---- append exponent, if non-zero.
        if (iexp .ne. 0) then
          write (expo, '(''e'',i4)') iexp
          string(ls+1:ls+5) = expo
          ls = ls + 5
        endif

*---- save number string.
        ns = 0
        do 40 js = 1, ls
          if (string(js:js) .ne. ' ') then
            ns = ns + 1
            string(ns:ns) = string(js:js)
          endif
   40   continue
        dmsave(isvcnt+1:isvcnt+ns) = string(1:ns)
        isvcnt = isvcnt + ns
      endif

      end
+ei
+dk dmsvvr
+if doom
      subroutine dmsvvr(lvar)
      implicit none
*----------------------------------------------------------------------*
* purpose:
*   save a variable reference.
* input:
*   lvar(1)   (pointer) pointer to the variable reference bank.
*----------------------------------------------------------------------*
+ca aparam
      integer ind1,ind2,ind3,ndim
      integer           lvar(1)
+ca memdum
+ca vargroup
+ca dmcommon

      character*(mcnam) name

*---- bank name.
      call uhtoc(q(lvar(1)+mvbank), mcwrd, name, mcnam)
      call dmsvnm(name)

*---- attribute name.
      if (iq(lvar(1)+mvseen) .eq. 2) then
        dmsave(isvcnt+1:isvcnt+2) = '->'
        isvcnt = isvcnt + 2
        call uhtoc(q(lvar(1)+mvattr), mcwrd, name, mcnam)
        call dmsvnm(name)

*---- set dimension count.
        ndim = 0
        ind1 = iq(lvar(1)+mvind1)
        ind2 = iq(lvar(1)+mvind2)
        ind3 = iq(lvar(1)+mvind3)
        if (ind1 .gt. 1) ndim = 1
        if (ind2 .gt. 1) ndim = 2
        if (ind3 .gt. 1) ndim = 3

*---- indices, if present.
        if (ndim .ge. 1) then
          dmsave(isvcnt+1:isvcnt+1) = '('
          isvcnt = isvcnt + 1
          call dmsvin(ind1)
          if (ndim .ge. 2) then
            dmsave(isvcnt+1:isvcnt+1) = ','
            isvcnt = isvcnt + 1
            call dmsvin(ind2)
            if (ndim .ge. 3) then
              dmsave(isvcnt+1:isvcnt+1) = ','
              isvcnt = isvcnt + 1
              call dmsvin(ind3)
            endif
          endif
          dmsave(isvcnt+1:isvcnt+1) = ')'
          isvcnt = isvcnt + 1
        endif
      endif

      end
+ei
+dk dmtrclose
+if doom
      subroutine dmtrclose
      implicit none
*----------------------------------------------------------------------*
* purpose:                                                             *
*   close buffers for tracking
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca message
+ca strgroup
+ca trdata
+ca trlink
      integer i,ld,lm,n
      logical dmact
      integer doom_debug

*---- drop file and record buffers.
      if (ltrfbf .ne. 0) call mzdrop(0, ltrfbf, '.')
      if (ltrrbf .ne. 0) call mzdrop(0, ltrrbf, '.')

      if (.not.dmact())  goto 999
      lm = lq(lroot-mdmtrk)
      n = 2 * iq(lm+1)
      ld = lq(lm-1)
      call doom_getvar('debug_flag ', doom_debug)
      if (doom_debug .gt. 1)  then
        print '(''survival table: ''/(2i10))', (iq(ld+i), i = 1, n)
      endif
*--- save track result bank
      call doom_ptrack(iq(lm+1), iq(ld+1))

  999 end
+ei
+dk dmtrinit
+if doom
      subroutine dmtrinit(nturn)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   initializes storage for track master table and sub-tables
*--- Input:
*    npart   number of particles
*    nturn   number of turns
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca prcgroup
+ca seqgroup
+ca strgroup
+ca message
+ca header
+ca refer
+ca trdata
+ca zunit
      integer loc,mdep,nturn

      logical dmact
      parameter (mdep = 1)

      if (.not.dmact())  goto 999
      if (npart * nturn .eq. 0 .or. iffreq .eq. 0)  then
        call aawarn('dmtrinit', 1,
     +  'no particles or turns or frequency --> no tracking!.')
      else
*--- book bank for intermediate tracking tables
        if (lq(lroot-mdmtrk) .ne. 0)  then
          call aawarn('dmtrinit', 1,
     +      'dropping bank LROOT-15 for DOOM track table.')
          call mzdrop(0, lq(lroot-mdmtrk), ' ')
        endif
*--- mother bank: occupation counts of daughter i in position i
        call mzbook(2, loc, lroot, -mdmtrk, 'DOOM',
     +  mdep, mdep, mdep, 7, 0)
*--- bank 1: list of turns + no. of surviving particles
        call mzbook(2, loc, lq(lroot-mdmtrk), -1, 'DM01',
     +  0, 0, 2*(nturn/iffreq+2), 7, -1)
      endif
  999 end
+ei
+dk dmtrsave
+if doom
      subroutine dmtrsave(iturn, track, number, ntrk)
      implicit none
*----------------------------------------------------------------------*
* purpose:                                                             *
*   store particle positions for current turn in DOOM.                 *
* input:                                                               *
*   iturn     (integer) turn number.                                   *
*   track(6,*)(real)    track coordinates: (x, px, y, py, t, pt).      *
*   number(*) (integer) number of current track.                       *
*   ntrk      (integer) number of surviving tracks.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer itrk,iturn,ld1,lm,np,ntrk
      double precision track
      dimension         track(6,*)
      integer           number(*)
+ca memdum
+ca message
+ca beam
+ca strgroup
+ca trdata
+ca trlink
      logical dmact

      if (.not.dmact())  goto 999
*---- skip hidden track (closed orbit).
      if (number(1) .eq. 0) then
        itrk = 2
      else
        itrk = 1
      endif

      lm = lq(lroot-mdmtrk)
      np = 2 * iq(lm+1)
      ld1 = lq(lm-1) + 2 * iq(lm+1)
      iq(ld1+1) = iturn
      iq(ld1+2) = ntrk + 1 - itrk
      iq(lm+1) = iq(lm+1) + 1

*--- save number of particles for this turn, and coordinates
      call doom_pturn(iturn, iq(ld1+2), number(itrk), track(1,itrk))

  999 end
+ei
+dk dmtrst1
+if doom
      subroutine dmtrst1(ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   initializes one-turn storage
*   ktrack    number of surviving tracks (= total at start)
*----------------------------------------------------------------------*
+ca aparam
+ca dmcommon
+ca range
      integer ktrack
      character * 40 loctxt
      data loctxt / 'xxx particles only in first turn in DOOM' /
      seq_lng = irg2 + 1 - irg1
      curr_pos = 0
      if (ktrack .gt. 0)  then
        last_part = mtw_leng / (7 * seq_lng)
        if (last_part .lt. ktrack)  then
          write(loctxt(1:3), '(i3)')  last_part
          call aawarn('dmtrst1', 1, loctxt)
        endif
        call vzero(optics_tb, mwflt * mtw_leng)
      else
        last_part = 0
      endif
      end
+ei
+dk dmtrst2
+if doom
      subroutine dmtrst2(ipos,suml,track,number,ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   keeps coordinates for one-turn storage
*--- input:
*   ipos      position in sequence
*   suml      s position
*   track     track coordinates
*   number    numbers of surviving tracks
*   ktrack    number of surviving tracks
*
*----------------------------------------------------------------------*
+ca aparam
+ca dmcommon
+ca memdum
+ca seqflag
+ca refer
      integer ipos, ktrack, number(*)
      double precision suml, track(6,*)
      integer i, j, k, kp, itrk, jbyt
      i = (iq(lsdir+ipos) - 1) * mwnam + 1
      call uhtoc(q(ldbnk(2)+i), mcwrd, elm_nam(curr_pos+1), mcnam)
      occt(curr_pos+1) = jbyt(iq(lsflg+ipos), mocc1, mocc2)
*---- skip hidden track (closed orbit).
      if (number(1) .eq. 0) then
        itrk = 2
      else
        itrk = 1
      endif
      kp = 7 * curr_pos * last_part
      do i = itrk, ktrack
        if (number(i) .le. last_part)  then
          k = 7 * (number(i) - 1)
          optics_tb(kp+k+1) = suml
          do j = 1, 6
            optics_tb(kp+k+j+1) = track(j,i)
          enddo
        endif
      enddo
      curr_pos = curr_pos + 1
      end
+ei
+dk dmtrst3
+if doom
      subroutine dmtrst3
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   store one-turn in DOOM
*----------------------------------------------------------------------*
+ca aparam
+ca dmcommon
      integer i, j, k, kp
      do i = 1, curr_pos
        do j = 1, last_part
          kp = 7 * (i - 1) * (j - 1)
          print '(a16, i6, 1p,7d12.4)', elm_nam(i), occt(i),
     +    (optics_tb(kp+k), k = 1, 7)
        enddo
      enddo
      end
+ei
+dk dmuse
+if doom
      logical function dmuse()
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Returns true if d.b. initialized, else false
*----------------------------------------------------------------------*
+ca aparam
+ca dmcommon

      dmuse = indoom .eq. 740614
      end
+ei
+dk dmvalu
+if doom
      subroutine dmvalu(rval)
      implicit none
*----------------------------------------------------------------------*
* purpose:
*   return expression value
*   uses the pointers to current keyword and current command.
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
+ca memdum
+ca bankhead
+ca cmdgroup
+ca message
+ca refer
+ca savbuf
+ca zunit
+ca datatype
      integer icat,idata,ncat
      double precision rval

      ncat = iq(lccmd+mbat)
      idata = mbat
      isave = iqlog
      do 90 icat = 1, ncat
        if (mod(iq(lccmd+idata+mctyp),10) .ne. 0) then
          call ucopy(q(lccmd+idata+mcval), rval, mwflt)
        endif
        idata = idata + mcsiz
   90 continue

      end
+ei
+dk bbstore
      subroutine bbstore()
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   store beam-beam kicks for use in tracking                          *
*----------------------------------------------------------------------*
+ca aparam
+ca bbcomm
+ca memdum
+ca beam
+ca seqflag
+ca trodat
+ca message
+ca mapelm
+ca option
+ca optic0
+ca optic1
+ca range
+ca refer
+ca status
+ca trdata
+ca trlink
+ca troptc
+ca wstack
+ca zunit
      character*(mcnam) elmnam
      logical fmap
      integer i, ipos, icode, jbyt, iflag, iocc, ienum
      double precision el, em(6,6)
      do i = 1, 6
        orbit(i) = orbit0(i)
      enddo
      suml = 0
*--- activate bb-kick storage
      bbd_flag = 1
      bbd_cnt = 0
*--- do one turn
      do ipos = irg1, irg2
*--- store position number
        bbd_pos = ipos
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        icode = jbyt(iflag, 1, mcode)

*---- Misalignment at entrance of element or line.
        if (icode .ne. 3  .and.  lcali .ne. 0) then
          call tmali1(ipos, .false., orbit, orbit, re, te)
          call m66mpy(re, em, em)
        endif

*---- Track through element.
        if (icode .eq. 1) then
          call tmmap(.true., .true., orbit, fmap, el, ek, re, te)
          if (fmap) then
            suml = suml + el
            call m66mpy(re, em, em)
          endif
        endif

*---- Misalignment at exit of element or line.
        if (icode .ne. 2  .and.  lcali .ne. 0) then
          call tmali2(ipos, .false., orbit, orbit, re, te)
          call m66mpy(re, em, em)
        endif
      enddo
      bbd_flag = 0
      end
+dk beamint
      subroutine beamint(parvec, track, np)
*----------------------------------------------------------------------*
* Purpose:
*   Hirata 6D beam-beam element (thin lens, but sliced)
*----------------------------------------------------------------------*
*   parvec    (double)  BB element parameter vector:
*                       1:  sigma_x [m]
*                       2:  sigma_y [m]
*                       3:  x_offset [m]
*                       4:  y_offset [m]
*                       5:  classical particle radius [m]
*                       6:  total bunch charge [electron charges] of
*                           opposite beam
*                       7:  gamma = E / (m c^2)
*                       8:  ex = hor. emittance
*                       9:  ey = vert. emittance
*                      10:  phi = crossing angle
*                      11:  cop = closed orbit px
*                      12:  coq = closed orbit py
*                      13:  alpha_x
*                      14:  alpha_y
*                      15:  disp_x
*                      16:  disp_y
*                      17:  ddisp_x/ds
*                      18:  ddisp_y/ds
*                      19:  sigzs = sigma_t of synch. movement
*                      20:  siges = sigma_e of synch. movement
*                      21:  coz   = closed orbit s off-set
*                      22:  coe   = closed orbit e off-set
*                      23:  no. of slices
*                      24:  iopt: 10 (if vertical crossing) + flag
*                           flag = 0: use table, 1: recalculate errf
*                      25:  cox = closed orbit off-set in x
*                      26:  coy = closed orbit off-set in y
      implicit none
+ca aparam
      integer i,iopt,ivert,np,nsli
      double precision alphaxs,alphays,alphxs,alphys,
     +betaxs,betays,coe,cop,coq,cox,coy,coz,cphi,d,dinv,emitxs,
     +emitys,etapxs,etapys,etaxs,etays,f,odlum,phi,pi,ptemp,
     +qtemp,siges,sigpps,sigqqs,sigxxn,sigxxs,sigyyn,sigyys,sigzs,
     +sigzzs,sphi,tphi,track,xiyn,xstar,xtemp,ystar,ytemp,
     +zstar, betas, ex, ey, exn, eyn, parvec(*)
      dimension track(6,np)
      dimension xstar(15),ystar(15),zstar(15)
      dimension sigxxs(15),sigpps(15),sigyys(15),sigqqs(15)
      dimension d(6,6),dinv(6,6)
      integer err_cnt
      external bbf, bbf1
      data err_cnt / 0 /
      data pi /3.141592653589793d0/
      phi=parvec(10)
      nsli=parvec(23)
      if (nsli .le. 0)  nsli = 1
      iopt=parvec(24)
      if (parvec(6) .eq. 0.)  goto 999
      betas = sqrt(1.d0 - 1.d0 / parvec(7)**2)
      ex = parvec(8)
      ey = parvec(9)
      exn = 4.d0 * betas * parvec(7) * ex
      eyn = 4.d0 * betas * parvec(7) * ey
      sigzs=parvec(19)
      siges=parvec(20)
      coz=parvec(21)
      coe=parvec(22)
*     in case of iopt=10 or 11 vertical crossing!!!!!
      ivert=0
      if(iopt.gt.2) then
        iopt=iopt-10
        ivert=1
        xiyn = -parvec(5) * parvec(6) / (pi * eyn)
        betaxs=parvec(2)**2 / ey
        betays=parvec(1)**2 / ex
        alphxs=parvec(14)
        alphys=parvec(13)
        etaxs=parvec(16)
        etays=parvec(15)
        etapxs=parvec(18)
        etapys=parvec(17)
        emitxs=ey
        emitys=ex
        cox=parvec(4) + parvec(26)
        cop=parvec(12)
        coy=-(parvec(3) + parvec(25))
        coq=-parvec(11)
*     rotation of 90 degrees!
        do i=1,np
          xtemp=track(1,i)
          ptemp=track(2,i)
          ytemp=track(3,i)
          qtemp=track(4,i)
          track(1,i)=+ytemp
          track(2,i)=+qtemp
          track(3,i)=-xtemp
          track(4,i)=-ptemp
        enddo
      else
        xiyn = -parvec(5) * parvec(6) / (pi * exn)
        betaxs=parvec(1)**2 / ex
        betays=parvec(2)**2 / ey
        alphxs=parvec(13)
        alphys=parvec(14)
        etaxs=parvec(15)
        etays=parvec(16)
        etapxs=parvec(17)
        etapys=parvec(18)
        emitxs=ex
        emitys=ey
        cox=parvec(3) + parvec(25)
        cop=parvec(11)
        coy=parvec(4) + parvec(26)
        coq=parvec(12)
      endif
      if (abs(emitxs) .lt. 1.d-16 .or. abs(emitys) .lt. 1.d-16) then
        err_cnt = err_cnt + 1
        if (err_cnt .le. 10)  then
          call aawarn('beamint', 1, 'emitxs or emitys = 0.')
        endif
        goto 999
      endif
      if (abs((emitxs - emitys)/(emitxs + emitys)) .lt. 1.d-3)
     +emitys = 0.4995 * (emitxs + emitys)
      sphi=sin(phi)
      cphi=cos(phi)
      tphi=tan(phi)

*     define slices
        call stsld(xstar,ystar,zstar,phi,
     &         sigzs,siges,emitxs,betaxs,alphxs,
     &         emitys,betays,alphys,
     &         etaxs,etapxs,etays,etapys,
     &         sigzzs,sigxxs,sigpps,sigyys,sigqqs,nsli)

*     define f
          sigxxn=emitxs*betaxs
          sigyyn=emitys*betays
      if (abs(betays) .lt. 1.d-16) then
        err_cnt = err_cnt + 1
        if (err_cnt .le. 10)  then
          call aawarn('beamint', 1, 'betays = 0.')
        endif
        goto 999
      endif
          f=xiyn/betays*2*pi*sqrt(sigyyn)*
     $         (sqrt(sigyyn)+sqrt(sigxxn))/nsli

        call revmat(etaxs,etapxs,etays,etapys,betaxs,betays,alphaxs,
     &     alphays, emitxs,emitys,sigzs,siges,d,dinv)

*       not necessary because mad has physical coordinates
*       call promvv(dinv,np,track)

           do i=1,np
           track(1,i)=track(1,i)-cox
           track(2,i)=track(2,i)-cop
           track(3,i)=track(3,i)-coy
           track(4,i)=track(4,i)-coq
           track(5,i)=track(5,i)-coz
           track(6,i)=track(6,i)-coe
           enddo

        call boost(sphi,cphi,tphi,np,track)
            if(iopt.eq.0) call sbc(xstar,ystar,zstar,bbf,
     &           odlum,sigxxs,sigpps,sigyys,sigqqs,f,np,nsli,track)
            if(iopt.eq.1) call sbc(xstar,ystar,zstar,bbf1,
     &           odlum,sigxxs,sigpps,sigyys,sigqqs,f,np,nsli,track)
        call boosti(sphi,cphi,np,track)

           do i=1,np
           track(1,i)=track(1,i)+cox
           track(2,i)=track(2,i)+cop
           track(3,i)=track(3,i)+coy
           track(4,i)=track(4,i)+coq
           track(5,i)=track(5,i)+coz
           track(6,i)=track(6,i)+coe
           enddo

*     in case of iopt=10 or 11 vertical crossing!!!!!
*     rotation of 90 degrees!
      if(ivert.eq.1) then
      do i=1,np
        xtemp=track(1,i)
        ptemp=track(2,i)
        ytemp=track(3,i)
        qtemp=track(4,i)
        track(1,i)=-ytemp
        track(2,i)=-qtemp
        track(3,i)=+xtemp
        track(4,i)=+ptemp
      enddo
      endif

  999 end
+dk boost
      subroutine boost(sphi,cphi,tphi,np,track)
      implicit none
* boost boost operation ********************************************
c    p,q,e are all normalized by p0
+ca aparam
      integer i,np
      double precision a,a1,cphi,h,h1x,h1y,h1z,hd1,sphi,sqr1a,tphi,
     +track,x1
      dimension track(6,*)
      do 1000 i=1,np
      a=(track(2,i)**2+track(4,i)**2)/(1+track(6,i))**2
      sqr1a=sqrt(1-a)
      h=(track(6,i)+1)*(1-sqr1a)
      track(2,i)=(track(2,i)-tphi*h)/cphi
      track(4,i)=track(4,i)/cphi
      track(6,i)=track(6,i)-sphi*track(2,i)
      a1=(track(2,i)**2+track(4,i)**2)/(1+track(6,i))**2
      sqr1a=sqrt(1-a1)
      hd1=(1+track(6,i))*sqr1a
      h1x=track(2,i)/hd1
      h1y=track(4,i)/hd1
      h1z=1-1/sqr1a
      x1=tphi*track(5,i)+(1+sphi*h1x)*track(1,i)
      track(3,i)=track(3,i)+sphi*h1y*track(1,i)
      track(5,i)=track(5,i)/cphi-sphi*h1z*track(1,i)
      track(1,i)=x1
*--- checked
 1000 continue
      return
      end
+dk sbc
      subroutine sbc(xstar,ystar,zstar,bbf,olum,
     &  sigxxs,sigpps,sigyys,sigqqs,f,np,nsli,track)
      implicit none
***sbc ***synchro-beam for headon collision**********************
*  call bbf  (table)
* olum is a luminosity
*****************************************************************
+ca aparam
      integer i,jsli,np,nsli
      double precision bbfx,bbfy,bbgx,bbgy,f,g,gfunc,olum,s,sepx,sepy,
     +sigpps,sigqqs,sigxxs,sigyys,sumsxsy,sx,sy,track,xstar,ystar,zstar
      external bbf
      dimension track(6,*)
      dimension sigxxs(nsli),sigpps(nsli),sigyys(nsli),sigqqs(nsli)
      dimension xstar(nsli),ystar(nsli),zstar(nsli)
c          write(6,*) 'welcome to sbc'
      olum=0.0
      do 2000 jsli=1,nsli

      do 1000 i=1,np
      s=(track(5,i)-zstar(jsli))/2
      sx=sigxxs(jsli)+sigpps(jsli)*s*s
      sy=sigyys(jsli)+sigqqs(jsli)*s*s
      sumsxsy = sx + sy
      if (abs((sx - sy) / sumsxsy) .lt. 1.d-3)  then
        sx = 0.5005 * sumsxsy
        sy = 0.4995 * sumsxsy
      endif
      sepx=track(1,i)+track(2,i)*s-xstar(jsli)
      sepy=track(3,i)+track(4,i)*s-ystar(jsli)
c           write(6,*) 'before gfunc'
c           write(6,*) i,sx,sy,sepx,sepy

      olum=olum+
     $  gfunc( sqrt(sx),sqrt(sy),sepx,sepy)
*--------1---------2--------3--------4---------5---------6---------7--
c           write(6,*) 'before bbf'
       if(sx.gt.sy) then
      call bbf(sepx,sepy,sx,sy,bbfx,bbfy,bbgx,bbgy)
       else
      call bbf(sepy,sepx,sy,sx,bbfy,bbfx,bbgy,bbgx)
       endif
      bbfx=f*bbfx
      bbfy=f*bbfy
      bbgx=f*bbgx
      bbgy=f*bbgy
      g=s*(sigpps(jsli)*bbgx+sigqqs(jsli)*bbgy)
      track(6,i)=track(6,i)-bbfx*(track(2,i)-bbfx/2)/2-
     &           bbfy*(track(4,i)-bbfy/2)/2-g
      track(1,i)=track(1,i)+s*bbfx
      track(2,i)=track(2,i)-bbfx
      track(3,i)=track(3,i)+s*bbfy
      track(4,i)=track(4,i)-bbfy

 1000 continue
 2000 continue
c              write(6,*) 'bye bye from sbc'
      olum=olum/(nsli*np)
      return
      end
+dk boosti
      subroutine boosti(sphi,cphi,np,track)
      implicit none
* boosti **************inverse boost *****************
+ca aparam
      integer i,np
      double precision a1,cphi,det,h1,h1d,h1x,h1y,h1z,sphi,sqr1a,track,
     +x1
      dimension track(6,np)
      do 1000 i=1,np
      a1=(track(2,i)**2+track(4,i)**2)/(1+track(6,i))**2
      sqr1a=sqrt(1-a1)
      h1d=(1+track(6,i))*sqr1a
      h1=(track(6,i)+1)*(1-sqr1a)
      h1x=track(2,i)/h1d
      h1y=track(4,i)/h1d
      h1z=1-1/sqr1a
      det=1+sphi*(h1x-sphi*h1z)
      x1=(track(1,i)-sphi*track(5,i))/det
      track(5,i)=cphi*((1+h1x*sphi)*track(5,i)-h1z*sphi*track(1,i))/det
      track(3,i)=track(3,i)-h1y*sphi*x1
      track(1,i) = x1
      track(6,i)=track(6,i)+sphi*track(2,i)
      track(2,i)=(track(2,i)+sphi*h1)*cphi
      track(4,i)=track(4,i)*cphi
*--- checked
 1000 continue
      return
      end
+dk gfunc
      function gfunc(sigx,sigy,bx,by)
      implicit none
* gfunc **************************************************************
+ca aparam
      double precision bx,by,func,gfunc,pi2,q,sigx,sigy,xx,yy
      data pi2 / 6.283185307179587d0/
      func(q)=exp(-q**2/2)
c         write(6,*) sigx,sigy,bx,by
      xx=bx/sigx
      yy=by/sigy
      if(xx.lt.6d0.and.yy.lt.6d0) then
          gfunc=func(xx)*func(yy)/(pi2*sigx*sigy)
      else
          gfunc=0
      endif
      return
      end
+dk bbf
      subroutine bbf(sepx,sepy,sigxx,sigyy,bbfx,bbfy,bbgx,bbgy)
      implicit none
***********************************************************************
* bbf gives transverse (f_x and f_y) and longitudinal(g_x and g_y)
* beam-beam kicks except for the kinematical term (nr_e/\gamma)
* sigxx is \sigma
***********************************************************************
+ca aparam
      double precision arg1x,arg1y,arg2x,arg2y,bbfx,bbfy,bbgx,bbgy,
     +comfac,const,expfac,fac,fac2,sepx,sepy,sigxx,sigxy,
     +sigyy,sqrpi2,wx1,wx2,wy1,wy2,x,w1equ(2)
       complex*16 z_,w_1,werff
       equivalence (w_1, w1equ)
      data sqrpi2/3.54490 77018 11032d0/
      x=sepx**2/sigxx+sepy**2/sigyy
      fac2=2.d0*abs(sigxx-sigyy)
      fac=sqrt(fac2)
      const=sqrpi2/fac
      sigxy=sqrt(sigxx/sigyy)
      arg1x=abs(sepx/fac)
      arg1y=abs(sepy/fac)
      z_=cmplx(arg1x,arg1y)
      w_1=werff(z_)
      wy1=dble(w_1)
      wx1=imag(w_1)
      if(x.lt.100.d0) then
       expfac=exp(-x*0.5d0)
       arg2x=arg1x/sigxy
       arg2y=arg1y*sigxy
      z_=cmplx(arg2x,arg2y)
      w_1=werff(z_)
*      wy2=real(w_1)
*      wx2=imag(w_1)
       wy2 = w1equ(1)
       wx2 = w1equ(2)
       bbfx=const*(wx1-expfac*wx2)
       bbfy=const*(wy1-expfac*wy2)
         if(sepx.lt.0) bbfx=-bbfx
         if(sepy.lt.0) bbfy=-bbfy
       comfac=sepx*bbfx+sepy*bbfy
       bbgx=-(comfac+2*(expfac/sigxy -1))/fac2
       bbgy= (comfac+2*(expfac*sigxy -1))/fac2

      else
       bbfx=const*wx1
       bbfy=const*wy1
        if(sepx.lt.0) bbfx=-bbfx
        if(sepy.lt.0) bbfy=-bbfy
       comfac=sepx*bbfx+sepy*bbfy
       bbgx=-(comfac-2)/fac2
       bbgy= -bbgx
      endif
c      write(6,*) comfac
      return
      end
+dk bbf1
      subroutine bbf1(sepx,sepy,sigxx,sigyy,bbfx,bbfy,bbgx,bbgy)
      implicit none
***bbf1   bbf without using table *************************************
* gives transverse (f_x and f_y) and longitudinal(g_x and g_y)
* beam-beam kicks except for the kinematical term (nr_e/\gamma)
* sigxx is \sigma
***********************************************************************
+ca aparam
      double precision arg1x,arg1y,arg2x,arg2y,bbfx,bbfy,bbgx,bbgy,
     +comfac,const,expfac,fac,fac2,sepx,sepy,sigxx,sigxy,
     +sigyy,sqrpi2,wx1,wx2,wy1,wy2,x
       complex*16 z_,w_1,cwerff
      data sqrpi2/3.54490 77018 11032d0/
      x=sepx**2/sigxx+sepy**2/sigyy
      fac2=2.d0*abs(sigxx-sigyy)
      fac=sqrt(fac2)
      const=sqrpi2/fac
      sigxy=sqrt(sigxx/sigyy)
      arg1x=abs(sepx/fac)
      arg1y=abs(sepy/fac)
      z_=cmplx(arg1x,arg1y)
      w_1=cwerff(z_)
      wy1=dble(w_1)
      wx1=imag(w_1)
      if(x.lt.100.d0) then
       expfac=exp(-x*0.5d0)
       arg2x=arg1x/sigxy
       arg2y=arg1y*sigxy
      z_=cmplx(arg2x,arg2y)
      w_1=cwerff(z_)
      wy2=dble(w_1)
      wx2=imag(w_1)
       bbfx=const*(wx1-expfac*wx2)
       bbfy=const*(wy1-expfac*wy2)
         if(sepx.lt.0) bbfx=-bbfx
         if(sepy.lt.0) bbfy=-bbfy
       comfac=sepx*bbfx+sepy*bbfy
       bbgx=-(comfac+2*(expfac/sigxy -1))/fac2
       bbgy= (comfac+2*(expfac*sigxy -1))/fac2

      else
       bbfx=const*wx1
       bbfy=const*wy1
        if(sepx.lt.0) bbfx=-bbfx
        if(sepy.lt.0) bbfy=-bbfy
       comfac=sepx*bbfx+sepy*bbfy
       bbgx=-(comfac-2)/fac2
       bbgy= -bbgx
      endif
c      write(6,*) comfac
      return
      end
+dk seterf
      subroutine seterf
      implicit none
c******************** seterf **********************************
+ca aparam
      integer i,j,mx,my,nx,ny
      double precision dx,dy,x,y
      complex*16 z_,cwerff
      complex*8 w_
      parameter (mx=39,my=30)
      common/erfcmm/ w_(0:3,0:mx,0:my)

      complex*16 i_,c_1,c_2, c_3, c_4, c_5
      data i_/(0d0,1d0)/,c_1/(-1.5d0,1.5d0)/,c_2/(0.5d0,-0.5d0)/,
     %      c_3/(0d0,-2d0)/,c_4/(1.5d0,0.5d0)/,c_5/(-1.5d0,0.5d0)/
      dx=0.1d0
      dy=0.1d0
      nx=39
      ny=30
      do 100 i=0,nx
      x=dx*i
      do 100 j=0,ny
      y=dy*j
      z_=cmplx(x,y)
      w_(0,i,j)=cwerff(z_)
  100 continue
      do 200 i=0,nx-1
      do 200 j=0,ny-1
      w_(1,i,j)=c_1*w_(0,i,j)+c_2*w_(0,i+1,j+1)+w_(0,i,j+1)
     %          -i_*w_(0,i+1,j)
      w_(2,i,j)=c_3*w_(0,i,j)+c_4*w_(0,i+1,j)+i_*w_(0,i+1,j+1)
     %          +c_5*w_(0,i,j+1)
      w_(3,i,j)=c_2*(w_(0,i,j+1)-w_(0,i+1,j)
     %                           +i_*(w_(0,i,j)-w_(0,i+1,j+1)))
  200 continue
      return
      end
+dk cwerff
      function cwerff(z_)
      implicit none
c******************** cwerff ****************************************
+ca aparam
      integer n,nc,nu
      double precision alamda,c,const,fn,h,h2,r1,r2,rs1,rs2,
     +s,s1,s2,t1,t2,x,xx,y,yy
      complex*16 z_,cwerff
      logical b
      data const/1.12837 91670 9551d0/
      xx=dble(z_)
      yy=imag(z_)
      x=abs(xx)
      y=abs(yy)
      if(y .lt. 4.29d0 .and. x .lt. 5.33d0) go to 1
      h=0.
      nc=0
      nu=8
      alamda=0.
      b=.true.
      go to 2
    1 s=(1d0-y/4.29d0)*sqrt(1d0-x**2/28.41d0)
      h=1.6d0*s
      h2=2d0*h
      nc=6+int(23d0*s)
      nu=9+int(21d0*s)
      alamda=h2**nc
      b= alamda .eq. 0d0
    2 r1=0d0
      r2=0d0
      s1=0d0
      s2=0d0
      n=nu+1
    3 n=n-1
      fn=n+1
      t1=y+h+fn*r1
      t2=x-fn*r2
      c=0.5d0/(t1**2+t2**2)
      r1=c*t1
      r2=c*t2
      if(h .le. 0.0 .or. n .gt. nc) go to 4
      t1=alamda+s1
      s1=r1*t1-r2*s2
      s2=r2*t1+r1*s2
      alamda=alamda/h2
    4 if(n .gt. 0) go to 3
      if(b) go to 6
      rs1=s1
      rs2=s2
      go to 7
    6 rs1=r1
      rs2=r2
    7 rs1=const*rs1
      if(y .eq. 0d0) rs1=exp(-x**2)
      cwerff=cmplx(rs1,const*rs2)
      if(yy .lt. 0d0) go to 8
      if(xx .lt. 0d0) cwerff=conjg(cwerff)
      return
    8 cwerff=2d0*exp(-cmplx(x,y)**2)-cwerff
      if(xx .gt. 0d0) cwerff=conjg(cwerff)
      return
      end
+dk werff
      function werff(z_)
      implicit none
c******************** werff ****************************************
      integer ix,iy,mx,my
      real x,y,z2i,z2r
      parameter (mx=39,my=30)
      complex*8 w_,dz_,z_1
      common/erfcmm/w_(0:3,0:mx,0:my)
      complex*16 werff,z_, zloc
      double precision zequ(2)
      equivalence (zloc, zequ)
      real*4 c1, c2, c3, c4, c5, c6, c7, c8, c9, c10
      data
     a c1/0.4613135e0/,c2/0.1901635e0/,c3/0.09999216e0/,c4/1.7844927e0/,
     b c5/2.883894e-3/,c6/5.5253437e0/,c7/0.5124242e0/, c8/0.2752551e0/,
     c c9/0.05176536e0/,c10/2.724745e0/
*      x=real(z_)
*      y=imag(z_)
      zloc = z_
      x = zequ(1)
      y = zequ(2)
      if(x.ge.3.8999.or.y.ge.2.9999) goto 20
      x=10.0*x
      y=10.0*y
      ix=int(x)
      iy=int(y)
      dz_=cmplx(x-float(ix),y-float(iy))
      werff=((dz_*w_(3,ix,iy)+w_(2,ix,iy))*dz_+w_(1,ix,iy))*dz_
     %     +w_(0,ix,iy)
      return
   20 z2r=x**2-y**2
      z2i=2.0*x*y
      z_1=cmplx(-y,x)
      if(x.ge.6.0.or.y.ge.6.0) goto 40
      werff=z_1*(c1/cmplx(z2r-c2,z2i)+c3/cmplx(z2r-c4,z2i)
     %          +c5/cmplx(z2r-c6,z2i))
      return
   40 werff=z_1*(c7/cmplx(z2r-c8,z2i)+c9/cmplx(z2r-c10,z2i))
      return
      end
+dk stsld
      subroutine stsld(xstar,ystar,zstar,phi,
     &         sigzs,siges,emitxs,betaxs,alphxs,
     &         emitys,betays,alphys,
     &         etaxs,etapxs,etays,etapys,
     &         sigzzs,sigxxs,sigpps,sigyys,sigqqs,nsli)
      implicit none
********stsld********************************************
*   makes a data of the strong slice
*   sigxx  is the <x**2> at headon frame.
*   sigzs is the sqrt<z**2> at lab. frame. (input)
*   at present, sigxxl etc do not depend on zstar
*   alphxs,alphys are not used for the moment
*********************************************************
+ca aparam
      integer i,nsli
      double precision alphxs,alphys,betaxs,betays,bord,bord1,border,
     +emitxs,emitys,etapxs,etapys,etaxs,etays,gauinv,phi,pi,siges,
     +sigpps,sigqqs,sigxxs,sigyys,sigz,sigzs,sigzz,sigzzs,xstar,ystar,
     +yy,zstar
      dimension sigxxs(nsli),sigpps(nsli),sigyys(nsli),sigqqs(nsli)
      dimension xstar(nsli),ystar(nsli),zstar(nsli)
      data border /8d0/
      data   pi / 3.141592653589793d0/
        sigz=sigzs/cos(phi)
        sigzz=sigz**2
* define zstar,xstar,ystar
*  bord is border zstar is the barycenter of region divided two borders.
         bord=+border
         do 101 i=nsli,1,-1
         yy=1d0/nsli*(i-1)
c            write(6,*) bord
         if(i.ne.1) bord1=dble(gauinv(yy))
         if(i.eq.1) bord1=-border
         zstar(i)=(exp(-bord**2/2)-exp(-bord1**2/2))
     &         /sqrt(2d0*pi)*nsli
         bord=bord1

         zstar(i)=zstar(i)*sigz
         xstar(i)=zstar(i)*sin(phi)
         ystar(i)=0
         sigxxs(i)=emitxs*betaxs+(etaxs*siges)**2
         sigpps(i)=(emitxs/betaxs+(etapxs*siges)**2)/cos(phi)**2
         sigyys(i)=emitys*betays+(etays*siges)**2
         sigqqs(i)=(emitys/betays+(etapys*siges)**2)/cos(phi)**2

c            write(6,*) i,zstar(i)
  101    continue
      return
      end
+dk revmat
      subroutine revmat(etax,etapx,etay,etapy,betax,betay,alphax,
     &     alphay, emitx,emity,sigz,sige,d,dinv)
      implicit none
* revmat ***********************************************
* d=b*h  dinv=hinv*binv
********************************************************
+ca aparam
      integer i,j
      double precision alphax,alphay,b,betax,betay,betaz,binv,c,cinv,d,
     +dinv,dsqrt,emitx,emity,etapx,etapy,etax,etay,h,hinv,sige,sigz,
     +work
      dimension work(6,6)
      dimension b(6,6),binv(6,6),h(6,6),hinv(6,6),c(6,6),cinv(6,6)
      dimension d(6,6),dinv(6,6)
* revolution for normal modes
      do 10 i=1,6
      do 10 j=1,6
      d(i,j)=0
      dinv(i,j)=0
      b(i,j)=0
      binv(i,j)=0
      h(i,j)=0
      hinv(i,j)=0
      c(i,j)=0
      cinv(i,j)=0
  10  continue
      betaz=sigz/sige
* parameters for d
      b(1,1)=1/dsqrt(betax)
      b(2,1)=alphax/dsqrt(betax)
      b(2,2)=dsqrt(betax)
      b(3,3)=1/dsqrt(betay)
      b(4,3)=alphay/dsqrt(betay)
      b(4,4)=dsqrt(betay)
      b(5,5)=1/dsqrt(betaz)
      b(6,6)=dsqrt(betaz)

      c(1,1)=1d0
      c(2,2)=1d0
      c(3,3)=1d0
      c(4,4)=1d0
      c(5,5)=1d0
      c(6,6)=1d0
      cinv(1,1)=1d0
      cinv(2,2)=1d0
      cinv(3,3)=1d0
      cinv(4,4)=1d0
      cinv(5,5)=1d0
      cinv(6,6)=1d0

c      call promat(work,cinv,c)
c      call shomat(work)

      do 20 i=1,6
 20   h(i,i)=1d0
      h(1,6)=-etax
      h(2,6)=-etapx
      h(3,6)=-etay
      h(4,6)=-etapy
      h(5,1)=etapx
      h(5,2)=-etax
      h(5,3)=etapy
      h(5,4)=-etay
c         call shomat(h)
c      call promat(d,b,h)

      do 30 i=1,6
 30   hinv(i,i)=1d0
      hinv(1,6)=etax
      hinv(2,6)=etapx
      hinv(3,6)=etay
      hinv(4,6)=etapy
      hinv(5,1)=-etapx
      hinv(5,2)=etax
      hinv(5,3)=-etapy
      hinv(5,4)=etay
      binv(1,1)=dsqrt(betax)
      binv(2,1)=-alphax/dsqrt(betax)
      binv(2,2)=1/dsqrt(betax)
      binv(3,3)=dsqrt(betay)
      binv(4,3)=-alphay/dsqrt(betay)
      binv(4,4)=1/dsqrt(betay)
      binv(5,5)=dsqrt(betaz)
      binv(6,6)=1/dsqrt(betaz)

      call promat(work,c,h)
      call promat(d,b,work)
      call promat(work,hinv,cinv)
      call promat(dinv,work,binv)

      return
      end
+dk promat
      subroutine promat(a,b,c)
      implicit none
* promat **  a=b*c  ************************************
*  matric a=b*c (6,6) matrix
+ca aparam
      integer i,j,k
      double precision a,b,c
      dimension a(6,6),b(6,6),c(6,6)
      do 200 i=1,6
      do 200 j=1,6
      a(i,j)=0
      do 100 k=1,6
 100  a(i,j)=a(i,j)+b(i,k)*c(k,j)
 200  continue
      return
      end
+dk gauinv
      function gauinv(p0)
      implicit none
*gauinv***********************************************
*  inverse of (integrated) normal distribution function
*              1         x= y
*     p(y)=-----------* integral exp(-x**2/2) dx
*          sqrt(2*pi)    x= -inf
*     if p(y)=p0, then gauinv(p0)=y.
*        0 < p0 < 1 ,   -inf < y < +inf
*  if this routine is used to convert uniform random numbers to
*  gaussian, maximum relative error in the distribution function
*  dp/dx=exp(-x**2/2)/sqrt(2*pi) is less than 0.640e-3 everywhere
*  in the range  2**(-31) < p0 < 1-2**31.  (minimax approximation)
+ca aparam
c------------------------
      double precision a0,a1,a2,a3,b0,b1,b2,b3,b4,c0,c1,c2,c3,c4,d0,d1,
     +d2,d3,d4,e0,e1,e2,e3,e4,f0,f1,f2,gauinv,p,p0,p1,p2,pp1,q,qq2,qq3,
     +qq4,qq5,t
      data pp1/0.334624883253d0/, qq2/0.090230446775d0/,
     1     qq3/0.049905685242d0/, qq4/0.027852994157d0/,
     2     qq5/0.015645650215d0/
      data a3/ 4.5585614d+01/, a2/ 2.1635544d+00/, a1/ 2.7724523d+00/,
     1     a0/ 2.5050240d+00/,
     2     b4/ 4.0314354d+02/, b3/-2.7713713d+02/, b2/ 7.9731883d+01/,
     3     b1/-1.4946512d+01/, b0/ 2.2157257d+00/,
     4     c4/ 4.1394487d+03/, c3/-1.5585873d+03/, c2/ 2.4648581d+02/,
     5     c1/-2.4719139d+01/, c0/ 2.4335936d+00/,
     6     d4/ 4.0895693d+04/, d3/-8.5400893d+03/, d2/ 7.4942805d+02/,
     7     d1/-4.1028898d+01/, d0/ 2.6346872d+00/,
     8     e4/ 3.9399134d+05/, e3/-4.6004775d+04/, e2/ 2.2566998d+03/,
     9     e1/-6.8317697d+01/, e0/ 2.8224654d+00/
      data f0/-8.1807613d-02/, f1/-2.8358733d+00/, f2/ 1.4902469d+00/
c------------------------
      gauinv = 0
      p=p0-0.5d0
      p1=abs(p)
      if(p1.ge.pp1) goto 120
      p2=p**2
      gauinv=(((a3*p2+a2)*p2+a1)*p2+a0)*p
      return
  120 q=0.5d0-p1
      if(q.le.qq2) goto 140
      gauinv=(((b4*q+b3)*q+b2)*q+b1)*q+b0
      goto 200
  140 if(q.le.qq3) goto 150
      gauinv=(((c4*q+c3)*q+c2)*q+c1)*q+c0
      goto 200
  150 if(q.le.qq4) goto 160
      gauinv=(((d4*q+d3)*q+d2)*q+d1)*q+d0
      goto 200
  160 if(q.le.qq5) goto 170
      gauinv=(((e4*q+e3)*q+e2)*q+e1)*q+e0
      goto 200
  170 if(q.le.0d0) goto 900
      t=sqrt(-2d0*log(q))
      gauinv=t+f0+f1/(f2+t)
  200 if(p.lt.0d0) gauinv=-gauinv
      return
  900 write(6,910) p0
      gauinv = 0
  910 format(' (func.gauinv) invalid input argument ',1pd20.13)
      return
      end
+dk dmzzzz
+dk emaaaa
+dk emce2i
      subroutine emce2i(em, ex, ey, et, sigma)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Convert eigenvectors to internal sigma matrix form.                *
* Input:                                                               *
*   EM(6,6)   (real)    Eigenvector matrix.                            *
*   EX        (real)    Horizontal emittance.                          *
*   EY        (real)    Vertical emittance.                            *
*   ET        (real)    Longitudinal emittance.                        *
* Output:                                                              *
*   SIGMA(6,6)(real)    Beam matrix in internal form.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer j,k
      double precision em,et,ex,ey,sigma
      dimension         em(6,6), sigma(6,6)
+ca status

      do 20 j = 1, 6
        do 10 k = 1, 6
          sigma(j,k) =
     +      ex * (em(j,1) * em(k,1) + em(j,2) * em(k,2)) +
     +      ey * (em(j,3) * em(k,3) + em(j,4) * em(k,4))
          if (stabt) then
            sigma(j,k) = sigma(j,k) +
     +        et * (em(j,5) * em(k,5) + em(j,6) * em(k,6))
          endif
   10   continue
   20 continue

      end
+dk emci2t
      subroutine emci2t(sigma, corr)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Convert beam matrix internal form to TRANSPORT form.               *
* Input:                                                               *
*   SIGMA(6,6)(real)    Beam matrix in internal form.                  *
* Output:                                                              *
*   CORR(6,6) (real)    Standard deviations and lower correlations.    *
*----------------------------------------------------------------------*
* Modified: 12-MAR-1999, M. Woodley (SLAC)                             *
*   Change TOL from 1.0D-10 to 1.0D-24                                 *
*----------------------------------------------------------------------*
+ca aparam
      integer j,k
      double precision corr,sigma,tol
      dimension         sigma(6,6), corr(6,6)

      parameter         (tol = 1.0d-24)
      do 10 j = 1, 6
        corr(j,j) = sqrt(abs(sigma(j,j)))
   10 continue

      do 30 k = 1, 5
        do 20 j = k + 1, 6
          if (corr(j,j) * corr(k,k) .gt. tol) then
            corr(j,k) = sigma(j,k) / (corr(j,j) * corr(k,k))
          else
            corr(j,k) = 0.0
          endif
          corr(k,j) = corr(j,k)
   20   continue
   30 continue

      end
+dk emct2i
      subroutine emct2i(corr, sigma)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Convert sigma matrix from TRANSPORT to internal form.              *
* Input:                                                               *
*   CORR(6,6) (real)    Standard deviations and lower correlations.    *
* Output:                                                              *
*   SIGMA(6,6)(real)    Beam matrix in internal form.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer j,k
      double precision corr,sigma
      dimension         corr(6,6), sigma(6,6)

      do 20 k = 1, 5
        do 10 j = k + 1, 6
          sigma(j,k) = corr(j,j) * corr(k,k) * corr(j,k)
          sigma(k,j) = sigma(j,k)
   10   continue
   20 continue

      do 30 j = 1, 6
        sigma(j,j) = corr(j,j)**2
   30 continue

      end
+dk emdamp
      subroutine emdamp(em1, em2, orb1, orb2, re)
      implicit none
*---------------------------------------------------------------------*
* Purpose:                                                            *
*   Deal with radiation damping in an element.                        *
* Input:                                                              *
*   EM1(6,6)  (real)    Matrix of eigenvectors at entrance.           *
*   EM2(6,6)  (real)    Matrix of eigenvectors at exit.               *
*   ORB1(6)   (real)    Orbit position at entrance.                   *
*   ORB2(6)   (real)    Orbit position at exit.                       *
* Input/output:                                                       *
*   RE(6,6)   (real)    Transfer matrix for the element; changed on   *
*                       output to contain damping.                    *
*---------------------------------------------------------------------*
* Modified: 11-JAN-1999, T. Raubenheimer (SLAC)                        *
*   Included FINTX attribute in RBEND, SBEND, and GBEND (NOTE: FINTX   *
*   is assumed to have same value as FINT if it is not set or is       *
*   negative as the default in the dict file)                          *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ii,j,iord,ir,isp,n,na,nd,ne,nord
      double precision an,ang,bi2gi2,corr,ct,data,di,dr,drt,e1,e2,e5sq1,
     +e5sq2,e5sqs1,e5sqs2,edg1,edg2,ek0,el,em1,em2,f1,f1s,f2,f2s,fact1,
     +fact1x,fact2,fact2x,ferror,fh,fh1,fh2,field,fint,four,h,h1,
     +h2,half,hbi,hcb,hcb1,hcb2,hcbs1,hcbs2,hgap,hx,hxx,hxy,hy,hyx,hyy,
     +o1,o2,one,orb1,orb2,pt1,pt2,px1,px2,py1,py2,r1sq,r2sq,re,rfac,
     +rfac1,rfac1x,rfac1y,rfac2,rfac2x,rfac2y,rfacx,rfacy,rff,rffrq,rfl,
     +rflag,rfv,rfvlt,rw,six,sk1,sk2,sk3,sks,st,str,t1,t2,tedg1,tedg2,
     +ten3m,ten6p,three,tilt,time,tw,twelve,two,twon,val,x,x1,x2,xkick,
     +y,y1,y2,ykick,zero
      dimension         em1(6,6), em2(6,6), orb1(6), orb2(6), re(6,6)
      double precision an2
      double precision fintx
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca prcgroup
+ca beam
+ca codata
+ca emdata
+ca option
+ca range
+ca refer
+ca stflag
+ca maxmul
+ca physicpm
+ca pi
      parameter         (ten3m = 1.0d-3, ten6p = 1.0d+6)
      parameter         (zero  = 0.0d0,  half  = 0.5d0)
      parameter         (one   = 1.0d0,  two   = 2.0d0)
      parameter         (three = 3.0d0,  twelve = 12.d0)
      parameter         (four  = 4.0d0,  six   = 6.0d0)

      dimension         ek0(6), rw(6,6), tw(6,6,6), ferror(2)
      dimension         data(2,0:maxmul), field(2,0:maxmul)
      dimension         o1(6), e1(6,6), o2(6), e2(6,6)
      logical bvflag
      integer bvpos
      parameter         (bvpos = 24)
      equivalence       (x1, o1(1)), (px1, o1(2))
      equivalence       (y1, o1(3)), (py1, o1(4))
      equivalence       (t1, o1(3)), (pt1, o1(4))
      equivalence       (x2, o2(1)), (px2, o2(2))
      equivalence       (y2, o2(3)), (py2, o2(4))
      equivalence       (t2, o2(3)), (pt2, o2(4))

      bvflag = .false.
*---- Switch on element type.
      isp = iq(lcelm+mbsp)
      go to (500,  20,  30, 500,  50,  60,  70,  80, 500, 100,
     +       500, 500, 500, 140, 150, 160, 500, 500, 500, 500,
     +       500, 500, 500, 500, 500, 260, 500, 500, 500, 500,
     +       500, 500, 500, 500, 500, 500, 500, 500, 500, 500), isp
      go to 500

*---- Dipole.
   20 continue
   30 continue

*---- Prepare data.
        call ucopy(q(lcelm+melen), el, mwflt)
        if (el .eq. zero) go to 500
        call ucopy(q(lcelm+meangb), an,   mwflt)
        call ucopy(q(lcelm+metltb), tilt, mwflt)
        call ucopy(q(lcelm+mek1b), sk1, mwflt)
        call ucopy(q(lcelm+mee1b), edg1, mwflt)
        call ucopy(q(lcelm+mee2b), edg2, mwflt)
        call ucopy(q(lcelm+mek2b), sk2, mwflt)
        call ucopy(q(lcelm+megapb), hgap, mwflt)
        call ucopy(q(lcelm+meintb), fint, mwflt)
        call ucopy(q(lcelm+meintbx+3*mcsiz), bvflag, 1)
        call ucopy(q(lcelm+meintbx), fintx, mwflt)
       sks = 0.0
      go to 35

*---- General bend (dipole, quadrupole, and skew quadrupole).
  260 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        if (el .eq. zero) go to 500
        call ucopy(q(lcelm+meangg), an,   mwflt)
        call ucopy(q(lcelm+metltg), tilt, mwflt)
        call ucopy(q(lcelm+mek1g), sk1, mwflt)
        call ucopy(q(lcelm+mee1g), edg1, mwflt)
        call ucopy(q(lcelm+mee2g), edg2, mwflt)
        call ucopy(q(lcelm+meksg), sks, mwflt)
        call ucopy(q(lcelm+megapg), hgap, mwflt)
        call ucopy(q(lcelm+meintg), fint, mwflt)
        call ucopy(q(lcelm+meintgx), fintx, mwflt)
        call ucopy(q(lcelm+meintgx+3*mcsiz), bvflag, 1)
        sk2 = 0.0

*---- Edge focusing angles.
   35 continue
*--- HG000915 use bv flag to possibly invert angle
        if (bvflag) an = beambv * an
*--- apply inversion and scaling
        sk1 = sk1 * elmfact(1)
        sks = sks * elmfact(1)
        sk2 = sk2 * elmfact(2)
        if (iq(lcelm+mbsp) .eq. 2) then
*--- HG001026: arc length to rectangular bend
          an2  = an / two
          if (an2 .ne. 0.d0 .and. rbarc)  el = el * an2 / sin(an2)
          edg1 = edg1 + an2
          edg2 = edg2 + an2
        endif
        h = an / el

*---- Refer orbit and eigenvectors to magnet midplane.
        ct = cos(tilt)
        st = sin(tilt)
        o1(1) =   ct * orb1(1) + st * orb1(3)
        o1(2) =   ct * orb1(2) + st * orb1(4)
        o1(3) = - st * orb1(1) + ct * orb1(3)
        o1(4) = - st * orb1(2) + ct * orb1(4)
        o1(5) = orb1(5)
        o1(6) = orb1(6)
        o2(1) =   ct * orb2(1) + st * orb2(3)
        o2(2) =   ct * orb2(2) + st * orb2(4)
        o2(3) = - st * orb2(1) + ct * orb2(3)
        o2(4) = - st * orb2(2) + ct * orb2(4)
        o2(5) = orb2(5)
        o2(6) = orb2(6)
        do 10 i = 1, 6
          e1(1,i) =   ct * em1(1,i) + st * em1(3,i)
          e1(2,i) =   ct * em1(2,i) + st * em1(4,i)
          e1(3,i) = - st * em1(1,i) + ct * em1(3,i)
          e1(4,i) = - st * em1(2,i) + ct * em1(4,i)
          e1(5,i) = em1(5,i)
          e1(6,i) = em1(6,i)
          e2(1,i) =   ct * em2(1,i) + st * em2(3,i)
          e2(2,i) =   ct * em2(2,i) + st * em2(4,i)
          e2(3,i) = - st * em2(1,i) + ct * em2(3,i)
          e2(4,i) = - st * em2(2,i) + ct * em2(4,i)
          e2(5,i) = em2(5,i)
          e2(6,i) = em2(6,i)
   10   continue

*---- Move through orbit through fringing field;
*     Requested components of eigenvectors are not affected.
        corr = (h + h) * hgap * fint
        call tmfrng(.false.,h,sk1,edg1,zero,+one,corr,ek0,rw,tw)
        call m66byv(rw,o1,o1)
*---- Tor: use FINTX if set
        if (fintx .gt. 0) then
          corr = (h + h) * hgap * fintx
        else
          corr = (h + h) * hgap * fint
        endif
        call tmfrng(.false.,h,sk1,edg2,zero,-one,corr,ek0,rw,tw)
        call m66inv(rw,rw)
        call m66byv(rw,o2,o2)

*---- Local curvature and its derivatives,
*     Coefficients for damping matrix.
        hx = sk1*x1 + sks*y1 + h + half*sk2 * (x1**2 - y1**2)
        hy = sks*x1 - sk1*y1 - sk2*x1*y1
        hxx = sk1 + sk2*x1
        hxy = sks - sk2*y1
        hyx = hxy
        hyy = - hxx
        h1 = sqrt(hx**2 + hy**2)
        hcb1 = h1**3
        hcbs1 = three*h1 *
     +    (hx * (hxx*px1 + hxy*py1) + hy * (hxy*px1 + hyy*py1))

        tedg1  = tan(edg1)
        fact1  = (one + h*x1) * (one - tedg1*x1)
        fact1x = h - tedg1 - 2.0*h*tedg1*x1
        rfac1  = cg*el*h1**2*fact1
        rfac1x = cg*el * (two*(hx*hxx+hy*hyx)*fact1 + h1**2*fact1x)
        rfac1y = cg*el *  two*(hx*hxy+hy*hyy)*fact1

        hx = sk1*x2 + sks*y2 + h + half*sk2 * (x2**2 - y2**2)
        hy = sks*x2 - sk1*y2 - sk2*x2*y2
        hxx = sk1 + sk2*x2
        hxy = sks - sk2*y2
        hyx = hxy
        hyy = - hxx
        h2 = sqrt(hx**2 + hy**2)
        hcb2 = h2**3
        hcbs2 = three*h2 *
     +    (hx * (hxx*px2 + hxy*py2) + hy * (hxy*px2 + hyy*py2))

        tedg2  = tan(edg2)
        fact2  = (one + h*x2) * (one - tedg2*x2)
        fact2x = h - tedg2 - 2.0*h*tedg2*x2
        rfac2  = cg*el*h2**2*fact2
        rfac2x = cg*el * (two*(hx*hxx+hy*hyx)*fact2 + h2**2*fact2x)
        rfac2y = cg*el *  two*(hx*hxy+hy*hyy)*fact2

*---- Cubic integration over h**3 * E(i,5) * conjg(E(i,5)).
        bi2gi2 = one / (betas * gammas)**2
        hbi = h / betas
        do 40 i = 1, 3
          ir = 2 * i - 1
          ii = 2 * i

*---- E(i,5) * conjg(E(i,5)) and its derivative w.r.t. S.
          e5sq1 = e1(5,ir)**2 + e1(5,ii)**2
          e5sq2 = e2(5,ir)**2 + e2(5,ii)**2
          e5sqs1 = two * (e1(5,ir) * (bi2gi2*e1(6,ir) - hbi*e1(1,ir))
     +                  + e1(5,ii) * (bi2gi2*e1(6,ii) - hbi*e1(1,ii)))
          e5sqs2 = two * (e2(5,ir) * (bi2gi2*e2(6,ir) - hbi*e2(1,ir))
     +                  + e2(5,ii) * (bi2gi2*e2(6,ii) - hbi*e2(1,ii)))

*---- Integrand and its derivative w.r.t. S.
          f1 = hcb1 * e5sq1
          f2 = hcb2 * e5sq2
          f1s = hcbs1 * e5sq1 + hcb1 * e5sqs1
          f2s = hcbs2 * e5sq2 + hcb2 * e5sqs2

*---- Actual integration.
          sum(i) = sum(i) + half * el * (f1 + f2) -
     +             el**2 * (f2s - f1s) / twelve
   40   continue
      go to 77

*---- Quadrupole.
   50 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mek1q), sk1, mwflt)
        str  = sk1
        n    = 1
        twon = two
        go to 75

*---- Sextupole.
   60 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mek1q), sk2, mwflt)
        str  = sk2 / two
        n    = 2
        twon = four
        go to 75

*---- Octupole.
   70 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mek1q), sk3, mwflt)
        str  = sk3 / six
        n    = 3
        twon = six

*---- Common to all pure multipoles.
   75   if (el .eq. zero) go to 500
        call ucopy(orb1, o1, 6*mwflt)
        call ucopy(orb2, o2, 6*mwflt)
        call ucopy(em1, e1, 36*mwflt)
        call ucopy(em2, e2, 36*mwflt)

*---- Local curvature.
        r1sq = orb1(1)**2 + orb1(3)**2
        r2sq = orb2(1)**2 + orb2(3)**2
        h1 = abs(str) * sqrt(r1sq)**n
        h2 = abs(str) * sqrt(r2sq)**n
        rfac = cg * str**2 * el
        rfac1 = rfac * r1sq**n
        rfac2 = rfac * r2sq**n
        rfac1x = twon * rfac * r1sq**(n-1) * x1
        rfac2x = twon * rfac * r1sq**(n-1) * x2
        rfac1y = twon * rfac * r1sq**(n-1) * y1
        rfac2y = twon * rfac * r1sq**(n-1) * y2

*---- Trapezoidal integration over h**3 * E(k,5) * conjg(E(k,5)).
        fh1 = half * el * h1**3
        fh2 = half * el * h2**3
        sum(1) = sum(1) + fh1 * (e1(5,1)**2 + e1(5,2)**2)
     +                  + fh2 * (e2(5,1)**2 + e2(5,2)**2)
        sum(2) = sum(2) + fh1 * (e1(5,3)**2 + e1(5,4)**2)
     +                  + fh2 * (e2(5,3)**2 + e2(5,4)**2)
        sum(3) = sum(3) + fh1 * (e1(5,5)**2 + e1(5,6)**2)
     +                  + fh2 * (e2(5,5)**2 + e2(5,6)**2)

*---- Damping matrices.
*     Code common to bending magnet and pure multipoles.
   77   call m66one(rw)
        rw(2,1) =     - rfac1x * (one + pt1) * px1
        rw(2,2) = one - rfac1  * (one + pt1)
        rw(2,3) =     - rfac1y * (one + pt1) * px1
        rw(2,6) =     - rfac1                * px1
        rw(4,1) =     - rfac1x * (one + pt1) * py1
        rw(4,3) =     - rfac1y * (one + pt1) * py1
        rw(4,4) = one - rfac1  * (one + pt1)
        rw(4,6) =     - rfac1                * py1
        rw(6,1) =     - rfac1x * (one + pt1)**2
        rw(6,3) =     - rfac1y * (one + pt1)**2
        rw(6,6) = one - two * rfac1 * (one + pt1)
        call m66mpy(re, rw, re)

        call m66one(rw)
        rw(2,1) =     - rfac2x * (one + pt2) * px2
        rw(2,2) = one - rfac2  * (one + pt2)
        rw(2,3) =     - rfac2y * (one + pt2) * px2
        rw(2,6) =     - rfac2                * px2
        rw(4,1) =     - rfac2x * (one + pt2) * py2
        rw(4,3) =     - rfac2y * (one + pt2) * py2
        rw(4,4) = one - rfac2  * (one + pt2)
        rw(4,6) =     - rfac2                * py2
        rw(6,1) =     - rfac2x * (one + pt2)**2
        rw(6,3) =     - rfac2y * (one + pt2)**2
        rw(6,6) = one - two * rfac2 * (one + pt2)
        call m66mpy(rw, re, re)
      go to 500

*---- Thin multipoles, EL is the fictitious length for radiation.
   80 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        if (el .ne. zero) then

*---- Multipole components.
          nd = 2 * mwflt * (maxmul + 1)
          call uzero(data, 1, nd)
          na = min(2 * maxmul + 4, iq(lcelm+mbat))
          call utgflt(lcelm, 3, na, data)
          call utglog(lcelm, bvpos, bvpos, bvflag)

          call uzero(field, 1, nd)
          if (lcfld .ne. 0) then
            ne = min(iq(lcfld-1), nd)
            call ucopy(q(lcfld+1), field, ne)
          endif

          nord = 0
          do 81 iord = 0, maxmul
            val =   data(1,iord)
            ang = - data(2,iord) * float(iord+1)
            field(1,iord) = val * cos(ang) + field(1,iord)
            field(2,iord) = val * sin(ang) + field(2,iord)
            if (field(1,iord).ne.zero .or. field(2,iord).ne.zero) then
              nord = iord
            endif
   81     continue

*--- HG000915 use bv flag to possibly invert angle
          if (bvflag) then
            field(1,0) = beambv * field(1,0)
            field(2,0) = beambv * field(2,0)
          endif
*--- apply inversion and scaling
          do i = 1, nord
            do j = 1, 2
              field(j,i) = field(j,i) * elmfact(i)
            enddo
          enddo

*---- Track orbit.
          x = orb1(1)
          y = orb1(3)

*---- Multipole kick.
          dr = zero
          di = zero
          do 82 iord = nord, 0, -1
            drt = (dr * x - di * y) / float(iord+1) + field(1,iord)
            di  = (dr * y + di * x) / float(iord+1) + field(2,iord)
            dr  = drt
   82     continue

*---- H is local "curvature" due to multipole kick.
          h  = sqrt(dr**2 + di**2) / el
          hcb = half * el * h**3
          sum(1)  = sum(1) + hcb *
     +      (em1(5,1)**2 + em1(5,2)**2 + em2(5,1)**2 + em2(5,2)**2)
          sum(2)  = sum(2) + hcb *
     +      (em1(5,3)**2 + em1(5,4)**2 + em2(5,3)**2 + em2(5,4)**2)
          sum(3)  = sum(3) + hcb *
     +      (em1(5,5)**2 + em1(5,6)**2 + em2(5,5)**2 + em2(5,6)**2)

*---- Damping matrix, is the same at both ends.
          rfac  = cg * (dr**2 + di**2) / el
          rfacx = cg * (- dr * re(2,1) + di * re(4,1)) / el
          rfacy = cg * (- dr * re(2,3) + di * re(4,3)) / el

          call m66one(rw)
          rw(2,1) = - rfacx * (one + orb1(6)) * orb1(2)
          rw(2,2) = one - rfac * (one + orb1(6))
          rw(2,3) = - rfacy * (one + orb1(6)) * orb1(2)
          rw(2,6) = - rfac * orb1(2)
          rw(4,1) = - rfacx * (one + orb1(6)) * orb1(4)
          rw(4,3) = - rfacy * (one + orb1(6)) * orb1(4)
          rw(4,4) = one - rfac * (one + orb1(6))
          rw(4,6) = - rfac * orb1(4)
          rw(6,1) = - rfacx * (one + orb1(6))
          rw(6,3) = - rfacy * (one + orb1(6))
          rw(6,6) = one - two * rfac * (one + orb1(6))
          call m66mpy(re, rw, re)
          call m66mpy(rw, re, re)
        endif
      go to 500

*---- RF cavities.
  100 continue
        call ucopy(q(lcelm+mevltc), rfv, mwflt)
        call ucopy(q(lcelm+mefrqc), rff, mwflt)
        call ucopy(q(lcelm+melagc), rfl, mwflt)
        rfvlt = ten3m * rfv
        rffrq = rff * (ten6p * two * pi / clight)
        rflag = two * pi * rfl
        time = half * (orb1(5) + orb2(5))
        sumu0 = sumu0 + rfvlt * sin(rflag - rffrq * time)
      go to 500

*---- Orbit correctors.
  140 continue
  150 continue
  160 continue
        call ucopy(q(lcelm+melen), el, mwflt)

*---- Original setting.
        if (el .ne. zero) then
          isp = iq(lcelm+mbsp)
          if (isp .eq. 14) then
            call ucopy(q(lcelm+mekick), xkick, mwflt)
            ykick = zero
          else if (isp .eq. 16) then
            xkick = zero
            call ucopy(q(lcelm+mekick), ykick, mwflt)
          else
            call ucopy(q(lcelm+mekick), xkick, mwflt)
            call ucopy(q(lcelm+mekick+mcsiz), ykick, mwflt)
          endif

*---- Correction from C.O. correction algorithm.
          if (dokick  .and.  lccom .ne. 0) then
            call ucopy(q(lccom+1), xcm, 2*mwflt)
          else
            xcm = zero
            ycm = zero
          endif

*---- Field errors.
          if (lcfld .ne. 0) then
            call ucopy(q(lcfld+1), ferror, 2*mwflt)
          else
            ferror(1) = zero
            ferror(2) = zero
          endif

*---- Local curvature.
          hx = abs(xcm + xkick + ferror(1)) / el
          hy = abs(ycm + ykick + ferror(2)) / el
          rfac = cg * (hx**2 + hx**2) * el

*---- Trapezoidal integration over h**3*E(k,5)*E*(k,5).
          fh = half * el * sqrt(hx**2 + hy**2)**3
          sum(1) = sum(1) + fh *
     +      (em1(5,1)**2 + em1(5,2)**2 + em2(5,1)**2 + em2(5,2)**2)
          sum(2) = sum(2) + fh *
     +      (em1(5,3)**2 + em1(5,4)**2 + em2(5,3)**2 + em2(5,4)**2)
          sum(3) = sum(3) + fh *
     +      (em1(5,5)**2 + em1(5,6)**2 + em2(5,5)**2 + em2(5,6)**2)

*---- Damping matrices.
          call m66one(rw)
          rw(2,2) = one - rfac * (one + orb1(6))
          rw(2,6) = - rfac * orb1(2)
          rw(4,4) = one - rfac * (one + orb1(6))
          rw(4,6) = - rfac * orb1(4)
          rw(6,6) = one - two * rfac * (one + orb1(6))
          call m66mpy(re, rw, re)

          call m66one(rw)
          rw(2,2) = one - rfac * (one + orb2(6))
          rw(2,6) = - rfac * orb2(2)
          rw(4,4) = one - rfac * (one + orb2(6))
          rw(4,6) = - rfac * orb2(4)
          rw(6,6) = one - two * rfac * (one + orb2(6))
          call m66mpy(rw, re, re)
        endif
      go to 500

  500 continue

 9999 end
+dk ememdo
      subroutine ememdo
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Adjust RF system and compute emittances by A. Chao's method.       *
*   EMIT command.                                                      *
* Attributes:                                                          *
*   DELTAP    (real)    Average relative energy error.                 *
*----------------------------------------------------------------------*
+ca aparam
+ca refer
+ca status
      double precision deltap

*---- Check main beam line.
      call lnchck('EMIT', error)

*---- Retrieve attribute.
      if (.not. error) then
        deltap = 0.0
        call utgflt(lccmd, 1, 1, deltap)

*---- Execute.
        call ememgo(deltap)
      endif

      end
+dk ememgo
      subroutine ememgo(deltap)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Compute emittances by A. Chao's method.                            *
* Input:                                                               *
*   DELTAP     (real)   Average energy error desired.                  *
*----------------------------------------------------------------------*
+ca aparam
+ca seqflag
+ca beam
+ca mapelm
+ca maptrn
+ca optic0
+ca optic1
+ca range
+ca refer
+ca status
+ca zunit
      integer i,icode,ienum,iflag,iocc,ipos,j,j1,j2,jbyt,k,k1,k2
      double precision aival,bmax,bx,deltap,dismax,el,em,em2,gmax,gx,
     +orbit1,rd,reval,tol,twopi

+ca pi
      parameter         (twopi = 2.0d0 * pi, tol = 1.000001d0)

      dimension         em(6,6), rd(6,6), reval(6), aival(6)
      dimension         orbit1(6), bmax(3,3), gmax(3,3), dismax(4)
      dimension         em2(6,6)
      character*(mcnam) elmnam
      logical           m66sta, fmap

*---- SYMM is not allowed.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)
      if (symm) then
        call aafail('EMEMIT', 1,
     +    '"SYMM" cannot be set for "EMIT" command.')
        go to 9999
      endif

*---- Adjust environment.
      call enfix
      if (error) go to 9999
      call enfreq(deltap)

*---- Compute one-turn map and find closed orbit.
      call tmturn(lcseq, deltas, error)
      if (error) go to 9999
      do 10 i = 1, 6
        orbit(i) = orbit0(i)
   10 continue
*---- Find eigenvectors at initial position.
      if (m66sta(rt)) then
        call laseig(rt, reval, aival, em)
        stabt = .false.
*        write (iqlog, '('' Static map, eigenvalues:'',(/1X,2E15.8))')
*     +    (reval(i), aival(i), i = 1, 4)
      else
        call ladeig(rt, reval, aival, em)
        stabt = reval(5)**2 + aival(5)**2 .le. tol  .and.
     +          reval(6)**2 + aival(6)**2 .le. tol
*        write (iqlog, '('' Static map, eigenvalues:'',(/1X,2E15.8))')
*     +    (reval(i), aival(i), i = 1, 6)
      endif
      if (error) go to 9999
      stabx = reval(1)**2 + aival(1)**2 .le. tol  .and.
     +        reval(2)**2 + aival(2)**2 .le. tol
      staby = reval(3)**2 + aival(3)**2 .le. tol  .and.
     +        reval(4)**2 + aival(4)**2 .le. tol

*---- Maximum extents.
      do 30 j = 1, 3
        j1 = 2 * j -1
        j2 = 2 * j
        do 20 k = 1, 3
          k1 = 2 * k - 1
          k2 = 2 * k
          bmax(j,k) = em(j1,k1) * em(j1,k1) + em(j1,k2) * em(j1,k2)
          gmax(j,k) = em(j2,k1) * em(j2,k1) + em(j2,k2) * em(j2,k2)
   20   continue
   30 continue

*---- Initialize damping calculation.
      if (frad .and. stabt) then
        call eminit
        call m66one(rd)
      endif

*---- Cumulated length.
      suml = 0.0

*---- Loop through element sequence.
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        icode = jbyt(iflag, 1, mcode)

*---- Physical element.
        if (icode .eq. 1) then

*---- Misalignment at entrance.
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            if (.not. stabt) call m66byv(re, disp, disp)
            call m66mpy(re, em, em)
            if (frad .and. stabt) call m66mpy(re, rd, rd)
          endif

*---- Keep orbit at entrance.
          call ucopy(orbit, orbit1, 6*mwflt)

*---- Track through element.
          call tmmap(.true., .true., orbit, fmap, el, ek, re, te)
          if (fmap) then

*---- Advance dispersion.
            if (.not. stabt) then
              call m66byv(re, disp, disp)
              do 40 j = 1, 4
                dismax(j) = max(abs(disp(j)),dismax(j))
   40         continue
            endif
            suml = suml + el

*---- Radiation damping.
            call m66mpy(re, em, em2)
            if (frad .and. stabt) then
              call emdamp(em, em2, orbit1, orbit, re)
              call m66mpy(re, rd, rd)
            endif
            call ucopy(em2, em, 36*mwflt)

*---- Compute beta and gamma.
            do 60 j = 1, 3
              j1 = 2 * j -1
              j2 = 2 * j
              do 50 k = 1, 3
                k1 = 2 * k - 1
                k2 = 2 * k
                bx = em(j1,k1) * em(j1,k1) + em(j1,k2) * em(j1,k2)
                bmax(j,k) = max(bmax(j,k),bx)
                gx = em(j2,k1) * em(j2,k1) + em(j2,k2) * em(j2,k2)
                gmax(j,k) = max(gmax(j,k),gx)
   50         continue
   60       continue
          endif

*---- Misalignment at exit.
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            if (.not. stabt) call m66byv(re, disp, disp)
            call m66mpy(re, em, em)
            if (frad .and. stabt) call m66mpy(re, rd, rd)
          endif

*---- Entrance of line.
        else if (icode .eq. 2) then

*---- Misalignment.
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            if (.not. stabt) call m66byv(re, disp, disp)
            call m66mpy(re, em, em)
            if (frad .and. stabt) call m66mpy(re, rd, rd)
          endif

*---- Exit of line.
        else

*---- Misalignment.
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            if (.not. stabt) call m66byv(re, disp, disp)
            call m66mpy(re, em, em)
            if (frad .and. stabt) call m66mpy(re, rd, rd)
          endif
        endif
   90 continue

*---- Undamped tunes and beam extents.
      qx = nsup * atan2(aival(1), reval(1)) / twopi
      if (qx .lt. 0.0) qx = qx + nsup
      qy = nsup * atan2(aival(3), reval(3)) / twopi
      if (qy .lt. 0.0) qy = qy + nsup
      qs = nsup * atan2(aival(5), reval(5)) / twopi
      if (qs .lt. 0.0) qs = - qs

*---- Summary output.
      call emsumm('EMIT', rd, em, bmax, gmax, dismax)

 9999 end
+dk emendo
      subroutine emendo
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   ENVELOPE command: Track beam envelope.                             *
* Attributes:                                                          *
*   SAVE      (name)    SAVE option: Table name.                       *
*   SIGMA0    (name)    Bank for initial conditions.                   *
*   LINE      (line)    Line for initial conditions.                   *
*   TAPE      (string)  TAPE option: File name.                        *
*----------------------------------------------------------------------*
* Modified: 30-NOV-1998, M. Woodley (SLAC)                             *
*   Add support for tape file output                                   *
*----------------------------------------------------------------------*
+ca aparam
+ca refer
+ca status
+ca message
      integer idisk
      integer mlin,msav,msig,mtape

      parameter         (msav = 1, msig = 2, mlin = 3, mtape = 4)

      character*(mcnam) twsnam(2), signam, savnam
      equivalence       (savnam, twsnam(1))
      equivalence       (signam, twsnam(2))
      integer           itype(3)
      character*(mcfil) strnam, filnam
      logical           tape, eflag
*---- Check main beam line.
      call lnchck('EMENDO', error)
      if (.not. error) then

*---- File name for TAPE option.
        strnam = ' '
        call utgstr(lccmd, mtape, mtape, strnam)
        tape = strnam .ne. ' '

*---- Open file for "TAPE" option.
        if (tape) then
          call flopen(strnam, 'SWFD', 0, 0, idisk, eflag)
          tape = .not. eflag
        endif

*---- Retrieve attributes.
        call utgtyp(lccmd, itype)
        signam = ' '
        savnam = ' '
        call utgnam(lccmd, msav, msig, twsnam)
        call emengo(itype, savnam, signam, mlin, tape, idisk)
      endif

*---- Close disk file.
      if (tape) then
        call flclos(idisk, error)
        if (.not. error) then
          call flname(idisk, filnam)
          msg(1) = 'Envelope functions written on file: ' // filnam
          call aainfo('emendo', 1, msg)
        endif
      endif

      end
+dk emengo
      subroutine emengo(itype, savnam, signam, iline, tape, idisk)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track beam envelope.                                               *
* Input:                                                               *
*   ITYPE(3)  (integer) Flag array: SAVE, SIGMA0, LINE.                *
*   SAVNAM    (name)    Name for SAVE table.                           *
*   SIGNAM    (name)    Name for SIGMA0 option.                        *
*   ILINE     (integer) Number for LINE attribute.                     *
*   TAPE      (logical) True: Write tape file output on disk.          *
*   IDISK     (integer) Logical unit number for tape file output.      *
*----------------------------------------------------------------------*
* Modified: 18-MAR-1999, M. Woodley (SLAC)                             *
*   Add support for tape file output                                   *
* Modified: 01-APR-1999, M. Woodley (SLAC)                             *
*   Initialize ENER1 (in COMMON /OPTIC1/) using ENERGY from BEAM common *
*----------------------------------------------------------------------*
+ca aparam
      integer ibeta,icode,ienum,iflag,ileng,iline,iocc,ipos,j,jbit,jbyt
      double precision aival,corr,dismax,disrms,el,em,one,orbmax,orbrms,
     +pos,reval,sigma,sigmax,sigrms,temp,tol,zero
      integer           itype(4)
      character*(mcnam) savnam, signam
      logical tape
      integer idisk
+ca memdum
+ca seqflag
+ca strgroup
+ca message
+ca beam
+ca mapelm
+ca maptrn
+ca optic0
+ca optic1
+if doom
+ca dmcommon
+ei
+ca range
+ca refer
+ca status
+ca twlink
+ca zunit

      parameter         (tol = 1.000001d0, zero = 0.0d0, one = 1.0d0)

      character*(mcnam) elmnam
      logical           fmap, fprt, fsav, m66sta
      dimension         em(6,6), sigma(6,6), reval(6), aival(6)
      dimension         corr(6,6), temp(6,6)
      dimension         dismax(6), disrms(6)
      dimension         orbmax(6), orbrms(6), sigmax(6), sigrms(6)

*---- Get data for beam.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Deal with SIGMA0; First check consistency.
      if (signam .ne. ' ') then
        call utleng(signam, ileng)
        call difind(ldbnk, signam(1:ileng), ibeta, ltwbet)
        if (ltwbet .eq. 0) then
          msg(1) = 'Initial SIGMA0 bank "' // signam(1:ileng)
     +    // '" not found.'
          call aafail('EMENGO', 1, msg)
          go to 9999
        else if (itype(iline) .ne. 0) then
          call aafail('EMENGO', 1,
     +    'Conflicting options SIGMA0 and LINE have been specified.')
          go to 9999
        endif

*---- Fetch SIGMA0 values.
        call uzero(orbit, 1, 6*mwflt)
        call uzero(disp,  1, 6*mwflt)
        call uzero(corr,  1, 36*mwflt)
        call utgflt(ltwbet,  1,  6, orbit)
        call utgflt(ltwbet,  7, 12, disp)
        call utgflt(ltwbet, 13, 18, corr(1,1))
        call utgflt(ltwbet, 19, 23, corr(2,2))
        call utgflt(ltwbet, 24, 27, corr(3,3))
        call utgflt(ltwbet, 28, 30, corr(4,4))
        call utgflt(ltwbet, 31, 32, corr(5,5))
        call utgflt(ltwbet, 33, 33, corr(6,6))
        call emct2i(corr, sigma)
        stabx = .true.
        staby = .true.
        stabt = .true.

*---- No SIGMA0 seen; maybe use LINE attribute.
      else
        if (itype(iline) .ne. 0) then
          call lnrefe(lccmd, iline, ltwlin, lroot, -minit)
          if (error) go to 9999
          call tmturn(ltwlin, deltas, error)
        else
          call tmturn(lcseq, deltas, error)
        endif
        if (error) go to 9999
        call ucopy(orbit0, orbit, 6*mwflt)

*---- Find eigenvectors at initial position.
        if (m66sta(rt)) then
          call twdisp(rt, rt(1,6), disp)
          disp(5) = 0.0
          disp(6) = 1.0
          call laseig(rt, reval, aival, em)
          stabt = .false.
        else
          call uzero(disp, 1, 6*mwflt)
          call ladeig(rt, reval, aival, em)
          if (error) go to 9999
          stabt = reval(5)**2 + aival(5)**2 .le. tol  .and.
     +            reval(6)**2 + aival(6)**2 .le. tol
        endif
        if (error) go to 9999
        stabx = reval(1)**2 + aival(1)**2 .le. tol  .and.
     +          reval(2)**2 + aival(2)**2 .le. tol
        staby = reval(3)**2 + aival(3)**2 .le. tol  .and.
     +          reval(4)**2 + aival(4)**2 .le. tol
        call emce2i(em, ex, ey, et, sigma)
      endif

*---- Create internal table for lattice functions.
      ltwfun = 0
      if (savnam .ne. ' ') call emensv(1, savnam, 0, sigma)
      if (error) go to 9999
      do 40 j = 1, 6
        dismax(j) = abs(disp(j))
        disrms(j) = disp(j)**2
        orbmax(j) = abs(orbit(j))
        orbrms(j) = orbit(j)**2
        sigmax(j) = sqrt(sigma(j,j))
        sigrms(j) = sigma(j,j)
   40 continue
      pos = one

*---- Initialize beam energy value ENER1 ... use ENERGY value from BEAM
*     common since ENVELOPE command doesn't have an explicit energy
*     attribute.
      ener1 = en0
*---- Loop through element sequence.
      suml = 0.0
      fsav = .false.
      call emenpr('ENVELOPE', 0, ' ', 0, 0, sigma)
      if (tape) call ementp(1, ' ', idisk, sigma, suml)
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        fprt = jbit(iflag,mprnt) .ne. 0  .or.
     +         ipos .eq. irg1  .or.  ipos .eq. irg2
        if (ltwfun .ne. 0) then
          fsav = jbit(iflag,moptc) .ne. 0
        endif
        icode = jbyt(iflag, 1, mcode)
+if doom
        currname = elmnam
        currocct = iocc
+ei
*---- Physical element.
        if (icode .eq. 1) then

*---- Misalignment at entrance.
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            if (.not. stabt) call m66byv(re, disp, disp)
            call m66mpy(re, sigma, temp)
            call m66mtr(temp, re, sigma)
          endif

*---- Track through element.
          call tmmap(.true., .true., orbit, fmap, el, ek, re, te)
          if (fmap) then
            if (.not. stabt) call m66byv(re, disp, disp)
            suml = suml + el
            call m66mpy(re, sigma, temp)
            call m66mtr(temp, re, sigma)

*---- Compute maximum extents.
            do 80 j = 1, 6
              dismax(j) = max(abs(disp(j)),dismax(j))
              disrms(j) = disrms(j) + disp(j)**2
              orbmax(j) = max(abs(orbit(j)),orbmax(j))
              orbrms(j) = orbrms(j) + orbit(j)**2
              sigmax(j) = max(sqrt(sigma(j,j)),sigmax(j))
              sigrms(j) = sigrms(j) + sigma(j,j)
   80       continue
            pos  = pos  + one
          endif

*---- Misalignment at exit.
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            if (.not. stabt) call m66byv(re, disp, disp)
            call m66mpy(re, sigma, temp)
            call m66mtr(temp, re, sigma)
          endif

*---- Print and save at exit.
          if (fprt) then
            call emenpr('ENVELOPE', icode, elmnam, ienum, iocc, sigma)
          endif
          if (fsav) then
            call emensv(2, elmnam, ipos, sigma)
          endif
          if (tape) call ementp(2, elmnam, idisk, sigma, suml)

*---- Entrance of line.
        else if (icode .eq. 2) then

*---- Output before entering.
          if (fprt) then
            call emenpr('ENVELOPE', icode, elmnam, 0, iocc, sigma)
          endif
          if (fsav) then
            call emensv(2, elmnam, ipos, sigma)
          endif

*---- Misalignment.
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            if (.not. stabt) call m66byv(re, disp, disp)
            call m66mpy(re, sigma, temp)
            call m66mtr(temp, re, sigma)
          endif

*---- Exit of line.
        else

*---- Misalignment.
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            if (.not. stabt) call m66byv(re, disp, disp)
            call m66mpy(re, sigma, temp)
            call m66mtr(temp, re, sigma)
          endif

*---- Output after exiting.
          if (fprt) then
            call emenpr('ENVELOPE', icode, elmnam, 0, iocc, sigma)
          endif
          if (fsav) then
            call emensv(2, elmnam, ipos, sigma)
          endif
        endif

*---- Fill in SAVESIGA command, if any.
        if (jbit(iflag,msbet) .ne. 0) then
          call emssig(ipos, orbit, disp, sigma)
        endif
   90 continue

*---- Summary.
      call prline(iqpr2)
      if (stabt) then
        do 210 j = 1, 6
          orbmax(j) = 1000.0 * orbmax(j)
          orbrms(j) = 1000.0 * sqrt(orbrms(j)/pos)
          sigmax(j) = 1000.0 * sigmax(j)
          sigrms(j) = 1000.0 * sqrt(sigrms(j)/pos)
  210   continue
        write (iqpr2, 910) orbmax, orbrms, sigmax, sigrms
      else
        do 220 j = 1, 4
          disrms(j) = sqrt(disrms(j)/pos)
          orbmax(j) = 1000.0 * orbmax(j)
          orbrms(j) = 1000.0 * sqrt(orbrms(j)/pos)
          sigmax(j) = 1000.0 * sigmax(j)
          sigrms(j) = 1000.0 * sqrt(sigrms(j)/pos)
  220   continue
        write (iqpr2, 920) (dismax(j), j=1,4), (disrms(j), j=1,4),
     +                     (orbmax(j), j=1,4), (orbrms(j), j=1,4),
     +                     (sigmax(j), j=1,4), (sigrms(j), j=1,4)
      endif
      call prline(iqpr2)
      if (tape) call ementp(3, ' ', idisk, sigma, suml)

*---- Drop LINE condition bank.
      if (ltwlin .ne. 0) call lndrop(ltwlin)

*---- Close lattice function table.
      if (ltwfun .ne. 0) call emensv(3, savnam, 0, sigma)

  910 format(t46,'x [mm]',t59,'px [mrad]',t78,'y [mm]',t91,'py [mrad]',
     +       t110,'t [mm]',t123,'pt [mrad]'/
     +       ' orbit',t13,'(abs. max.)',t36,6f16.6/
     +       t13,'(r.m.s.)',t36,6f16.6/
     +       ' sigma',t13,'(abs. max.)',t36,6f16.6/
     +       t13,'(r.m.s.)',t36,6f16.6)
  920 format(t47,'x [m]',t60,'px [rad]',t79,'y [m]',t92,'py [rad]'/
     +       ' dispersion',t13,'(abs. max.)',t36,4f16.6/
     +       t13,'(r.m.s.)',t36,4f16.6/
     +       t46,'x [mm]',t59,'px [mrad]',t78,'y [mm]',t91,'py [mrad]'/
     +       ' orbit',t13,'(abs. max.)',t36,4f16.6/
     +       t13,'(r.m.s.)',t36,4f16.6/
     +       ' sigma',t13,'(abs. max.)',t36,4f16.6/
     +       t13,'(r.m.s.)',t36,4f16.6)

 9999 end
+dk emenpr
      subroutine emenpr(comand, iloc, elmnam, ienum, iocc, sigma)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print beam sizes for NORMAL command.                               *
*   Uses data from BEAM command and current beam line sequence.        *
* Input:                                                               *
*   COMAND    (char)    Name of command.                               *
*   ILOC      (integer) Position code:                                 *
*                       1 = Beginning of system.                       *
*                       4 = After an element.                          *
*                       5 = Beginning of line.                         *
*                       6 = End of line.                               *
*                       7 = Summary.                                   *
*   ELMNAM    (char)    Element name.                                  *
*   IENUM     (integer) Element number.                                *
*   IOCC      (integer) Occurrence number.                             *
*   SIGMA(6,6)(real)    Beam matrix in internal form.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer ienum,iloc,iocc,j,k,mhead,mline,nline,npage
      double precision corr,eps,sigma
      character*(*)     comand
      character*(mcnam) elmnam
      dimension         sigma(6,6)
+ca beam
+ca range
+ca optic1
+ca status
+ca zunit

      character         apos*5, title*(*)
      dimension         corr(6,6)

      save              nline, npage

      parameter         (eps = 1.0d-8, mhead = 2, mline = 7)
      parameter         (title = 'Beam envelope.')
+ca maxlin

*---- Page layout control.
      if (iloc .eq. 0) then
        npage = 0
        nline = maxlin

*---- Print page header.
      else
        nline = nline + mline
        if (nline .ge. maxlin) then
          npage = npage + 1
          call prhead(comand, title, deltas, 0, nline, npage)
          nline = nline + mhead + mline
          if (stabt) then
            write (iqpr2, 910)
          else
            write (iqpr2, 920)
          endif
          call prline(iqpr2)
        endif

*---- Compute standard deviations and correlations.
        call emci2t(sigma, corr)

*---- Print output lines.
        if (iloc .eq. 1) then
          write (apos, '(I5)') ienum
        else if (iloc .eq. 2) then
          apos = 'begin'
        else
          apos = 'end'
        endif
        if (stabt) then
          write (iqpr2, 930) apos, elmnam, iocc, suml,
     +      (1000.0 * orbit(j), 1000.0 * corr(j,j),
     +       (corr(j,k), k = 1, j - 1), j = 1, 6)
        else
          write (iqpr2, 940) apos, elmnam, iocc, suml,
     +      (1000.0 * orbit(j), disp(j), 1000.0 * corr(j,j),
     +       (corr(j,k), k = 1, j - 1), j = 1, 4)
        endif
      endif

  910 format(t8,'Element sequence',t47,'orbit',t60,'sigma',t73,
     +       'c o r r e l a t i o n s')
  920 format(t8,'Element sequence',t47,'orbit',t60,'dispersion',
     +       t73,'sigma', t86, 'c o r r e l a t i o n s')
  930 format(' ',a5,' ',a8,i4,f10.3,
     +       t31,'x [mm]',t41,2f13.6/t31,'px [mrad]',t41,3f13.6/
     +       t31,'y [mm]',t41,4f13.6/t31,'py [mrad]',t41,5f13.6/
     +       t31,'t [mm]',t41,6f13.6/t31,'pt [mrad]',t41,7f13.6)
  940 format(' ',a5,' ',a8,i4,f10.3,
     +       t31,'x [mm]',t41,3f13.6/t31,'px [mrad]',t41,4f13.6/
     +       t31,'y [mm]',t41,5f13.6/t31,'py [mrad]',t41,6f13.6)

      end
+dk emensv
      subroutine emensv(iflag, elmnam, ipos, sigma)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save beam envelope in ENVELOPE command for postprocessing.         *
* Input:                                                               *
*   IFLAG     (integer) Position code:                                 *
*                       1 = Create table.                              *
*                       2 = Save.                                      *
*                       3 = Close.                                     *
*   ELMNAM    (char)    Element name; for IFLAG = 1|3: Table name.     *
*   IPOS      (integer) Position number.                               *
*   SIGMA(6,6)(real)    Correlation matrix.                            *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ibias,iflag,ipos,k,l,maxcol,nb,nc,nr,ns
      double precision corr,dummy,sigma
      character*(mcnam) elmnam
      dimension         sigma(6,6)
+ca memdum
+ca seqgroup
+ca message
+ca optic1
+ca option
+ca range
+ca refer
+ca twlink

      parameter         (maxcol = 35)
      character*(mcnam) colnam(maxcol)
      dimension         corr(6,6)
      integer           icfrm(maxcol)

      data colnam
     +  / 'NAME', 'S',
     +    'XCO',   'PXCO',  'YCO',   'PYCO',  'TCO',   'PTCO',
     +    'DX',    'DPX',   'DY',    'DPY',   'DT',    'DPT',
     +    'SIGX',  'R12',   'R13',   'R14',   'R15',   'R16',
     +    'SIGPX', 'R23',   'R24',   'R25',   'R26',   'SIGY',
     +    'R34',   'R35',   'R36',   'SIGPY', 'R45',   'R46',
     +    'SIGT',  'R56',   'SIGPT' /

*---- Create new table for envelope.
*     Warning: L is local link. Be careful with Zebra calls.
      if (iflag .eq. 1) then
        lsnum = lq(lcseq-msnum)
        ns = 1
        nr = iq(lq(lcseq-msflg)-1)
        nc = maxcol
        nb = 1
        icfrm(1) = 5
        icfrm(2) = 3
        if (double) icfrm(2) = mreal
        do 10 i = 3, maxcol
          icfrm(i) = icfrm(2)
   10   continue
        call tbcrea(elmnam, ns, nr, nc, colnam, icfrm, nb, ltwfun)
        call tbpdsc(ltwfun, 'TYPE', 5, 0, dummy, 'ENVELOPE')
        call mzbook(2, l, ltwfun, -1, 'BRNG', 0, 0, mss, 7, 0)
        call ucopy(q(lcseq+1), q(l+1), mss)

*---- Save one position.
      else if (ltwfun .ne. 0) then
        if (iflag .eq. 2) then
          call emci2t(sigma, corr)
          call tbset(ltwfun, ipos, 3, ltwbuf)
          call uctoh(elmnam, q(ltwbuf+1), mcwrd, mcnam)
          ibias = 1 + mwnam
          if (double) then
            call ucopy(suml, q(ltwbuf+ibias), mwflt)
            ibias = ibias + mwflt
            call ucopy(orbit, q(ltwbuf+ibias), 6*mwflt)
            ibias = ibias + 6 * mwflt
            call ucopy(disp, q(ltwbuf+ibias), 6*mwflt)
            ibias = ibias + 6 * mwflt
            call ucopy(corr(1,1), q(ltwbuf+ibias), 6*mwflt)
            ibias = ibias + 6 * mwflt
            call ucopy(corr(2,2), q(ltwbuf+ibias), 5*mwflt)
            ibias = ibias + 5 * mwflt
            call ucopy(corr(3,3), q(ltwbuf+ibias), 4*mwflt)
            ibias = ibias + 4 * mwflt
            call ucopy(corr(4,4), q(ltwbuf+ibias), 3*mwflt)
            ibias = ibias + 3 * mwflt
            call ucopy(corr(5,5), q(ltwbuf+ibias), 2*mwflt)
            ibias = ibias + 2 * mwflt
            call ucopy(corr(6,6), q(ltwbuf+ibias), mwflt)
          else
            q(ltwbuf+ibias) = suml
            ibias = ibias + 1
            do 20 i = 1, 6
              q(ltwbuf+ibias) = orbit(i)
              ibias = ibias + 1
   20       continue
            do 30 i = 1, 6
              q(ltwbuf+ibias) = disp(i)
              ibias = ibias + 1
   30       continue
            do 40 i = 1, 6
            do 40 k = i, 6
              q(ltwbuf+ibias) = corr(i,k)
              ibias = ibias + 1
   40       continue
          endif

*---- Close table file.
        else if (iflag .eq. 3) then
          call tbpdsc(ltwfun, 'CIRCUM', mreal, 0, nsup * suml, ' ')
          call tbclos(ltwfun)
          msg(1) = 'Orbit and eigenvectors saved in table: ' // elmnam
          call aainfo('EMENSV', 1, msg)
        endif
      endif

      end
+dk ementp
      subroutine ementp(iloc, elmnam, idisk, sigma, suml)
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TAPE option of ENVELOPE command.                                   *
* Input:                                                               *
*   ILOC      (integer) Position code:                                 *
*                       1 = Beginning of system.                       *
*                       2 = After an element.                          *
*                       3 = Summary at end of system.                  *
*   ELMNAM    (char)    Name associated with current element.          *
*   IDISK     (integer) Logical unit for output                        *
*   SIGMA(6,6)(real)    Beam matrix in internal form.                  *
*   SUML      (real)    Accumulated length.                            *
*----------------------------------------------------------------------*
* Created:  18-MAR-1999, M. Woodley (SLAC)                             *
*   Add tape file output for ENVELOPE command                          *
* Modified: 16-APR-1999, M. Woodley (SLAC)                             *
*   Add INITIAL record                                                 *
*----------------------------------------------------------------------*
      implicit none
      integer i, iloc, idisk
      character *(*) elmnam
      double precision sigma(6,6), suml
+ca aparam
+ca refer

      if (iloc .eq. 1) then
*---- Begin of system: Write header record.
        call tphead(idisk, 'ENVELOPE')
        lcelm = 0
        call tpelem('INITIAL', idisk)
        write (idisk, 910)
     +    (sigma(1,i), i = 1, 6),
     +    (sigma(2,i), i = 1, 6),
     +    (sigma(3,i), i = 1, 6),
     +    (sigma(4,i), i = 1, 6),
     +    (sigma(5,i), i = 1, 6),
     +    (sigma(6,i), i = 1, 6), suml
      else if (iloc .eq. 3) then
*---- End of system: Write summary record.
      else
*---- Exit of element: Write data record.
        call tpelem(elmnam, idisk)
        write (idisk, 910)
     +    (sigma(1,i), i = 1, 6),
     +    (sigma(2,i), i = 1, 6),
     +    (sigma(3,i), i = 1, 6),
     +    (sigma(4,i), i = 1, 6),
     +    (sigma(5,i), i = 1, 6),
     +    (sigma(6,i), i = 1, 6), suml
      endif

  910 format(1p,6e16.9/6e16.9/6e16.9/6e16.9/6e16.9/7e16.9)

      end
+dk emevdo
      subroutine emevdo
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   EIGEN command: Track eigenvectors for periodic solution.           *
* Attributes:                                                          *
*   SAVE      (name)    SAVE option: Table name.                       *
*----------------------------------------------------------------------*
+ca aparam
+ca refer
+ca status
      integer msav

      parameter         (msav = 1)

      character*(mcnam) savnam

*---- Check main beam line.
      call lnchck('EMEVDO', error)

*---- Retrieve attribute.
      if (.not. error) then
        savnam = ' '
        call utgnam(lccmd, msav, msav, savnam)
        call emevgo(savnam)
      endif

      end
+dk emevgo
      subroutine emevgo(savnam)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   EIGEN command: Track eigenvectors for periodic solution.           *
* Attributes:                                                          *
*   SAVNAM    (name)    SAVE option: Table name.                       *
*----------------------------------------------------------------------*
+ca aparam
      integer icode,ienum,iflag,iocc,ipos,j,jbit,jbyt
      double precision aival,amu,amuj,el,em,one,reval,sigma,tol,utwopi,
     +zero
      character*(mcnam) savnam
+ca seqflag
+ca beam
+ca mapelm
+ca maptrn
+ca optic0
+ca optic1
+if doom
+ca dmcommon
+ei
+ca range
+ca refer
+ca status
+ca twlink
+ca zunit

+ca pi
      parameter         (utwopi = 1.0d0 / (2.0d0 * pi))
      parameter         (tol = 1.000001d0, zero = 0.0d0, one = 1.0d0)

      character*(mcnam) elmnam
      logical           fmap, fprt, fsav, m66sta
      dimension         em(6,6), reval(6), aival(6), sigma(6,6)
      dimension         amu(3)

*---- Get data for beam.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Find periodic solution.
      call tmturn(lcseq, deltas, error)
      if (error) go to 9999
      call ucopy(orbit0, orbit, 6*mwflt)
      amu(1) = 0.0
      amu(2) = 0.0
      amu(3) = 0.0

*---- Find eigenvectors at initial position.
      if (m66sta(rt)) then
        call laseig(rt, reval, aival, em)
        stabt = .false.
      else
        call ladeig(rt, reval, aival, em)
        stabt = reval(5)**2 + aival(5)**2 .le. tol  .and.
     +          reval(6)**2 + aival(6)**2 .le. tol
      endif
      if (error) go to 9999
      stabx = reval(1)**2 + aival(1)**2 .le. tol  .and.
     +        reval(2)**2 + aival(2)**2 .le. tol
      staby = reval(3)**2 + aival(3)**2 .le. tol  .and.
     +        reval(4)**2 + aival(4)**2 .le. tol

*---- Create internal table for lattice functions.
      ltwfun = 0
      if (savnam .ne. ' ') call emevsv(1, savnam, 0, em, amu)
      if (error) go to 9999

*---- Loop through element sequence.
      suml = 0.0
      fsav = .false.
      call emevpr('EIGEN', 0, ' ', 0, 0, em, amu)
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        fprt = jbit(iflag,mprnt) .ne. 0  .or.
     +         ipos .eq. irg1  .or.  ipos .eq. irg2
        if (ltwfun .ne. 0) then
          fsav = jbit(iflag,moptc) .ne. 0
        endif
        icode = jbyt(iflag, 1, mcode)
+if doom
        currname = elmnam
        currocct = iocc
+ei
*---- Physical element.
        if (icode .eq. 1) then

*---- Misalignment at entrance.
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            call m66mpy(re, em, em)
            do 20 j = 1, 3
              amuj = atan2(em(2*j-1,2*j),em(2*j-1,2*j-1)) * utwopi
              amu(j) = amuj + anint(amu(j)-amuj)
   20       continue
          endif

*---- Track through element.
          call tmmap(.true., .true., orbit, fmap, el, ek, re, te)
          if (fmap) then
            suml = suml + el
            call m66mpy(re, em, em)
            do 30 j = 1, 3
              amuj = atan2(em(2*j-1,2*j),em(2*j-1,2*j-1)) * utwopi
              amu(j) = amuj + anint(amu(j)-amuj)
   30       continue
          endif

*---- Misalignment at exit.
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            call m66mpy(re, em, em)
            do 40 j = 1, 3
              amuj = atan2(em(2*j-1,2*j),em(2*j-1,2*j-1)) * utwopi
              amu(j) = amuj + anint(amu(j)-amuj)
   40       continue
          endif

*---- Print and save at exit.
          if (fprt) then
            call emevpr('EIGEN', icode, elmnam, ienum, iocc,  em, amu)
          endif
          if (fsav) then
            call emevsv(2, elmnam, ipos, em, amu)
          endif

*---- Entrance of line.
        else if (icode .eq. 2) then

*---- Output before entering.
          if (fprt) then
            call emevpr('EIGEN', icode, elmnam, 0, iocc,  em, amu)
          endif
          if (fsav) then
            call emevsv(2, elmnam, ipos, em, amu)
          endif

*---- Misalignment.
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            call m66mpy(re, em, em)
            do 50 j = 1, 3
              amuj = atan2(em(2*j-1,2*j),em(2*j-1,2*j-1)) * utwopi
              amu(j) = amuj + anint(amu(j)-amuj)
   50       continue
          endif

*---- Exit of line.
        else

*---- Misalignment.
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            call m66mpy(re, em, em)
            do 60 j = 1, 3
              amuj = atan2(em(2*j-1,2*j),em(2*j-1,2*j-1)) * utwopi
              amu(j) = amuj + anint(amu(j)-amuj)
   60       continue
          endif

*---- Output after exiting.
          if (fprt) then
            call emevpr('EIGEN', icode, elmnam, 0, iocc, em, amu)
          endif
          if (fsav) then
            call emevsv(2, elmnam, ipos, em, amu)
          endif
        endif

*---- Fill in SAVESIGA command, if any.
        if (jbit(iflag,msbet) .ne. 0) then
          call emce2i(em, ex, ey, et, sigma)
          call emssig(ipos, orbit, disp, sigma)
        endif
   90 continue
      call prline(iqpr2)
      qx = nsup * amu(1)
      qy = nsup * amu(2)
      if (stabt) then
        qs = nsup * abs(amu(3))
        write (iqpr2, 910) qx, qy, qs
      else
        write (iqpr2, 920) qx, qy
      endif
      call prline(iqpr2)

*---- Close lattice function table.
      if (ltwfun .ne. 0) call emevsv(3, savnam, 0, em, amu)

  910 format(' ',t61,'Q1 = ',f14.6,t87,'Q2 = ',f14.6,t113,'Q3 = ',f14.6)
  920 format(' ',t74,'Q1 = ',f14.6,t100,'Q2 = ',f14.6)

 9999 end
+dk emevpr
      subroutine emevpr(comand, iloc, elmnam, ienum, iocc, em, amu)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print orbit and eigenvectors for EIGEN  command.                   *
* Input:                                                               *
*   COMAND    (char)    Name of command.                               *
*   ILOC      (integer) Position code:                                 *
*                       0 = Initialize.                                *
*                       1 = After an element.                          *
*                       2 = Beginning of line.                         *
*                       3 = End of line.                               *
*   ELMNAM    (char)    Element name.                                  *
*   IENUM     (integer) Element number.                                *
*   IOCC      (integer) Occurrence number.                             *
*   EM(6,6)   (real)    Eigenvector matrix.                            *
*----------------------------------------------------------------------*
+ca aparam
      integer ienum,iloc,iocc,j,k,mhead,mline,nline,npage
      double precision amu,em
      character*(*)     comand
      character*(mcnam) elmnam
      dimension         em(6,6), amu(3)
+ca beam
+ca optic1
+ca status
+ca zunit

      character         apos*5, title*(*)

      save              nline, npage

      parameter         (mhead = 2, mline = 6)
      parameter         (title = 'Eigenmodes.')
+ca maxlin

*---- Page layout control.
      if (iloc .eq. 0) then
        npage = 0
        nline = maxlin

*---- Print page header.
      else
        nline = nline + mline
        if (nline .ge. maxlin) then
          npage = npage + 1
          call prhead(comand, title, deltas, 0, nline, npage)
          nline = nline + mhead + mline
          if (stabt) then
            write (iqpr2, 910)
          else
            write (iqpr2, 920)
          endif
          call prline(iqpr2)
        endif

*---- Print output lines.
        if (iloc .eq. 1) then
          write (apos, '(I5)') ienum
        else if (iloc .eq. 2) then
          apos = 'begin'
        else
          apos = 'end'
        endif
        if (stabt) then
          write (iqpr2, 930) apos, elmnam, iocc, suml,
     +          (1000.0 * orbit(j),
     +           (em(j,k), k = 1, 6), j = 1, 6), amu
        else
          write (iqpr2, 940) apos, elmnam, iocc, suml,
     +          (1000.0 * orbit(j), disp(j),
     +           (em(j,k), k = 1, 4), j = 1, 4), amu(1), amu(2)
        endif
      endif

  910 format(t8,'Element sequence',t47,'orbit',t60,'Re(1)',t73,'Im(1)',
     +       t86,'Re(2)',t99,'Im(2)',t112,'Re(3)',t125,'Im(3)')
  920 format(t8,'Element sequence',t47,'orbit',t60,'dispersion',
     +       t73,'Re(1)',t86,'Im(1)',t99,'Re(2)',t112,'Im(2)')
  930 format(' ',a5,' ',a8,i4,f10.3,
     +       t31,'x  [mm]',t41,7f13.6/t31,'px [mrad]',t41,7f13.6/
     +       t31,'y  [mm]',t41,7f13.6/t31,'py [mrad]',t41,7f13.6/
     +       t31,'t  [mm]',t41,7f13.6/t31,'pt [mrad]',t41,7f13.6/
     +       t31,'mu [2pi]',t41,3f26.6)
  940 format(' ',a5,' ',a8,i4,f10.3,
     +       t31,'x  [mm]',t41,6f13.6/t31,'px [mrad]',t41,6f13.6/
     +       t31,'y  [mm]',t41,6f13.6/t31,'py [mrad]',t41,6f13.6/
     +       t31,'mu [2pi]',t41,2f26.6)

      end
+dk emevsv
      subroutine emevsv(iflag, elmnam, ipos, em, amu)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save eigenvectors in EIGEN command for postprocessing.             *
* Input:                                                               *
*   IFLAG     (integer) Position code:                                 *
*                       1 = Create table.                              *
*                       2 = Save.                                      *
*                       3 = Close.                                     *
*   ELMNAM    (char)    Element name; for IFLAG = 1|3: Table name.     *
*   IPOS      (integer) Position number.                               *
*   EM(6,6)   (real)    Eigenvector matrix.                            *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ibias,iflag,ipos,l,maxcol,nb,nc,nr,ns
      double precision amu,dummy,em
      character*(mcnam) elmnam
      dimension         em(36), amu(3)
+if doom
      double precision deltas
+ei
+ca memdum
+ca seqgroup
+ca message
+ca range
+ca optic1
+if doom
+ca dmcommon
+ei
+ca option
+ca refer
+ca twlink
+ca twdata
      parameter         (maxcol = 47)
      character*(mcnam) colnam(maxcol)
      integer           icfrm(maxcol)

      data colnam
     +  / 'NAME', 'S',
     +    'XCO',  'PXCO', 'YCO',  'PYCO', 'TCO',  'PTCO',
     +    'E11',  'E21',  'E31',  'E41',  'E51',  'E61',
     +    'E12',  'E22',  'E32',  'E42',  'E52',  'E62',
     +    'E13',  'E23',  'E33',  'E43',  'E53',  'E63',
     +    'E14',  'E24',  'E34',  'E44',  'E54',  'E64',
     +    'E15',  'E25',  'E35',  'E45',  'E55',  'E65',
     +    'E16',  'E26',  'E36',  'E46',  'E56',  'E66',
     +    'MU1',  'MU2',  'MU3' /

*---- Create new table for eigenvectors.
*     Warning: L is local link. Be careful with Zebra calls.
      if (iflag .eq. 1) then
        lsnum = lq(lcseq-msnum)
        ns = 1
+if doom
        ndelta = 1
+ei
        nr = iq(lq(lcseq-msflg)-1)
        nc = maxcol
        nb = 1
        icfrm(1) = 5
        icfrm(2) = 3
        if (double) icfrm(2) = mreal
        do 10 i = 3, maxcol
          icfrm(i) = icfrm(2)
   10   continue
        call tbcrea(elmnam, ns, nr, nc, colnam, icfrm, nb, ltwfun)
        call tbpdsc(ltwfun, 'TYPE', 5, 0, dummy, 'EIGEN')
        call mzbook(2, l, ltwfun, -1, 'BRNG', 0, 0, mss, 7, 0)
        call ucopy(q(lcseq+1), q(l+1), mss)
+if doom
        call dmopt1(elmnam, 1, -3, elmnam, 0)
+ei
*---- Save one position.
      else if (ltwfun .ne. 0) then
        if (iflag .eq. 2) then
          call tbset(ltwfun, ipos, 3, ltwbuf)
          call uctoh(elmnam, q(ltwbuf+1), mcwrd, mcnam)
          ibias = 1 + mwnam
          if (double) then
            call ucopy(suml, q(ltwbuf+ibias), mwflt)
            ibias = ibias + mwflt
            call ucopy(orbit, q(ltwbuf+ibias), 6*mwflt)
            ibias = ibias + 6 * mwflt
            call ucopy(em, q(ltwbuf+ibias), 36*mwflt)
            ibias = ibias + 36 * mwflt
            call ucopy(amu, q(ltwbuf+ibias), 3*mwflt)
          else
            q(ltwbuf+ibias) = suml
            do 20 i = 1, 6
              q(ltwbuf+ibias+i) = orbit(i)
   20       continue
            ibias = ibias + 6
            do 30 i = 1, 36
              q(ltwbuf+ibias+i) = em(i)
+if doom
              dmemat(i) = em(i)
+ei
   30       continue
            ibias = ibias + 36
            do 40 i = 1, 3
              q(ltwbuf+ibias+i) = amu(i)
+if doom
              dmamu(i) = amu(i)
+ei
   40       continue
          endif
+if doom
          call dmopt2(-3, 0, 0, deltas)
+ei
*---- Close table file.
        else if (iflag .eq. 3) then
          call tbpdsc(ltwfun, 'CIRCUM', mreal, 0, nsup * suml, ' ')
          call tbclos(ltwfun)
+if doom
          call dmopt3(-3)
          call dmopt4
+ei
          msg(1) = 'Orbit and eigenvectors saved in table: ' // elmnam
          call aainfo('EMEVSV', 1, msg)
        endif
      endif

      end
+dk eminit
      subroutine eminit
      implicit none
*---------------------------------------------------------------------*
* Purpose:                                                            *
*   Initialize radiation damping calculation.                         *
*---------------------------------------------------------------------*
+ca aparam
+ca beam
+ca emdata
      double precision three,zero

      parameter        (zero = 0.0d0, three = 3.0d0)

      cg = arad * gammas**3 / three
      sum(1) = zero
      sum(2) = zero
      sum(3) = zero
      sumu0 = zero

      end
+dk emnorm
      subroutine emnorm
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Compute emittances by A. Chao's method, and track eigenvectors.    *
*   EMIT command.                                                      *
* Attributes:                                                          *
*   ORDER     (integer) Order of map (ignored).                        *
*   RFCAVITY  (name)    RF cavity to be adjusted (ignored).            *
*   DELTAP    (real)    Average relative energy error.                 *
*   EIGEN     (logical) Request eigenvectors.                          *
*   TWISS     (logical) Request Mais-Ripken functions.                 *
*   BEAM      (logical) Request Beam envelope.                         *
*   TABLE     (name)    Request eigenvector table.                     *
*----------------------------------------------------------------------*
* Modified: 30-NOV-1998, M. Woodley (SLAC)                             *
*   Add two (dummy) arguments to call to EMENGO (support for tape file *
*   output from ENVELOPE command)                                      *
*----------------------------------------------------------------------*
+ca aparam
+ca beam
+ca message
+ca refer
      integer nlines
      double precision deltap

      integer           itype(7), jtype(3)
      logical           flag(3)
      character*(mcnam) blank, tabnam

      data blank        / ' ' /

*---- Retrieve option flags.
      call utgtyp(lccmd, itype)
      deltap = 0.0
      call utgflt(lccmd, 3, 3, deltap)
      flag(1) = .false.
      flag(2) = .false.
      flag(3) = .false.
      call utglog(lccmd, 4, 6, flag)
      tabnam = blank
      call utgnam(lccmd, 7, 7, tabnam)

*---- Ignored attributes.
      if (itype(1) .ne. 0  .or.  itype(2) .ne. 0) then
        call aawarn('EMNORM', 1,
     +    'Attributes "ORDER" and/or "RFCAVITY" ignored.')
      endif

*---- Build warning message.
      msg(1) = 'Command "NORMAL" is now obsolete, using the sequence:'
      if (itype(3) .eq. 0) then
        msg(2) = '     EMIT'
      else
        write (msg(2), 910) deltap
      endif
      nlines = 2
      if (flag(1)) then
        nlines = nlines + 1
        if (itype(7) .eq. 0) then
          msg(nlines) = '     EIGEN'
        else
          write (msg(nlines), 920) tabnam
        endif
      endif
      if (flag(2)) then
        nlines = nlines + 1
        msg(nlines) = '     TWISS3'
      endif
      if (flag(3)) then
        nlines = nlines + 1
        msg(nlines) = '     ENVELOPE'
      endif
      call aawarn('EMNORM', nlines, msg)

*---- Execute command sequence.
      jtype(1) = 0
      jtype(2) = 0
      jtype(3) = 0
      call ememgo(deltap)
      if (flag(1)) call emevgo(tabnam)
      if (flag(2)) call emtwgo(jtype, blank, blank, 3)
      if (flag(3)) call emengo(jtype, blank, blank, 3, .false., 0)

  910 format('     EMIT, DELTAP = ',f10.6)
  920 format('     EIGEN, SAVE = ',a)

      end
+dk emssig
      subroutine emssig(ipos, orbit, disp, sigma)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save beam envelope for subsequent use in ENVELOPE command.         *
* Input:                                                               *
*   IPOS      (integer) Position where SIGMA0 bank is linked.          *
*   ORBIT(6)  (real)    Orbit position.                                *
*   SIGMA(6,6)(real)    Beam matrix in internal form.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer ikey,ipos
      double precision corr,disp,orbit,sigma
      dimension         orbit(6), disp(6), sigma(6,6)
+ca memdum
+ca refer
+ca twlink

      dimension         corr(6,6)

*---- Search for desired SIGMA0 bank chain.
      call difind(ldkey, 'SIGMA0', ikey, lckey)
      ltwbet = lq(lckey-1)
      call emci2t(sigma, corr)

*---- Loop to store in proper bank(s).
  100 if (ltwbet .ne. 0) then
        if (iq(ltwbet-5) .eq. ipos) then
          call utpflt(ltwbet,  1,  6, orbit)
          call utpflt(ltwbet,  7, 12, disp)
          call utpflt(ltwbet, 13, 18, corr(1,1))
          call utpflt(ltwbet, 19, 23, corr(2,2))
          call utpflt(ltwbet, 24, 27, corr(3,3))
          call utpflt(ltwbet, 28, 30, corr(4,4))
          call utpflt(ltwbet, 31, 32, corr(5,5))
          call utpflt(ltwbet, 33, 33, corr(6,6))
        endif
        ltwbet = lq(ltwbet)
        go to 100
      endif

      end
+dk emsumm
      subroutine emsumm(comand, rd, em, bmax, gmax, dismax)
      implicit none
*---------------------------------------------------------------------*
* Purpose:                                                            *
*   Finish radiation damping calculation and print summary.           *
* Input:                                                              *
*   COMAND    (name)    Name of command.                              *
*   RD(6,6)   (real)    Damped one-turn transfer matrix.              *
*   EM(6,6)   (real)    Undamped eigenvectors.                        *
*   BMAX(3,3) (real)    Maximum extents of modes.                     *
*   GMAX(3,3) (real)    Maximum divergences of modes.                 *
*   DISMAX(6) (real)    Maximum dispersion.                           *
*---------------------------------------------------------------------*
+ca aparam
      integer j,j1,j2,k,k1,k2,nline
      double precision aival,alj,bmax,bstar,clg,dismax,dummy,em,etpr,
     +expr,eypr,f0,gmax,gstar,rd,reval,sal,sigma,tau,ten3p,tenp6,tenp9,
     +three,tune,twopi
      character*(*)     comand
      dimension         rd(6,6), em(6,6), bmax(3,3), gmax(3,3)
      dimension         dismax(4)
+ca beam
+ca emdata
+ca range
+ca status
+ca physicpm
+ca zunit

      character*(*)     title

      dimension         reval(6), aival(6), alj(3), tau(3), tune(3)
      dimension         sigma(6,6), bstar(3,3), gstar(3,3), dummy(6,6)

+ca pi
      parameter         (twopi = 2.0d0 * pi)
      parameter         (three = 3.0d0)
      parameter         (ten3p = 1.0d3, tenp6 = 1.0d6, tenp9 = 1.0d9)
      parameter         (title = 'Summary.')

*---- Synchrotron energy loss [GeV].
      if (stabt .and. frad) then
        u0 = sumu0 * nsup

*---- Tunes.
        call ladeig(rd, reval, aival, dummy)
        if (error) go to 999
        tune(1) = nsup * atan2(aival(1), reval(1)) / twopi
        if (tune(1) .lt. 0.0) tune(1) = tune(1) + nsup
        tune(2) = nsup * atan2(aival(3), reval(3)) / twopi
        if (tune(2) .lt. 0.0) tune(2) = tune(2) + nsup
        tune(3) = nsup * atan2(aival(5), reval(5)) / twopi
        if (tune(3) .lt. 0.0) tune(3) = - tune(3)

*---- Damping constants per turn.
        alj(1) = - log(reval(1)**2 + aival(1)**2) * (nsup / 2.0)
        alj(2) = - log(reval(3)**2 + aival(3)**2) * (nsup / 2.0)
        alj(3) = - log(reval(5)**2 + aival(5)**2) * (nsup / 2.0)

*---- Damping partition numbers.
        sal = 2.0 * en0 / u0
        pdamp(1) = alj(1) * sal
        pdamp(2) = alj(2) * sal
        pdamp(3) = alj(3) * sal

*---- Emittances.
        clg = ((55.0 * hbar * clight) / (96.0 * sqrt(three)))
     +      * ((nsup * arad * gammas**5) / amass)
        ex = clg * sum(1) / alj(1)
        ey = clg * sum(2) / alj(2)
        et = clg * sum(3) / alj(3)

*---- Damping constants per second and damping times.
        f0 = freq0 * tenp6
        alj(1) = abs(alj(1) * f0)
        alj(2) = abs(alj(2) * f0)
        alj(3) = abs(alj(3) * f0)
        tau(1) = 1.0 / alj(1)
        tau(2) = 1.0 / alj(2)
        tau(3) = 1.0 / alj(3)
      endif

*---- TRANSPORT sigma matrix.
      call emce2i(em, ex, ey, et, sigma)

*---- Extents at interaction point.
      do 30 j = 1, 3
        j1 = 2 * j -1
        j2 = 2 * j
        do 20 k = 1, 3
          k1 = 2 * k - 1
          k2 = 2 * k
          bstar(j,k) = em(j1,k1) * em(j1,k1) + em(j1,k2) * em(j1,k2)
          gstar(j,k) = em(j2,k1) * em(j2,k1) + em(j2,k2) * em(j2,k2)
   20   continue
   30 continue

*---- Store BEAM common to BEAM bank, ET is given.
      exn = ex * (4.0 * betas * gammas)
      eyn = ey * (4.0 * betas * gammas)
      ietflg = 1
      sigx = sqrt(abs(sigma(1,1)))
      sigy = sqrt(abs(sigma(3,3)))
      if (sigma(5,5) .gt. 0.d0 .or. sigma(6,6) .gt. 0.d0)  then
        sigt = sqrt(abs(sigma(5,5)))
        sige = sqrt(abs(sigma(6,6)))
      endif
      call enput

*---- Summary output; header and global parameters.
      call prhead(comand, title, deltas, 0, nline, 1)
      call enprgl

*---- Dynamic case.
      expr = ex * tenp6
      eypr = ey * tenp6
      etpr = et * tenp6
      if (stabt) then
        if (frad) write (iqpr2, 910) ten3p * u0
        write (iqpr2, 920) 1, 2, 3
        write (iqpr2, 930) qx, qy, qs
        if (frad) write (iqpr2, 940) tune
        write (iqpr2, 950) ((bstar(j,k), j = 1, 3), k = 1, 3),
     +                     ((gstar(j,k), j = 1, 3), k = 1, 3),
     +                     ((bmax(j,k), j = 1, 3), k = 1, 3),
     +                     ((gmax(j,k), j = 1, 3), k = 1, 3)
        if (frad) then
          write (iqpr2, 960) pdamp, alj, (tau(j), j = 1, 3),
     +                       expr, eypr, etpr
        endif
      else
        write (iqpr2, 920) 1, 2
        write (iqpr2, 930) qx, qy
        write (iqpr2, 970) ((bstar(j,k), j = 1, 2), k = 1, 2),
     +                     ((gstar(j,k), j = 1, 2), k = 1, 2),
     +                     ((bmax(j,k), j = 1, 2), k = 1, 2),
     +                     ((gmax(j,k), j = 1, 2), k = 1, 2)
      endif

*---- RF system.
      call enprrf

  910 format(t6,'U0',t16,f14.6,' [MeV/turn]')
  920 format(' '/' ',t42,3(9x,'M o d e',3x,i1:))
  930 format(' Fractional tunes',t30,'undamped',t42,3f20.8)
  940 format(' ',t30,'damped',t42,3f20.8)
  950 format(' '/' beta* [m]',t30,'x',t42,3e20.8/t30,'y',t42,3e20.8/
     +  t30,'t',t42,3e20.8/
     +  ' '/' gamma* [1/m]',t30,'px',t42,3e20.8/t30,'py',t42,3e20.8/
     +  t30,'pt',t42,3e20.8/
     +  ' '/' beta(max) [m]',t30,'x',t42,3e20.8/t30,'y',t42,3e20.8/
     +  t30,'t',t42,3e20.8/
     +  ' '/' gamma(max) [1/m]',t30,'px',t42,3e20.8/t30,'py',t42,3e20.8/
     +  t30,'pt',t42,3e20.8)
  960 format(' '/' Damping partition numbers',t42,3f20.8/
     +  ' Damping constants [1/s]',t46,3e20.8/
     +  ' Damping times [s]',t46,3e20.8/
     +  ' Emittances [pi micro m]',t42,3e20.8)
  970 format(' '/' beta* [m]',t30,'x',t42,2e20.8/t30,'y',t42,2e20.8/
     +  ' '/' gamma* [1/m]',t30,'px',t42,2e20.8/t30,'py',t42,2e20.8/
     +  ' '/' beta(max) [m]',t30,'x',t42,2e20.8/t30,'y',t42,2e20.8/
     +  ' '/' gamma(max) [1/m]',t30,'px',t42,2e20.8/t30,'py',t42,2e20.8)

  999 end
+dk emtwdo
      subroutine emtwdo
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TWISS3 command: Track Mais-Ripken lattice functions.               *
* Attributes:                                                          *
*   SAVE      (name)    SAVE option: Table name.                       *
*   BETA0     (name)    Initial values for functions (ignored).        *
*   LINE      (line)    Line for initial conditions.                   *
*----------------------------------------------------------------------*
+ca aparam
+ca refer
+ca status
      integer mbet,mlin,msav

      parameter         (msav = 1, mbet = 2, mlin = 3)

      character*(mcnam) twsnam(2), savnam, betnam
      equivalence       (savnam, twsnam(1)), (betnam, twsnam(2))
      integer           itype(3)

*---- Check main beam line.
      call lnchck('EMTWDO', error)

*---- Retrieve attributes.
      call utgtyp(lccmd, itype)
      if (.not. error) then
        savnam = ' '
        call utgnam(lccmd, msav, mbet, twsnam)
        call emtwgo(itype, savnam, betnam, mlin)
      endif

      end
+dk emtwgo
      subroutine emtwgo(itype, savnam, betnam, iline)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TWISS3 command: Track Mais-Ripken lattice functions.               *
* Attributes:                                                          *
*   ITYPE(3)  (integer) Flag array: SAVE, BETA0, LINE.                 *
*   SAVNAM    (name)    SAVE option: Table name.                       *
*   BETNAM    (name)    Initial values for functions (ignored).        *
*   ILINE     (integer) Number for LINE attribute.                     *
*----------------------------------------------------------------------*
+ca aparam
      integer icode,ienum,iflag,iline,iocc,ipos,j,j1,j2,jbit,jbyt,k,k1,
     +k2
      double precision aival,amu,amuj,bmax,bx,dismax,disrms,el,em,gmax,
     +gx,one,orbmax,orbrms,pos,reval,sigma,tol,utwopi
      integer           itype(3)
      character*(mcnam) savnam, betnam
+ca memdum
+ca seqflag
+ca strgroup
+ca message
+ca beam
+ca mapelm
+ca maptrn
+ca optic0
+ca optic1
+if doom
+ca dmcommon
+ei
+ca range
+ca refer
+ca status
+ca twlink
+ca zunit

+ca pi
      parameter         (utwopi = 1.0d0 / (2.0d0 * pi))
      parameter         (tol = 1.000001d0, one = 1.0d0)

      character*(mcnam) elmnam
      logical           fmap, fprt, fsav, m66sta
      dimension         em(6,6), reval(6), aival(6), sigma(6,6)
      dimension         bmax(3,3), gmax(3,3), amu(3)
      dimension         orbmax(6), orbrms(6), dismax(6), disrms(6)

*---- Get data for beam.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- LINE attribute.
      if (itype(iline) .ne. 0) then
        call lnrefe(lccmd, iline, ltwlin, lroot, -minit)
        if (error) go to 9999
        call tmturn(ltwlin, deltas, error)
      else
        call tmturn(lcseq, deltas, error)
      endif
      if (error) go to 9999
      call ucopy(orbit0, orbit, 6*mwflt)

*---- Find eigenvectors at initial position.
      if (m66sta(rt)) then
        call twdisp(rt, rt(1,6), disp)
        disp(5) = 0.0
        disp(6) = 1.0
        call laseig(rt, reval, aival, em)
        stabt = .false.
      else
        call uzero(disp, 1, 6*mwflt)
        call ladeig(rt, reval, aival, em)
        stabt = reval(5)**2 + aival(5)**2 .le. tol  .and.
     +          reval(6)**2 + aival(6)**2 .le. tol
      endif
      if (error) go to 9999
      stabx = reval(1)**2 + aival(1)**2 .le. tol  .and.
     +        reval(2)**2 + aival(2)**2 .le. tol
      staby = reval(3)**2 + aival(3)**2 .le. tol  .and.
     +        reval(4)**2 + aival(4)**2 .le. tol

*---- Maximum extents.
      do 30 j = 1, 3
        j1 = 2 * j -1
        j2 = 2 * j
        do 20 k = 1, 3
          k1 = 2 * k - 1
          k2 = 2 * k
          bmax(j,k) = em(j1,k1) * em(j1,k1) + em(j1,k2) * em(j1,k2)
          gmax(j,k) = em(j2,k1) * em(j2,k1) + em(j2,k2) * em(j2,k2)
   20   continue
        amu(j) = 0.0
   30 continue
      do 40 j = 1, 6
        orbmax(j) = abs(orbit(j))
        orbrms(j) = orbit(j)**2
        dismax(j) = abs(disp(j))
        disrms(j) = disp(j)**2
   40 continue
      pos   = one

*---- Create internal table for lattice functions.
      ltwfun = 0
      if (savnam .ne. ' ') call emtwsv(1, savnam, 0, em, amu)
      if (error) go to 9999

*---- Loop through element sequence.
      suml  = 0.0
      fsav = .false.
      call emtwpr('TWISS3', 0, ' ', 0, 0, em, amu)
      do 190 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        fprt = jbit(iflag,mprnt) .ne. 0  .or.
     +         ipos .eq. irg1  .or.  ipos .eq. irg2
        if (ltwfun .ne. 0) then
          fsav = jbit(iflag,moptc) .ne. 0
        endif
        icode = jbyt(iflag, 1, mcode)
+if doom
        currname = elmnam
        currocct = iocc
+ei
*---- Physical element.
        if (icode .eq. 1) then

*---- Misalignment at entrance.
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            if (.not. stabt) call m66byv(re, disp, disp)
            call m66mpy(re, em, em)
            do 50 j = 1, 3
              amuj = atan2(em(2*j-1,2*j),em(2*j-1,2*j-1)) * utwopi
              amu(j) = amuj + anint(amu(j)-amuj)
   50       continue
          endif

*---- Track through element.
          call tmmap(.true., .true., orbit, fmap, el, ek, re, te)
          if (fmap) then
            if (.not. stabt) then
              call m66byv(re, disp, disp)
            endif
            suml = suml + el
            call m66mpy(re, em, em)

*---- Compute maximum extents and phases.
            do 70 j = 1, 3
              j1 = 2 * j -1
              j2 = 2 * j
              do 60 k = 1, 3
                k1 = 2 * k - 1
                k2 = 2 * k
                bx = em(j1,k1)*em(j1,k1) + em(j1,k2)*em(j1,k2)
                bmax(j,k) = max(bmax(j,k),bx)
                gx = em(j2,k1)*em(j2,k1) + em(j2,k2)*em(j2,k2)
                gmax(j,k) = max(gmax(j,k),gx)
   60         continue
              amuj = atan2(em(2*j-1,2*j),em(2*j-1,2*j-1)) * utwopi
              amu(j) = amuj + anint(amu(j)-amuj)
   70       continue
            do 80 j = 1, 6
              orbmax(j) = max(abs(orbit(j)),orbmax(j))
              orbrms(j) = orbrms(j) + orbit(j)**2
              dismax(j) = max(abs(disp(j)),dismax(j))
              disrms(j) = disrms(j) + disp(j)**2
   80       continue
            pos  = pos  + one
          endif

*---- Misalignment at exit.
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            if (.not. stabt) call m66byv(re, disp, disp)
            call m66mpy(re, em, em)
            do 90 j = 1, 3
              amuj = atan2(em(2*j-1,2*j),em(2*j-1,2*j-1)) * utwopi
              amu(j) = amuj + anint(amu(j)-amuj)
   90       continue
          endif

*---- Print and save at exit.
          if (fprt) then
            call emtwpr('TWISS3', icode, elmnam, ienum, iocc, em, amu)
          endif
          if (fsav) then
            call emtwsv(2, elmnam, ipos, em, amu)
          endif

*---- Entrance of line.
        else if (icode .eq. 2) then

*---- Output before entering.
          if (fprt) then
            call emtwpr('TWISS3', icode, elmnam, 0, iocc, em, amu)
          endif
          if (fsav) then
            call emtwsv(2, elmnam, ipos, em, amu)
          endif

*---- Misalignment.
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            if (.not. stabt) call m66byv(re, disp, disp)
            call m66mpy(re, em, em)
            do 100 j = 1, 3
              amuj = atan2(em(2*j-1,2*j),em(2*j-1,2*j-1)) * utwopi
              amu(j) = amuj + anint(amu(j)-amuj)
  100       continue
          endif

*---- Exit of line.
        else

*---- Misalignment.
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            if (.not. stabt) call m66byv(re, disp, disp)
            call m66mpy(re, em, em)
            do 110 j = 1, 3
              amuj = atan2(em(2*j-1,2*j),em(2*j-1,2*j-1)) * utwopi
              amu(j) = amuj + anint(amu(j)-amuj)
  110       continue
          endif

*---- Output after exiting.
          if (fprt) then
            call emtwpr('TWISS3', icode, elmnam, 0, iocc, em, amu)
          endif
          if (fsav) then
            call emtwsv(2, elmnam, ipos, em, amu)
          endif
        endif

*---- Fill in SAVESIGA command, if any.
        if (jbit(iflag,msbet) .ne. 0) then
          call emce2i(em, ex, ey, et, sigma)
          call emssig(ipos, orbit, disp, sigma)
        endif
  190 continue

*---- Summary.
      call prline(iqpr2)
      qx = nsup * amu(1)
      qy = nsup * amu(2)
      if (stabt) then
        qs = nsup * abs(amu(3))
        do 210 j = 1, 6
          orbmax(j) = 1000.0 * orbmax(j)
          orbrms(j) = 1000.0 * sqrt(orbrms(j)/pos)
  210   continue
        write (iqpr2, 910)
     +    qx, (bmax(1,k), k = 1, 3), (gmax(1,k), k = 1, 3),
     +    qy, (bmax(2,k), k = 1, 3), (gmax(2,k), k = 1, 3),
     +    qs, (bmax(3,k), k = 1, 3), (gmax(3,k), k = 1, 3)
        call prline(iqpr2)
        write (iqpr2, 920) orbmax, orbrms
      else
        do 220 j = 1, 4
          orbmax(j) = 1000.0 * orbmax(j)
          orbrms(j) = 1000.0 * sqrt(orbrms(j)/pos)
          disrms(j) = sqrt(disrms(j)/pos)
  220   continue
        write (iqpr2, 930)
     +    qx, (bmax(1,k), k = 1, 2), (gmax(1,k), k = 1, 2),
     +    qy, (bmax(2,k), k = 1, 2), (gmax(2,k), k = 1, 2)
        call prline(iqpr2)
        write (iqpr2, 940)
     +    (dismax(j), j=1,4), (disrms(j), j=1,4),
     +    (orbmax(j), j=1,4), (orbrms(j), j=1,4)
      endif
      call prline(iqpr2)

*---- Drop LINE condition bank.
      if (ltwlin .ne. 0) call lndrop(ltwlin)

*---- Close lattice function table.
      if (ltwfun .ne. 0) call emtwsv(3, savnam, 0, em, amu)

  910 format(t31,'Q [1]',t44,'betx [m]',t60,'bety [m]',t76,'bett [m]',
     +       t90,'gamx [1/m]',t106,'gamy [1/m]',t122,'gamt [1/m]'/
     +       ' Mode 1',t20,7f16.6/' Mode 2',t20,7f16.6/
     +       ' Mode 3',t20,7f16.6)
  920 format(t46,'x [mm]',t59,'px [mrad]',t78,'y [mm]',t91,'py [mrad]',
     +       t110,'t [mm]',t123,'pt [mrad]'/
     +       ' orbit',t13,'(abs. max.)',t36,6f16.6/
     +       t13,'(r.m.s.)',t36,6f16.6)
  930 format(t31,'Q [1]',t44,'betx [m]',t60,'bety [m]',t76,
     +       'gamx [1/m]',t90,'gamy [1/m]'/
     +       ' Mode 1',t20,5f16.6/' Mode 2',t20,5f16.6)
  940 format(t47,'x [m]',t60,'px [rad]',t79,'y [m]',t92,'py [rad]'/
     +       ' dispersion',t13,'(abs. max.)',t36,4f16.6/
     +       t13,'(r.m.s.)',t36,4f16.6/
     +       t46,'x [mm]',t59,'px [mrad]',t78,'y [mm]',t91,'py [mrad]'/
     +       ' orbit',t13,'(abs. max.)',t36,4f16.6/
     +       t13,'(r.m.s.)',t36,4f16.6)

 9999 end
+dk emtwpr
      subroutine emtwpr(comand, iloc, elmnam, ienum, iocc, em, amu)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print Mais-Ripken betatron functions for TWISS3 command.           *
* Input:                                                               *
*   COMAND    (char)    Name of command.                               *
*   ILOC      (integer) Position code:                                 *
*                       0 = Initialize.                                *
*                       1 = After an element.                          *
*                       2 = Beginning of line.                         *
*                       3 = End of line.                               *
*   ELMNAM    (char)    Element name, at beginning: command name.      *
*   IENUM     (integer) Element number.                                *
*   IOCC      (integer) Occurrence number.                             *
*   EM(6,6)   (real)    Eigenvector matrix.                            *
*   AMU(3)    (real)    Phases of eigenmodes.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer ienum,ihead,iline,iloc,iocc,j,j1,j2,k,k1,k2,nline,npage
      double precision alf,amu,bet,em,gam
      character*(*)     comand
      character*(mcnam) elmnam
      dimension         em(6,6), amu(3)
+ca beam
+ca optic1
+ca status
+ca zunit

      dimension         bet(3,3), gam(3,3), alf(3,3)
      character         apos*5, title*(*)

      save              ihead, iline, nline, npage

      parameter         (title = 'Mais-Ripken functions.')
+ca maxlin

*---- Page layout control.
      if (iloc .eq. 0) then
        npage = 0
        nline = maxlin
        iline = 2
        if (stabx) iline = iline + 1
        if (staby) iline = iline + 1
        ihead = 4
        if (.not. stabt) ihead = 6

*---- Compute functions to be printed.
      else
        do 20 j = 1, 3
          j1 = 2 * j -1
          j2 = 2 * j
          do 10 k = 1, 3
            k1 = 2 * k - 1
            k2 = 2 * k
            bet(j,k) = em(j1,k1) * em(j1,k1) + em(j1,k2) * em(j1,k2)
            gam(j,k) = em(j2,k1) * em(j2,k1) + em(j2,k2) * em(j2,k2)
            alf(j,k) = em(j1,k1) * em(j2,k1) + em(j2,k2) * em(j1,k2)
   10     continue
   20   continue

*---- Print page header.
        nline = nline + iline
        if (nline .ge. maxlin) then
          npage = npage + 1
          call prhead(comand, title, deltas, 0, nline, npage)
          nline = nline + ihead + iline
          if (stabt) then
            write (iqpr2, 910)
          else
            write (iqpr2, 920)
          endif
          call prline(iqpr2)
        endif

*---- Print output lines.
        if (iloc .eq. 1) then
          write (apos, '(I5)') ienum
        else if (iloc .eq. 2) then
          apos = 'begin'
        else
          apos = 'end  '
        endif
        if (stabt) then
          write (iqpr2, 930) apos, elmnam, iocc, suml,
     +      (1000.0 * orbit(j), j = 1, 6)
          if (stabx) write (iqpr2, 940)
     +      1, amu(1), (bet(j,1), gam(j,1), alf(j,1), j = 1, 3)
          if (staby) write (iqpr2, 940)
     +      2, amu(2), (bet(j,2), gam(j,2), alf(j,2), j = 1, 3)
          write (iqpr2, 940)
     +      3, amu(3), (bet(j,3), gam(j,3), alf(j,3), j = 1, 3)
        else
          write (iqpr2, 950) apos, elmnam, iocc, suml,
     +      (1000.0 * orbit(j), j = 1, 4), (disp(j), j = 1, 4)
          if (stabx) write (iqpr2, 960)
     +      1, amu(1), (bet(j,1), gam(j,1), alf(j,1), j = 1, 2)
          if (staby) write (iqpr2, 960)
     +      2, amu(2), (bet(j,2), gam(j,2), alf(j,2), j = 1, 2)
        endif
      endif

  910 format(' Element sequence',t50,'x',t60,'px',
     +       t80,'y',t90,'py',t110,'t',t120,'pt'/
     +       t50,'[mm]',t60,'[mrad]',t80,'[mm]',t90,'[mrad]',
     +       t110,'[mm]',t120,'[mrad]'/
     +       t28,'mode',t36,'mu',
     +       t46, 'betx',t56, 'gamx',t66, 'alfx',
     +       t76, 'bety',t86, 'gamy',t96, 'alfy',
     +       t106,'bett',t116,'gamt',t126,'alft'/
     +       t36,'[2pi]',
     +       t46, '[m]',t56, '[1/m]',t66, '[1]',
     +       t76, '[m]',t86, '[1/m]',t96, '[1]',
     +       t106,'[m]',t116,'[1/m]',t126,'[1]')
  920 format(' Element sequence',
     +       t55,'x',   t67,'px',    t91,'y',   t103,'py'/
     +       t55,'[mm]',t67,'[mrad]',t91,'[mm]',t103,'[mrad]'/
     +       t55,'Dx',  t67,'Dpx',   t91,'Dy',  t103,'Dpy'/
     +       t55,'[m]', t67,'[rad]', t91,'[m]', t103,'[rad]'/
     +       t28,'mode',t37,'mu',
     +       t49,'betx',t61,'gamx',t73,'alfx',
     +       t85,'bety',t97,'gamy',t109,'alfy'/
     +       t37,'[2pi]',
     +       t49,'[m]',t61,'[1/m]',t73,'[1]',
     +       t85,'[m]',t97,'[1/m]',t109,'[1]')
  930 format(' ',a5,' ',a8,i4,f10.3,t32,10x,3(5x,2f10.6,5x))
  940 format(t31,i1,10f10.5)
  950 format(' ',a5,' ',a8,i4,f10.3,t32,12x,2(6x,2f12.6,6x)/
     +       t32,12x,2(6x,2f12.6,6x))
  960 format(t31,i1,7f12.6)

      end
+dk emtwsv
      subroutine emtwsv(iflag, elmnam, ipos, em, amu)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save eigenvectors in EIGEN command for postprocessing.             *
* Input:                                                               *
*   IFLAG     (integer) Position code:                                 *
*                       1 = Create table.                              *
*                       2 = Save.                                      *
*                       3 = Close.                                     *
*   ELMNAM    (char)    Element name; for IFLAG = 1|3: Table name.     *
*   IPOS      (integer) Position number.                               *
*   EM(6,6)   (real)    Eigenvector matrix.                            *
*   AMU(3)    (real)    Phases of eigenmodes.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ibias,iflag,ipos,j,j1,j2,k,k1,k2,l,maxcol,nb,nc,
     +nr,ns
      double precision alf,amu,bet,dummy,em,gam
      character*(mcnam) elmnam
      dimension         em(6,6), amu(3)
+if doom
      double precision deltas
+ei
+ca memdum
+ca seqgroup
+ca message
+ca range
+ca optic1
+if doom
+ca dmcommon
+ei
+ca option
+ca refer
+ca twlink
+ca twdata

      parameter         (maxcol = 44)
      character*(mcnam) colnam(maxcol)
      dimension         bet(3,3), alf(3,3), gam(3,3)
      integer           icfrm(maxcol)

      data colnam
     +  / 'NAME',  'S',
     +    'XCO',   'PXCO',  'YCO',   'PYCO',  'TCO',   'PTCO',
     +    'DX',    'DPX',   'DY',    'DPY',   'DT',    'DPT',
     +    'BETX1', 'BETY1', 'BETT1',
     +    'BETX2', 'BETY2', 'BETT2',
     +    'BETX3', 'BETY3', 'BETT3',
     +    'ALFX1', 'ALFY1', 'ALFT1',
     +    'ALFX2', 'ALFY2', 'ALFT3',
     +    'ALFX3', 'ALFY3', 'ALFT3',
     +    'GAMX1', 'GAMY1', 'GAMT1',
     +    'GAMX2', 'GAMY2', 'GAMT2',
     +    'GAMX3', 'GAMY3', 'GAMT3',
     +    'MU1',   'MU2',   'MU3' /

*---- Create new table for lattice functions.
*     Warning: L is local link. Be careful with Zebra calls.
      if (iflag .eq. 1) then
        lsnum = lq(lcseq-msnum)
        ns = 1
+if doom
        ndelta = 1
+ei
        nr = iq(lq(lcseq-msflg)-1)
        nc = maxcol
        nb = 1
        icfrm(1) = 5
        icfrm(2) = 3
        if (double) icfrm(2) = mreal
        do 10 i = 3, maxcol
          icfrm(i) = icfrm(2)
   10   continue
        call tbcrea(elmnam, ns, nr, nc, colnam, icfrm, nb, ltwfun)
        call tbpdsc(ltwfun, 'TYPE', 5, 0, dummy, 'TWISS3')
        call mzbook(2, l, ltwfun, -1, 'BRNG', 0, 0, mss, 7, 0)
        call ucopy(q(lcseq+1), q(l+1), mss)
+if doom
        call dmopt1(elmnam, 1, -2, elmnam, 0)
+ei
*---- Save one position.
      else if (ltwfun .ne. 0) then
        if (iflag .eq. 2) then

*---- Compute values to be saved.
          do 30 j = 1, 3
            j1 = 2 * j -1
            j2 = 2 * j
            do 20 k = 1, 3
              k1 = 2 * k - 1
              k2 = 2 * k
              bet(j,k) = em(j1,k1) * em(j1,k1) + em(j1,k2) * em(j1,k2)
              gam(j,k) = em(j2,k1) * em(j2,k1) + em(j2,k2) * em(j2,k2)
              alf(j,k) = em(j1,k1) * em(j2,k1) + em(j2,k2) * em(j1,k2)
   20       continue
   30     continue

          call tbset(ltwfun, ipos, 3, ltwbuf)
          call uctoh(elmnam, q(ltwbuf+1), mcwrd, mcnam)
          ibias = 1 + mwnam
          if (double) then
            call ucopy(suml, q(ltwbuf+ibias), mwflt)
            ibias = ibias + mwflt
            call ucopy(orbit, q(ltwbuf+ibias), 6*mwflt)
            ibias = ibias + 6 * mwflt
            call ucopy(disp, q(ltwbuf+ibias), 6*mwflt)
            ibias = ibias + 6 * mwflt
            call ucopy(bet, q(ltwbuf+ibias), 9*mwflt)
            ibias = ibias + 9 * mwflt
            call ucopy(alf, q(ltwbuf+ibias), 9*mwflt)
            ibias = ibias + 9 * mwflt
            call ucopy(gam, q(ltwbuf+ibias), 9*mwflt)
            ibias = ibias + 9 * mwflt
            call ucopy(amu, q(ltwbuf+ibias), 3*mwflt)
          else
            q(ltwbuf+ibias) = suml
            ibias = ibias + 1
            do 60 i = 1, 6
              q(ltwbuf+ibias)   = orbit(i)
              q(ltwbuf+ibias+6) = disp(i)
              ibias = ibias + 1
   60       continue
            ibias = ibias + 6
            do 70 i = 1, 3
            do 70 k = 1, 3
              q(ltwbuf+ibias)    = bet(k,i)
              q(ltwbuf+ibias+9)  = alf(k,i)
              q(ltwbuf+ibias+18) = gam(k,i)
+if doom
              dmbet(k,i) = bet(k,i)
              dmalf(k,i) = alf(k,i)
              dmgam(k,i) = gam(k,i)
+ei
              ibias = ibias + 1
   70       continue
            ibias = ibias + 18
            do 80 i = 1, 3
              q(ltwbuf+ibias) = amu(i)
+if doom
              dmamu(i) = amu(i)
+ei
              ibias = ibias + 1
   80       continue
          endif
+if doom
          call dmopt2(-2, 0, 0, deltas)
+ei
*---- Close table file.
        else if (iflag .eq. 3) then
          call tbpdsc(ltwfun, 'CIRCUM', mreal, 0, nsup * suml, ' ')
          call tbclos(ltwfun)
+if doom
          call dmopt3(-2)
          call dmopt4
+ei
          msg(1) = 'Orbit and eigenvectors saved in table: ' // elmnam
          call aainfo('EMTWSV', 1, msg)
        endif
      endif

      end
+dk emzzzz
+dk enaaaa
+dk enarb
      subroutine enarb(el, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save TRANSPORT map for a MAKELUMP.                                 *
* Input:                                                               *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer i1,i2
      double precision ek,el,re,te
      dimension         ek(6), re(6,6), te(6,6,6)
+ca refer

*---- Length of element.
      i2 = 2
      call utpflt(lcelm, i2, i2, el)

*---- Element kick.
      i1 = i2 + 1
      i2 = i2 + 6
      call utpflt(lcelm, i1, i2, ek)

*---- Transfer matrix.
      i1 = i2 + 1
      i2 = i2 + 36
      call utpflt(lcelm, i1, i2, re)

*---- Second order terms.
      i1 = i2 + 1
      i2 = i2 + 216
      call utpflt(lcelm, i1, i2, te)

      end
+dk enbeam
      subroutine enbeam
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   BEAM command: Store data from BEAM command into BEAM bank.         *
* 18 attributes:                                                       *
*   PARTICLE, MASS,     CHARGE,   ENERGY,   PC,       GAMMA,           *
*   EX,       EY,       EXN,      EYN,      ET,       SIGT,            *
*   SIGE,     KBUNCH,   NPART,    BCURRENT, BUNCHED,  RADIATE          *
* Additional quantities kept in BEAM bank:                             *
*   BETA      (real)    Relativistic parameter v/c.                    *
*   U0        (real)    Radiation loss per turn in GeV.                *
*   ARAD      (real)    Classical particle radius.                     *
*   PDAMP(3)  (real)    Damping partition numbers.                     *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca beagroup
+ca strgroup
+ca beam
+ca refer
+ca status
+ca zunit
+ca physicpm
      integer ipart,maxprt
      double precision pachrg,pamass

      parameter         (maxprt =  6)

      character*(mcnam) padict(maxprt)
      dimension         pamass(maxprt), pachrg(maxprt)
      integer           itype(mbdata)

      data padict / 'ELECTRON', 'PROTON', 'POSITRON', 'ANTIPROTON',
     +              'POSMUON',  'NEGMUON' /
      data pamass /  emass,      pmass,    emass,      pmass,
     +               mumass,     mumass /
      data pachrg /  -1.0,        1.0,      1.0,       -1.0,
     +               1.0,        -1.0 /

*---- BEAM common already contains data from BEAM bank.
*     Overwrite new data coming from BEAM command.
      call utgtyp(lccmd, itype)
      call utgnam(lccmd, mbpart, mbpart, prtnam)
      call utgnam(lccmd, mbsequ, mbsequ, bsequnam)
      call utgflt(lccmd, mbmass, mbcurr, amass)
      call utglog(lccmd, mbfbch, mbfrad, fbch)
      if (itype(mbbv) .ne. 0) call utgflt(lccmd, mbbv, mbbv, beambv)
*---- Store particle name, mass and charge.
      if (itype(mbpart) .ne. 0) then
        call utlook(prtnam, padict, maxprt, ipart)
        if (ipart .ne. 0) then
          prtnam = padict(ipart)
          if (itype(mbmass) .ne. 0) then
            call aawarn('ENBEAM', 1,
     +      'Redundant data on BEAM --- MASS will be ignored.')
          endif
          if (itype(mbchrg) .ne. 0) then
            call aawarn('ENBEAM', 1,
     +      'Redundant data on BEAM --- CHARGE will be ignored.')
          endif
          amass = pamass(ipart)
          charge = pachrg(ipart)
        else
          call aawarn('ENBEAM', 1,
     +    'Unknown particle ' // prtnam // ' ignored')
        endif
      else if (amass .le. 0.0) then
        call aafail('ENBEAM', 1,
     +  'Inconsistent data on BEAM --- expect MASS > 0.')
      endif
*--- store sequence name, use default if none
      if (itype(mbsequ) .eq. 0) bsequnam = 'NO_SEQU'
*---- Store energy, p*c and gamma.
      if (itype(mbener) .ne. 0) then
        if (itype(mbpc) .ne. 0) then
            call aawarn('ENBEAM', 1,
     +      'Redundant data on BEAM --- PC will be ignored.')
        endif
        if (itype(mbgamm) .ne. 0) then
            call aawarn('ENBEAM', 1,
     +      'Redundant data on BEAM --- GAMMA will be ignored.')
        endif
        if (en0 .le. amass) then
          call aafail('ENBEAM', 1,
     +    'Inconsistent data on BEAM --- expect ENERGY > MASS.')
        else
          pc = sqrt(en0**2 - amass**2)
          gamma = en0 / amass
          beta = pc / en0
        endif
      else if (itype(mbpc) .ne. 0) then
        if (itype(mbgamm) .ne. 0) then
            call aawarn('ENBEAM', 1,
     +      'Redundant data on BEAM --- GAMMA will be ignored.')
        endif
        en0 = sqrt(pc**2 + amass**2)
        gamma = en0 / amass
        beta = pc / en0
      else if (itype(mbgamm) .ne. 0) then
        if (gamma .le. 1.0) then
          call aafail('ENBEAM', 1,
     +    'Inconsistent data on BEAM --- expect GAMMA > 1.')
        else
          en0 = gamma * amass
          pc = sqrt(en0**2 - amass**2)
          beta = pc / en0
        endif
      else
        if (en0 .le. amass) then
          call aafail('ENBEAM', 1,
     +    'Inconsistent data on BEAM --- expect ENERGY > MASS.')
        else
          pc = sqrt(en0**2 - amass**2)
          gamma = en0 / amass
          beta = pc / en0
        endif
      endif
      betas = beta
      gammas = gamma

*---- Horizontal emittance.
      if (itype(mbex) .ne. 0) then
        if (itype(mbexn) .ne. 0) then
            call aawarn('ENBEAM', 1,
     +      'Redundant data on BEAM --- EXN will be ignored.')
        endif
        exn = ex * (4.0 * beta * gamma)
      else if (itype(mbexn) .ne. 0) then
        ex = exn / (4.0 * beta * gamma)
      endif

*---- Vertical emittance.
      if (itype(mbey) .ne. 0) then
        if (itype(mbeyn) .ne. 0) then
            call aawarn('ENBEAM', 1,
     +      'Redundant data on BEAM --- EYN will be ignored.')
        endif
        eyn = ey * (4.0 * beta * gamma)
      else if (itype(mbeyn) .ne. 0) then
        ey = eyn / (4.0 * beta * gamma)
      endif

*---- Longitudinal emittance: Cannot be dealt with at this time.
      if (itype(mbet) .ne. 0) then
        ietflg = 1
        if (itype(mbsigt) .ne. 0) then
            call aawarn('ENBEAM', 1,
     +      'Redundant data on BEAM --- SIGT will be ignored.')
        endif
        if (itype(mbsige) .ne. 0) then
            call aawarn('ENBEAM', 1,
     +      'Redundant data on BEAM --- SIGE will be ignored.')
        endif
      else if (itype(mbsigt) .ne. 0) then
        ietflg = 2
        if (itype(mbsige) .ne. 0) then
            call aawarn('ENBEAM', 1,
     +      'Redundant data on BEAM --- SIGE will be ignored.')
        endif
      else if (itype(mbsige) .ne. 0) then
        ietflg = 3
      endif

*---- Beam current and particle number: Deferred handling.
      if (itype(mbcurr) .ne. 0) then
        ipnflg = 1
        if (itype(mbpnum) .ne. 0) then
            call aawarn('ENBEAM', 1,
     +      'Redundant data on BEAM --- NPART will be ignored.')
        endif
      else if (itype(mbpnum) .ne. 0) then
        ipnflg = 2
      endif

*---- Fill in BEAM bank and force re-evaluation of maps.
      if (.not. error) then
        arad = erad * emass / amass * charge**2
        call enput
        call aapdrp
      endif

      end
+dk endump
      subroutine endump
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   SELECT command, set dump flags in working beam line.               *
* Attributes, must be given in this order in the dictionary:           *
*   FLAG      (name)    Dump flag to be set or reset.                  *
*   RANGE     (range)   Range to limit selections.                     *
*   CLASS     (name)    Class of elements to be affected in RANGE.     *
*   PATTERN   (string)  Regular expression to limit choice.            *
*   FULL      (logical) If true, all dump flags are set.               *
*   CLEAR     (logical) If true, all dump flags are cleared first.     *
* (*) Dimensions may be changed in the command dictionary.             *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca seqflag
+ca seqgroup
+ca message
+ca refer
+ca status
+ca datatype
      integer idict,iflag,ipos,ipos1,ipos2,j,leng,mclass,mclear,mflag,
     +mfull,mpatt,mrange,ndict

      parameter         (ndict = 9)
      parameter         (mflag  = 1)
      parameter         (mrange = 2, mclass = 3, mpatt  = 4)
      parameter         (mfull  = 5, mclear = 6)

      logical           done, flag(2)
      character*(mcnam) dict(ndict), flgnam, class
      character*(mcstr) patt
      integer           kflag(ndict), itype(6)
      external          enflag

      data dict         / 'FIRST',  'LIE',    'REFER',  'SECOND',
     +                    'TWISS',  'OPTICS', 'TRACK',  'ERROR',
     +                    'SEQEDIT' /
      data kflag        /  mfrst,    mlump,    mrefe,    mscnd,
     +                     mprnt,    moptc,    mtrck,    mserr,
     +                     0 /

*---- Fetch flag name.
      call utgtyp(lccmd, itype)
      flgnam = 'OPTICS'
      call utgnam(lccmd, mflag, mflag, flgnam)
      call utleng(flgnam, leng)
      call utlook(flgnam(1:leng), dict, ndict, idict)
      if (idict .eq. 0) then
        msg(1) = 'Unknown selection flag "' // flgnam // '" ignored.'
        call aawarn('ENDUMP', 1, msg)

*---- Flag is "SEQEDIT"; reroute call to sequence editor
*     Check valid use of sequence editor subcommand.
      else if (idict .eq. ndict) then
        if (imodul .ne. mplin) then
          msg(1) =
     +    'Cannot run editor subcommand outside sequence editor,'
          msg(2) = 'SEQEDIT command required first.'
          call aafail('LNESEL', 2, msg)
        else
          call lnesel
        endif

*---- Check main beam line.
      else
        call lnchck('SELECT', error)
        if (.not. error) then
          lsflg = lq(lcseq-msflg)
          iflag = kflag(idict)

*---- Fetch logical flags.
          flag(1) = .false.
          flag(2) = .false.
          call utglog(lccmd, mfull, mclear, flag)

*---- FULL option sets select flags for full map.
*     In this case no further processing is needed.
          ipos1 = iq(lcseq+msr1)
          ipos2 = iq(lcseq+msr2)
          if (flag(1)) then
            do 20 ipos = ipos1, ipos2
              call sbit1(iq(lsflg+ipos), iflag)
   20       continue

*---- CLEAR option: clears select flags for full map.
          else if (flag(2)) then
            do 30 ipos = ipos1, ipos2
              call sbit0(iq(lsflg+ipos), iflag)
   30       continue
            do 40 j = mrange, mpatt
              if (itype(j) .ne. 0) then
                call aawarn('ENDUMP', 1,
     +            'No selection can be made with "CLEAR" option.')
                return
              endif
   40       continue

*---- Now set select flags according to RANGE, CLASS and PATTERN.
          else
            class = ' '
            patt  = ' '
            call utgnam(lccmd, mclass, mclass, class)
            call utgstr(lccmd, mpatt,  mpatt,  patt)
            lcatt = lq(lccmd-mrange)
            call ensrng(lcatt, class, patt, enflag, iflag, 0, done)
          endif
        endif
      endif

      end
+dk enfix
      subroutine enfix
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Adjust RF system for nominal beam data, and find beam sizes.       *
*   Uses data from BEAM command and current beam line sequence.        *
*   Nominal optics ignore cavities, radiation, and imperfections.      *
*----------------------------------------------------------------------*
* Modified: 09-SEP-1999, M. Woodley (SLAC)                             *
*   Skip the storage ring computations if there are LCAVITY elements   *
*   in the beamline                                                    *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca beagroup
+ca cmdgroup
+ca elmgroup
+ca prcgroup
+ca seqgroup
+ca strgroup
+ca message
+ca beam
+ca maptrn
+ca optic0
+ca optic1
+ca refer
+ca status
+ca stflag
+ca datatype
+ca physicpm
      integer ipos,irfk,isp,j
      double precision ds,eta,fact,freq,harm,rlag,slope,ten3m,ten6p,tol,
     +twopi,volt,zero,one

+ca pi
      parameter         (zero=0.d0,one=1.d0,twopi = 2.0 * pi)
      parameter         (ten3m = 1.0d-3, ten6p = 1.0d+6)
      parameter         (tol   = 1.0d-15)
      logical           anylcav

*---- Skip, if no beam line set yet.
      if (lcseq .eq. 0) go to 9999

*---- Initial optical functions.
      deltas = zero
      dtbyds = zero
      deltat = zero
      gammas = gamma
      betas  = beta

*---- Do ring stuff only if there are no LCAVITY elements in the beam
*     line.
      if (.not. anylcav()) then

*---- Reset occurrence counts for cavities.
      call difind(ldkey, 'RFCAVITY', irfk, lckey)
      lcelm = lq(lckey-1)
   10 if (lcelm .ne. 0) then
        iq(lcelm-5) = 0
        lcelm = lq(lcelm)
        go to 10
      endif

*---- Set nominal frequencies and find voltage slope.
      slope = zero
      do 20 ipos = iq(lcseq+msr1), iq(lcseq+msr2)
        lcelm = lq(ldbnk(3)-iq(lq(lcseq-msdir)+ipos))
        if (iq(lcelm+mbpr) .eq. mpelm) then
          isp = iq(lcelm+mbsp)
          if (isp .eq. 10) then
            iq(lcelm-5) = iq(lcelm-5) + 1
            call ucopy(q(lcelm+mevltc), volt, mwflt)
            call ucopy(q(lcelm+melagc), rlag, mwflt)
            volt = charge * volt * ten3m / pc
            harm = iq(lcelm+mehrmc)
            rlag = twopi * rlag
            slope = slope + harm * volt * cos(rlag)
          endif
        endif
   20 continue
*---- Initial optical functions.
      deltas = zero
      dtbyds = zero
      deltat = zero
      gammas = gamma
      betas  = beta
      call tmrefe(lcseq)
      if (iq(lcseq+msym) .ne. 0) call tmmksm(.false.)

*---- Circumference, momentum compaction, revolution frequency (MHz).
      circ = iq(lcseq+msup) * suml
      ds = rt(5,6)
      do 30 j = 1, 4
        ds = ds + rt(5,j) * disp0(j)
   30 continue
      eta = - betas**2 * ds / suml
      alfa = one / gammas**2 + eta
      freq0 = (betas * clight) / (ten6p * circ)
*---- Beam current and particle number.
      if (ipnflg .eq. 1) then
        parnum = anint(currnt / (freq0 * ten6p * qelect))
      else
        currnt = parnum * freq0 * ten6p * qelect
      endif

*---- Set nominal frequency for all cavities.
      call difind(ldkey, 'RFCAVITY', irfk, lckey)
      lcelm = lq(lckey-1)
   40 if (lcelm .ne. 0) then
        harm = iq(lcelm+mehrmc)
        freq = harm * freq0
        call utpflt(lcelm, 5, 5, freq)
        lcelm = lq(lcelm)
        go to 40
      endif

*---- Synchrotron tune.
      slope = - iq(lcseq+msup) * slope
      stabt = slope .ne. zero
      qs = sqrt(abs((eta * slope) / (twopi * betas)))
*---- Energy spread and bunch length
      if (stabt  .and.  qs .gt. zero) then
        fact = (eta * circ) / (twopi * qs)
        if (ietflg .eq. 1) then
          sigt = sqrt(abs(et * fact))
          sige = sqrt(abs(et / fact))
        else if (ietflg .eq. 2) then
          sige = sigt / fact
          et = sige * sigt
        else if (ietflg .eq. 3) then
          sigt = sige * fact
          et = sige * sigt
        endif
      endif
      if (sigt .le. tol) then
        sigt = one
        call aawarn('ENFIX',1,'Zero value of SIGT replaced by 1.')
      endif
      if (sige .le. tol) then
        sige = ten3m
        call aawarn('ENFIX',1,'Zero value of SIGE replaced by 1/1000.')
      endif
*---- Store data into BEAM bank.
      call enput
      endif

 9999 end
+dk enflag
      subroutine enflag(ipos, iflag, idum2, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Set flag IFLAG at position IPOS in current beam line sequence.     *
* Input:                                                               *
*   LCSEQ     /REFER/   Current beam line sequence.                    *
*   IPOS      (integer) Bias of position within bank.                  *
*   IFLAG     (integer) Flag to be set.                                *
*   IDUM2     (integer) Not used.                                      *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer idum2,iflag,ipos
      logical           eflag
+ca memdum
+ca seqgroup
+ca refer

      eflag = .false.
      lsflg = lq(lcseq-msflg)
      if (ipos .gt. 0  .and.  ipos .le. iq(lsflg-1)) then
        call sbit1(iq(lsflg+ipos),iflag)
      endif

      end
+dk enfreq
      subroutine enfreq(deltap)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Adjust RF frequencies for all cavities for energy error desired.   *
* Input:                                                               *
*   DELTAP    (real)    Relative energy error delta(E)/(p0*c).         *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca message
+ca beam
+ca optic0
+ca refer
+ca zunit
+ca physicpm
      integer irfk
      double precision deltap,eta,etas,freq,harm,one,ten6m

      parameter         (one = 1.0d0, ten6m = 1.0d-6)

*---- Find revolution frequency.
      eta = alfa - 1.0 / gamma**2
      deltas = deltap
      dtbyds = deltas * eta / beta
      deltat = circ * dtbyds
      freq0 = (clight * ten6m * beta) / (circ * (one + eta * deltas))
      etas = beta * gamma * (one + deltas)
      gammas = sqrt(one + etas**2)
      betas = etas / gammas

*---- Adjust cavities.
      call difind(ldkey, 'RFCAVITY', irfk, lckey)
      lcelm = lq(lckey-1)
   10 if (lcelm .ne. 0) then
        harm = iq(lcelm+mehrmc)
        freq = freq0 * harm
        call utpflt(lcelm, 5, 5, freq)
        lcelm = lq(lcelm)
        go to 10
      endif

*---- Propagate changes just made.
      call aapmod

      end
+dk enget
      subroutine enget
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Fill complete BEAM common from BEAM bank.                          *
* 18 attributes:                                                       *
*   PARTICLE, MASS,     CHARGE,   ENERGY,   PC,       GAMMA,           *
*   EX,       EY,       EXN,      EYN,      ET,       SIGT,            *
*   SIGE,     KBUNCH,   NPART,    BCURRENT, BUNCHED,  RADIATE          *
* Additional quantities kept in BEAM bank:                             *
*   BETA      (real)    Relativistic parameter v/c.                    *
*   U0        (real)    Radiation loss per turn in GeV.                *
*   ARAD      (real)    Classical particle radius.                     *
*   PDAMP(3)  (real)    Damping partition numbers.                     *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca beagroup
+ca strgroup
+ca beam
+ca refer
+ca stflag
      double precision loc_elk(mfact), loc_elm(0:mbmult)
      integer i,k,iflag,locpt,bsequ_number
      character *(mcnam) seqnm
*-- flags for strength inversion depending on bvbeam
*     all flags in loc_elk except stated otherwise
*     drift, rbend(loc_elm), sbend(loc_elm), matrix, quadrupole
*     sextupole, octupole, multipole (loc_elm), solenoid, rfcavity
*     elseparator, srotation, yrotation, hkicker, kicker
*     vkicker, hmonitor, monitor, vmonitor, ecollimator
*     rcollimator, beambeam, lump, instrument, marker
*     gbend(loc_elm)
      data loc_elk /
     +  1.d0,  1.d0,  1.d0,  1.d0, -1.d0,
     + -1.d0, -1.d0,  1.d0,  1.d0,  1.d0,
     +  1.d0,  1.d0,  1.d0,  1.d0,  1.d0,
     +  1.d0,  1.d0,  1.d0,  1.d0,  1.d0,
     +  1.d0,  1.d0,  1.d0,  1.d0,  1.d0,
     +  1.d0,  24 * 1.d0 /
*--- multipole and field error inversion (per order, 1 = dipole)
      data loc_elm / 1.d0, mbmult * -1.d0 /
      if (lbeam .eq. 0)  then
        prtnam = ' '
        bsequnam = 'NO_SEQU'
        amass = 0.0
        charge = 0.0
        en0 = 0.0
        pc = 0.0
        gamma = 0.0
        ex = 1.0
        exn = 0.0
        ey = 1.0
        eyn = 0.0
        et = 1.0
        sigt = 0.0
        sige = 0.0
        bunch = 1.0
        parnum = 0.0
        currnt = 0.0
        sigx = 0.0
        sigy = 0.0
        freq0 = 0.0
        beta = 0.0
        u0 = 0.0
        arad = 0.0
        beambv = 1.d0
        pdamp(1) = 0.0
        pdamp(2) = 0.0
        pdamp(3) = 0.0
        fbch = .true.
        frad = .false.
        ietflg = 1
        ipnflg = 1
      elseif (currseq .ne. 0)  then
        seqnm = sequnam
        k = bsequ_number(seqnm)
        if (k .eq. 0)  then
          seqnm = 'NO_SEQU'
          k = 1
        endif
*--- copy bank
        locpt = lq(lq(lroot-mbeam)-k)
        k = iq(locpt-3)
        i = iq(locpt-1)
        call ucopy(lq(locpt-k-1), lq(lbeam-k-1), k+1)
        call ucopy(iq(locpt+1), iq(lbeam+1), i)
        call utgnam(lbeam, mbpart, mbpart, prtnam)
        call utgnam(lbeam, mbsequ, mbsequ, bsequnam)
        call utgflt(lbeam, mbmass, mbcurr, amass)
        call utglog(lbeam, mbfbch, mbfrad, fbch)
        call utgflt(lbeam, mbfreq, mbdata, freq0)
        iflag  = iq(lbeam-5)
        ietflg = mod(iflag,16)
        ipnflg = mod(iflag/16,16)
      endif
      if (beambv .lt. 0.d0)  then
        do i = 1, mfact
          elkfact(i) = abs(beambv) * loc_elk(i)
        enddo
        do i = 0, mbmult
          elmfact(i) = abs(beambv) * loc_elm(i)
        enddo
      else
        do i = 1, mfact
          elkfact(i) = beambv
        enddo
        do i = 0, mbmult
          elmfact(i) = beambv
        enddo
      endif
*---- Make sure that flags are set properly.
      do 10 i = 1, maxdof
        doflag(i) = .true.
   10 continue
      dorad  = frad

      end
+dk enlump
      subroutine enlump
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for a MAKELUMP.                                      *
* Attributes:                                                          *
*   NAME      (name)    Name for the new lump.                         *
*   RANGE     (range)   Range for the lump.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca seqflag
+ca seqgroup
+ca message
+ca codata
+ca pa6lnk
+ca refer
+ca status
+ca stflag
+ca wstack
      integer icode,idiff,iek,ienum,iflag,ifm,ifp,ihm,ihp,ikey,il,ilast,
     +ileng,iln,iocc,ipos,ipr,ire,irg1,irg2,irt,isave,isp,ite,itm,itp,
     +itt,jbit,jbyt,llast,lmap,ltemp,mxdrp,nkat,nord,ns
      double precision displ,el,orbl,orbt,suml

      parameter         (mxdrp = 9)

      character*(mcnam) elmnam, lmpnam
      dimension         displ(6), orbt(6), orbl(6)
      logical           fmap, radsav

*---- Check for presence of main beam line.
      call lnchck('ENLUMP', error)
      if (error) go to 9999

*---- Get name for LUMP.
      lmpnam = ' '
      call utgnam(lccmd, 1, 1, lmpnam)
      if (lmpnam .eq. ' ') then
        call aafail('ENLUMP', 1, 'LABEL for MAKELUMP missing.')
        go to 9999
      endif

*---- Get and check range.
      call utgrng(lq(lccmd-2), lcseq, irg1, irg2, error)
      if (error) then
        call aafail('ENLUMP', 1, 'Invalid range for MAKELUMP')
        go to 9999
      endif

*---- Initialize, test for validity.
      radsav = dorad
      if (dorad) then
        dorad = .false.
        call diname(ldbnk, iq(lcelm+mbnam), elmnam)
        call utleng(elmnam, ileng)
        msg(1) = 'LUMP "' // elmnam(1:ileng)
     +  // '" will ignore radiation.'
        call aawarn('ENLUMP', 1, msg)
      endif

*---- Extract relevant pointers.
      lsdir = lq(lcseq-msdir)
      lsflg = lq(lcseq-msflg)
      lsali = lq(lcseq-msali)
      lsfld = lq(lcseq-msfld)
      lsnum = lq(lcseq-msnum)
      lscom = lq(lcseq-mscom)

*---- Initialize polynomial package.
      call painit(6)

*---- Fetch LUMP order.
      nord = 4
      call utgint(lccmd, 3, 3, nord)
      nord = min(nord, 6)

*---- Allocate working store.
      isave = iwork
      iek = iwork
      ire = iek + 6
      ite = ire + 36
      irt = ite + 216
      itt = irt + 36
      ifm = itt + 216
      ifp = ifm + 36
      ihm = ifp + itop6(nord)
      ihp = ihm + 36
      itm = ihp + itop6(nord)
      itp = itm + 36
      iwork = itp + itop6(nord)
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Set up identity maps.
      suml = 0.0
      call uzero(orbt, 1, 6*mwflt)
      call m66one(dq(irt+1))
      call uzero(dq(itt+1), 1, 216*mwflt)
      call uzero(orbl, 1, 6*mwflt)
      call lmone(nord, dq(ifp+1), dq(ifm+1))

*---- Build the desired lump.
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        icode = jbyt(iflag,1,mcode)

*---- Misalignment at entrance.
        if (icode .ne. 3  .and.  lcali .ne. 0) then
          call tmali1(ipos, .true., orbt, orbt,
     +      dq(ire+1), dq(ite+1))
          call tmcat(.true., dq(ire+1), dq(ite+1), dq(irt+1),
     +      dq(itt+1), dq(irt+1), dq(itt+1))
          call ucopy(q(lcali+1), displ, 6 * mwflt)
          call lmdsp1(ipos, nord, displ, dq(itp+1), dq(itm+1))
          call lamove(nord, dq(itp+1), dq(itm+1), orbl,
     +                dq(ihp+1), dq(ihm+1))
          call lmcat(nord, dq(ifp+1), dq(ifm+1), dq(ihp+1), dq(ihm+1),
     +               dq(ifp+1), dq(ifm+1))
        endif

*---- Physical element.
        if (icode .eq. 1) then
          call tmmap(.true., .true., orbt, fmap, el,
     +               dq(iek+1), dq(ire+1), dq(ite+1))
          if (fmap) then
            call tmcat(.true., dq(ire+1), dq(ite+1),
     +        dq(irt+1), dq(itt+1), dq(irt+1), dq(itt+1))
            suml = suml + el
          endif
          call lmmap(nord, el, dq(itp+1), dq(itm+1))
          call lamove(nord, dq(itp+1), dq(itm+1), orbl,
     +                dq(ihp+1), dq(ihm+1))
          call lmcat(nord, dq(ifp+1), dq(ifm+1), dq(ihp+1), dq(ihm+1),
     +               dq(ifp+1), dq(ifm+1))
        endif

*---- Misalignment at exit.
        if (icode .ne. 2  .and.  lcali .ne. 0) then
          call tmali2(ipos, .true., orbt, orbt,
     +      dq(ire+1), dq(ite+1))
          call tmcat(.true., dq(ire+1), dq(ite+1), dq(irt+1),
     +      dq(itt+1), dq(irt+1), dq(itt+1))
          call ucopy(q(lcali+1), displ, 6 * mwflt)
          call lmdsp2(ipos, nord, displ, dq(itp+1), dq(itm+1))
          call lamove(nord, dq(itp+1), dq(itm+1), orbl,
     +                dq(ihp+1), dq(ihm+1))
          call lmcat(nord, dq(ifp+1), dq(ifm+1), dq(ihp+1), dq(ihm+1),
     +               dq(ifp+1), dq(ifm+1))
        endif

*---- Remove banks linked to positions within range.
*       Misalignments.
        if (lsali .ne. 0  .and.  lq(lsali-ipos) .ne. 0) then
          call mzdrop(0, lq(lsali-ipos), '.')
        endif
*       Field errors.
        if (lsfld .ne. 0  .and.  lq(lsfld-ipos) .ne. 0) then
          call mzdrop(0, lq(lsfld-ipos), '.')
        endif
*       Orbit correction data: Just flag and drop later
        if (lscom .ne. 0  .and.  lq(lscom-ipos) .ne. 0) then
          call mzflag(0, lq(lscom-ipos), mxdrp, '.')
        endif
   90 continue

*---- Remove flagged element positions.
      llast = 0
      lccom = lq(lcseq-mselm)
  110 if (lccom .ne. 0) then
        ltemp = lq(lccom-1)
        if (jbit(iq(lccom), mxdrp) .ne. 0) then
          if (llast .eq. 0) then
            lq(lcseq-mselm) = ltemp
          else
            lq(llast-1) = ltemp
          endif
          call mzdrop(0, lccom, '.')
        else
          llast = lccom
        endif
        lccom = ltemp
        go to 110
      endif

*---- Remove flagged corrector positions.
      ncor(1) = 0
      ncor(2) = 0
      llast = 0
      lccom = lq(lcseq-mscor)
  120 if (lccom .ne. 0) then
        ltemp = lq(lccom-1)
        if (jbit(iq(lccom), mxdrp) .ne. 0) then
          if (llast .eq. 0) then
            lq(lcseq-mselm) = ltemp
          else
            lq(llast-1) = ltemp
          endif
          call mzdrop(0, lccom, '.')
        else
          llast = lccom
          if (jbit(iq(lccom), 1) .ne. 0) ncor(1) = ncor(1) + 1
          if (jbit(iq(lccom), 2) .ne. 0) ncor(2) = ncor(2) + 1
        endif
        lccom = ltemp
        go to 120
      endif

*---- Remove flagged monitor positions.
      nmon(1) = 0
      nmon(2) = 0
      llast = 0
      lccom = lq(lcseq-msmon)
  130 if (lccom .ne. 0) then
        ltemp = lq(lccom-1)
        if (jbit(iq(lccom), mxdrp) .ne. 0) then
          if (llast .eq. 0) then
            lq(lcseq-mselm) = ltemp
          else
            lq(llast-1) = ltemp
          endif
          call mzdrop(0, lccom, '.')
        else
          llast = lccom
          if (jbit(iq(lccom), 1) .ne. 0) nmon(1) = nmon(1) + 1
          if (jbit(iq(lccom), 2) .ne. 0) nmon(2) = nmon(2) + 1
        endif
        lccom = ltemp
        go to 130
      endif

*---- Build new LUMP element.
      call difind(ldkey, 'LUMP', ikey, lckey)
      call kwget(lckey, iln, ipr, isp, nkat)
      call aabook(lcelm, lmpnam(1:4), ipr, isp, lckey, 1)
      call didefi(ldbnk, lmpnam, lcelm)
      iq(lcelm+mbat+2*mcsiz+mcval) = nord

*---- Store TRANSPORT map.
      il = iq(lcelm+mbat) + mbemap
      ns = (6 + 36 + 216) * mwflt
      call mzbook(2, lmap, lcelm, -il, 'LMAP', 0, 0, ns, mreal, 0)
      call utpflt(lcelm, 2, 2, suml)
      call ucopy(orbt, q(lmap+1), 6*mwflt)
      call ucopy(dq(irt+1), q(lmap+6*mwflt+1), 36*mwflt)
      call ucopy(dq(itt+1), q(lmap+42*mwflt+1), 216*mwflt)

*---- Store Lie map.
      il = iq(lcelm+mbat) + mbelie
      ns = (36 + itop6(nord)) * mwflt
      call mzbook(2, lmap, lcelm, -il, 'LMAP', 0, 0, ns, mreal, 0)
      call ucopy(dq(ifm+1), q(lmap+1), 36*mwflt)
      call ucopy(dq(ifp+1), q(lmap+36*mwflt+1), itop6(nord)*mwflt)

*---- Replace RANGE by new LUMP.
      iq(lsdir+irg1) = iq(lcelm+mbnam)
      iq(lsflg+irg1) = 1
      call sbyt(1, iq(lsflg+irg1), mocc1, mocc2)
      iq(lsnum+irg1) = 1

*---- Move information for subequent elements.
      ilast = irg1
      do 150 ipos = irg2 + 1, iq(lsflg-1)
        ilast = ilast + 1
        iq(lsdir+ilast) = iq(lsdir+ipos)
        iq(lsflg+ilast) = iq(lsflg+ipos)
*       Misalignments.
        if (lsali .ne. 0) then
          if (lq(lsali-ipos) .ne. 0) then
            call zshunt(0, lq(lsali-ipos), lsali, -ilast, 0)
            iq(lq(lsali-ilast)-5) = ilast
          else
            lq(lsali-ilast) = 0
          endif
        endif
*       Field errors.
        if (lsfld .ne. 0) then
          if (lq(lsfld-ipos) .ne. 0) then
            call zshunt(0, lq(lsfld-ipos), lsfld, -ilast, 0)
            iq(lq(lsfld-ilast)-5) = ilast
          else
            lq(lsfld-ilast) = 0
          endif
        endif
*       Orbit correction data.
        if (lscom .ne. 0) then
          if (lq(lscom-ipos) .ne. 0) then
            call zshunt(0, lq(lscom-ipos), lscom, -ilast, 0)
            iq(lq(lscom-ilast)-5) = ilast
          else
            lq(lscom-ilast) = 0
          endif
        endif
  150 continue

*---- Release unused space.
      idiff = ilast - iq(lsflg-1)
      call mzpush(0, lsdir, 0, idiff, 'I')
      call mzpush(0, lsflg, 0, idiff, 'I')
      call mzpush(0, lsnum, 0, idiff, 'I')
      if (lsali .ne. 0) call mzpush(0, lsali, idiff, 0, 'I')
      if (lsfld .ne. 0) call mzpush(0, lsfld, idiff, 0, 'I')
      if (lscom .ne. 0) call mzpush(0, lscom, idiff, 0, 'I')

*---- Update USED range.
      if (irg2 .lt. iq(lcseq+msr1)) then
*       MAKELUMP range completely below USED range.
        iq(lcseq+msr1) = iq(lcseq+msr1) + idiff
        iq(lcseq+msr2) = iq(lcseq+msr2) + idiff
      else if (irg1 .gt. iq(lcseq+msr2)) then
*       MAKELUMP range completely above USED range.
        continue
      else if (irg1 .ge. iq(lcseq+msr1)  .and.
     +         irg2 .le. iq(lcseq+msr2)) then
*       MAKELUMP range completely within USED range.
        iq(lcseq+msr2) = iq(lcseq+msr2) + idiff
      else
*       MAKELUMP range contains one or both ends of USED range.
*       Reset USED range to complete USED line.
        iq(lcseq+msr1) = 1
        iq(lcseq+msr2) = ilast
        msg(1) =
     +    'MAKELUMP range overlaps one or both ends of USED range.'
        msg(2) = 'Please reselect a new range for computation with:'
        msg(3) = '     USE, RANGE=<range>'
        call aawarn('ENLUMP', 3, msg)
      endif

*---- Must recompute one-turn map.
      newmap = .true.

*---- Restore radiation flag.
      dorad = radsav

*---- Release working store.
      iwork = isave

 9999 end
+dk enmain
      subroutine enmain(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Switch routine (subprocess code) for environment section.          *
* Input:                                                               *
*   IPR       (integer) Process code.                                  *
*   ISP       (integer) Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca header
+ca refer
      integer ipr,isp
+if doom
      integer nc,nz
+ei

*---- User-defined services.
      if (isp .le. 0  .or.  isp .gt. 20) then
        call usercm(ipr, isp)

*---- BEAM.
      else if (isp .eq. 1) then
        call enbeam

*---- BETA0: No action required (data already stored).
      else if (isp .eq. 2) then
        continue

*---- PRINT.
      else if (isp .eq. 3) then
        call enprnt

*---- SAVEBETA.
      else if (isp .eq. 4) then
        call ensbet

*---- TITLE.
      else if (isp .eq. 5) then
        call utgstr(lccmd, 1, 1, ctitle)
+if doom
*--- put title in DOOM
        nz = 0
        call utleng(ctitle, nc)
        if (nc .gt. 1 .or. ctitle(1:1) .ne. ' ')
     +  call doom_pstring('TITLE ', nz, nc, ctitle)
+ei
*---- USE.
      else if (isp .eq. 6) then
        call enuse

*---- SELECT.
      else if (isp .eq. 7) then
        call endump

*---- SPLIT.
      else if (isp .eq. 8) then
        call ensplt

*---- SAVESIGMA.
      else if (isp .eq. 9) then
        call enssig

*---- SIGMA0: No action required (data already stored).
      else if (isp .eq. 10) then
        continue

*---- MAKLEUMP.
      else if (isp .eq. 11) then
        call enlump
      endif

      end
+dk enprem
      subroutine enprem
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print emittances and sigmas.                                       *
*----------------------------------------------------------------------*
+ca aparam
+ca beam
+ca zunit
      double precision ten3p,ten6p

      parameter         (ten6p = 1.0d6, ten3p = 1.0d3)

*---- Emittances and sigmas.
      write (iqpr2, 910) ten6p * ex, ten3p * sigx,
     +                   ten6p * ey, ten3p * sigy,
     +                   ten6p * et, ten3p * sigt, ten3p * sige

  910 format(' '/' Emittances:'/' '/
     +       t6,'Ex',t16,e16.6,' pi*mm*mrad',t48,'sigx',t58,f14.6,' mm'/
     +       t6,'Ey',t16,e16.6,' pi*mm*mrad',t48,'sigy',t58,f14.6,' mm'/
     +       t6,'Et',t16,e16.6,' pi*mm*mrad',t48,'sigt',t58,f14.6,' mm',
     +       t88,'sigE',t96,f14.6,' 1/1000')

      end
+dk enprgl
      subroutine enprgl
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print global data for machine.                                     *
*----------------------------------------------------------------------*
+ca aparam
+ca beam
+ca optic0
+ca zunit
      integer len
      double precision eta,t0

*---- Global parameters.
      call utleng(prtnam, len)
      if (alfa .gt. 0.0) then
        gamtr = sqrt(1.0 / alfa)
      else if (alfa .eq. 0.0) then
        gamtr = 0.0
      else
        gamtr = - sqrt(-1.0 / alfa)
      endif
      t0 = 1.0 / freq0
      eta = alfa - 1.0 / gamma**2
      write (iqpr2, 910) prtnam(1:len), frad, circ, freq0, t0, alfa,
     +eta, gamtr, currnt, bunch, parnum, en0, gamma, beta

  910 format(' '/' Global parameters for ',a,'S, radiate = ',l1,':'/' '/
     +       t6,'C',t16,f14.6,' m',t46,'f0',t56,f14.6,' MHz',
     +       t86,'T0',t96,f14.6,' microseconds'/
     +       t6,'alfa',t16,e18.6,t46,'eta',t56,e18.6,
     +       t86,'gamma(tr)',t96,f14.6/
     +       t6,'Bcurrent',t16,f14.6,' A/bunch',t46,'Kbunch',t56,f14.6,
     +       t86,'Npart',t96,e18.6,' per bunch'/
     +       t6,'E',t16,f14.6,' GeV',t46,'gamma',t56,f14.6,
     +       t86,'beta',t96,f14.6)

      end
+dk enprnt
      subroutine enprnt
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   PRINT command, set print flags in working beam line.               *
* Attributes, must be given in this order in the dictionary:           *
*   RANGE     (range)   Range to limit selections.                     *
*   CLASS     (name)    Class of elements to be affected in RANGE.     *
*   PATTERN   (string)  Regular expression to limit choice.            *
*   FULL      (logical) If true, all print flags are set.              *
*   CLEAR     (logical) If true, all print flags are cleared first.    *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca seqflag
+ca seqgroup
+ca refer
+ca status
+ca datatype
      integer ipos,ipos1,ipos2,mclass,mclear,mfull,mpatt,mrange

      character*(mcnam) class
      character*(mcstr) patt
      logical           done, flag(2)
      external          enflag

      parameter         (mrange = 1, mclass = 2, mpatt  = 3)
      parameter         (mfull  = 4, mclear = 5)

*---- Check main beam line.
      call lnchck('PRINT ', error)
      if (.not. error) then
        lsflg = lq(lcseq-msflg)

*---- Fetch logical flags.
        flag(1) = .false.
        flag(2) = .false.
        call utglog(lccmd, mfull, mclear, flag)

*---- FULL option sets print flags for full map.
*     In this case no further processing is needed.
        ipos1 = iq(lcseq+msr1)
        ipos2 = iq(lcseq+msr2)
        if (flag(1)) then
          do 10 ipos = ipos1, ipos2
            call sbit1(iq(lsflg+ipos), mprnt)
   10     continue

*---- CLEAR option: clears print flags for full map.
        else if (flag(2)) then
          do 20 ipos = ipos1, ipos2
            call sbit0(iq(lsflg+ipos), mprnt)
   20     continue

*---- Now set print flags according to RANGE, CLASS and PATTERN.
        else
          class = ' '
          patt  = ' '
          call utgnam(lccmd, mclass, mclass, class)
          call utgstr(lccmd, mpatt,  mpatt,  patt)
          lcatt = lq(lccmd-mrange)
          call ensrng(lcatt, class, patt, enflag, mprnt, 0, done)
        endif
      endif

      end
+dk enprrf
      subroutine enprrf
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print data of RF system.                                           *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca refer
+ca zunit
      integer iharm,irfk
      double precision data

      character*(mcnam) cavnam
      dimension         data(4)

*---- Loop over all RF cavities.
      write (iqpr2, 910)
      call difind(ldkey, 'RFCAVITY', irfk, lckey)
      lcelm = lq(lckey-1)

*---- Fetch data for next cavity and print.
   10 if (lcelm .ne. 0) then
        call diname(ldbnk, iq(lcelm+mbnam), cavnam)
        data(1) = 0.0
        data(2) = 0.0
        data(3) = 0.0
        data(4) = 0.0
        iharm = 0
        call utgflt(lcelm, 2, 5, data)
        call utgint(lcelm, 6, 6, iharm)
        write (iqpr2, 920) cavnam, data, iharm, iq(lcelm-5)
        lcelm = lq(lcelm)
        go to 10
      endif

  910 format(' '/' RF system:'/' '/' Cavity',t40,'L',t57,'volt',
     +       t78,'lag',t92,'frequency',t109,'harmon',t119,'occur.'/
     +       ' name',t40,'m',t59,'MV',t98,'MHz')
  920 format(' ',a16,t21,4f20.6,i14,i10)

      end
+dk enput
      subroutine enput
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Store complete BEAM common into BEAM bank.                         *
* 18 attributes:                                                       *
*   PARTICLE, MASS,     CHARGE,   ENERGY,   PC,       GAMMA,           *
*   EX,       EY,       EXN,      EYN,      ET,       SIGT,            *
*   SIGE,     KBUNCH,   NPART,    BCURRENT, BUNCHED,  RADIATE          *
* Additional quantities kept in BEAM bank:                             *
*   FREQ0     (real)    Revolution frequency in MHz.                   *
*   BETA      (real)    Relativistic parameter v/c.                    *
*   U0        (real)    Radiation loss per turn in GeV.                *
*   ARAD      (real)    Classical particle radius.                     *
*   PDAMP(3)  (real)    Damping partition numbers.                     *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca beagroup
+ca strgroup
+ca markbits
+ca beam
+ca refer
      integer i,k,ipr,isp,locpt,bsequ_number,idir

      character*(mcnam) label
      data label        / 'BEAM' /

*---- Make sure there is a BEAM bank.
      call difind(ldkey, label, idir, lckey)
      lbeam = lq(lckey-3)
      if (lbeam .eq. 0) then
        label = 'BEAM'
        ipr = iq(lckey+mbpr)
        isp = iq(lckey+mbsp)
        call aabook(lbeam, label, ipr, isp, lckey, 1)
        lq(lckey-3) = lbeam
        call didefi(ldbnk, label, lbeam)
        call sbit1(iq(lbeam), mxcls)
        iq(lbeam+mbln) = 0
      endif

*---- Store data into BEAM bank.
      call utpnam(lbeam, mbpart, mbpart, prtnam)
      call utpnam(lbeam, mbsequ, mbsequ, bsequnam)
      call utpflt(lbeam, mbmass, mbcurr, amass)
      call utplog(lbeam, mbfbch, mbfrad, fbch)
      call utpflt(lbeam, mbfreq, mbdata, freq0)
      iq(lbeam-5) = ietflg + 16 * ipnflg
*--- store in beam bank pool - either new, or overwrite old
      k = bsequ_number(bsequnam)
      if (k .eq. 0)  then
        if (liftbeam .eq. iq(lq(lroot-mbeam)-3))  then
          call mzpush(0, lq(lroot-mbeam), liftbeam, 0, 'I')
        endif
        liftbeam = liftbeam + 1
        currbeam = liftbeam
        call mzbook(2, locpt, lq(lroot-mbeam), -liftbeam, 'SBEA',
     +  iq(lbeam-3), iq(lbeam-2), iq(lbeam-1), 0, -1)
        bseqnames(liftbeam) = bsequnam
      else
        locpt = lq(lq(lroot-mbeam)-k)
      endif
*--- copy bank
      k = iq(lbeam-3)
      i = iq(lbeam-1)
      call ucopy(lq(lbeam-k-1), lq(locpt-k-1), k+1)
      call ucopy(iq(lbeam+1), iq(locpt+1), i)
      end
+dk enrang
      subroutine enrang(lrng, rngnam)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Encode the name of a range.                                        *
* Input:                                                               *
*   LRNG(1)   (pointer) Range reference bank.                          *
* Output:                                                              *
*   RNGNAM*(*)(char)    Range name.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer i,icode1,icode2,idir1,idir2,index1,index2,j,len,leng1,
     +leng2,mclab
      integer           lrng(*)
      character*(mcrng) rngnam
+ca memdum
+ca refer

      character*(mcnam) elnam1, elnam2
      parameter         (mclab = mcnam + 8)
      character*20      label1, label2
      character*(mcrng) tmpnam

*---- Fetch data.
      icode1 = iq(lrng(1)+1)
      idir1  = iq(lrng(1)+2)
      index1 = iq(lrng(1)+3)
      icode2 = iq(lrng(1)+4)
      idir2  = iq(lrng(1)+5)
      index2 = iq(lrng(1)+6)
      call diname(ldbnk, idir1, elnam1)
      call diname(ldbnk, idir2, elnam2)

*---- Ordinary range.
      if (icode1 .lt. 7) then
        if (icode1 .eq. 1) then
          label1 = '#S'
          leng1 = 2
        else if (icode1 .eq. 2) then
          label1 = '#E'
          leng1 = 2
        else if (icode1 .eq. 3) then
          label1 = '#F'
          leng1 = 2
        else if (icode1 .eq. 4) then
          label1 = '#L'
          leng1 = 2
        else if (icode1 .eq. 5) then
          write (label1, '(''#'',I7)') index1
          leng1 = 8
        else
          write (label1, '(A12,''['',I6,'']'')') elnam1, index1
          leng1 = 12
          if (index1 .ne. 0) leng1 = 20
        endif
        if (icode2 .eq. 1) then
          label2 = '#S'
          leng2 = 2
        else if (icode2 .eq. 2) then
          label2 = '#E'
          leng2 = 2
        else if (icode2 .eq. 3) then
          label2 = '#F'
          leng2 = 2
        else if (icode2 .eq. 4) then
          label2 = '#L'
          leng2 = 2
        else if (icode2 .eq. 5) then
          write (label2, '(''#'',I7)') index2
          leng2 = 8
        else
          write (label2, '(A12,''['',I6,'']'')') elnam2, index2
          leng2 = 12
          if (index2 .ne. 0) leng2 = 20
        endif

*---- Pack non-blank characters to range name.
        j = 0
        rngnam = ' '
        do 10 i = 1, leng1
          if (label1(i:i) .ne. ' ') then
            j = j + 1
            rngnam(j:j) = label1(i:i)
          endif
   10   continue
        j = j + 1
        rngnam(j:j) = '/'
        do 20 i = 1, leng2
          if (label2(i:i) .ne. ' ') then
            j = j + 1
            if (j .gt. len(rngnam)) go to 30
            rngnam(j:j) = label2(i:i)
          endif
   20   continue
   30   continue

*---- "Selection" range.
      else if (index1 .eq. 0) then
        rngnam = elnam1
      else
        write (tmpnam, '(A12,''['',I6,''/'',I6,'']'')')
     +  elnam1, index1, index2
        j = 0
        rngnam = ' '
        do 40 i = 1, len(tmpnam)
          if (tmpnam(i:i) .ne. ' ') then
            j = j + 1
            rngnam(j:j) = tmpnam(i:i)
          endif
   40   continue
      endif

      end
+dk ensbet
      subroutine ensbet
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save lattice functions for subsequent TWISS, SAVEBETA command.     *
* Attributes:                                                          *
*   LABEL     (name)    Name for BETA0 bank to be stored.              *
*   PLACE     (range)   Place in main beam line where to take data.    *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca seqflag
+ca seqgroup
+ca strgroup
+ca refer
+ca status
+ca twlink
      integer idir,ikey,iln,ipos,ipr,isp,nkat,kseq,locseq,sequ_number

      character*(mcnam) betnam, seqnm
      logical           build

*---- Check for presence of main beam line.
      call lnchck('ENSBET', error)

*---- Look for position in main beam line.
      if (.not. error) then
        lcatt = lq(lccmd-2)
        call utgpos(lcatt, lcseq, 0, ipos, error)
        if (ipos .eq. 0) ipos = 1

*---- Find BETA0 dictionary entry.
        if (.not. error) then
          call difind(ldkey, 'BETA0', ikey, lckey)
          call kwget(lckey, iln, ipr, isp, nkat)

*--- sequence ?
          seqnm = ' '
          call utgnam(lccmd, 3, 3, seqnm)
          kseq = sequ_number(seqnm)
          if (kseq .eq. 0)  kseq = currseq
*---- Look for a previous BETA0 bank.
          betnam = 'BETA0'
          call utgnam(lccmd, 1, 1, betnam)
          call difind(ldbnk, betnam, idir, ltwbet)
          if (ltwbet .eq. 0) then
            build = .true.
          else
            build = iq(ltwbet+mbpr).ne.ipr .or. iq(ltwbet+mbsp).ne.isp
          endif

*---- If not BUILD, create new one and link it to directory.
          if (build) then
            call aabook(ltwbet, 'BETA', ipr, isp, lckey, 1)
            call didefi(ldbnk, betnam, ltwbet)
          endif

*---- Link to main beam line.
          locseq = lq(lq(lroot-mcseq)-kseq)
          call sbit1(iq(lq(locseq-msflg)+ipos), msbet)
          iq(ltwbet-5) = ipos
        endif
      endif

      end
+dk enspca
      subroutine enspca(ipos, icount, idum2, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Assign split information to current element.                       *
* Input:                                                               *
*   IPOS      (integer) Current position number.                       *
*   ICOUNT    (integer) Counter for split banks generated.             *
*   IDUM2     (integer) Unused.                                        *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,icount,idata,idum2,ipos,ipr,isp,l,nd
      double precision fract,ftest
      logical           eflag
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca seqgroup
+ca refer

      character*(mcnam) posnam

*---- Test for valid beam element.
      eflag = .false.
      if (lcelm .eq. 0) go to 90
      ipr = iq(lcelm+mbpr)
      isp = iq(lcelm+mbsp)
      if (ipr .ne. mpelm  .or.  isp .le. 0  .or.  isp .gt. 30) go to 90

*---- Can element be split?
      go to (10, 10, 10, 90, 10, 10, 10, 90, 10, 10,
     +       10, 90, 90, 10, 10, 10, 10, 10, 10, 10,
     +       10, 90, 90, 10, 90, 10, 10, 90, 90, 90,
     +       90, 90, 90, 90, 90, 90, 90, 90, 90, 90), isp

*---- Lift split bank and put it in proper order.
   10 continue
        idata = mbat + mcsiz
        call ucopy(q(lccmd+idata+mcval), fract, mwflt)
        lsspl = lq(lcseq-msspl)
        ibias = - ipos
        lcspl = lq(lsspl-ipos)
   20   if (lcspl .ne. 0) then
          call ucopy(q(lcspl+mwnam+3), ftest, mwflt)
          if (ftest .lt. fract) then
            lsspl = lcspl
            ibias = 0
            lcspl = lq(lcspl)
            go to 20
          endif
        endif
        nd = mwnam + mwflt + 2
        call mzbook(2, l, lsspl, ibias, 'SPLT', 0, 0, nd, 0, 0)

*---- Fill in split information.
        iq(l+1) = mwnam * 16 + 5
        posnam = ' '
        call utgnam(lccmd, 1, 1, posnam)
        call uctoh(posnam, iq(l+2), mcwrd, mcnam)
        iq(l+mwnam+2) = mwflt * 16 + 3
        call ucopy(fract, q(l+mwnam+3), mwflt)

*---- Count split banks generated.
        icount = icount + 1
   90 continue

      end
+dk ensplt
      subroutine ensplt
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Assign split information to a set of beam elements.                *
* SPLIT command. Attributes:                                           *
*   NAME      (name)    Name to be given to intermediate point.        *
*   FRACTION  (real)    Fraction of element where split is desired.    *
*   RANGE     (range)   Range to limit selections.                     *
*   CLASS     (name)    Class of elements to be affected in RANGE.     *
*   PATTERN   (string)  Regular expression to limit choice.            *
*   FULL      (logical) If true, all elements are split at FRACTION.   *
*   CLEAR     (logical) If true, all splits are cleared first.         *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca seqgroup
+ca message
+ca refer
+ca status
+ca datatype
      integer icount,ienum,iflag,iocc,ipos,ipos1,ipos2,mclass,mclear,
     +mfrac,mfull,mname,mpatt,mrange,nl
      double precision fract

      external          enspca
      character*(mcnam) elmnam, class
      character*(mcstr) patt
      logical           done, flag(2)

      parameter         (mname  = 1, mfrac  = 2)
      parameter         (mrange = 3, mclass = 4, mpatt  = 5)
      parameter         (mfull  = 6, mclear = 7)

*---- Check if a map module exists.
      call lnchck('SPLIT', error)
      if (.not. error) then

*---- Check if fraction is in range.
        call utgflt(lccmd, mfrac, mfrac, fract)
        if (fract .lt. 0.0  .or.  fract .gt. 1.0) then
          msg(1) = 'SPLIT fraction should lie in the range (0..1)'
     +    // ' SPLIT ignored.'
          call aawarn('ENSPLT', 1, msg)

*---- Get logical flags.
        else
          flag(1) = .false.
          flag(2) = .false.
          call utglog(lccmd, mfull, mclear, flag)

*---- CLEAR option clears split flags.
          lsdir = lq(lcseq-msdir)
          lsspl = lq(lcseq-msspl)
          if (flag(2)  .and.  lsspl .ne. 0) then
            call mzdrop(0, lsspl, 'V')
            call aainfo('ENSPLT', 1, 'SPLIT positions cleared.')
            lsspl = 0

*---- Lift split bank, if not already done.
          else
            if (lsspl .eq. 0) then
              nl = iq(lsdir-1)
              call mzbook(2, lsspl, lcseq, -msspl, 'SPLT', nl, nl, 0,
     +                    2, 0)
            endif

*---- FULL option splits all elements; this requires no further setting.
            icount = 0
            if (flag(1)) then
              ipos1 = iq(lcseq+msr1)
              ipos2 = iq(lcseq+msr2)
              do 10 ipos = ipos1, ipos2
                call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
                call enspca(ipos, icount, 0, error)
   10         continue

*---- Now set select flags according to RANGE, CLASS and PATTERN.
            else
              class = ' '
              patt  = ' '
              call utgnam(lccmd, mclass, mclass, class)
              call utgstr(lccmd, mpatt,  mpatt,  patt)
              lcatt = lq(lccmd-mrange)
              call ensrng(lcatt, class, patt, enspca, icount, 0, done)
            endif

*---- Tell user how many split positions have been added.
            if (icount .ne. 0) then
              write (msg, 920) icount
  920         format('Split positions added to ',i6,' elements.')
              call aainfo('ENSPLT', 1, msg)
            endif
          endif
        endif
      endif

      end
+dk ensrng
      subroutine ensrng(lrng, class, patt, action, idum1, idum2, done)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Apply subroutine ACTION to all places in a range.                  *
* Input:                                                               *
*   LCSEQ     /REFER/   Current beam line sequence.                    *
*   LRNG(1)   (pointer) Range reference bank.                          *
*   CLASS     (name)    Class name to limit selection.                 *
*   PATTERN   (string)  Pattern string to limit selection.             *
*                       (all three conditions "anded" together).       *
*   ACTION    (subr)    Subroutine to be executed in each position.    *
*   IDUM1(*)  (integer) Additional argument for ACTION.                *
*   IDUM2(*)  (integer) Additional argument for ACTION.                *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,ipos,ipos1,ipos2,l
      integer           lrng(*), idum1(*), idum2(*)
      character*(mcnam) class, label
      character*(mcstr) patt
      logical           done
      external          action
+ca memdum
+ca bankhead
+ca prcgroup
+ca seqflag
+ca seqgroup
+ca message
+ca refer
+ca status

      logical           eflag, found

*---- Determine range to be considered.
      if (lrng(1) .eq. 0) then
        ipos1 = iq(lcseq+msr1)
        ipos2 = iq(lcseq+msr2)
      else
        call utgrng(lrng, lcseq, ipos1, ipos2, error)
      endif

*---- Find class name.
      if (class .eq. ' ') then
        lccls = 0
      else
        call difind(ldbnk, class, idir, lccls)
        if (lccls .eq. 0) then
          call utleng(class, l)
          msg(1) = 'Unknown class name "' // class(1:l) // '".'
          call aafail('ENSRNG', 1, msg)
          error = .true.
        endif
      endif

*---- Build pattern.
      if (patt .eq. ' '  .or.  patt .eq. '.*') then
        lref1 = 0
      else
        call utpatt(patt, lref1)
      endif

*---- Loop for positions.
      if (error) go to 9999
      done = .false.
      lsdir = lq(lcseq-msdir)
      do 90 ipos = ipos1, ipos2
        idir  = iq(lsdir+ipos)
        lcelm = lq(ldbnk(3)-idir)

*---- If CLASS != ' ', test for class membership.
        if (lccls .ne. 0) then
          found = .false.
          lref2 = lcelm
   20     if (lref2 .ne. 0  .and. .not. found) then
            if (lref2 .eq. lccls) then
              found = .true.
            endif
            if (iq(lref2+mbpr) .ne. mplin) then
              lref2 = lq(lref2-iq(lref2+mbat)-mbecls)
              go to 20
            endif
          endif

*---- Default for CLASS = ' ' is all classes.
        else
          found = .true.
        endif

*---- Test for pattern match (skip, if not found as a class member).
        if (found  .and.  lref1 .ne. 0) then
          call diname(ldbnk, idir, label)
          call utmtpt(lref1, label, found)
        endif

*---- If tests succeeded, perform action.
        if (found) then
          eflag = .false.
          call action(ipos, idum1, idum2, eflag)
          error = error .or. eflag
          done = .true.
        endif
   90 continue

*---- Drop pattern.
      if (lref1 .ne. 0) call mzdrop(0, lref1, 'L')

*---- Test for empty range.
      if (.not. (error .or. done)) then
        call aawarn('ENSRNG', 1,
     +  'No elements found in range which fulfill the conditions.')
      endif

 9999 end
+dk enssig
      subroutine enssig
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   SAVESIGMA command: Define place to save beam envelope.             *
* Attributes:                                                          *
*   LABEL     (name)    Name for BETA0 bank to be stored.              *
*   PLACE     (range)   Place in main beam line where to take data.    *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca seqflag
+ca seqgroup
+ca refer
+ca status
+ca twlink
      integer idir,ikey,iln,ipos,ipr,isp,nkat

      character*(mcnam) signam
      logical           build

*---- Check for presence of main beam line.
      call lnchck('ENSSIG', error)

*---- Look for position in main beam line.
      if (.not. error) then
        lcatt = lq(lccmd-2)
        call utgpos(lcatt, lcseq, 0, ipos, error)
        if (ipos .eq. 0) ipos = 1

*---- Find SIGMA0 dictionary entry.
        if (.not. error) then
          call difind(ldkey, 'SIGMA0', ikey, lckey)
          call kwget(lckey, iln, ipr, isp, nkat)

*---- Look for a previous SIGMA0 bank.
          signam = 'SIGMA0'
          call utgnam(lccmd, 1, 1, signam)
          call difind(ldbnk, signam, idir, ltwbet)
          if (ltwbet .eq. 0) then
            build = .true.
          else
            build = iq(ltwbet+mbpr).ne.ipr .or. iq(ltwbet+mbsp).ne.isp
          endif

*---- If not BUILD, create new one and link it to directory.
          if (build) then
            call aabook(ltwbet, 'SIGM', ipr, isp, lckey, 1)
            call didefi(ldbnk, signam, ltwbet)
          endif

*---- Link to main beam line.
          call sbit1(iq(lq(lcseq-msflg)+ipos), msbet)
          iq(ltwbet-5) = ipos
        endif
      endif

      end
+dk enstyp
      subroutine enstyp(type, action, idum1, idum2, done)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Perform subroutine ACTION for all elements with type TYPE.         *
* Input:                                                               *
*   LCSEQ     /REFER/   Current beam line sequence.                    *
*   TYPE      (char)    Element type to be considered.                 *
*   ACTION    (subr)    Subroutine to be executed for each element.    *
*   IDUM1(*)  (integer) Additional argument for ACTION.                *
*   IDUM2(*)  (integer) Additional argument for ACTION.                *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,ileng,ipos,ipos1,ipos2,jbyt
      character*(mcnam) type
      integer           idum1(*), idum2(*)
      logical           done
      external          action
+ca memdum
+ca bankhead
+ca cmdgroup
+ca seqflag
+ca seqgroup
+ca message
+ca refer
+ca status
+ca datatype

      logical           eflag
      character*(mcnam) atype

      lsdir = lq(lcseq-msdir)
      lsflg = lq(lcseq-msflg)
      ipos1 = iq(lcseq+msr1)
      ipos2 = iq(lcseq+msr2)
      done = .false.

*---- Loop on sequence.
      do 10 ipos = ipos1, ipos2
        idir = iq(lsdir+ipos)
        if (jbyt(iq(lsflg+ipos),1,mcode) .eq. 1) then
          lcelm = lq(ldbnk(3)-idir)
          if (iq(lcelm+mbat+mctyp) .eq. 10 * mtnam + 1) then
            call utgnam(lcelm, 1, 1, atype)
            if (atype .eq. type) then
              call action(ipos, idum1, idum2, eflag)
              error = error .or. eflag
              done = .true.
            endif
          endif
        endif
   10 continue

*---- Test for empty range.
      if (.not. done) then
        call utleng(type, ileng)
        msg(1) = 'Element type "' // type(1:ileng)
     +  // '" not found in working range.'
        call aawarn('ENSTYP', 1, msg)
      endif

      end
+dk enuse
      subroutine enuse
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Execute USE command, i.e. expand main beam line.                   *
* Creates a beam line sequence bank and two of its dependents:         *
*   link 1:   Directory indices for line members.                      *
*   link 2:   Position types and flags.                                *
* More dependent banks may be created later.                           *
* Attributes, must be given in this order in the dictionary:           *
*   PERIOD    (line)    Beam line to be expanded.                      *
*   RANGE     (range)   Range of beam line to be used.                 *
*   SYMM      (logical) Symmetry flag.                                 *
*   SUPER     (integer) Number of superperiods.                        *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca seqgroup
+ca strgroup
+ca message
+ca refer
+ca status
+ca twlink
+ca datatype
      integer idata,idir,itype,irg1,irg2,i,ns,nprev,nlift,ikey

      character*(mcnam) linnam
      character*(mcrng) rngnam

*---- Set up the main beam line.
      ns = 0
      nprev = currseq
      nlift = 0
*     LNREFE lifts the first two dependent banks.
      if (iq(lccmd+mbat+mctyp) .ne. 10 * mtlin) then
        itype = iq(lccmd+mbat+mctyp)
        idir = iq(lccmd+mbat+mcval)
        if (idir .eq. 0  .or.  itype/10 .ne. mtlin) then
          call rdfail('ENUSE', 1, 'Invalid line reference.')
          return
        endif
        call diname(ldbnk, idir, sequnam)
        do i = 1, liftseq
          if (seqnames(i) .eq. sequnam)  ns = i
        enddo
        if (ns .eq. 0)  then
*--- not pre-existing
          if (liftseq .eq. iq(lq(lroot-mcseq)-3))  then
            call mzpush(0, lq(lroot-mcseq), liftseq, 0, 'I')
          endif
          liftseq = liftseq + 1
          currseq = liftseq
          nlift = 1
        else
          call get_active(sequnam, 'ENUSE')
          if (lcseq .ne. 0)  call lndrop(lcseq)
          currseq = ns
        endif
        call lnrefe(lccmd, 1, lcseq, lq(lroot-mcseq), -currseq)
        if (error) then
          if (nlift .ne. 0)  liftseq = liftseq - 1
          currseq = nprev
          go to 9999
        endif
        if (ns .eq. 0)  then
          msg(1) = 'New beam line expanded: ' // sequnam
        else
          msg(1) = 'Beam line re-expanded: ' // sequnam
        endif
        seqnames(currseq) = sequnam
        call enget
        call aainfo('ENUSE', 1, msg)

*---- Unlink any BETA0 bank which may exist.
        call difind(ldkey, 'BETA0', ikey, lckey)
        ltwbet = lq(lckey-1)
   10   if (ltwbet .ne. 0) then
          iq(ltwbet-5) = -99999
          ltwbet = lq(ltwbet)
          go to 10
        endif

*---- No main beam line set.
      else if (lcseq .eq. 0) then
        call aawarn('ENUSE', 1, 'No beam line specified.')
        return

*---- Old beam line kept.
      else
        call uhtoc(q(lcseq+msbn), mcwrd, linnam, mcnam)
        msg(1) = 'Old beam line kept: ' // linnam
        call aainfo('ENUSE', 1, msg)
      endif
  100 continue
*---- Find desired range.
      idata = mbat + mcsiz
      if (iq(lccmd+idata+mctyp) .eq. 10 * mtrng + 1) then
        iq(lcseq+msr1) = 1
        iq(lcseq+msr2) = iq(lq(lcseq-msdir)-1)
        lcatt = lq(lccmd-2)
        call utgrng(lcatt, lcseq, irg1, irg2, error)
        if (error) go to 9999

*---- Store range name and limits.
        call enrang(lcatt, rngnam)
        call uctoh(rngnam, iq(lcseq+msrn), mcwrd, 40)
        iq(lcseq+msr1) = irg1
        iq(lcseq+msr2) = irg2
*---- Precomputed maps become invalid.
        call lnmark('ENUSE')
      endif

*---- Symmetry flag.
      idata = idata + mcsiz
      if (iq(lccmd+idata+mctyp) .eq. 10 * mtlog + 1) then
        iq(lcseq+msym) = iq(lccmd+idata+mcval)
      endif

*---- Number of superperiods.
      idata = idata + mcsiz
      if (iq(lccmd+idata+mctyp) .eq. 10 * mtint + 1) then
        iq(lcseq+msup) = iq(lccmd+idata+mcval)
      endif

 9999 end
+dk enzzzz
+dk eraaaa
+dk eralca
      subroutine eralca(ipos, ncount, idum, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Assign alignment errors to current element.                        *
* Input:                                                               *
*   IPOS      (integer) Current position number.                       *
*   NCOUNT(2) (integer) Counter for misalignments assigned.            *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
* Modified: 7-JAN-1999, T. Raubenheimer (SLAC)                         *
*   Added LCAV (ISP #27) to physical elements that can be misaligned   *
*----------------------------------------------------------------------*
+ca aparam
      integer i,idata,idum,iflag,ileng,iocc,ipos,ipr,isp,itype,jbyt,
     +jpos,maxval,nd,nv
      double precision err,errors
      logical           eflag
      integer           ncount(2)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca seqflag
+ca seqgroup
+ca erdata
+ca message
+ca refer
+ca datatype

      parameter         (maxval = 10)

      character*(mcnam) elmnam
      dimension         errors(maxval)

*---- Test for valid pointer.
      eflag = .false.
      lcelm = lq(ldbnk(3)-iq(lsdir+ipos))
      if (lcelm .eq. 0) go to 90
      ipr = iq(lcelm+mbpr)
      iflag = jbyt(iq(lsflg+ipos), 1, mcode)

*---- Test for beginning of line.
      if (ipr .eq. mplin  .and.  iflag .eq. 2) go to 10

*---- Test for element.
      if (ipr .eq. mpelm) then
        isp = iq(lcelm+mbsp)
        go to (90, 10, 10, 90, 10, 10, 10, 10, 10, 10,
     +         10, 90, 90, 10, 10, 10, 20, 20, 20, 10,
     +         10, 90, 10, 90, 90, 10, 10, 90, 90, 90,
     +         90, 90, 90, 90, 90, 90, 90, 90, 90, 90), isp
      endif
      go to 90

*---- All magnet types, cavity, collimator, lump, line, sequence.
   10 continue
        nv = 6
      go to 50

*---- Monitor.
   20 continue
        nv = maxval

*---- Test for redefinition of errors.
   50 continue
      call diname(ldbnk, iq(lsdir+ipos), elmnam)
      iocc = jbyt(iq(lsflg+ipos), mocc1, mocc2)
      lcali = lq(lsali-ipos)
      call uzero(errors, 1, mwflt*maxval)
      if (lcali .eq. 0) then
       ncount(1) = ncount(1) + 1
      else
        if (adderr) call ucopy(q(lcali+1), errors, iq(lcali-1))
        ncount(2) = ncount(2) + 1
        call mzdrop(0, lcali, '.')
      endif

*---- Allocate space for errors.
      nd = nv * mwflt
      call mzbook(2, lcali, lsali, -ipos, 'EALI', 0, 0, nd, mreal, 0)

*---- Generate error values.
      idata = mbat
      do 80 i = 1, maxval
        itype = mod(iq(lccmd+idata+mctyp),10)
        if (itype .eq. 3) then
          lcexp = lq(lccmd-i)
          call exeval(lcexp)
        endif
        if (i .le. nv) then
          call ucopy(q(lccmd+idata+mcval), err, mwflt)
          errors(i) = errors(i) + err
        else if (itype .ne. 0) then
          call utleng(elmnam, ileng)
          write (msg, 910) elmnam(1:ileng), iocc
  910     format('Monitor errors ignored: ',a,'[',i8,'].')
          call aawarn('ERALCA', 1, msg)
        endif
        idata = idata + mcsiz
   80 continue
      call ucopy(errors, q(lcali+1), nd)

*---- Copy errors to end of line.
      if (iflag .eq. 2) then
        do 85 jpos = ipos, iq(lcseq+msr2)
          if (iq(lsdir+jpos) .eq. iq(lsdir+ipos)  .and.
     +        jbyt(iq(lsflg+ipos), 1, mcode) .eq. 3) then
            if (lq(lsali-jpos) .ne. 0) then
              call mzdrop(0, lq(lsali-jpos), ' ')
            endif
            call mzcopy(2, lcali, 2, lsali, -jpos, 'S')
          endif
  85    continue
      endif

*---- Anything else cannot be misaligned.
   90 continue

      end
+dk eralig
      subroutine eralig
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Assign misalignment errors to a set of beam elements.              *
* EALIGN command. Attributes:                                          *
*   DX        (real)    X displacement.                                *
*   DY        (real)    Y displacement.                                *
*   DS        (real)    S displacement.                                *
*   DPHI      (real)    Rotation about X axis.                         *
*   DTHETA    (real)    Rotation about Y axis.                         *
*   DPSI      (real)    Rotation about S axis.                         *
*   MREX      (real)    Monitor read error in X.                       *
*   MREY      (real)    Monitor read error in Y.                       *
*   MREDX     (real)    Monitor read error in DX.                      *
*   MREDY     (real)    Monitor read error in DY.                      *
* (*) Dimensions may be changed in the command dictionary.             *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca seqflag
+ca seqgroup
+ca strgroup
+ca erdata
+ca message
+ca range
+ca refer
+ca status
+ca datatype
      integer ipos,jbit,lines,nl

      integer           nelm(2)

*---- Check if a map module exists.
      call lnchck('EALIGN', error)
      if (error) go to 9999

*---- Lift error banks, if not already done.
      lsdir = lq(lcseq-msdir)
      lsali = lq(lcseq-msali)
      if (lsali .eq. 0) then
        nl = iq(lsdir-1)
        call mzbook(2, lsali, lcseq, -msali, 'EALI', nl, nl, 0, 2, 0)
      endif

*---- Retrieve beam line description.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Call ERALCA for setting errors.
      nelm(1) = 0
      nelm(2) = 0
      do 90 ipos = irg1, irg2
        if (jbit(iq(lsflg+ipos), mserr) .ne. 0) then
          call eralca(ipos, nelm, 0, error)
        endif
   90 continue

*---- Tell user how many error sets have been assigned.
      if (nelm(1) + nelm(2) .eq. 0) then
        call aawarn('ERALIG', 1,
     +  'No alignment errors assigned (no or empty range seen).')
      else
        newmap = .true.
        lines = 0
        if (nelm(1) .ne. 0) then
          lines = lines + 1
          write (msg(lines), 910) 'assigned to', nelm(1)
        endif
        if (nelm(2) .ne. 0) then
          lines = lines + 1
          if (adderr) then
            write (msg(lines), 910) 'added to on', nelm(2)
         else
            write (msg(lines), 910) 'replaced on', nelm(2)
          endif
        endif
        call aainfo('ERALIG', lines, msg)
      endif

  910 format('Alignment errors ',a,' ',i7,' elements and/or lines.')

 9999 end
+dk erfcca
      subroutine erfcca(ipos, ncount, idum2, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Assign field errors to current element.
* Input:
*   IPOS      (integer) Current position number.
*   NCOUNT(2) (integer) Counter for field error sets assigned.
*   IDUM2     (integer) Unused.
* Output:
*   EFLAG     (logical) Error flag.
*--- doom modification: store order and reference radius of multipoles
*----------------------------------------------------------------------*
+ca aparam
      integer ibase,ibegin,idum2,iend,ileng,inorma,inormr,iocc,iord,
     +iorder,ipos,ipr,iskewa,iskewr,isp,jbyt,jnorma,jnormr,jskewa,
     +jskewr,knorma,knormr,kskewa,kskewr,mnorma,mord,mrad,nd,
     +nord,mproc
      double precision corstr,el,err1,err2,fact,factor,flderr,radius,
     +relerr,strg
      logical           eflag, proc_flag
      integer           ncount(2)
+if doom
      integer i
+ei
+ca memdum
+ca bankhead
+ca cmdgroup
+if doom
+ca dmcommon
+ei
+ca elmgroup
+ca prcgroup
+ca seqflag
+ca erdata
+ca keyword
+ca message
+ca refer
+ca datatype

+ca maxmul
      parameter (mord = 1, mrad = 2, mnorma = 3, mproc = 87)

      character*(mcnam) elmnam
      dimension         flderr(2,0:maxmul), corstr(2)

*---- Test for valid beam element.
      eflag = .false.
      lcelm = lq(ldbnk(3)-iq(lsdir+ipos))
      if (lcelm .eq. 0) go to 9999
      ipr = iq(lcelm+mbpr)
      isp = iq(lcelm+mbsp)
      if (ipr.ne.mpelm .or. isp.le.0 .or. isp.gt.30) go to 9999
      call diname(ldbnk, iq(lsdir+ipos), elmnam)
      iocc = jbyt(iq(lsflg+ipos), mocc1, mocc2)

*---- Branch on subprocess code.
      go to (800, 100, 100, 800, 200, 250, 300, 350, 800, 800,
     +       800, 800, 800, 150, 150, 150, 800, 800, 800, 800,
     +       800, 800, 800, 800, 800, 400, 800, 800, 800, 800,
     +       800, 800, 800, 800, 800, 800, 800, 800, 800, 800), isp

*---- Bending magnets.
  100 continue
        call ucopy(q(lcelm+meangb), strg, mwflt)
        iorder = 0
        ibegin = 0
        iend = 3
      go to 700

*---- Corrector magnets.
  150 continue
        call ucopy(q(lcelm+mekick), corstr(1), mwflt)
        if (isp .eq. 15) then
          call ucopy(q(lcelm+mekick+mcsiz), corstr(2), mwflt)
        else
          corstr(2) = 0.0
        endif
        strg = sqrt(corstr(1)**2 + corstr(2)**2)
        iorder = 0
        ibegin = 0
        iend = 0
      go to 700

*---- Quadrupole.
  200 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mek1q), strg, mwflt)
        strg = strg * el
        iorder = 1
        ibegin = 1
        iend = 1
      go to 700

*---- Sextupole.
  250 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mek2s), strg, mwflt)
        strg = strg * el
        iorder = 2
        ibegin = 2
        iend = 2
      go to 700

*---- Octupole.
  300 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mek3o), strg, mwflt)
        strg = strg * el
        iorder = 3
        ibegin = 3
        iend = 3
      go to 700

*---- Multipole.
  350 continue
        iorder = 0
        proc_flag = .false.
        call utgint(lccmd, mord, mord, iorder)
        call utglog(lccmd, mproc, mproc, proc_flag)
        ibase = 2 * iorder + 3
        strg = 0.0
        call utgflt(lcelm, ibase, ibase, strg)
        ibegin = 0
        iend = maxmul
      go to 700

*---- General bend.
  400 continue
        call ucopy(q(lcelm+meangb), strg, mwflt)
        iorder = 0
        ibegin = 0
        iend = 3
      go to 700

*---- Test for redefinition of errors.
  700 continue
      call uzero(flderr, 1, 2*mwflt*(maxmul+1))
      nord = -1
      lcfld = lq(lsfld-ipos)
      if (lcfld .eq. 0) then
        ncount(1) = ncount(1) + 1
      else
        if (adderr) then
          call ucopy(q(lcfld+1), flderr, iq(lcfld-1))
          nord = (iq(lcfld-1) / (2 * mwflt)) - 1
        endif
        ncount(2) = ncount(2) + 1
        call mzdrop(0, lcfld, '.')
      endif

*---- Use of relative error requires RADIUS to be given.
      radius = 1.0
      call utgflt(lccmd, mrad, mrad, radius)
+if doom
*--- add name, order, and radius to list if not yet done
      do i = 1, nmult
        if (elmnam .eq. multname(i))  goto 701
      enddo
      if (nmult .eq. max_mult)  then
        call aawarn('ERFCCA', 1,
     +      'max. number of multipoles reached in table multname.')
        goto 701
      endif
      nmult = nmult + 1
      multname(nmult) = elmnam
      refmult(nmult) = radius
      multord(nmult) = iorder
  701 continue
+ei
*---- Calculate errors in any element.
      knorma = mnorma
      kskewa = knorma + 1 + iadim1(4)
      knormr = kskewa + 1 + iadim1(6)
      kskewr = knormr + 1 + iadim1(8)
      inorma = mbat + (knorma - 1) * mcsiz
      iskewa = mbat + (kskewa - 1) * mcsiz
      inormr = mbat + (knormr - 1) * mcsiz
      iskewr = mbat + (kskewr - 1) * mcsiz

*---- Loop over multipole components - 
      if (proc_flag)  then
*--- first all normal, then skew
      do iord = 0, maxmul

*---- Normal component.
        err1 = 0.0
        jnorma = 0
        if (iord .le. iadim1(4)) then
          jnorma = mod(iq(lccmd+inorma+mctyp),10)
          if (jnorma .ne. 0) then
            if (jnorma .eq. 3) then
              lcexp = lq(lccmd-knorma-iord)
              call exeval(lcexp)
            endif
            call ucopy(q(lccmd+inorma+mcval), err1, mwflt)
          endif
        endif
        if (jnorma .eq. 0  .and.  iord .le. iadim1(8)) then
          jnormr = mod(iq(lccmd+inormr+mctyp),10)
          if (jnormr .ne. 0) then
            if (jnormr .eq. 3) then
              lcexp = lq(lccmd-knormr-iord)
              call exeval(lcexp)
            endif
            call ucopy(q(lccmd+inormr+mcval), relerr, mwflt)
            fact = factor(iord)/factor(iorder) * radius**(iorder-iord)
            err1 = relerr * strg * fact
          endif
        endif
*---- Can the current element handle this component?
        if (err1 .ne. 0.0) then
          if (iord .lt. ibegin  .or.  iord .gt. iend) then
            call utleng(elmnam, ileng)
            write (msg, 910) iord, elmnam(1:ileng), iocc
            call aawarn('ERFCCA', 1, msg)
          else
            flderr(1,iord) = flderr(1,iord) + err1
            if (iord .gt. nord) nord = iord
          endif
        endif

*---- Next component.
        inorma = inorma + mcsiz
        iskewa = iskewa + mcsiz
        inormr = inormr + mcsiz
        iskewr = iskewr + mcsiz
      enddo

      inorma = mbat + (knorma - 1) * mcsiz
      iskewa = mbat + (kskewa - 1) * mcsiz
      inormr = mbat + (knormr - 1) * mcsiz
      iskewr = mbat + (kskewr - 1) * mcsiz

      do iord = 0, maxmul

*---- Skewed component.
        err2 = 0.0
        jskewa = 0
        if (iord .le. iadim1(6)) then
          jskewa = mod(iq(lccmd+iskewa+mctyp),10)
          if (jskewa .ne. 0) then
            if (jskewa .eq. 3) then
              lcexp = lq(lccmd-kskewa-iord)
              call exeval(lcexp)
            endif
            call ucopy(q(lccmd+iskewa+mcval), err2, mwflt)
          endif
        endif
        if (jskewa .eq. 0  .and.  iord .le. iadim1(10)) then
          jskewr = mod(iq(lccmd+iskewr+mctyp),10)
          if (jskewr .ne. 0) then
            if (jskewr .eq. 3) then
              lcexp = lq(lccmd-kskewr-iord)
              call exeval(lcexp)
            endif
            call ucopy(q(lccmd+iskewr+mcval), relerr, mwflt)
            fact = factor(iord)/factor(iorder) * radius**(iorder-iord)
            err2 = relerr * strg * fact
          endif
        endif

*---- Can the current element handle this component?
        if (err2 .ne. 0.0) then
          if (iord .lt. ibegin  .or.  iord .gt. iend) then
            call utleng(elmnam, ileng)
            write (msg, 910) iord, elmnam(1:ileng), iocc
            call aawarn('ERFCCA', 1, msg)
          else
            flderr(2,iord) = flderr(2,iord) + err2
            if (iord .gt. nord) nord = iord
          endif
        endif

*---- Next component.
        inorma = inorma + mcsiz
        iskewa = iskewa + mcsiz
        inormr = inormr + mcsiz
        iskewr = iskewr + mcsiz
      enddo
      else
*--- normal + skew alternating (previous order)
      do 790 iord = 0, maxmul

*---- Normal component.
        err1 = 0.0
        jnorma = 0
        if (iord .le. iadim1(4)) then
          jnorma = mod(iq(lccmd+inorma+mctyp),10)
          if (jnorma .ne. 0) then
            if (jnorma .eq. 3) then
              lcexp = lq(lccmd-knorma-iord)
              call exeval(lcexp)
            endif
            call ucopy(q(lccmd+inorma+mcval), err1, mwflt)
          endif
        endif
        if (jnorma .eq. 0  .and.  iord .le. iadim1(8)) then
          jnormr = mod(iq(lccmd+inormr+mctyp),10)
          if (jnormr .ne. 0) then
            if (jnormr .eq. 3) then
              lcexp = lq(lccmd-knormr-iord)
              call exeval(lcexp)
            endif
            call ucopy(q(lccmd+inormr+mcval), relerr, mwflt)
            fact = factor(iord)/factor(iorder) * radius**(iorder-iord)
            err1 = relerr * strg * fact
          endif
        endif

*---- Skewed component.
        err2 = 0.0
        jskewa = 0
        if (iord .le. iadim1(6)) then
          jskewa = mod(iq(lccmd+iskewa+mctyp),10)
          if (jskewa .ne. 0) then
            if (jskewa .eq. 3) then
              lcexp = lq(lccmd-kskewa-iord)
              call exeval(lcexp)
            endif
            call ucopy(q(lccmd+iskewa+mcval), err2, mwflt)
          endif
        endif
        if (jskewa .eq. 0  .and.  iord .le. iadim1(10)) then
          jskewr = mod(iq(lccmd+iskewr+mctyp),10)
          if (jskewr .ne. 0) then
            if (jskewr .eq. 3) then
              lcexp = lq(lccmd-kskewr-iord)
              call exeval(lcexp)
            endif
            call ucopy(q(lccmd+iskewr+mcval), relerr, mwflt)
            fact = factor(iord)/factor(iorder) * radius**(iorder-iord)
            err2 = relerr * strg * fact
          endif
        endif

*---- Can the current element handle this component?
        if (err1**2 + err2**2 .ne. 0.0) then
          if (iord .lt. ibegin  .or.  iord .gt. iend) then
            call utleng(elmnam, ileng)
            write (msg, 910) iord, elmnam(1:ileng), iocc
            call aawarn('ERFCCA', 1, msg)
          else
            flderr(1,iord) = flderr(1,iord) + err1
            flderr(2,iord) = flderr(2,iord) + err2
            if (iord .gt. nord) nord = iord
          endif
        endif

*---- Next component.
        inorma = inorma + mcsiz
        iskewa = iskewa + mcsiz
        inormr = inormr + mcsiz
        iskewr = iskewr + mcsiz
  790 continue
      endif
*---- Allocate space for errors.
      if (nord .ge. 0) then
        nd = 2 * mwflt * (nord + 1)
        call mzbook(2, lcfld, lsfld, -ipos, 'EFLD', 0, 0, nd, mreal, 0)
        call ucopy(flderr, q(lcfld+1), nd)
      else
        call utleng(elmnam, ileng)
        write (msg, 920) elmnam(1:ileng), iocc
        call aawarn('ERFCCA', 1, msg)
      endif

  800 continue

  910 format('Element cannot handle field errors of order ',i2,
     +       ': ',a,'[',i8,'].')
  920 format('Field errors for the following element are zero: ',
     +       a,'[',i8,'].')

 9999 end
+dk erfcom
      subroutine erfcom
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Assign misalignment errors to a set of beam elements or lines.     *
* EFCOMP command. Attributes:                                          *
*   ORDER     (integer) Order of base component.                       *
*   RADIUS    (real)    Radius for relative errors.                    *
*   DBLN      (defer)   Normal dipole error DKLN(0).                   *
*   DKLN(*)   (defer)   Normal multipole error.                        *
*   DBLS      (defer)   Skewed dipole errors DKLS(0).                  *
*   DKLS(*)   (defer)   Skewed multipole errors.                       *
*   DBLNR     (defer)   Relative normal dipole error DKLNR(0).         *
*   DKLNR(*)  (defer)   Relative normal multipole error.               *
*   DBLSR     (defer)   Relative skewed dipole error DKLSR(0).         *
*   DKLSR(*)  (defer)   Relative skewed multipole errors.              *
* (*) Dimensions may be changed in the command dictionary.             *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca seqflag
+ca seqgroup
+ca erdata
+ca keyword
+ca message
+ca range
+ca refer
+ca status
+ca datatype
      integer iln,inorma,inormr,iord,iorder,ipos,ipr,iskewa,iskewr,isp,
     +jbit,knorma,knormr,kskewa,kskewr,lines,mnorma,mord,nkat,nl

+ca maxmul
      parameter         (mord   = 1, mnorma = 3)
      integer           nelm(2)

*---- Check if a map module exists.
      call lnchck('EFIELD', error)
      if (error) go to 9999

*---- Get attribute dimensions from keyword.
      call kwget(lckey, iln, ipr, isp, nkat)

*---- Lift error banks, if not already done.
      lsdir = lq(lcseq-msdir)
      lsflg = lq(lcseq-msflg)
      lsfld = lq(lcseq-msfld)
      if (lsfld .eq. 0) then
        nl = iq(lsdir-1)
        call mzbook(2, lsfld, lcseq, -msfld, 'EFLD', nl, nl, 0, 2, 0)
      endif

*---- Check for conflicts between absolute and relative errors.
      knorma = mnorma
      kskewa = knorma + iadim1(4) + 1
      knormr = kskewa + iadim1(6) + 1
      kskewr = knormr + iadim1(8) + 1
      inorma = mbat + (knorma - 1) * mcsiz
      iskewa = mbat + (kskewa - 1) * mcsiz
      inormr = mbat + (knormr - 1) * mcsiz
      iskewr = mbat + (kskewr - 1) * mcsiz
      do 10 iord = 0, maxmul
        if (iord .le. iadim1(4)  .and.  iord .le. iadim1(8)) then
          if (mod(iq(lccmd+inorma+mctyp),10) .ne. 0  .and.
     +        mod(iq(lccmd+inormr+mctyp),10) .ne. 0) then
            write (msg, 910) iord
            call aawarn('ERFCOM', 2, msg)
          endif
        endif
        if (iord .le. iadim1(6)  .and.  iord .le. iadim1(10)) then
          if (mod(iq(lccmd+iskewa+mctyp),10) .ne. 0  .and.
     +        mod(iq(lccmd+iskewr+mctyp),10) .ne. 0) then
            write (msg, 910) iord
            call aawarn('ERFCOM', 2, msg)
          endif
        endif
        inorma = inorma + mcsiz
        iskewa = iskewa + mcsiz
        inormr = inormr + mcsiz
        iskewr = iskewr + mcsiz
   10 continue

*---- Check base order.
      iorder = 0
      call utgint(lccmd, mord, mord, iorder)
      if (iorder .lt. 0  .or.  iorder .gt. maxmul) then
        write (msg, 920) iorder
        call aafail('ERFCOM', 2, msg)
        return
      endif

*---- Retrieve beam line description.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Call ERFCCA for setting errors.
      nelm(1) = 0
      nelm(2) = 0
      do 90 ipos = irg1, irg2
        if (jbit(iq(lsflg+ipos), mserr) .ne. 0) then
          call erfcca(ipos, nelm, 0, error)
        endif
   90 continue

*---- Message about errors created.
      if (nelm(1) + nelm(2) .eq. 0) then
        call aawarn('ERFCOM', 1,
     +  'No field errors assigned (no or empty range seen).')
      else
        lines = 0
        if (nelm(1) .ne. 0) then
          lines = lines + 1
          write (msg(lines), 930) 'assigned to', nelm(1)
        endif
        if (nelm(2) .ne. 0) then
          lines = lines + 1
          if (adderr) then
            write (msg(lines), 930) 'added to on', nelm(2)
          else
            write (msg(lines), 930) 'replaced on', nelm(2)
          endif
        endif
        call aainfo('ERFCOM', lines, msg)
        newmap = .true.
      endif

  910 format('Both absolute and relative field error of order ',
     +       i2,' seen,'/
     +       'absolute errors will be used in case of conflict.')
  920 format('Order of basic component = ',i5,' is out of order.')
  930 format('Field errors ',a,' ',i7,' element(s).')

 9999 end
+dk erfica
      subroutine erfica(ipos, ncount, idum2, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Assign field errors to current element.                            *
* Input:                                                               *
*   IPOS      (integer) Current position number.                       *
*   NCOUNT(2) (integer) Counter for field error sets assigned.         *
*   IDUM2     (integer) Unused.                                        *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer iabs,ibase,ibegin,idum2,iend,ileng,iocc,iord,iorder,ipos,
     +ipr,irel,irot,isp,jabs,jbyt,jrel,jrot,kabs,krel,krot,mabs,mord,
     +mrad,nd,nord
      double precision ampl,amprel,angle,corstr,el,fact,factor,flderr,
     +radius,strg
      logical           eflag
      integer           ncount(2)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca prcgroup
+ca seqflag
+ca erdata
+ca keyword
+ca message
+ca refer
+ca datatype

+ca maxmul
      parameter         (mord = 1, mrad = 2, mabs = 3)

      character*(mcnam) elmnam
      dimension         corstr(2), flderr(2,0:maxmul)

*---- Test for valid beam element.
      eflag = .false.
      lcelm = lq(ldbnk(3)-iq(lsdir+ipos))
      if (lcelm .eq. 0) go to 9999
      ipr = iq(lcelm+mbpr)
      isp = iq(lcelm+mbsp)
      if (ipr.ne.mpelm .or. isp.le.0 .or. isp.gt.30) go to 9999
      call diname(ldbnk, iq(lsdir+ipos), elmnam)
      iocc = jbyt(iq(lsflg+ipos), mocc1, mocc2)

*---- Branch on subprocess code.
      go to (800, 100, 100, 800, 200, 250, 300, 350, 800, 800,
     +       800, 800, 800, 150, 150, 150, 800, 800, 800, 800,
     +       800, 800, 800, 800, 800, 400, 800, 800, 800, 800,
     +       800, 800, 800, 800, 800, 800, 800, 800, 800, 800), isp

*---- Bending magnets.
  100 continue
        call ucopy(q(lcelm+meangb), strg, mwflt)
        iorder = 0
        ibegin = 0
        iend = 3
      go to 700

*---- Corrector magnets.
  150 continue
        call ucopy(q(lcelm+mekick), corstr(1), mwflt)
        if (isp .eq. 15) then
          call ucopy(q(lcelm+mekick+mcsiz), corstr(2), mwflt)
        else
          corstr(2) = 0.0
        endif
        strg = sqrt(corstr(1)**2 + corstr(2)**2)
        iorder = 0
        ibegin = 0
        iend = 0
      go to 700

*---- Quadrupole.
  200 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mek1q), strg, mwflt)
        strg = strg * el
        iorder = 1
        ibegin = 1
        iend = 1
      go to 700

*---- Sextupole.
  250 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mek2s), strg, mwflt)
        strg = strg * el
        iorder = 2
        ibegin = 2
        iend = 2
      go to 700

*---- Octupole.
  300 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mek3o), strg, mwflt)
        strg = strg * el
        iorder = 3
        ibegin = 3
        iend = 3
      go to 700

*---- Multipole.
  350 continue
        iorder = 0
        call utgint(lccmd, mord, mord, iorder)
        ibase = 2 * iorder + 3
        strg = 0.0
        call utgflt(lcelm, ibase, ibase, strg)
        ibegin = 0
        iend = maxmul
      go to 700

*---- General bend.
  400 continue
        call ucopy(q(lcelm+meangb), strg, mwflt)
        iorder = 0
        ibegin = 0
        iend = 3
      go to 700

*---- Test for redefinition of errors.
  700 continue
      call uzero(flderr, 1, 2*mwflt*(maxmul+1))
      nord = -1
      lcfld = lq(lsfld-ipos)
      if (lcfld .eq. 0) then
        ncount(1) = ncount(1) + 1
      else
        if (adderr) then
          call ucopy(q(lcfld+1), flderr, iq(lcfld-1))
          nord = (iq(lcfld-1) / (2 * mwflt)) - 1
        endif
        ncount(2) = ncount(2) + 1
        call mzdrop(0, lcfld, '.')
      endif

*---- Get radius for relative errors.
      radius = 1.0
      call utgflt(lccmd, mrad, mrad, radius)

*---- Find bias in bank for errors.
      kabs = mabs
      krel = kabs + iadim1(4) + 1
      krot = krel + iadim1(6) + 1
      iabs = mbat + (kabs - 1) * mcsiz
      irel = mbat + (krel - 1) * mcsiz
      irot = mbat + (krot - 1) * mcsiz

*---- If absolute error present, use it.
      do 790 iord = 0, maxmul
        jabs = 0
        ampl = 0.0
        if (iord .le. iadim1(4)) then
          jabs = mod(iq(lccmd+iabs+mctyp),10)
          if (jabs .ne. 0) then
            if (jabs .eq. 3) then
              lcexp = lq(lccmd-kabs-iord)
              call exeval(lcexp)
            endif
            call ucopy(q(lccmd+iabs+mcval), ampl, mwflt)
          endif
        endif

*---- If no absolute error is present, try relative error.
        if (jabs .eq. 0  .and.  iord .le. iadim1(6)) then
          jrel = mod(iq(lccmd+irel+mctyp),10)
          if (jrel .ne. 0) then
            if (jrel .eq. 3) then
              lcexp = lq(lccmd-krel-iord)
              call exeval(lcexp)
            endif
            call ucopy(q(lccmd+irel+mcval), amprel, mwflt)
            fact = factor(iord)/factor(iorder) * radius**(iorder-iord)
            ampl = amprel * strg * fact
          endif
        endif

*---- Fetch tilt angle for this component.
        angle = 0.0
        if (iord .le. iadim1(8)) then
          jrot = mod(iq(lccmd+irot+mctyp),10)
          if (jrot .ne. 0) then
            if (jrot .eq. 3) then
              lcexp = lq(lccmd-krot-iord)
              call exeval(lcexp)
            endif
            call ucopy(q(lccmd+irot+mcval), angle, mwflt)
          endif
        endif

*---- Can the current element handle this component?
        if (ampl .ne. 0.0) then
          if (iord .lt. ibegin  .or.  iord .gt. iend) then
            call utleng(elmnam, ileng)
            write (msg, 920) iord, elmnam(1:ileng), iocc
            call aawarn('ERFICA', 1, msg)
          else
            if (iord .gt. nord) nord = iord
            angle = real(iord+1) * angle
            flderr(1,iord) = flderr(1,iord) + ampl * cos(angle)
            flderr(2,iord) = flderr(2,iord) + ampl * sin(angle)
          endif
        endif

*---- Next component.
        iabs = iabs + mcsiz
        irel = irel + mcsiz
        irot = irot + mcsiz
  790 continue

*---- Allocate space for errors.
      if (nord .ge. 0) then
        nd = 2 * mwflt * (nord + 1)
        call mzbook(2, lcfld, lsfld, -ipos, 'EFLD', 0, 0, nd, mreal, 0)
        call ucopy(flderr, q(lcfld+1), nd)
      else
        call utleng(elmnam, ileng)
        write (msg, 930) elmnam(1:ileng), iocc
        call aawarn('ERFCCA', 1, msg)
      endif

  800 continue

  920 format('Element cannot handle field errors of order ',i2,
     +       ': ',a,'[',i8,'].')
  930 format('Field errors for the following element are zero: ',
     +       a,'[',i8,'].')

 9999 end
+dk erfiel
      subroutine erfiel
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Assign misalignment errors to a set of beam elements or lines.     *
* EALIGN command. Attributes:                                          *
*   ORDER     (integer) Order of base component.                       *
*   RADIUS    (real)    Radius for relative errors.                    *
*   DBL       (defer)   Absolute dipole error.                         *
*   DKL(*)    (defer)   Relative dipole error.                         *
*   DBLR      (defer)   Absolute multipole errors.                     *
*   DKLR(*)   (defer)   Relative multipole errors.                     *
*   ROT0      (defer)   Tilt for dipole error.                         *
*   ROT(*)    (defer)   Tilt for multipole errors.                     *
* (*) Dimensions may be changed in the command dictionary.             *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca seqflag
+ca seqgroup
+ca erdata
+ca keyword
+ca message
+ca range
+ca refer
+ca status
+ca zunit
+ca datatype
      integer iabs,iln,iord,iorder,ipos,ipr,irel,isp,jbit,kabs,krel,
     +lines,mabs,mord,nkat,nl,nord

+ca maxmul
      parameter         (mord   = 1, mabs = 3)

      integer           nelm(2)

*---- Check if a map module exists.
      call lnchck('EFIELD', error)
      if (error) go to 9999

*---- Get attribute dimensions from keyword.
      call kwget(lckey, iln, ipr, isp, nkat)

*---- Test for conflicts between relative and absolute errors.
      kabs = mabs
      krel = kabs + iadim1(4) + 1
      iabs = mbat + (kabs - 1) * mcsiz
      irel = mbat + (krel - 1) * mcsiz

*---- Check for conflicts between absolute and relative errors.
      nord = min(maxmul, iadim1(4), iadim1(6))
      do 10 iord = 0, nord
        if (mod(iq(lccmd+irel+mctyp),10) .ne. 0) then
          if (mod(iq(lccmd+iabs+mctyp),10) .ne. 0) then
            write (msg, 910) iord
            call aawarn('ERFIEL', 2, msg)
          endif
        endif
        irel = irel + mcsiz
        iabs = iabs + mcsiz
   10 continue

*---- Check base order.
      iorder = 0
      call utgint(lccmd, mord, mord, iorder)
      if (iorder .lt. 0  .or.  iorder .gt. maxmul) then
        write (msg, 920) iorder
        call aafail('ERFIEL', 2, msg)
        return
      endif

*---- Lift error banks, if not already done.
      lsdir = lq(lcseq-msdir)
      lsflg = lq(lcseq-msflg)
      lsfld = lq(lcseq-msfld)
      if (lsfld .eq. 0) then
        nl = iq(lsdir-1)
        call mzbook(2, lsfld, lcseq, -msfld, 'EFLD', nl, nl, 0, 2, 0)
      endif

*---- Retrieve beam line description.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Call ERFICA for setting errors.
      nelm(1) = 0
      nelm(2) = 0
      do 90 ipos = irg1, irg2
        if (jbit(iq(lsflg+ipos), mserr) .ne. 0) then
          call erfica(ipos, nelm, 0, error)
        endif
   90 continue

*---- Message about errors created.
      if (nelm(1) + nelm(2) .eq. 0) then
        call aawarn('ERFIEL', 1,
     +  'No field errors assigned (no or empty range seen).')
      else
        newmap = .true.
        lines = 0
        if (nelm(1) .ne. 0) then
          lines = lines + 1
          write (msg(lines), 930) 'assigned to', nelm(1)
        endif
        if (nelm(2) .ne. 0) then
          lines = lines + 1
          if (adderr) then
            write (msg(lines), 930) 'added to on', nelm(2)
          else
            write (msg(lines), 930) 'replaced on', nelm(2)
          endif
        endif
        call aainfo('ERFIEL', lines, msg)
      endif

  910 format('Both absolute and relative field error of order ',
     +       i2,' seen,'/
     +       'absolute errors will be used in case of conflict.')
  920 format('Order of basic component = ',i5,' is out of order.')
  930 format('Field errors ',a,' ',i7,' element(s).')

 9999 end
+dk erlist
      subroutine erlist(ipos, iopt, idum, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print errors for one single element.                               *
* Input:                                                               *
*   LCSEQ     /REFER/   Current beam line sequence.                    *
*   IPOS      (integer) Current position in sequence.                  *
*   IOPT      (integer) Option flag: 1=Initialize, 2=Print, 3=End.     *
*   IDUM      (integer) Unused.                                        *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer idum,ienum,iflag,iocc,iopt,ipos,j,jbyt,kline,lvect,mhead,
     +nd,nline,npage
      double precision vect,zero
      logical           eflag
+ca memdum
+ca seqflag
+ca range
+ca refer
+ca zunit

+ca maxlin
+ca maxmul
      parameter         (mhead = 5)

      character         elmnam*(mcnam), title*(*)
      dimension         vect(2*maxmul+8)

      save              npage, nline

      parameter         (zero = 0.0d0)
      parameter         (title = 'Imperfections.')

*---- Initialize printing.
      eflag = .false.
      if (iopt .eq. 1) then
        call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)
        npage = 0
        nline = maxlin

*---- Print errors for one element.
      else if (iopt .eq. 2) then
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        if (lcali .ne. 0  .or.  lcfld .ne. 0) then

*---- Extract misalignment errors.
          if (lcali .eq. 0) then
            call uzero(vect, 1, 6*mwflt)
          else
            call ucopy(q(lcali+1), vect, 6*mwflt)
          endif
          lvect = 6

*---- Extract field errors.
          if (lcfld .ne. 0) then
            nd = iq(lcfld-1)
            call ucopy(q(lcfld+1), vect(7), nd)
            lvect = lvect + nd / mwflt
          endif

*---- If NLINE too big, start a new page.
          kline = (lvect + 9) / 10
          if (nline + kline .ge. maxlin) then
            npage = npage + 1
            call prhead('EPRINT', title, zero, -1, nline, npage)
            nline = nline + mhead
            write (iqpr2, 920)
            call prline(iqpr2)
          endif
          nline = nline + kline

*---- Print error vector.
          if (jbyt(iq(lsflg+ipos),1,mcode) .eq. 1) then
            write (iqpr2, 930) ienum, elmnam, iocc,
     +        (1000.0 * vect(j), j = 1, lvect)
          else if (jbyt(iq(lsflg+ipos),1,mcode) .eq. 2) then
            write (iqpr2, 940) elmnam, iocc,
     +        (1000.0 * vect(j), j = 1, lvect)
          else if (jbyt(iq(lsflg+ipos),1,mcode) .eq. 3) then
            write (iqpr2, 950) elmnam, iocc,
     +        (1000.0 * vect(j), j = 1, lvect)
          endif
        endif
      else
        nline = nline + 1
        call prline(iqpr2)
      endif

  910 format(' Imperfections.',t31,a,'line: ',a,t51,'Range: ',a,
     +       t122,'page',i6)
  920 format(' Element sequence',t23,'Displacements in [mm]',
     +       t65,'Rotations in [mrad]',t107,'Field errors in 1.0E-3'/
     +       ' pos.  element occ.',t23,'DX',t37,'DY',t51,'DS',
     +       t65,'DPHI',t79,'DTHETA',t93,'DPSI',t107,'Re(K0L)',
     +       t121,'Im(K0L)'/
     +       ' no.   name    no.',t23,'Re(K1L)',t37,'Im(K1L)',
     +       t51, 'Re(K2L)',t65, 'Im(K2L)',t79,'Re(K3L)',t93,'Im(K3L)',
     +       t107,'Re(K4L)',t121,'Im(K4L)'/t23,'Re(K5L)',t37,'Im(K5L)',
     +       t51, 'Re(K6L)',t65, 'Im(K6L)',t79,'Re(K7L)',t93,'Im(K7L)',
     +       t107,'etc.')
  930 format(' ',i5,1x,a8,i4,8g14.5:/(t20,8g14.5:))
  940 format(' begin',1x,a8,i4,8g14.5:/(t20,8g14.5:))
  950 format(' end  ',1x,a8,i4,8g14.5:/(t20,8g14.5:))

      end
+dk ermain
      subroutine ermain(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Switch routine (subprocess code) for errors section.               *
* Input:                                                               *
*   IPR       (integer) Process code.                                  *
*   ISP       (integer) Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer ipr,isp

*---- User-defined services.
      if (isp .le. 0  .or.  isp .gt. 10) then
        call usercm(ipr, isp)

*---- ISP = 1, EALIGN.
      else if (isp .eq. 1) then
        call eralig

*---- ISP = 2, EFIELD.
      else if (isp .eq. 2) then
        call erfiel

*---- ISP = 3, EOPT.
      else if (isp .eq. 3) then
        call eropt

*---- ISP = 4, EPRINT.
      else if (isp .eq. 4) then
        call erprnt

*---- ISP = 5, ESAVE.
      else if (isp .eq. 5) then
        call ersave

*---- ISP = 6, EFCOMP.
      else if (isp .eq. 6) then
        call erfcom
      endif

      end
+dk eropt
      subroutine eropt
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Set options for error definitions and applications.                *
*   EOPT command.                                                      *
* Attributes:                                                          *
*   SEED      (integer) Seed for random generator.                     *
*   ADD       (logical) Superposition flag.                            *
*----------------------------------------------------------------------*
+ca aparam
+ca erdata
+ca refer
      double precision seed

*---- SEED option.
      seed = 0.0
      call utgflt(lccmd, 1, 1, seed)
      if (seed .ne. 0.0) call init55(int(seed + 0.5))

*---- ADD option.
      call utglog(lccmd, 2, 2, adderr)

      end
+dk erprnt
      subroutine erprnt
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print currently assigned errors for a given range.                 *
*   EPRINT command.                                                    *
* Attributes, must be given in this order in the dictionary:           *
*   RANGE     (range)   Range over which to print errors.              *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca seqflag
+ca seqgroup
+ca refer
+ca status
+ca datatype
      integer ipos,ipos1,ipos2,jbit,lcrng

      logical           eflag
      external          erlist

*---- Check main beam line.
      call lnchck('EPRINT', error)
      if (.not. error) then
        lcrng = lq(lccmd-1)
        if (lcrng .ne. 0) then
          call utgrng(lcrng, lcseq, ipos1, ipos2, error)
        else
          ipos1 = iq(lcseq+msr1)
          ipos2 = iq(lcseq+msr2)
        endif

*---- Print.
        if (.not. error) then
          call erlist(0, 1, 0, eflag)
          do 10 ipos = ipos1, ipos2
            if (jbit(iq(lsflg+ipos), mserr) .ne. 0) then
              call erlist(ipos, 2, 0, eflag)
            endif
   10     continue
          call erlist(0, 3, 0, eflag)
        endif
      endif

 9999 end
+dk ersave
      subroutine ersave
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save error definitions: ESAVE command.                             *
* Attribute:                                                           *
*   FILENAME  (string)  File name to receive output.                   *
*   ALIGN     (logical) Save alignment errors.                         *
*   FIELD     (logical) Save field errors.                             *
*   ORDER     (integer) Base order for normalisation.                  *
*   RADIUS    (real)    Radius for normalisation.                      *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca seqflag
+ca seqgroup
+ca message
+ca range
+ca refer
+ca savbuf
+ca status
+ca zunit
      integer i,ibase,ibegin,iend,ienum,iflag,iocc,iord,iorder,ipos,isp,
     +j,jbit,jbyt,malign,mfield,mfile,morder,mrad,nali,nd,nfld
      double precision corstr,data,el,fact,factor,field,radius,strg

+ca maxmul
      parameter         (mfile  = 1, mfield = 2, malign = 3,
     +                   morder = 4, mrad   = 5)

      character*(mcfil) filnam
      character*(mcnam) elmnam
      logical           flag(2)
      dimension         corstr(2), data(8), field(2,0:maxmul)

*---- Check main beam line.
      call lnchck('ESAVE', error)
      if (.not. error) then

*---- Open desired file.
        filnam = 'esave'
        call utgstr(lccmd, 1, 1, filnam)
        call flopen(filnam, 'SWFD', 0, 0, isave, error)
        if (.not. error) then

*---- Get logical flags and clear counters.
          flag(1) = .false.
          flag(2) = .false.
          call utglog(lccmd, mfield, malign, flag)
          nali = 0
          nfld = 0

*---- Unpack sequence definition.
          lsdir = lq(lcseq-msdir)
          lsali = lq(lcseq-msali)
          lsfld = lq(lcseq-msfld)
          lcali = 0
          lcfld = 0

*---- Loop over beam line.
          do 900 ipos = 1, iq(lsdir-1)
            call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
            if (jbyt(iflag,1,mcode) .le. 2  .and.
     +          jbit(iq(lsflg+ipos), mserr) .ne. 0) then

*---- Write SELECT commands.
              if (flag(1) .and. lsali .ne. 0) lcali = lq(lsali-ipos)
              if (flag(2) .and. lsfld .ne. 0) lcfld = lq(lsfld-ipos)
              if (lcali .ne. 0  .or. lcfld .ne. 0) then
                write (isave, 920) elmnam, iocc
              endif

*---- Write alignment errors.
              if (lcali .ne. 0) then
                call uzero(data, 1, 8*mwflt)
                call ucopy(q(lcali+1),data,min(iq(lcali-1),8*mwflt))
                if (iq(lcali-1) .le. 6*mwflt) then
                  write (isave, 910) (data(j), j = 1, 6)
                else
                  write (isave, 910) (data(j), j = 1, 8)
                endif
                nali = nali + 1
              endif

*---- Write field error.
              if (lcfld .ne. 0) then
                nd = min(iq(lcfld-1),mwflt*(2*maxmul+2))
                call ucopy(q(lcfld+1), field, nd)

*---- Test for valid beam element.
                isp = iq(lcelm+mbsp)
                call diname(ldbnk, iq(lsdir+ipos), elmnam)
                iocc = jbyt(iq(lsflg+ipos), mocc1, mocc2)

*---- Branch on subprocess code.
        go to (900, 100, 100, 900, 200, 250, 300, 350, 900, 900,
     +         900, 900, 900, 150, 150, 150, 900, 900, 900, 900,
     +         900, 900, 900, 900, 900, 400, 900, 900, 900, 900,
     +         900, 900, 900, 900, 900, 900, 900, 900, 900, 900), isp

*---- Bending magnets.
 100            continue
                call ucopy(q(lcelm+meangb), strg, mwflt)
                iorder = 0
                ibegin = 0
                iend = 3
                go to 700

*---- Corrector magnets.
 150            continue
                call ucopy(q(lcelm+mekick), corstr(1), mwflt)
                if (isp .eq. 15) then
                  call ucopy(q(lcelm+mekick+mcsiz), corstr(2), mwflt)
                else
                  corstr(2) = 0.0
                endif
                strg = sqrt(corstr(1)**2 + corstr(2)**2)
                iorder = 0
                ibegin = 0
                iend = 0
                go to 700

*---- Quadrupole.
 200            continue
                call ucopy(q(lcelm+melen), el, mwflt)
                call ucopy(q(lcelm+mek1q), strg, mwflt)
                strg = strg * el
                iorder = 1
                ibegin = 1
                iend = 1
                go to 700

*---- Sextupole.
 250            continue
                call ucopy(q(lcelm+melen), el, mwflt)
                call ucopy(q(lcelm+mek2s), strg, mwflt)
                strg = strg * el
                iorder = 2
                ibegin = 2
                iend = 2
                go to 700

*---- Octupole.
 300            continue
                call ucopy(q(lcelm+melen), el, mwflt)
                call ucopy(q(lcelm+mek3o), strg, mwflt)
                strg = strg * el
                iorder = 3
                ibegin = 3
                iend = 3
                go to 700

*---- Multipole.
 350            continue
                iorder = 0
                call utgint(lccmd, morder, morder, iorder)
                ibase = 2 * iorder + 3
                strg = 0.0
                call utgflt(lcelm, ibase, ibase, strg)
                ibegin = 0
                iend = maxmul
                go to 700

*---- General bend.
 400            continue
                call ucopy(q(lcelm+meangb), strg, mwflt)
                iorder = 0
                ibegin = 0
                iend = 3
                go to 700

*---- Normalize the errors.
 700            continue
                call ucopy(q(lcfld+1), field, iq(lcfld-1))
                iend = min(iend, (iq(lcfld-1) / (2*mwflt)) - 1)

*---- Use of relative error requires RADIUS to be given.
                radius = 1.0
                call utgflt(lccmd, mrad, mrad, radius)

*---- Loop over multipole components.
                do 790 iord = ibegin, iend
                  fact = factor(iord) / factor(iorder) *
     +                  radius**(iorder-iord)
                  field(1,iord) = field(1,iord) / (strg * fact)
                  field(2,iord) = field(2,iord) / (strg * fact)
 790            continue

*---- Dipole component.
                write (savbuf, 925) radius, iorder
                if (ibegin .le. 0) then
                  savbuf(64:65) = ',&'
                  write (isave, 930) savbuf
                  write (savbuf, 940) field(1,0), field(2,0)
                endif

*---- Other components.
                do 800 i = max(ibegin, 1), iend
                  if (field(1,i).ne.0.0 .or. field(2,i).ne.0.0) then
                    savbuf(64:65) = ',&'
                    write (isave, 930) savbuf
                    write (savbuf, 950) i, field(1,i), i, field(2,i)
                  endif
 800            continue
                write (isave, 930) savbuf
                nfld = nfld + 1
              endif
            endif
 900      continue

*---- Completion message.
          write (isave, 960)
          call flname(isave, filnam)
          call flclos(isave, error)
          if (.not. error) then
            write (msg, 970) filnam, nali, nfld
            call aainfo('ERSAVE', 3, msg)
          endif
        endif
      endif

  910 format(1p,'EALIGN, DX =',e15.8,', DY =',e15.8,
     +       ', DS =',e15.8,',&'/
     +       '  DPHI =',e15.8,', DTHETA =',e15.8,
     +       ', DPSI =',e15.8,:,',&'/
     +       ' MREX =',e15.8,', MREY =',e15.8)
  920 format('SELECT, FLAG=ERROR, CLEAR'/
     +       'SELECT, FLAG=ERROR, RANGE = "',a,'"[',i5,']')
  925 format('EFCOMP, RADIUS = ',1p,e16.8,', ORDER =',i2)
  930 format(a80)
  940 format(5x,'DBLNR     = ',    1p,e16.8,', DBLSR     = ',    e16.8)
  950 format(5x,'DKLNR(',i2,') = ',1p,e16.8,', DKLSR(',i2,') = ',e16.8)
  960 format('SELECT, FLAG=ERROR, CLEAR'/'RETURN')
  970 format('Error definitions saved on file: ',a/
     +       i8,' misaligned elements,'/
     +       i8,' elements with field errors.')

      end
+dk erzzzz
+dk exaaaa
+dk exbin
      subroutine exbin(iopr)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Generate binary instruction on top of stack.                       *
* Input:                                                               *
*   IOPR     (integer) Operation code.                                 *
*----------------------------------------------------------------------*
+ca aparam
+ca exlink
+ca exstak
+ca express
      integer iopr

      call exoper(iopr)
      isval(level) = max(isval(level), isval(level+1))

*---- At least one operand variable: build subtract instruction.
      if (isval(level) .ne. 0) then
        nxopr = nxopr + 1
        ixopr(nxopr) = iopr
        rxval(nxopr) = 0.0

*---- Otherwise fold constants.
      else
        nxopr = nxopr - 1
        rxval(nxopr) = rsval(level)
      endif

      end
+dk excons
      subroutine excons(pval)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Generate instruction to load constant.                             *
* Input:                                                               *
*   PVAL   (real)       Value of constant.                             *
*----------------------------------------------------------------------*
+ca aparam
+ca express
+ca exstak
      double precision pval

*---- Put value to stack.
      isval(level) = 0
      rsval(level) = pval

*---- Generate fetch operation.
      nxopr = nxopr + 1
      ixopr(nxopr) = -1
      rxval(nxopr) = pval

      end
+dk excopy
      subroutine excopy(lbank, ilink, idata)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Copy expression bank to /EXPRESS/ common.                          *
*   Assumes that the expression has been evaluated beforehand.         *
* Output:                                                              *
*   LBANK(1)  (pointer) Pointer to supporting bank.                    *
*   ILINK     (integer) Attribute number.                              *
*   IDATA     (integer) Bias of value in data bank.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,idata,ilink,jop
      integer           lbank(1)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca vargroup
+ca exlink
+ca express
+ca exstak
+ca fundef
+ca refer
+ca zunit

      lexbnk = lbank(1)
      lexexp = lq(lexbnk-ilink)

*---- Load result to stack.
      level = level + 1
      call ucopy(q(lexbnk+idata), rsval(level), mwflt)

*---- No expression present.
      if (lexexp .eq. 0) then
        isval(level) = 0
        nxopr = nxopr + 1
        ixopr(nxopr) = -1
        rxval(nxopr) = rsval(level)

*---- Otherwise copy expression.
      else
        ibias = 0
        isval(level) = 1
        do 90 jop = 1, iq(lexexp-2)
          lexvar = lq(lexexp-jop)
          nxopr = nxopr + 1
          ixopr(nxopr) = iq(lexexp+ibias+mxop)
          if (ixopr(nxopr) .eq. -3) then
            call uhtoc(q(lexvar+mvbank), mcwrd, axbank(nxopr), mcnam)
            call uhtoc(q(lexvar+mvattr), mcwrd, axattr(nxopr), mcnam)
            ixsub1(nxopr) = iq(lexvar+mvind1)
            ixsub2(nxopr) = iq(lexvar+mvind2)
            ixsub3(nxopr) = iq(lexvar+mvind3)
          else if (ixopr(nxopr) .eq. -2) then
            call uhtoc(q(lexvar+mvbank), mcwrd, axbank(nxopr), mcnam)
            axattr(nxopr) = ' '
            ixsub1(nxopr) = 1
            ixsub2(nxopr) = 1
            ixsub3(nxopr) = 1
          else if (ixopr(nxopr) .eq. -1) then
            call ucopy(q(lexexp+ibias+mxval), rxval(nxopr), mwflt)
          endif
          ibias = ibias + mxsiz
   90   continue
      endif

      end
+dk exdump
      subroutine exdump(lexp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Dump expression bank.                                              *
* Output:                                                              *
*   LEXP(1)   (pointer)  Pointer to expression bank.                   *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,idata,idir,iopr,jbias,jop
      double precision rval
      integer           lexp(*)
+ca memdum
+ca bankhead
+ca expgroup
+ca vargroup
+ca exlink
+ca fundef
+ca refer
+ca zunit
      character*(mcnam) axbank, axattr

      write (iqlog, 910)
      ibias = 0
      lexexp = lexp(1)

*---- Loop over load and arithmetic operations.
      do 90 jop = 1, iq(lexexp-2)
        lexvar = lq(lexexp-jop)
        iopr = iq(lexexp+ibias+mxop)
        if (iopr .eq. -8) then
          call uhtoc(q(lexvar+1), mcwrd, axbank, mcnam)
          write (iqlog, 920) axbank
        else if (iopr .le. -5) then
          jbias = iq(lexexp+ibias+mxval)
          if (iopr .eq. -7) then
            write (iqlog, 930) 'GETTABD', jbias
          else if (iopr .eq. -6) then
            write (iqlog, 930) 'GETTABS', jbias
          else if (iopr .eq. -5) then
            write (iqlog, 930) 'GETTABI', jbias
          endif
        else if (iopr .eq. -4) then
          call uhtoc(q(lexvar+mvbank), mcwrd, axbank, mcnam)
          write (iqlog, 940) axbank, iq(lexvar+mvind1)
        else if (iopr .eq. -3) then
          call uhtoc(q(lexvar+mvbank), mcwrd, axbank, mcnam)
          call uhtoc(q(lexvar+mvattr), mcwrd, axattr, mcnam)
          write (iqlog, 950) axbank, axattr,
     +      iq(lexvar+mvind1), iq(lexvar+mvind2), iq(lexvar+mvind3)
        else if (iopr .eq. -2) then
          call uhtoc(q(lexvar+mvbank), mcwrd, axbank, mcnam)
          write (iqlog, 960) axbank, iq(lexvar+mvind1)
        else if (iopr .eq. -1) then
          call ucopy(q(lexexp+ibias+mxval), rval, mwflt)
          write (iqlog, 970) rval
        else
          write (iqlog, 980) funnam(iopr)
        endif
        ibias = ibias + mxsiz
   90 continue

*---- Store operation.
      if (ibias .lt. iq(lexexp-1)) then
        lexbnk = lq(lexexp+1)
        idata  = iq(lexexp+ibias+mxval)
        idir   = iq(lexbnk+mbnam)
        if (idir .eq. 0) then
          axbank = ' '
        else
          call diname(ldbnk, idir, axbank)
        endif
        write (iqlog, 990) axbank, idata
      endif

  910 format(' EXDUMP.')
  920 format(t11,'GETDESC',t21,a)
  930 format(t11,a,t41,'[',i5,']')
  940 format(t11,'GETSEQ',t21,a,t41,'[',i5,']')
  950 format(t11,'GETATTR',t21,a,t41,'[',a,'(',i5,',',i5,',',i5,')]')
  960 format(t11,'GETPAR',t21,a,t41,'[',i5,']')
  970 format(t11,'GETCON',t21,1pe16.8)
  980 format(t11,a)
  990 format(t11,'PUT',t21,a,t41,'[',i5,']'/' ')

      end
+dk exeval
      subroutine exeval(lexp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Evaluate one expression, propagate modification flags.             *
* Input:                                                               *
*   LEXP(1)   (pointer) Pointer to expression bank.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,idata,iopr,jbit,jop
      integer           lexp(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca vargroup
+ca markbits
+ca message
+ca exlink
+ca exstak
+ca fundef
+ca option
+ca refer

      character*(mcnam) bnknam
      logical           change

      lexexp = lexp(1)
      if (lexexp .eq. 0) then
        call aafail('EXEVAL', 1,
     +  'Internal MAD error: Missing expression.')
        go to 9999
      endif

*---- Operations.
      change = .false.
      level = 0
      ibias = 0
      do 90 jop = 1, iq(lexexp-2)
        iopr = iq(lexexp+ibias+mxop)
        lexvar = lq(lexexp-jop)
        lexbnk = lq(lexvar-1)

*---- Load constant.
        if (iopr .eq. -1) then
          level = level + 1
          call ucopy(q(lexexp+ibias+mxval), rsval(level), mwflt)

*---- Load parameter, attribute or position from sequence.
        else if (iopr .le. -2) then
          if (iopr .eq. -4) then
            idata = iq(lexvar+mvbias)
          else
            idata = mbat + mcsiz * (iq(lexvar+mvbias) - 1) + mcval
          endif
          level = level + 1
          call ucopy(q(lexbnk+idata), rsval(level), mwflt)
          if (jbit(iq(lexbnk),mxmod) .ne. 0) change = .true.

*---- Operations.
        else
          call exoper(iopr)
        endif
        ibias = ibias + mxsiz
   90 continue

*---- Store result.
      lexbnk = lq(lexexp+1)
      idata = iq(lexexp+ibias+mxval)
      call ucopy(rsval(level), q(lexbnk+idata), mwflt)
      if (change) then
        call sbit1(iq(lexbnk), mxmod)
        if (debug) then
          call diname(ldbnk, iq(lexbnk+mbnam), bnknam)
          msg(1) = 'Marking bank as modified: ' // bnknam
          call aainfo('EXEVAL', 1, msg)
        endif
      endif
      level = level - 1

*---- Dump expression and result.
      if (iexpfl .eq. 1  .or.  iexpfl .eq. 3) then
        call exdump(lexexp)
        write (msg, '(''Result = '',1P,E16.8)') rsval(1)
        call aainfo('EXEVEAL', 1, msg)
      endif
      if (iexpfl .eq. 2  .or.  iexpfl .eq. 3) then
        call dzshow('expression', 0, lexexp, 'V', 0, 0, 0, 0)
      endif

*---- Check for empty stack.
      if (level .ne. 0) then
        call aafail('EXEVAL', 1,
     +  'Internal MAD error: Invalid expression bank.')
        call exdump(lexexp)
      endif

 9999 end
+dk exevl1
      subroutine exevl1(lexp, ltab, lbuf, rval)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Evaluate one expression, propagate modification flags.             *
* Input:                                                               *
*   LEXP(1)   (pointer) Pointer to expression bank.                    *
*   LTAB(1)   (pointer) Pointer to table.                              *
*   LBUF(1)   (pointer) Pointer to table buffer.                       *
* Output:                                                              *
*   RVAL      (real)    Result value.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,iopr,ival,jbias,jform,jop
      double precision rval
      integer           lexp(1), ltab(1), lbuf(1)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca vargroup
+ca markbits
+ca message
+ca exlink
+ca exstak
+ca fundef
+ca option
+ca refer

      character*(mcnam) bnknam
      character*(mcstr) sval

      lexexp = lexp(1)
      if (lexexp .eq. 0) then
        call aafail('EXEVL1', 1,
     +  'Internal MAD error: Missing expression.')
        go to 9999
      endif

*---- Operations.
      level = 0
      ibias = 0
      do 90 jop = 1, iq(lexexp-2)
        iopr = iq(lexexp+ibias+mxop)
        lexvar = lq(lexexp-jop)

*---- Load constant.
        if (iopr .eq. -1) then
          level = level + 1
          call ucopy(q(lexexp+ibias+mxval), rsval(level), mwflt)

*---- Load value from table descriptor.
        else if (iopr .eq. -8) then
          level = level + 1
          call uhtoc(q(lexvar+1), mcwrd, bnknam, mcnam)
          call tbgdsc(ltab, bnknam, jform, ival, rval, sval)
          if (jform .eq. 2) then
            rsval(level) = ival
          else
            rsval(level) = rval
          endif

*---- Load value from table column.
        else if (iopr .le. -5) then
          level = level + 1
          jbias = iq(lexexp+ibias+mxval)
          if (iopr .eq. -7) then
            call ucopy(q(lbuf(1)+jbias+1), rsval(level), mwflt)
          else if (iopr .eq. -6) then
            rsval(level) = q(lbuf(1)+jbias+1)
          else
            rsval(level) = iq(lbuf(1)+jbias+1)
          endif

*---- Load parameter, attribute, or position from sequence.
        else if (iopr .le. -2) then
          lexbnk = lq(lexvar-1)
          if (iopr .eq. -4) then
            jbias = iq(lexvar+mvbias)
          else
            jbias = mbat + mcsiz * (iq(lexvar+mvbias) - 1) + mcval
          endif
          level = level + 1
          call ucopy(q(lexbnk+jbias), rsval(level), mwflt)

*---- Operations.
        else
          call exoper(iopr)
        endif
        ibias = ibias + mxsiz
   90 continue

*---- Check for empty stack.
      if (level .ne. 1) then
        call aafail('EXEVL1', 1,
     +  'Internal MAD error: Invalid expression.')
        call exdump(lexexp)
      endif

*---- Dump expression and result.
      if (iexpfl .eq. 1  .or.  iexpfl .eq. 3) then
        call exdump(lexexp)
        write (msg, '(''Result = '',1P,E16.8)') rsval(1)
        call aainfo('EXEVL1', 1, msg)
      endif
      if (iexpfl .eq. 2  .or.  iexpfl .eq. 3) then
        call dzshow('expression', 0, lexexp, 'V', 0, 0, 0, 0)
      endif

*---- Return result.
      rval = rsval(1)

 9999 end
+dk exfill
      subroutine exfill
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Fill in variable references.                                       *
*----------------------------------------------------------------------*

+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca strgroup
+ca vargroup
+ca message
+ca exlink
+ca keyword
+ca option
+ca refer
+ca datatype
      integer icat,idir,ikat,ikey,ileng,iln,ind1,ind2,ind3,ipr,isp,jk,
     +jleng,jvar,nkat,iaux

      character*(mcnam) atrnam, bnknam

*---- Find PARAMETER keyword.
      call difind(ldkey, 'PARAMETE', ikey, lexpar)

*---- Loop for all variable references.
      do 90 jvar = 1, iq(lq(lroot-mdvar)+1)
        lexvar = lq(lq(lroot-mdvar)-jvar)
        lexbnk = lq(lexvar-1)
        if (lexbnk .eq. 0)  then
          iaux = -1
        else
          idir = iq(lexbnk+mbnam)
          iaux = lq(ldbnk(3)-idir)
        endif
        if (lexbnk .eq. 0 .or. iaux .ne. lexbnk) then

*---- Try to find bank name.
          call uhtoc(q(lexvar+mvbank), mcwrd, bnknam, mcnam)
          call utleng(bnknam, ileng)
          call difind(ldbnk, bnknam(1:ileng), idir, lexbnk)
          lq(lexvar-1) = lexbnk

*---- Parameter bank: Create with zero value, if not existent.
          if (iq(lexvar+mvseen) .eq. 1) then
            if (lexbnk .eq. 0) then
              call kwget(lexpar, iln, ipr, isp, nkat)
              call aabook(lexbnk, bnknam, ipr, isp, lexpar, 1)
              iq(lexbnk+mbln) = 0
              iq(lexbnk+mbat+mctyp) = 10 * mtflt + 1
              call didefi(ldbnk, bnknam, lexbnk)
              lq(lexvar-1) = lexbnk
              iq(lexvar+mvbias) = 1

*---- Check legal use of parameter.
            else if (iq(lexbnk+mbpr) .eq. mppar) then
              iq(lexvar+mvbias) = 1
            else if (iq(lexbnk+mbpr) .eq. mplin  .and.
     +               iq(lexbnk+mbsp) .eq. 2) then
              iq(lexvar+mvbias) = iq(lexvar+mvind1)
            else
              write (msg, 910) bnknam(1:ileng)
              call aafail('EXFILL', 1, msg)
              go to 9999
            endif

*---- Data bank: Must be known.
          else if (iq(lexvar+mvseen) .eq. 2) then
            if (lexbnk .eq. 0) then
              write (msg, 920) bnknam
              call aafail('EXFILL', 1, msg)

*---- Find attribute.
            else
              ind1 = iq(lexvar+mvind1)
              ind2 = iq(lexvar+mvind2)
              ind3 = iq(lexvar+mvind3)
              call kwget(lq(lexbnk+1), iln, ipr, isp, nkat)
              call uhtoc(q(lexvar+mvattr), mcwrd, atrnam, mcnam)
              call utleng(atrnam, jleng)
              call utlook(atrnam(1:jleng), katnam, nkat, ikat)
              if (ikat .eq. 0) then
                write (msg, 930) bnknam(1:ileng), atrnam(1:jleng)
                call aafail('EXFILL', 1, msg)
              else if (iatype(ikat) .ne. mtflt) then
                write (msg, 940) bnknam(1:ileng), atrnam(1:jleng)
                call aafail('EXFILL', 1, msg)
              else if (ind1 .gt. iadim1(ikat)  .or.
     +                 ind2 .gt. iadim2(ikat)  .or.
     +                 ind3 .gt. iadim3(ikat)) then
                write (msg, 950)
     +          bnknam(1:ileng), atrnam(1:jleng), ind1, ind2, ind3
                call aafail('EXFILL', 1, msg)
              else

*---- Compute position number in bank.
                icat = 0
                do 10 jk = 1, ikat
                  icat = icat + iadim1(jk) * iadim2(jk) * iadim3(jk)
   10           continue
                iq(lexvar+mvbias) = icat + (ind1 - iadim1(ikat)) +
     +            (ind2 - iadim2(ikat)) * iadim1(ikat) +
     +            (ind3 - iadim3(ikat)) * iadim1(ikat) * iadim2(ikat)
              endif
            endif
          endif
        endif
   90 continue

*---- VERIFY option: Check if all parameters are defined.
      if (verify) then
        lexbnk = lq(lexpar-1)
  100   if (lexbnk .ne. 0) then
          if (iq(lexbnk+mbln) .eq. 0) then
            idir = iq(lexbnk+mbnam)
            call diname(ldbnk, idir, bnknam)
            call utleng(bnknam, ileng)
            write (msg, 960) bnknam(1:ileng)
            call aawarn('EXFILL', 1, msg)
          endif
          lexbnk = lq(lexbnk)
          go to 100
        endif
      endif

  910 format('Expression refers to name "',a,'" --- not a parameter.')
  920 format('Expression refers to name "',a,'" --- unable to find it.')
  930 format('Expression refers to attribute "',a,'[',a,
     +       ']" --- unable to find it.')
  940 format('Expression refers to attribute "',a,'[',a,
     +       '" --- not of real type.')
  950 format('Expression refers to attribute "',a,'[',a,'(',i5,',',i5,
     +       ',',i5,')]" --- index out of range.')
  960 format('VERIFY option found undefined parameter: "',a,/
     +       '" --- value set to zero.')

 9999 end
+dk exhalf
      subroutine exfact(fact)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Generate instruction to apply factor to stack.                     *
*----------------------------------------------------------------------*
+ca aparam
+ca exlink
+ca exstak
+ca express
      double precision fact

      rsval(level) = rsval(level) * fact
      if (isval(level) .ne. 0) then
        nxopr = nxopr + 1
        ixopr(nxopr) = -1
        rxval(nxopr) = fact
        nxopr = nxopr + 1
        ixopr(nxopr) = 3
        rxval(nxopr) = 0.0
      else
        rxval(nxopr) = rsval(level)
      endif

      end
+dk exinit
      subroutine exinit
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initialize expression handler.                                     *
*----------------------------------------------------------------------*
+ca aparam
+ca exlink
+ca fundef
      integer iexflg

      data iexflg       / 0 /

*---- Local links.
      if (iexflg .eq. 0) then
        call mzlink(0, '/EXLINK/', lexbnk, lexbnk, lexvar)
        iexflg = 1
      endif

*---- Precedences for load and store operations.
      ipre  (-8) = 4
      ipre  (-7) = 4
      ipre  (-6) = 4
      ipre  (-5) = 4
      ipre  (-4) = 4
      ipre  (-3) = 4
      ipre  (-2) = 4
      ipre  (-1) = 4
      ipre  ( 0) = 0

*---- Binary operators.
      funnam( 1) = '+'
      ipre  ( 1) = 1
      ifun  ( 1) = 1
      narg  ( 1) = 2
      funnam( 2) = '-'
      ipre  ( 2) = 1
      ifun  ( 2) = 1
      narg  ( 2) = 2
      funnam( 3) = '*'
      ipre  ( 3) = 2
      ifun  ( 3) = 1
      narg  ( 3) = 2
      funnam( 4) = '/'
      ipre  ( 4) = 2
      ifun  ( 4) = 1
      narg  ( 4) = 2
      funnam( 5) = '^'
      ipre  ( 5) = 3
      ifun  ( 5) = 1
      narg  ( 5) = 2

*---- Unary operators.
      funnam( 6) = '+'
      ipre  ( 6) = 2
      ifun  ( 6) = 1
      narg  ( 6) = 1
      funnam( 7) = '-'
      ipre  ( 7) = 2
      ifun  ( 7) = 1
      narg  ( 7) = 1

*---- Mathematical functions.
      funnam( 8) = 'SQRT'
      ipre  ( 8) = 4
      ifun  ( 8) = 2
      narg  ( 8) = 1
      funnam( 9) = 'LOG'
      ipre  ( 9) = 4
      ifun  ( 9) = 2
      narg  ( 9) = 1
      funnam(10) = 'EXP'
      ipre  (10) = 4
      ifun  (10) = 2
      narg  (10) = 1
      funnam(11) = 'SIN'
      ipre  (11) = 4
      ifun  (11) = 2
      narg  (11) = 1
      funnam(12) = 'COS'
      ipre  (12) = 4
      ifun  (12) = 2
      narg  (12) = 1
      funnam(13) = 'ABS'
      ipre  (13) = 4
      ifun  (13) = 2
      narg  (13) = 1
      funnam(14) = 'TAN'
      ipre  (14) = 4
      ifun  (14) = 2
      narg  (14) = 1
      funnam(15) = 'ASIN'
      ipre  (15) = 4
      ifun  (15) = 2
      narg  (15) = 1
      funnam(16) = 'ACOS'
      ipre  (16) = 4
      ifun  (16) = 2
      narg  (16) = 1
      funnam(17) = 'ATAN'
      ipre  (17) = 4
      ifun  (17) = 2
      narg  (17) = 1
      funnam(18) = 'ATAN2'
      ipre  (18) = 4
      ifun  (18) = 2
      narg  (18) = 2
      funnam(19) = 'MAX'
      ipre  (19) = 4
      ifun  (19) = 2
      narg  (19) = 2
      funnam(20) = 'MIN'
      ipre  (20) = 4
      ifun  (20) = 2
      narg  (20) = 2

*---- Random generators.
      funnam(21) = 'RANF'
      ipre  (21) = 4
      ifun  (21) = 3
      narg  (21) = 0
      funnam(22) = 'GAUSS'
      ipre  (22) = 4
      ifun  (22) = 3
      narg  (22) = 0
      funnam(23) = 'USER0'
      ipre  (23) = 4
      ifun  (23) = 3
      narg  (23) = 0
      funnam(24) = 'TGAUSS'
      ipre  (24) = 4
      ifun  (24) = 3
      narg  (24) = 1
      funnam(25) = 'USER1'
      ipre  (25) = 4
      ifun  (25) = 3
      narg  (25) = 1
      funnam(26) = 'USER2'
      ipre  (26) = 4
      ifun  (26) = 3
      narg  (26) = 2

      end
+dk exlkex
      subroutine exlkex
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Link a complete expression to the expression table.                *
* Input:                                                               *
*   LCEXP     /REFER/   Expression bank.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca strgroup
+ca refer
      integer jlink,ltemp,mxadd

      parameter         (mxadd = 100)

*---- Expression must exist.
      if (lcexp .ne. 0) then

*---- If directory is full, increase its size.
        if (iq(lq(lroot-mdexp)+1) .ge. iq(lq(lroot-mdexp)-3)) then
          ltemp = lq(lroot-mdexp)
          call mzpush(0, ltemp, mxadd, 0, 'I')
        endif

*---- Put link to directory.
        iq(lq(lroot-mdexp)+1) = iq(lq(lroot-mdexp)+1) + 1
        lq(lq(lroot-mdexp)-iq(lq(lroot-mdexp)+1)) = lcexp

*---- Link variable references within expression.
        do 90 jlink = 1, iq(lcexp-3)
          lcvar = lq(lcexp-jlink)
          if (lcvar .ne. 0) call exlkvr
   90   continue
      endif

      end
+dk exlkvr
      subroutine exlkvr
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Link a variable reference to the variable table.                   *
* Input:                                                               *
*   LCVAR     /REFER/   Variable reference bank.                       *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca strgroup
+ca refer
      integer ltemp,mxadd

      parameter         (mxadd = 100)

*---- Expression must exist.
      if (lcvar .ne. 0) then

*---- If directory is full, increase its size.
        if (iq(lq(lroot-mdvar)+1) .ge. iq(lq(lroot-mdvar)-3)) then
          ltemp = lq(lroot-mdvar)
          call mzpush(0, ltemp, mxadd, 0, 'I')
        endif

*---- Put link to directory.
        iq(lq(lroot-mdvar)+1) = iq(lq(lroot-mdvar)+1) + 1
        lq(lq(lroot-mdvar)-iq(lq(lroot-mdvar)+1)) = lcvar
      endif

      end
+dk exload
      subroutine exload(label, attrib, lbank, ilink, idata)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Generate instruction to half load real value to stack.             *
* Input:                                                               *
*   LABEL     (char)    Label of bank to be accessed.                  *
*   LBANK(1)  (pointer) Pointer to bank to be accessed.                *
*   ILINK     (integer) Number of attribute to be loaded.              *
*   IDATA     (integer) Bias of data word in bank.                     *
*----------------------------------------------------------------------*
+ca aparam
      integer idata,ilink
      character*(*)     label, attrib
      integer           lbank(1)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca exlink
+ca exstak
+ca express

      level = level + 1
      call ucopy(q(lbank(1)+idata), rsval(level), mwflt)
      nxopr = nxopr + 1
      if (lq(lbank(1)-ilink) .eq. 0) then
        isval(level)  = 0
        ixopr(nxopr)  = -1
        rxval(nxopr)  = rsval(level)
      else
        isval(level)  = 1
        if (attrib .eq. ' ') then
          ixopr(nxopr)  = -4
          ixsub1(nxopr) = idata
        else
          ixopr(nxopr)  = -3
          ixsub1(nxopr) = 1
        endif
        ixsub2(nxopr) = 1
        ixsub3(nxopr) = 1
        rxval(nxopr)  = 0.0
        axbank(nxopr) = label
        axattr(nxopr) = attrib
      endif

      end
+dk exmake
      subroutine exmake(lbank, ilink, idata, rval, iexpr)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Generate bank for expression.                                      *
* Input:                                                               *
*   LBANK(1) (pointer)  Data bank pointer.                             *
*   ILINK    (integer)  Bias for expression bank pointer.              *
*   IDATA    (integer)  Bias for data storage.                         *
*   RVAL     (real)     Value, if constant expression.                 *
*   IEXPR    (integer)  Expression flag returned by EXREAD.            *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,idata,iexpr,ilink,jx,nd,nl
      double precision rval
      integer           lbank(*)
+ca memdum
+ca cmdgroup
+ca expgroup
+ca vargroup
+ca markbits
+ca exlink
+ca express
+ca option
+ca refer
+ca datatype

*---- Initial operations.
      lexbnk = lbank(1)
      lcexp = lq(lexbnk-ilink)
      if (lcexp .ne. 0) call aadrop(lcexp)
      call ucopy(rval, q(lexbnk+idata), mwflt)

*---- Book expression bank.
      if (iexpr .ge. 2) then
        nl = nxopr
        nd = (nxopr + 1) * mxsiz
        call mzbook(2, lcexp, lbank, -ilink, 'EXPR', nl, nl, nd, 7, 0)

*---- Mark deferred expression.
        if (iexpr .eq. 3) call sbit1(iq(lcexp), mxdef)

*---- Fill in operations.
        ibias = 0
        do 90 jx = 1, nxopr

*---- Bank format and operation code.
          iq(lcexp+ibias+mxf1) = 16 * 1 + 2
          iq(lcexp+ibias+mxop) = ixopr(jx)
          iq(lcexp+ibias+mxf2) = 16 * mwflt + mreal

*---- Load variable: Lift variable reference bank (linked in EXLKEX).
          if (ixopr(jx) .le. -2) then
            call mzbook(2, lcvar, lcexp, -jx, 'VREF', 1, 0, mvsiz, 7, 0)

*---- Fill in variable reference bank.
            iq(lcvar+mvf1) = 16 * 2 * mwnam + 5
            call uctoh(axbank(jx), iq(lcvar+mvbank), mcwrd, mcnam)
            call uctoh(axattr(jx), iq(lcvar+mvattr), mcwrd, mcnam)
            iq(lcvar+mvf2) = 16 * 6 + 2
            if (ixopr(jx) .eq. -3) then
              iq(lcvar+mvseen) = 2
            else
              iq(lcvar+mvseen) = 1
            endif
            iq(lcvar+mvind1) = ixsub1(jx)
            iq(lcvar+mvind2) = ixsub2(jx)
            iq(lcvar+mvind3) = ixsub3(jx)

*---- Load constant: Store constant value.
          else if (ixopr(jx) .eq. -1) then
            call ucopy(rxval(jx), q(lcexp+ibias+mxval), mwflt)
          endif
          ibias = ibias + mxsiz
   90   continue

*---- Append store operation.
        iq(lcexp+ibias+mxf1) = 16 * 1 + 2
        iq(lcexp+ibias+mxop) = 0
        iq(lcexp+ibias+mxf2) = 16 * mwflt + 2
        iq(lcexp+ibias+mxval) = idata

*---- Link to expression table.
        call exlkex

*---- Dump expression.
        if (iexpfl .eq. 1  .or.  iexpfl .eq. 3) then
          call exdump(lcexp)
        endif
        if (iexpfl .eq. 2  .or.  iexpfl .eq. 3) then
          call dzshow('expression', 0, lcexp, 'V', 0, 0, 0, 0)
        endif
      endif

      end
+dk exmak1
      subroutine exmak1(ltab, lbnk, ilink)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Generate bank for table column expression.                         *
*   Constant or deferred expression is not permitted.                  *
* Input:                                                               *
*   LTAB(1)  (pointer)  Pointer to table being listed.                 *
*   LBNK(1)  (pointer)  Supporting bank for expression bank.           *
*   ILINK    (integer)  Supporting link in bank LBNK (like MZBOOK).    *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,icat,idir,ikat,ileng,ilink,iln,ind1,ind2,ind3,ipr,
     +isp,jbias,jform,jk,jleng,jx,nd,nkat,nl
      integer           ltab(1), lbnk(1)

+ca memdum
+ca bankhead
+ca expgroup
+ca prcgroup
+ca vargroup
+ca message
+ca exlink
+ca express
+ca keyword
+ca option
+ca refer
+ca datatype

*---- Build expression bank. No space reserved for store operation.
      lexbnk = lbnk(1)
      nl = nxopr
      nd = nxopr * mxsiz
      call mzbook(2, lexexp, lexbnk, ilink, 'EXPR', nl, nl, nd, 7, 0)

*---- Fill in operations.
      ibias = 0
      do 90 jx = 1, nxopr

*---- Bank format and operation code.
        iq(lexexp+ibias+mxf1) = 16 * 1 + 2
        iq(lexexp+ibias+mxop) = ixopr(jx)
        iq(lexexp+ibias+mxf2) = 16 * mwflt + 2

*---- Load constant: Store constant value.
        if (ixopr(jx) .eq. -1) then
          iq(lexexp+ibias+mxf2) = 16 * mwflt + mreal
          call ucopy(rxval(jx), q(lexexp+ibias+mxval), mwflt)

*---- Load variable.
        else if (ixopr(jx) .le. -2) then

*---- Look up variable in table columns.
          if (ixopr(jx) .eq. -2) then
            call tbcol(ltab, axbank(jx), jform, jbias)
            if (jform .ge. 2  .and.  jform .le. 4) then
              ixopr(jx) = - (jform + 3)

*---- Look up variable in table descriptors.
            else
              call tbqdsc(ltab, axbank(jx), jform)
              if (jform .ge. 2  .and.  jform .le. 4) then
                ixopr(jx) = -8
              endif
            endif
            iq(lexexp+ibias+mxop) = ixopr(jx)
          endif

*---- Load variable from table descriptor.
          if (ixopr(jx) .eq. -8) then
            call mzbook(2,lexvar,lexexp,-jx,'GTBD',0,0,mwnam,5,0)
            call uctoh(axbank(jx), iq(lexvar+1), mcwrd, mcnam)

*---- Load variable from table column.
          else if (ixopr(jx) .le. -5) then
            iq(lexexp+ibias+mxval) = jbias

*---- Book variable reference bank and fill in.
          else
            call mzbook(2,lexvar,lexexp,-jx,'VREF',1,0,mvsiz,7,0)
            iq(lexvar+mvf1) = 16 * 2 * mwnam + 5
            call uctoh(axbank(jx), iq(lexvar+mvbank), mcwrd, mcnam)
            call uctoh(axattr(jx), iq(lexvar+mvattr), mcwrd, mcnam)
            iq(lexvar+mvf2) = 16 * 6 + 2
            iq(lexvar+mvind1) = ixsub1(jx)
            iq(lexvar+mvind2) = ixsub2(jx)
            iq(lexvar+mvind3) = ixsub3(jx)

*---- Find bank referred to.
            call utleng(axbank(jx), ileng)
            call utleng(axattr(jx), jleng)
            call difind(ldbnk, axbank(jx)(1:ileng), idir, lexbnk)
            lq(lexvar-1) = lexbnk
            if (lexbnk .eq. 0) then
              write (msg, 910) axbank(jx)(1:ileng)
              call aafail('EXMAK1', 1, msg)

*---- Parameter: Check.
            else
              if (ixopr(jx) .eq. -2) then
                if (iq(lexbnk+mbpr) .ne. mppar) then
                  write (msg, 920) axbank(jx)(1:ileng)
                  call aafail('EXMAK1', 1, msg)
                else
                  iq(lexvar+mvbias) = 1
                  iq(lexvar+mvseen) = 1
                endif

*---- Bank attribute: Fill in bias.
              else
                call kwget(lq(lexbnk+1), iln, ipr, isp, nkat)
                call utleng(axattr(jx), ileng)
                call utlook(axattr(jx)(1:ileng), katnam, nkat, ikat)
                ind1 = ixsub1(jx)
                ind2 = ixsub2(jx)
                ind3 = ixsub3(jx)
                if (ikat .eq. 0) then
                  write (msg, 930) axbank(jx)(1:ileng),
     +              axattr(jx)(1:jleng)
                  call aafail('EXMAK1', 1, msg)
                else if (iatype(ikat) .ne. mtflt) then
                  write (msg, 940) axbank(jx)(1:ileng),
     +              axattr(jx)(1:jleng)
                  call aafail('EXMAK1', 1, msg)
                else if (ind1 .gt. iadim1(ikat)  .or.
     +                   ind2 .gt. iadim2(ikat)  .or.
     +                   ind3 .gt. iadim3(ikat)) then
                  write (msg, 950) axbank(jx)(1:ileng),
     +              axattr(jx)(1:jleng), ind1, ind2, ind3
                  call aafail('EXMAK1', 1, msg)
                else
                  icat = 0
                  do 10 jk = 1, ikat
                    icat = icat + iadim1(jk) * iadim2(jk) * iadim3(jk)
   10             continue
                  iq(lexvar+mvbias) = icat + (ind1 - iadim1(ikat)) +
     +              (ind2 - iadim2(ikat)) * iadim1(ikat) +
     +              (ind3 - iadim3(ikat)) * iadim1(ikat) * iadim2(ikat)
                  iq(lexvar+mvseen) = 2
                endif
              endif
            endif
          endif
        endif
        ibias = ibias + mxsiz
   90 continue

*---- Dump expression.
      if (iexpfl .eq. 1  .or.  iexpfl .eq. 3) then
        call exdump(lexexp)
      endif
      if (iexpfl .eq. 2  .or.  iexpfl .eq. 3) then
        call dzshow('expression', 0, lexexp, 'V', 0, 0, 0, 0)
      endif

  910 format('Expression refers to name "',a,'" --- unable to find.')
  920 format('Expression refers to name "',a,'" --- not a parameter.')
  930 format('Expression refers to attribute "',a,'[',a,
     +       '] --- unable to find.')
  940 format('Expression refers to attribute "',a,'[',a,
     +       '] --- not of real type.')
  950 format('Expression refers to aAttribute "',a,'[',a,'(',i5,',',i5,
     +       ',',i5,')] --- index out of range.')

      end
+dk exoper
      subroutine exoper(iopr)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Perform one operation in parameter evaluation.                     *
* Input:                                                               *
*   IOPR     (integer)  Operation type code.                           *
*----------------------------------------------------------------------*
+ca aparam
+ca message
+ca exstak
      integer iopr,iy,lbadtp,nbadtp,nint
      double precision dum1,dum2,frndm,user0,user1,user2,x,y

      data   lbadtp, nbadtp      / 50, 0 /

*---- Select operation.
      go to ( 10,  20,  30,  40,  50,  60,  70,  80,  90, 100,
     +       110, 120, 130, 140, 150, 160, 170, 180, 190, 200,
     +       210, 220, 230, 240, 250, 260), iopr

*---- Invalid operation.
      if (nbadtp .le. lbadtp) then
        call aafail('EXOPER', 1, 'Unknown operation code.')
        nbadtp = nbadtp + 1
        go to 9999
      else
        call zfatam(' Too many bad operations in EXOPER.')
      endif

*==== Operators.
*---- Addition.
   10 continue
        level = level - 1
        rsval(level) = rsval(level) + rsval(level+1)
      go to 9999

*---- Subtraction.
   20 continue
        level = level - 1
        rsval(level) = rsval(level) - rsval(level+1)
      go to 9999

*---- Multiplication.
   30 continue
        level = level - 1
        rsval(level) = rsval(level) * rsval(level+1)
      go to 9999

*---- Division.
   40 continue
        level = level - 1
        if (rsval(level+1) .eq. 0.) then
          write (msg, 920) 'Division by zero'
          call aawarn('EXOPER', 1, msg)
          rsval(level) = 0.
        else
          rsval(level) = rsval(level) / rsval(level+1)
        endif
      go to 9999

*---- Power.
   50 continue
        level = level - 1
        x = rsval(level)
        y = rsval(level+1)
        if (y .eq. 0.) then
          rsval(level) = 1.
        else if (x .gt. 0.) then
          rsval(level) = exp(log(x) * y)
        else if (x .eq. 0.) then
          if (y .ge. 0.) then
            rsval(level) = 0.
          else
            write (msg, 920) 'Negative power of zero'
            call aawarn('EXOPER', 1, msg)
            rsval(level) = 0.
          endif
        else
          iy = nint(y)
          if (abs(y-iy) .lt. 1.e-15) then
            rsval(level) = x**iy
          else
            write (msg, 920) 'Fractional power of negative number'
            call aawarn('EXOPER', 1, msg)
            rsval(level) = 0.
          endif
        endif
      go to 9999

*---- Unary plus.
   60 continue
      go to 9999

*---- Unary minus.
   70 continue
        rsval(level) = - rsval(level)
      go to 9999

*==== Mathematical functions.
*---- Square root.
   80 continue
        if (rsval(level) .lt. 0.) then
          write (msg, 920) 'Square root of negative number'
          call aawarn('EXOPER', 1, msg)
          rsval(level) = 0.
        else
          rsval(level) = sqrt(rsval(level))
        endif
      go to 9999

*---- Logarithm.
   90 continue
        if (rsval(level) .le. 0.) then
          write (msg, 920) 'Logarithm of non-positive number'
          call aawarn('EXOPER', 1, msg)
          rsval(level) = 0.
        else
          rsval(level) = log(rsval(level))
        endif
      go to 9999

*---- Exponential.
  100 continue
        rsval(level) = exp(rsval(level))
      go to 9999

*---- Sine.
  110 continue
        rsval(level) = sin(rsval(level))
      go to 9999

*---- Cosine.
  120 continue
        rsval(level) = cos(rsval(level))
      go to 9999

*---- Absolute value.
  130 continue
        rsval(level) = abs(rsval(level))
      go to 9999

*---- Tangent.
  140 continue
        rsval(level) = tan(rsval(level))
      go to 9999

*---- Arc sine.
  150 continue
        if (abs(rsval(level)) .gt. 1.0) then
          write (msg, 920) 'Arcsine(x) with |x| > 1'
          call aawarn('EXOPER', 1, msg)
          rsval(level) = 0.
        else
          rsval(level) = asin(rsval(level))
        endif
      go to 9999

*---- Arc cosine.
  160 continue
        if (abs(rsval(level)) .gt. 1.0) then
          write (msg, 920) 'Arccosine(x) with |X| > 1'
          call aawarn('EXOPER', 1, msg)
          rsval(level) = 0.
        else
          rsval(level) = acos(rsval(level))
        endif
      go to 9999

*---- Arc tangent (one argument).
  170 continue
        rsval(level) = atan(rsval(level))
      go to 9999

*---- Arc tangent (2 arguments).
  180 continue
        level = level - 1
        if (rsval(level) .eq. 0.  .and.  rsval(level+1) .eq. 0.) then
          write (msg, 920) 'Arctangent(0/0)'
          call aawarn('EXOPER', 1, msg)
          rsval(level) = 0.
        else
          rsval(level) = atan2(rsval(level), rsval(level+1))
        endif
      go to 9999

*---- Maximum.
  190 continue
        level = level - 1
        rsval(level) = max(rsval(level), rsval(level+1))
      go to 9999

*---- Minimum.
  200 continue
        level = level - 1
        rsval(level) = min(rsval(level), rsval(level+1))
      go to 9999

*==== Random generators.
*---- Random number, uniformly distributed in 0..1.
  210 continue
        level = level + 1
        rsval(level) = frndm()
      go to 9999

*---- Random number, Gaussian distribution with unit sigma.
  220 continue
        level = level + 1
        call grndm(dum1, dum2)
        rsval(level) = dum1
      go to 9999

*---- Random number, user defined, no arguments.
  230 continue
        level = level + 1
        rsval(level) = user0()
      go to 9999

*---- Random number, Gaussian with unit sigma,
*     Truncated at 'argument'.
  240 continue
  245   call grndm(dum1, dum2)
        if (abs(dum1) .le. abs(rsval(level))) then
          rsval(level) = dum1
        else
          go to 245
        endif
      go to 9999

*---- Random number, user defined, one argument.
  250 continue
        rsval(level) = user1(rsval(level))
      go to 9999

*---- Random number, user defined, two arguments.
  260 continue
        level = level - 1
        rsval(level) = user2(rsval(level), rsval(level+1))
      go to 9999

  920 format(a,' encountered --- Result set to zero.')

 9999 end
+dk exordr
      subroutine exordr
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Order the chained expressions for evaluation in correct order.     *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca expgroup
+ca strgroup
+ca vargroup
+ca markbits
+ca exlink
+ca zunit
+ca datatype
      integer ibias,iopr,jbit,jdef,jexp,jop,nexp

      logical           known

*---- Clear markers for defined expressions.
      nexp = iq(lq(lroot-mdexp)+1)
      do 10 jexp = 1, nexp
        lexexp = lq(lq(lroot-mdexp)-jexp)
        call sbit0(iq(lexexp), mxord)
   10 continue

*==== Reorder expression directory.
      do 90 jdef = 1, nexp

*---- Try to find another expression which can be evaluated.
        do 80 jexp = jdef, nexp
          lexexp = lq(lq(lroot-mdexp)-jexp)

*---- Expression should not be deferred.
          known = jbit(iq(lexexp),mxdef) .eq. 0
          if (known) then

*---- All operands should be defined previously.
            ibias = 0
            do 50 jop = 1, iq(lexexp-2)
              iopr = iq(lexexp+ibias+mxop)

*---- Fetch operation: Get variable reference bank.
              if (iopr .eq. -3  .or.  iopr .eq. -2) then
                lexvar = lq(lexexp-jop)

*---- Data bank containing operand
                lexbnk = lq(lexvar-1)
                if (lexbnk .ne. 0) then

*---- Is there an expression bank?
                  lexsub = lq(lexbnk-iq(lexvar+mvbias))
                  if (lexsub .ne. 0) then

*---- Defined ordinary expression?
                    if (jbit(iq(lexsub),mxord) .eq. 0) then
                      known = .false.
                      go to 60
                    endif
                  endif
                else
                  known = .false.
                  go to 60
                endif
              endif
              ibias = ibias + mxsiz
   50       continue
   60       continue
          endif

*---- Exchange this expression with current expression.
          if (known) then
            lq(lq(lroot-mdexp)-jexp) = lq(lq(lroot-mdexp)-jdef)
            lq(lq(lroot-mdexp)-jdef) = lexexp
            call sbit1(iq(lexexp), mxord)
            go to 90
          endif
   80   continue

*---- No expression found, quit ordering pass.
        go to 100
   90 continue
      jdef = nexp

*==== End of ordering pass.
*     Last expression to be evaluated.
  100 continue
      iq(lq(lroot-mdexp)+2) = jdef

*---- Is everything defined?
      do 190 jexp = jdef + 1, nexp
        lexexp = lq(lq(lroot-mdexp)-jexp)

*---- If deferred expression, check that operands are defined.
        if (jbit(iq(lexexp),mxdef) .ne. 0) then
          known = .true.
          ibias = 0
          do 150 jop = 1, iq(lexexp-2)
            iopr = iq(lexexp+ibias+mxop)

*---- Fetch operation: Get variable reference bank.
            if (iopr .eq. -3  .or.  iopr .eq. -2) then
              lexvar = lq(lexexp-jop)

*---- Data bank containing operand.
              lexbnk = lq(lexvar-1)
              if (lexbnk .ne. 0) then

*---- Is there an expression bank?
                lexsub = lq(lexbnk-iq(lexvar+mvbias))
                if (lexsub .ne. 0) then

*---- Defined ordinary expression?
                  if (jbit(iq(lexsub),mxord) .eq. 0) then
                    known = .false.
                    go to 160
                  endif
                endif
              else
                known = .false.
                go to 160
              endif
            endif
            ibias = ibias + mxsiz
  150     continue
  160     continue

*---- Ordinary expression could not be defined.
        else
          known = .false.
        endif

*---- Message, if not known.
        if (.not. known) then
          call aafail('EXORDR', 1,
     +    'Unable to define expression (maybe circular definitions?):')
          call exdump(lexexp)
        endif
  190 continue

      end
+dk exread
      subroutine exread(ieval, rval, iseen)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode parameter expression.                                       *
* Input:                                                               *
*   IEVAL    (integer)  Evaluation flag:                               *
*                       1: Constant, 2: Normal, 3: Deferred.           *
* Output:                                                              *
*   RVAL     (real)     Value, if constant expression.                 *
*   ISEEN    (integer)  Result flag:                                   *
*                       0: Error,                                      *
*                       1: Constant,                                   *
*                       2: Normal expression                           *
*                       3: Deferred expression.                        *
*----------------------------------------------------------------------*
+ca aparam
+ca message
+ca chcode
+ca express
+ca exstak
+ca fundef
+ca stbuff
+ca zunit
      integer ichar,ieval,ileng,iseen,jfun,leng
      double precision pval,rval

      character*(mcnam) bnknam
      logical           eflag

      iseen = 0
      eflag = .false.

*---- Initialize stack.
      nxopr = 0
      level = 1
      isopr(1) = 100
      isval(1) = 0
      rsval(1) = 0.

*---- Expression. Left parenthesis?
      if (token(jtok) .eq. '(') then
        jtok = jtok + 1
        level = level + 1
        isopr(level) = 101
      endif

*---- Unary "+" or "-"?
  100 continue
      if (token(jtok) .eq. '+') then
        jtok = jtok + 1
      else if (token(jtok) .eq. '-') then
        jtok = jtok + 1
        level = level + 1
        isopr(level) = 7
      endif

*---- Factor or term.
  200 continue

*---- Expression in parentheses?
      if (token(jtok) .eq. '(') then
        jtok = jtok + 1
        level = level + 1
        isopr(level) = 101
        go to 100

*---- Function or parameter name?
      else if (ichtyp(ichar(token(jtok))) .eq. 10  .or.
     +         token(jtok) .eq. ''''  .or.  token(jtok) .eq. '"') then
        call rdword(bnknam, leng)

*---- Function?
        if (token(jtok) .eq. '(') then
          call utlook(bnknam(1:leng), funnam, nfun, jfun)
          if (jfun .gt. 0) then
            jtok = jtok + 1

*---- Function without arguments.
            if (narg(jfun) .eq. 0) then
              if (token(jtok) .eq. ')') then
                jtok = jtok + 1
                level = level + 1
                isopr(level) = jfun
                call exunst(ieval)
              else
                call rdfail('EXREAD', 1, 'Invalid expression.')
                go to 800
              endif

*---- Function with one or more arguments.
            else
              level = level + 1
              isopr(level) = jfun
              level = level + 1
              isopr(level) = 100 + narg(jfun)
              go to 100
            endif
          else
            call utleng(bnknam, ileng)
            msg(1) = 'Unknown function"' // bnknam(1:ileng) // '".'
            call rdfail('EXREAD', 1, msg)
            go to 800
          endif

*---- Reference to bank attribute, parameter, or constant.
        else
          call exrefe(ieval, bnknam, eflag)
          if (eflag) go to 800
        endif

*---- Numeric value?
      else if (ichtyp(ichar(token(jtok))) .le. 9  .or.
     +         token(jtok) .eq. '.') then
        call rdnumb(pval, eflag)
        if (eflag) go to 800
        call excons(pval)

*---- Anything else is error.
      else
        call rdfail('EXREAD', 1, 'Invalid operand.')
        go to 800
      endif

*---- Unstack function calls.
  300 continue
      if (isopr(level) .lt. 100  .and.  ifun(isopr(level)) .gt. 1) then
        call exunst(ieval)
        go to 300
      endif

*---- Unstack power operator.
      if (isopr(level) .eq. 5) then
        call exunst(ieval)
      endif

*---- Test for power operator.
      if (token(jtok) .eq. '^') then
        jtok = jtok + 1
        level = level + 1
        isopr(level) = 5
        go to 200
      endif

*---- Unstack unary operators.
      if (isopr(level) .lt. 100  .and.  narg(isopr(level)) .eq. 1) then
        call exunst(ieval)
        go to 300
      endif

*---- Unstack multiply operators.
      if (isopr(level) .eq. 3 .or. isopr(level) .eq. 4) then
        call exunst(ieval)
      endif

*---- Test for multiply operators.
      if (token(jtok) .eq. '*') then
        jtok = jtok + 1
        level = level + 1
        isopr(level) = 3
        go to 200
      else if (token(jtok) .eq. '/') then
        jtok = jtok + 1
        level = level + 1
        isopr(level) = 4
        go to 200
      endif

*---- Unstack adding operators.
      if (isopr(level) .eq. 1 .or. isopr(level) .eq. 2) then
        call exunst(ieval)
      endif

*---- Test for adding operators.
      if (token(jtok) .eq. '+') then
        jtok = jtok + 1
        level = level + 1
        isopr(level) = 1
        go to 200
      else if (token(jtok) .eq. '-') then
        jtok = jtok + 1
        level = level + 1
        isopr(level) = 2
        go to 200
      endif

*---- Unstack comma.
      if (isopr(level) .gt. 101  .and.  token(jtok) .eq. ',') then
        jtok = jtok + 1
        isopr(level) = isopr(level) - 1
        isval(level-2) = isval(level)
        rsval(level-2) = rsval(level)
        go to 100

*---- Unstack parenthesis.
      else if (isopr(level) .eq. 101  .and.  token(jtok) .eq. ')') then
        jtok = jtok + 1
        level = level - 1
        isval(level) = isval(level+1)
        rsval(level) = rsval(level+1)
        go to 300
      else if (isopr(level) .ne. 100) then
        call rdfail('EXREAD', 1, 'Invalid expression.')
        go to 800
      endif

*---- If constant expression, return value.
      if (isval(1) .eq. 0) then
        rval = rsval(1)
        iseen = 1

*---- Otherwise build expression bank.
      else
        rval = 0.

*---- Normal expression.
        if (isval(1) .lt. 3) then
          iseen = 2

*---- Deferred expression.
        else
          iseen = 3
        endif
      endif
      go to 9999

*---- Error exit --- assume zero value.
  800 continue
      iseen = 0
      rval = 0.

 9999 end
+dk exrefe
      subroutine exrefe(ieval, bnknam, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Generate parameter operation for fetching value.                   *
* Input:                                                               *
*   IEVAL    (integer)  Evaluation flag:                               *
*                       1: Constant, 2: Normal, 3: Deferred.           *
*   BNKNAM   (char)     Data bank name.                                *
* Output:                                                              *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ieval,index1,index2,index3,iocode,ipar,leng
      character*(mcnam) bnknam
      logical           eflag
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca exlink
+ca express
+ca exstak
+ca refer
+ca stbuff
+ca zunit

      character*(mcnam) atrnam

*---- Initialize.
      eflag = .false.
      index1 = 1
      index2 = 1
      index3 = 1

*---- Parameter or constant.
      if (token(jtok) .ne. '[') then
        call difind(ldbnk, bnknam, ipar, lexbnk)

*---- Constant value: Generate constant load.
        if (lexbnk .ne. 0  .and.  iq(lexbnk+mbpr) .eq. mppar  .and.
     +      iq(lexbnk+mbsp) .eq. 1) then
          nxopr = nxopr + 1
          ixopr(nxopr) = - 1
          call ucopy(q(lexbnk+mbat+mcval), rxval(nxopr), mwflt)
          isval(level) = 0
          rsval(level) = rxval(nxopr)
          go to 9999
        endif

*---- Generate parameter load.
        atrnam = ' '
        iocode = - 2

*---- Bank attribute: finish decoding and generate attribute load.
      else
        jtok = jtok + 1
        call rdword(atrnam, leng)
        if (leng .eq. 0) then
          call rdfail('EXREFE', 1, 'Attribute name expected.')
          eflag = .true.
          go to 9999
        endif

*---- Possible subscript list.
        call dcindx(index1, index2, index3, eflag)
        if (eflag) go to 9999

*---- Closing bracket.
        if (token(jtok) .ne. ']') then
          call rdfail('EXREFE', 1, 'Closing bracket "]" missing.')
          eflag = .true.
          go to 9999
        endif
        jtok = jtok + 1

*---- Generate bank attribute load.
        iocode = - 3
      endif

*---- Error, if variable occurs in constant expression.
      if (ieval .eq. 1) then
        call rdfail('EXREFE', 1, 'Variable in constant expression.')
        eflag = .true.
        go to 9999
      endif
      nxopr = nxopr + 1
      ixopr(nxopr) = iocode
      ixsub1(nxopr) = index1
      ixsub2(nxopr) = index2
      ixsub3(nxopr) = index3
      rxval(nxopr) = 0.
      axbank(nxopr) = bnknam
      axattr(nxopr) = atrnam
      isval(level) = 1
      rsval(level) = 0.

 9999 end
+dk exstrg
      subroutine exstrg(name, ltab, lbnk, ilink, rval, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode expression stored in a string.                              *
* Input:                                                               *
*   NAME      (name)    Table column or string name.                   *
*   LTAB(1)   (pointer) Pointer to table header bank.                  *
*   LBNK(1)   (pointer) Supporting bank for expression.                *
*   ILINK     (integer) Supporting link for expression (see MZBOOK).   *
* Output:                                                              *
*   RVAL      (real)    Value returned for constant expression.        *
*   EFLAG     (logical) .TRUE. if error (NAME not found)               *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,icat1,icat2,ichar,idata,idir,iform,ikat,ileng,ilink,
     +iln,ipr,iseen,isp,ival,j,nkat
      double precision rval
      character*(mcnam) name
      integer           ltab(1), lbnk(1)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca chcode
+ca keyword
+ca refer
+ca stbuff

      character*(mcstr) string(3)
      character*(mcnam) sval
      logical           eflag

*---- First test: table column name.
      eflag = .true.
      string(1) = name
      string(2) = ' '
      string(3) = name
      call utleng(name, ileng)
      if (ileng .gt. 0) then
        call tbcol(ltab, name(1:ileng), iform, ibias)
        if (iform .ge. 2  .and.  iform .le. 4) then
          eflag = .false.

*---- Second test: descriptor name.
        else
          call tbqdsc(ltab, name(1:ileng), iform)
          if (iform .ge. 2  .and.  iform .le. 4) then
            eflag = .false.

*---- Third test: expression stored in global string.
          else
            call difind(ldbnk, name(1:ileng), idir, lcsrc)
            if (lcsrc .ne. 0  .and.
     +        iq(lcsrc+mbpr) .eq. mpstr  .and.
     +        iq(lcsrc+mbsp) .eq. 1) then
              call utgstr(lcsrc, 1, 3, string)
              ileng = iq(lcsrc+mbat+mcval)
              eflag = .false.

*---- Fourth test: expression restricted to specific table.
            else
              call tbgdsc(ltab, 'TYPE', iform, ival, rval, sval)
              if (iform .eq. 5) then
                call difind(ldbnk, 'T_' // sval, idir, lcsrc)
                if (lcsrc .ne. 0  .and.
     +            iq(lcsrc+mbpr) .eq. mpstr  .and.
     +            iq(lcsrc+mbsp) .ne. 1) then
                  call kwget(lq(lcsrc+1), iln, ipr, isp, nkat)
                  call utlook(name(1:ileng), katnam, nkat, ikat)
                  if (ikat .ne. 0) then
                    icat1 = 3 * ikat - 2
                    icat2 = 3 * ikat
                    call utgstr(lcsrc, icat1, icat2, string)
                    idata = mbat + 3 * mcsiz * (ikat - 1) + mcval
                    ileng = iq(lcsrc+idata)
                    eflag = .false.
                  endif
                endif
              endif
            endif
          endif
        endif
      endif

*---- Test for valid use.
      if (eflag) then
        call aawarn('EXSTRG', 1, 'Name "' // name(1:ileng) //
     +              '" is not table column or string.')

*---- Remove blanks and pack to statement buffer.
      else
        ntok = 0
        do 10 j = 1, ileng
          if (string(1)(j:j) .ne. ' ') then
            ntok = ntok + 1
            token(ntok) = ch2upp(ichar(string(1)(j:j)))
          endif
   10   continue

*---- Append semicolon.
        if (ntok .gt. 0) then
          jtok = 1
          ntok = ntok + 1
          token(ntok) = ';'

*---- Decode expression and store in /EXPRESS/.
          call exread(2, rval, iseen)

*---- Store constant value or build expression bank.
          if (iseen .eq. 2) then
            call exmak1(ltab, lbnk, ilink)
          endif
        endif
      endif

      end
+dk exunst
      subroutine exunst(ieval)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Unstack parameter operation with any number of operands.           *
* Input:                                                               *
*   IEVAL    (integer)  Evaluation flag:                               *
*                       1: Constant, 2: Normal, 3: Deferred.           *
*----------------------------------------------------------------------*
+ca aparam
+ca message
+ca exstak
+ca express
+ca fundef
      integer ieval,ileng,isw,itype,j

*---- Get operation code.
      itype = isopr(level)

*---- Is any operand not a constant?
      do 10 j = 1, narg(itype)
        if (isval(level-j+1) .ne. 0) go to 100
   10 continue

*---- All operands are constant: Test for random function.
      if (ifun(itype) .eq. 3) then
        if (ieval .eq. 3) go to 100
        call utleng(funnam(itype), ileng)
        if (ieval .eq. 1) then
          msg(1) = 'Random function "' // funnam(itype)(1:ileng)
     +    // '" evaluated immediately in constant expression.'
          call rdwarn('EXUNST', 1, msg)
        else if (ieval .eq. 2) then
          msg(1) = 'Random function "' // funnam(itype)(1:ileng)
     +    // '" evaluated immediately in non-deferred expression.'
          call rdwarn('EXUNST', 1, msg)
        endif
      endif

*---- Reduce constant expression.
      call exoper(itype)
*     Discard operand fetches and construct fetch for result.
      nxopr = nxopr - narg(itype) + 1
      ixopr(nxopr) = - 1
      rxval(nxopr) = rsval(level)
*     Correct stack pointer and move result to place.
      level = level - 2 + narg(itype)
      rsval(level) = rxval(nxopr)
      isval(level) = 0
      go to 9999

*---- Operands not constant, or deferred random function.
  100 continue
*     Unstack operator.
      level = level - 1
*     Determine type of result.
      isw = ifun(itype)
      do 110 j = 1, narg(itype)
        isw = max(isw, isval(level+j-1))
  110 continue
      isval(level) = isw
*     Generate operation.
      nxopr = nxopr + 1
      ixopr(nxopr) = itype

 9999 end
+dk exupdt
      subroutine exupdt
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Walk through expressions directory.                                *
*   Evaluate all defined ordinary expressions.                         *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca markbits
+ca refer
+ca strgroup
      integer jbit,jexp,nexp

      nexp = iq(lq(lroot-mdexp)+2)
      do 90 jexp = 1, nexp
        lcexp = lq(lq(lroot-mdexp)-jexp)
        if (jbit(iq(lcexp),mxdef) .eq. 0) call exeval(lcexp)
   90 continue

      end
+dk exzzzz
+dk flaaaa
+dk flassi
      subroutine flassi
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*    Re-assign I/O streams, ASSIGN command.                            *
* Attributes:                                                          *
*    DATA     (string)  File name or TERM.                             *
*    ECHO     (string)  File name or TERM.                             *
*    PRINT    (string)  File name or TERM.                             *
*----------------------------------------------------------------------*
+ca aparam
+ca message
+ca refer
+ca status
+ca zunit
      integer iunit

      character*(mcfil) filnam, strnam(3)

*---- Fetch data.
      strnam(1) = ' '
      strnam(2) = ' '
      strnam(3) = ' '
      call utgstr(lccmd, 1, 3, strnam)

*---- DATA stream.
      if (strnam(1) .ne. ' ') then
        call flopen(strnam(1), 'SRFD', 0, 0, iunit, error)
        if (.not. error  .and.  iqread .ne. iunit) then
          call flname(iunit, filnam)
          msg(1) = 'Now reading file: ' // filnam
          call aainfo('FLASSI', 1, msg)
          iqread = iunit
        endif
      endif

*---- ECHO stream.
      if (strnam(2) .ne. ' ') then
        if (iqlog .gt. 20) then
          call flname(iqlog, filnam)
          call aainfo('FLASSI', 1, 'Closing ECHO file: ' // filnam)
          call flclos(iqlog, error)
        endif
        if (strnam(2)(1:4) .eq. 'TERM') then
          call aainfo('FLASSI', 1,
     +      'ECHO stream rerouted to standard output.')
          iqlog = iqtype
          call aainfo('FLASSI', 1,
     +      'ECHO stream rerouted to standard output.')
        else
          call flopen(strnam(2), 'SWFD', 0, 0, iunit, error)
          if (.not. error  .and.  iqlog .ne. iunit) then
            call flname(iunit, filnam)
            msg(1) = 'ECHO stream rerouted to file: ' // filnam
            call aainfo('FLASSI', 1, msg)
            iqlog = iunit
            call aainfo('FLASSI', 1, msg)
          endif
        endif
        iqprnt = iqlog
      endif

*---- PRINT stream.
      if (strnam(3) .ne. ' ') then
        if (iqpr2 .gt. 20) then
          call flname(iqpr2, filnam)
          call aainfo('FLASSI', 1, 'Closing PRINT file: ' // filnam)
          call flclos(iqpr2, error)
        endif
        if (strnam(3)(1:4) .eq. 'TERM') then
          call aainfo('FLASSI', 1,
     +      'PRINT stream rerouted to standard output.')
          iqpr2 = iqtype
        else
          call flopen(strnam(3), 'SWFD', 0, 0, iunit, error)
          if (.not. error  .and.  iqpr2 .ne. iunit) then
            call flname(iunit, filnam)
            msg(1) = 'PRINT stream rerouted to file: ' // filnam
            call aainfo('FLASSI', 1, msg)
            iqpr2 = iunit
          endif
        endif
      endif

      end
+dk flcall
      subroutine flcall(iflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   CALL and RETURN commands.                                          *
* Input:                                                               *
*   IFLAG     (integer) Case distinction: 1 = CALL, 2 = RETURN.        *
*----------------------------------------------------------------------*
+ca aparam
+ca message
+ca lnbuff
+ca option
+ca refer
+ca status
+ca zunit
      integer icall,iflag,level,lines,maxcal

      parameter         (maxcal = 10)
      integer           ifilst(maxcal), ilinst(maxcal)
      real              time1(maxcal), time2
      save              ifilst, ilinst, level, time1
      character*(mcfil) filnam
      logical           intrac

      data level        / 0 /

*---- Input line should be empty.
      if (jtext .lt. ntext) then
        call aawarn('FLCALL', 1,
     +  'Text after CALL or RETURN command skipped.')
        jtext = ntext
      endif

*---- Distinguish CALL/RETURN.
      if (iflag .eq. 1) then

*---- Test for CALL stack overflow.
        if (level .ge. maxcal) then
          write (msg, 910) maxcal
  910     format('CALL''s cannot be nested more than ',i2,
     +           ' levels deep --- CALL ignored.')
          call aafail('FLCALL', 1, msg)

*---- Open call file.
        else
          filnam = 'call'
          call utgstr(lccmd, 1, 1, filnam)

*---- Call to terminal input.
          if (filnam(1:4) .eq. 'TERM') then
            if (iqread .eq. iqttin) then
              call rdwarn('FLCALL', 1,
     +        'Already reading standard input --- CALL ignored.')
            else if (inter) then
              level = level + 1
              ifilst(level) = iqread
              ilinst(level) = lintxt
              call timex(time1(level))
              iqread = iqttin
              lintxt = 0
              call aainfo('FLCALL', 1, 'Now reading standard input.')
              prompt = intrac()
            else
              call rdwarn('FLCALL', 1,
     +        'Not running interactively --- cannot CALL terminal.')
            endif

*---- Stack old input file and switch to new one.
          else
            call flopen(filnam, 'SRFD', 0, 0, icall, error)
            if (.not. error) then
              level = level + 1
              ifilst(level) = iqread
              ilinst(level) = lintxt
              call timex(time1(level))
              iqread = icall
              lintxt = 0
              call flname(icall, filnam)
              msg(1) = 'Now reading file: ' // filnam
              call aainfo('FLCALL', 1, msg)
              prompt = .false.
            endif
          endif
        endif

*---- Perform RETURN command.
      else

*---- In case of CALL stack underflow, perform STOP.
        if (level .le. 0) then
          call aawarn('FLCALL', 1,
     +    'RETURN on main input file --- Replaced by STOP.')
          call zend
          stop

*---- Close call file and switch to previous input file.
        else
          if (iqread .ne. iqttin) call flclos(iqread, error)
          iqread = ifilst(level)
          lintxt = ilinst(level)
          call flname(iqread, filnam)
          if (trace) then
            lines = 2
            call timex(time2)
            write (msg, 930) time2 - time1(level)
  930       format(f12.3,' seconds used to read file.')
          else
            lines = 1
          endif
          msg(lines) = 'Now reading file: ' // filnam
          call aainfo('FLCALL', lines, msg)
          level = level - 1

*---- If new input file is terminal, turn off scanning mode.
          if (level .eq. 0) then
            prompt = intrac()
            if (scan  .and.  inter  .and.  iqread .eq. iqttin) then
              call aainfo('FLCALL', 1, 'Leaving scanning mode.')
              scan = .false.
            endif
          endif
        endif
      endif

      end
+dk flclos
      subroutine flclos(iunit, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Close I/O stream.                                                  *
* Input:                                                               *
*   IUNIT     (integer) Logical unit number.                           *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ierr,iunit
      logical           eflag
+ca message
+ca fltable

*---- Check stream number in range.
      eflag = .false.
      if (iunit .le. 0  .or.  iunit .gt. maxfil) then
        write (msg, 910) iunit
        call aawarn('FLCLOS', 1, msg)

*---- File should be open.
      else if (iost(iunit) .eq. 0) then
        write (msg, 920) iunit, iofn(iunit)
        call aawarn('FLCLOS', 2, msg)

*---- Default stream must not be closed.
      else if (iunit .le. maxdef) then
        write (msg, 930) iunit, iofn(iunit)
        call aawarn('FLCLOS', 2, msg)

*---- If all OK, close file.
      else if (iost(iunit) .gt. 0) then
        ierr = 0
        close (unit = iunit, status = 'KEEP', iostat = ierr)

*---- Test for error.
        if (ierr .ne. 0) then
          write (msg, 940) iunit, ierr, iofn(iunit)
          call aafail('FLCLOS', 2, msg)
          eflag = .true.

*---- Record inactive state.
        else
          iost(iunit) = 0
          iodr (iunit) = ' '
        endif
      endif

  910 format('Unable to close stream number ',i3,
     +       ' --- number out of range.')
  920 format('Stream number ',i3,' already closed,'/
     +       'file name: ',a)
  930 format('Stream number ',i3,' cannot be closed,'/
     +       'file name: ',a)
  940 format('Unable to close stream number ',i3,', code = ',i3,','/
     +       'file name: ',a)

      end
+dk flcsys
      subroutine flcsys
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Execute operating system command (if possible for current O/S).    *
*   SYSTEM command.                                                    *
* Attribute:                                                           *
*   COMMAND   (string)  System command in string form.                 *
*----------------------------------------------------------------------*
+ca aparam
+ca refer

      character*(mcstr) string
      integer           systemf

      call utgstr(lccmd, 1, 1, string)
      if (systemf(string) .eq. 0) then
        call aainfo('FLCSYS', 1, 'System call completed.')
      else
        call aawarn('FLCSYS', 1, 'System call failed.')
      endif

      end
+dk fldele
      subroutine fldele(iunit, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Delete I/O file.                                                   *
* Input:                                                               *
*   IUNIT     (integer) Logical unit number.                           *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ierr,iunit
      logical           eflag
+ca message
+ca fltable
+ca zunit

*---- Check stream number in range.
      eflag = .false.
      if (iunit .le. 0  .or.  iunit .gt. maxfil) then
        write (msg, 910) iunit
        call aawarn('FLDELE', 1, msg)

*---- File must not be deleted already.
      else if (iost(iunit) .lt. 0) then
        write (msg, 920) iunit
        call aawarn('FLDELE', 2, msg)

*---- Default stream must not be deleted.
      else if (iunit .le. maxdef) then
        write (msg, 930) iunit, iofn(iunit)
        call aawarn('FLDELE', 2, msg)

*--- If all OK, delete file.
      else

*---- If file is closed, reopen it.
        ierr = 0
        if (iost(iunit) .eq. 0) then
          open (unit = iunit, file = iofn(iunit), status = 'UNKNOWN',
     +          iostat = ierr)
        endif

*---- If open successful, close and delete.
        if (ierr .eq. 0) then
          close (unit = iunit, status = 'DELETE', iostat = ierr)
        endif

*---- Test for error.
        if (ierr .ne. 0) then
          write (msg, 950) iunit, ierr, iofn(iunit)
          call aafail('FLDELE', 2, msg)
          eflag = .true.

*---- Delete file from table.
        else
          msg(1) = 'File deleted: ' // iofn(iunit)
          call aainfo('FLDELE', 1, msg)
          iost(iunit) = - 1
          iodr (iunit) = ' '
        endif
      endif

  910 format('Unable to delete stream number ',i3,
     +       ', number out of range.')
  920 format('Stream number ',i3,' already deleted,'/
     +       'file name: ',a)
  930 format('Stream number ',i3,' cannot be deleted,'/
     +       'file name: ',a)
  950 format('Unable to delete stream number ',i3,', code = ',i3/
     +       'file name: ',a)

      end
+dk fldump
      subroutine fldump
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Write memory dump file (to be reloaded with FLLOAD).               *
*   POOLDUMP command.                                                  *
* Attribute:                                                           *
*   FILENAME  (string)  File name for dump.                            *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca coesti
+ca header
+ca message
+ca quest
+ca refer
+ca status
+ca strgroup
+if doom
+ca dmcommon
+ei
      integer iunit,mfintg,mfname,mfreal,msize
      parameter         (mfname = 1,
     +                   mfreal = mfname + mwnam + 1,
     +                   mfintg = mfreal + 16 * mwflt + 1,
     +                   msize = mfintg + 3 + 1)
      character*(mcfil) filnam, strnam

*---- Name of POOLDUMP file to be written.
      strnam = 'pooldump'
      call utgstr(lccmd, 1, 1, strnam)

*---- Get an index for pooldump file.
      call flopen(strnam, 'SWUD', 0, 0, iunit, error)
      if (.not. error) then
*--- add floating format check, version number,
*    closed orbit estimate, and closed orbit fit tolerance
        q(lroot+2) = 100.
        call uctoh(nvers, iq(lroot+3), mcwrd, 8)
        call ucopy(coest, q(lroot+5), 7 * mwflt)
*---- Write pooldump file.
        call flname(iunit, filnam)
        call fzfile(iunit, 0, 'IOR')
        call fzout(iunit, 2, lroot, 1, '.', 2, 0, 0)
        if (iquest(1) .ne. 0) then
          msg(1) = 'Unable to write stream: ' // strnam
          msg(2) = 'File name: ' // filnam
          call aafail('FLDUMP', 2, msg)
        else
          call fzendo(iunit, 'T')
          call flclos(iunit, error)

*---- Success.
          if (.not. error) then
            msg(1) = 'Memory dump written on stream: ' // strnam
            msg(2) = 'File name: ' // filnam
            call aainfo('FLDUMP', 2, msg)
+if doom
*--- suppress DOOM update
            noupdate = .true.
+ei
          endif
        endif
      endif

      end
+dk flend
      subroutine flend
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Close all I/O streams and discard temporary files.                 *
*----------------------------------------------------------------------*
+ca aparam
+ca fltable
+ca status
      integer iunit

*---- Loop for user-defined files.
      do 90 iunit = maxdef + 1, maxfil

*---- If scratch file and still in table, delete it.
        if (iolc(iunit) .eq. 'S' .and. iost(iunit) .ge. 0) then
          call fldele(iunit, error)

*---- If normal disk file and open, close it.
        else if (iolc(iunit).eq.'D' .and. iost(iunit).gt.0) then
          call flclos(iunit, error)
        endif
   90 continue

      end
+dk flinit
      subroutine flinit
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initialize I/O system: Clear I/O unit table.                       *
*----------------------------------------------------------------------*
+ca aparam
+ca fltable
+ca zunit
      integer i

      do 90 i = 1, maxfil
        iofn(i) = ' '
        iost(i) = - 1
   90 continue

*---- Standard I/O streams.
      iqttin = 5
      iqtype = 6
      iofn(iqttin) = 'standard input'
      iofn(iqtype) = 'standard output'
      iost(iqttin) = 1
      iost(iqtype) = 1

      end
+dk flload
      subroutine flload
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Read memory dump file (as written by FLDUMP).                      *
*   POOLLOAD command.                                                  *
* Attribute:                                                           *
*   FILENAME  (string)  File name for load.                            *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca coesti
+ca header
+ca strgroup
+ca message
+ca quest
+ca refer
+ca status
+ca zunit
      integer iunit,mfintg,mfname,mfreal

      parameter         (mfname = 1,
     +                   mfreal = mfname + mwnam + 1,
     +                   mfintg = mfreal + 16 * mwflt + 1)
      character*(mcfil) filnam, strnam
      character * 8      tmpc

*---- Name of POOLDUMP file to be read.
      strnam = 'pooldump'
      call utgstr(lccmd, 1, 1, strnam)

*---- Get an index for pooldump file.
      call flopen(strnam, 'SRUD', 0, 0, iunit, error)
      if (.not. error) then
        call flname(iunit, filnam)
        call mzwipe(2)
        call fzfile(iunit, 0, 'IOR')
        call fzin(iunit, 2, lroot, 1, '.', 0, 0)
        if (iquest(1) .ne. 0) then
          msg(1) = 'Unable to read stream: ' // strnam
          msg(2) = 'File name: ' // filnam
          call aafail('FLLOAD', 2, msg)
        else
          call fzendi(iunit, 'T')
          call flclos(iunit, error)

*--- perform floating format check, version number check,
*    reload closed orbit estimate, and closed orbit fit tolerance
        if (q(lroot+2) .ne. 100.)  then
          call aafail('FLLOAD', 1,
     +    'pooldump file has wrong floating point format')
        else
          call uhtoc(q(lroot+3), 4, tmpc, 8)
          if (tmpc(:4) .ne. nvers(:4)) then
            msg(1) = 'pooldump from version             ' // tmpc
            msg(2) = 'incompatible with current version ' // nvers
            call aafail('FLLOAD', 2, msg)
          else if (tmpc(5:) .ne. nvers(5:)) then
            msg(1) = 'pooldump from version             ' // tmpc
            msg(2) = 'being read with current version   ' // nvers
            call aawarn('FLLOAD', 2, msg)
          endif
        endif
        call ucopy(q(lroot+5), coest, 7 * mwflt)

*---- Re-initialize table manager.
          call tbinit(0)

*---- Copy some structural links to reference area for efficiency.
          ldkey(1) = lq(lroot-mdkey)
          ldkey(2) = lq(lroot-mdkey-1)
          ldkey(3) = lq(lroot-mdkey-2)
          ldkey(4) = lq(lroot-mdkey-3)
          ldbnk(1) = lq(lroot-mdbnk)
          ldbnk(2) = lq(lroot-mdbnk-1)
          ldbnk(3) = lq(lroot-mdbnk-2)
          ldbnk(4) = lq(lroot-mdbnk-3)
          lcseq = lq(lq(lroot-mcseq)-1)

*---- Success.
          if (.not. error) then
            msg(1) = 'Memory dump read on stream: ' // strnam
            msg(2) = 'File name: ' // filnam
            call aainfo('FLLOAD', 2, msg)
          endif
        endif
      endif

      end
+dk flmain
      subroutine flmain(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Switch routine (subprocess code) for I/O services section.         *
* Input:                                                               *
*   IPR       (integer) Process code.                                  *
*   ISP       (integer) Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca fllink
      integer iflflg,ipr,isp

      data iflflg       / 0 /

*---- Initialize link area.
      if (iflflg .eq. 0) then
        call mzlink(0, '/FLLINK/', lfltab, lfltab, lflbuf)
        iflflg = 1
      endif

*---- User-defined services.
      if (isp .le. 0  .or.  isp .gt. 20) then
        call usercm(ipr, isp)

*---- ARCHIVE.
      else if (isp .eq. 1) then
        call flwtfs

*---- RETRIEVE.
      else if (isp .eq. 2) then
        call flrtfs

*---- ASSIGN.
      else if (isp .eq. 3) then
        call flassi

*---- CALL.
      else if (isp .eq. 4) then
        call flcall(1)

*---- RETURN.
      else if (isp .eq. 5) then
        call flcall(2)

*---- EXCITE.
      else if (isp .eq. 6) then
        call flxcit(1)

*---- INCREMENT.
      else if (isp .eq. 7) then
        call flxcit(2)

*---- POOLDUMP.
      else if (isp .eq. 8) then
        call fldump

*---- POOLLOAD.
      else if (isp .eq. 9) then
        call flload

*---- SAVE.
      else if (isp .eq. 10) then
        call svmain

*---- STATUS.
      else if (isp .eq. 11) then
        call fltell

*---- SYSTEM.
      else if (isp .eq. 12) then
        call flcsys

*---- HELP.
      else if (isp .eq. 13) then
        call svhelp

*---- SYSTEM.
      else if (isp .eq. 14) then
        call svshow

*---- TABLE.
      else if (isp .eq. 15) then
        call tblist

*---- SAVELINE.
      else if (isp .eq. 16) then
        call svslin

*---- STRUCTURE.
      else if (isp .eq. 17) then
        call flstrc

*---- MAKESEQUENCE.
      else if (isp .eq. 18) then
        call flseq
      endif

      end
+dk flname
      subroutine flname(iunit, filnam)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Return file name for logical unit IUNIT.                           *
* Input:                                                               *
*   IUNIT     (integer) Logical unit number.                           *
* Output:                                                              *
*   FILNAM    (char)    External file name.                            *
*----------------------------------------------------------------------*
+ca aparam
      integer iunit
      character*(*)     filnam
+ca fltable

      if (iost(iunit) .ge. 0) then
        filnam = iofn(iunit)
      else
        filnam = ' '
      endif

      end
+dk flnfix
      subroutine flnfix(strnam, mode, filnam, leng, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Convert stream name to valid external file name.                   *
*   System dependent routine.                                          *
* Input:                                                               *
*   STRNAM    (char)    Stream name.                                   *
*   MODE      (char*4)  File mode.                                     *
* Output:                                                              *
*   FILNAM    (char)    External file name.                            *
*   LENG      (integer) Length of name for comparing.                  *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer len,leng
      character*(*)     strnam, filnam
      character*4       mode
      logical           eflag
+ca message
+ca chcode
+ca zunit

      eflag = .false.
      filnam = strnam
      leng = len(strnam)

      end
+dk flnset
      subroutine flnset(strnam, filnam)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Define default file name.                                          *
*   System-dependent routine.                                          *
* Input:                                                               *
*   STRNAM    (char)    Stream name.                                   *
* Output:                                                              *
*   FILNAM    (char)    File name.                                     *
*----------------------------------------------------------------------*
* Modified: 30-APR-1999, M. Woodley (SLAC)                             *
*   NT and unix (AIX) specific code delineated with *WNT or *AIX       *
*----------------------------------------------------------------------*
+ca aparam
      character*(*)     strnam, filnam
+ca chcode
+if slac
*WNT- Hardcode location of dictionary file
*WNT  IF (STRNAM.EQ.'dict') THEN
*WNT    FILNAM = 'C:\MAD8acc\MAD8acc.dict'
*WNT    FILNAM = '\\Aegis\www-project\lc\local'//
*WNT +           '\AccelPhysics\Codes\Mad\MAD8acc.dict'
*WNT  ELSE
*WNT    FILNAM = STRNAM
*WNT  ENDIF
      filnam = strnam                                    ! *AIX
+el
      filnam = strnam
+ei

      end
+dk flopen
      subroutine flopen(strnam, mode, lrec, lfil, iunit, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Open I/O file and connect it to a stream.                          *
* Input:                                                               *
*   STRNAM    (char)    Stream name.                                   *
*   MODE      (char*4)  File mode.                                     *
*   LREC      (integer) Record length:                                 *
*                       For formatted files in characters,             *
*                       for unformatted files in ZEBRA words.          *
*   LFIL      (integer) File length in records (required on IBM).      *
* Output:                                                              *
*   IUNIT     (integer) Logical unit number.                           *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer iunit,leng,lfil,lrec
      character*(*)     strnam
      character*4       mode
      logical           eflag
+ca message
+ca fltable

      character*(mcfil) filnam
      character*1       acc, dir, frm, loc

*---- Unpack status flags.
      eflag = .false.
      acc = mode(1:1)
      dir = mode(2:2)
      frm = mode(3:3)
      loc = mode(4:4)

*---- Convert stream name to file name.
      call flnfix(strnam, mode, filnam, leng, eflag)
      if (eflag) go to 9999

*---- Check if attributes are consistent with previous use.
      do 50 iunit = 1, maxfil
        if (iofn(iunit)(1:leng) .eq. filnam(1:leng)) then
          if (iofr(iunit) .ne. frm) then
            write (msg, 910) 'format', iofr(iunit), frm
            call aafail('FLOPEN', 1, msg)
            eflag = .true.
          endif
          if (ioac(iunit) .ne. acc) then
            write (msg, 910) 'access', ioac(iunit), acc
            call aafail('FLOPEN', 1, msg)
            eflag = .true.
          endif
          filnam = iofn(iunit)
          go to 200
        endif
   50 continue
      if (eflag) go to 9999

*---- Not found, find free stream entry.
      do 70 iunit = maxdef + 1, maxfil
        if (iost(iunit) .lt. 0) go to 100
   70 continue

*---- No free entry found, take first closed entry.
      do 90 iunit = maxdef + 1, maxfil
        if (iost(iunit) .eq. 0) go to 100
   90 continue

*---- Stream table is full.
      call aafail('FLOPEN', 1, 'File name table full.')
      eflag = .true.
      go to 9999

*---- Fill in I/O unit table.
  100 continue
      iofn(iunit) = filnam
      ioac(iunit) = acc
      iodr(iunit) = ' '
      iofr(iunit) = frm
      iolc(iunit) = loc
      iost(iunit) = - 1

*---- Open file, unless already open.
  200 continue
      if (iost(iunit) .le. 0) then
        call flsyst(filnam, mode, lrec, lfil, iunit, eflag)

*---- Test for error.
        if (eflag) then
          if (dir .eq. 'R') then
            write (msg, 930) 'input', filnam
          else
            write (msg, 930) 'output', filnam
          endif
          call aafail('FLOPEN', 1, msg)
        else
          iost(iunit) = 1
          iodr(iunit) = dir
        endif
      else
        msg(1) = 'File already open: ' // filnam
        call aawarn('FLOPEN', 1, msg)
      endif

  910 format('Inconsistent ',a,' code. Old = ',a1,', new = ',a1)
  920 format('Inconsistent ',a,' length. Old = ',i3,', new = ',i3)
  930 format('Unable to open ',a,' file: ',a)

 9999 end
+dk flrtfs
      subroutine flrtfs
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Read an internal MAD table on a TFS file. RETRIEVE command.        *
* Attributes:                                                          *
*   TABLE     (name)    Name to be given to the table.                 *
*   FILENAME  (string)  Name of TFS file to be read.                   *
*----------------------------------------------------------------------*
+ca aparam
+ca message
+ca refer
+ca status
      integer ileng,iunit

      character         tabnam*(mcnam), strnam*(mcfil), filnam*(mcfil)

*---- Get attributes.
      tabnam = 'TWISS'
      call utgnam(lccmd, 1, 1, tabnam)
      strnam = tabnam
      call utgstr(lccmd, 2, 2, strnam)

*---- Open disk file.
      call flopen(strnam, 'SRFD', 0, 0, iunit, error)
      if (.not. error) then
        call flname(iunit, filnam)

*---- Read table on file.
        call tbrtfs(tabnam, iunit)
        if (.not. error) then
          call utleng(tabnam, ileng)
          msg(1) = 'Table "' // tabnam(1:ileng)
     +    // '" read on file: ' // filnam
          call aainfo('FLWTFS', 1, msg)
        endif

*---- Close disk file.
        call flclos(iunit, error)
      endif

      end
+dk flseq
      subroutine flseq
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   MAKESEQUENCE command,                                              *
*   Build a beam line sequence from the USE'd range.                   *
* Attribute:                                                           *
*   LABEL     (char)    Name for generated sequence.                   *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca markbits
+ca seqflag
+ca seqgroup
+ca message
+ca lnlink
+ca option
+ca range
+ca refer
+ca status
      integer i,icode,idata,idir,ielem,ienum,iflag,ikey,iln,imark,iocc,
     +ipos,ipr,isp,isup,jbyt,ndata,nelem,nkat
      double precision el,factor,half,suml,zero

      parameter         ( zero = 0.0, half = 0.5d0 )
      character*(mcnam) attr(2), dict(3), elmnam, tmpnam

      data dict         / 'ENTRY', 'CENTRE', 'EXIT' /

*---- Check presence of beam line.
      call lnchck('FLSEQ', error)
      if (error) go to 9999
      call utbeam(lcseq, irg1, irg2, symm, isup, linnam, rngnam)

*---- Lift bank, link it to SEQUENCE keyword, and mark it as modified.
      attr(1) = 'sequence'
      attr(2) = 'CENTRE'
      call utgnam(lccmd, 1, 2, attr)
      call difind(ldkey, 'SEQUENCE', ikey, lckey)
      call kwget(lckey, iln, ipr, isp, nkat)
      call aabook(llneat, attr(1), ipr, isp, lckey, 1)

*---- Decode REFER attribute.
      do 10 i = 1, 3
        if (attr(2) .eq. dict(i)) go to 20
   10 continue
      msg(1) = 'Invalid "REFER" attribute "' // attr(2) // '".'
      call aafail('FLSEQ', 1, msg)
      go to 9999

*---- Store REFER attribute.
   20 continue
      factor = float(i-1) * half
      call utpnam(llneat, 1, 1, attr(2))

*---- Push command bank to make room for element positions.
      nelem = irg2 - irg1 + 10
      ndata = nelem * mwflt
      call mzpush(0, llneat, nelem, ndata, 'I')
      iq(llneat+mbat+mcsiz+1) = 16 * ndata + mreal
      idata = mbat + mcsiz + 2
      call ucopy(zero, q(llneat+idata), mwflt)

*---- Book bank for directory index table.
      call mzbook(2, llnedr, llneat, -1, 'SDIR', 1, 1, nelem + 1, 2, 0)

*---- Store elements in sequence.
      suml = 0.0
      ielem = 1
      lsdir = lq(lcseq-msdir)

      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)

*---- Test for element.
        if (lcelm .ne. 0) then
          icode = jbyt(iflag,1,mcode)
          if (icode .eq. 1) then
            if (iq(lcelm+mbsp) .eq. 8) then
              el = 0.0
            else
              call ucopy(q(lcelm+melen), el, mwflt)
            endif

*---- Determine position for non-drift.
            if (iq(lcelm+mbsp) .ne. 1) then
              call ucopy(suml + factor * el, q(llneat+idata), mwflt)
              idata = idata + mwflt
              ielem = ielem + 1

*---- Mark as alias.
              call sbit1(iq(lccls), mxals)

*---- Assign new name.
              write (tmpnam, '(A8,I6)') elmnam, iocc
              do 80 i = 1, 14
                if (tmpnam(i:i) .eq. ' ') tmpnam(i:i) = '_'
   80         continue
              call direfe(ldbnk, tmpnam, idir)
              iq(llnedr+ielem) = idir
              lq(ldbnk(3)-idir) = lcelm
            endif

*---- Sum up length.
            suml = suml + el
          endif
        endif
   90 continue

*---- Append end marker.
      call difind(ldbnk, 'end', imark, lcelm)

      if (imark .eq. 0) then
        call difind(ldkey, 'MARKER', ikey, lckey)
        call kwget(lckey, iln, ipr, isp, nkat)
        call direfe(ldbnk, 'end ', imark)
        lq(ldbnk(3)-imark) = lq(lckey-3)
      endif

      call ucopy(suml, q(llneat+idata), mwflt)
      ielem = ielem + 1
      iq(llnedr+ielem) = imark

*---- If all OK, define this sequence.
*     Do not drop excessive space; may be used in sequence editor.
      if (error) then
        call lndrop(llneat)
      else
        iq(llnedr+1) = ielem
        call didefi(ldbnk, attr(1), llneat)

*---- DEFINE dump option.
        if (ideffl .eq. 1  .or.  ideffl .eq. 3) then
          call aadump(llneat)
        endif
        if (ideffl .eq. 2  .or.  ideffl .eq. 3) then
          call dzshow('sequence', 0, llneat, 'V', 0, 0, 0, 0)
        endif
      endif

 9999 end
+dk flstrc
      subroutine flstrc
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Execute STRUCTURE command.                                         *
* Attributes:                                                          *
*   FILENAME  (string)  File to receive output.                        *
*   ORDER     (integer) Maximum multipole order to output.             *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca seqflag
+ca message
+ca range
+ca refer
+ca status
+ca zunit
      integer icode,idisk,ienum,iflag,iocc,ipos,jbyt,nord
      double precision data,el,suml,zero

      parameter         (zero = 0.0d0)

      character         elmnam*(mcnam), filnam*(mcfil)
      dimension         data(6)
      logical           eflag

*---- Check main beam line, and retrieve its description.
      call lnchck('STRUCTURE', eflag)
      if (eflag) go to 9999
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Retrieve command attributes.
      filnam = 'structure'
      call utgstr(lccmd, 1, 1, filnam)
      nord = 0
      call utgint(lccmd, 2, 2, nord)

*---- Initialize.
      suml = 0.0

*---- Initial disk output.
      if (filnam .ne. ' ') then
        call flopen(filnam, 'SWFD', 0, 0, idisk, eflag)
        if (.not. eflag) then
          call tphead(idisk, 'STRUCTURE')
          lcelm = 0
          call tpstrc('INITIAL', idisk, nord)
          write (idisk, 910) zero, zero, zero, suml,
     +                       zero, zero, zero
        endif
      else
        call aawarn('FLSTRC', 1, 'File name missing -- no output.')
        go to 9999
      endif

*---- Output loop.
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)

        if (lcelm .ne. 0) then
          icode = jbyt(iflag,1,mcode)

          if (icode .eq. 1) then
            if (iq(lcelm+mbsp) .ne. 8) then
              call ucopy(q(lcelm+melen), el, mwflt)
              suml = suml + el
            endif

            call tpstrc(elmnam, idisk, nord)

            if (lcali .ne. 0) then
              call ucopy(q(lcali+1), data, 6*mwflt)
              write (idisk, 910) data(1), data(2), data(3), suml,
     +                           data(4), data(5), data(6)
            else
              write (idisk, 910) zero, zero, zero, suml,
     +                           zero, zero, zero
            endif
          endif
        endif
   90 continue

*---- Close output file.
      call flclos(idisk, eflag)
      if (.not. eflag) then
        call flname(idisk, filnam)
        msg(1) = 'Structure written on file: ' // filnam
        call aainfo('SURVEY', 1, msg)
      endif

  910 format(1p,4e16.9/3e16.9)

 9999 end
+dk flsyst
      subroutine flsyst(filnam, mode, lrec, lfil, iunit, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   System-dependent part of file open operation.                      *
* Input:                                                               *
*   FILNAM    (char)    File name.                                     *
*   MODE      (char*4)  File mode.                                     *
*   LREC      (integer) Record length in characters.                   *
*   LFIL      (integer) File length in records.                        *
*   IUNIT     (integer) Logical unit number.                           *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
* Modified: 30-APR-1999, M. Woodley (SLAC)                             *
*   NT and unix (AIX) specific code delineated with *WNT or *AIX       *
*----------------------------------------------------------------------*
+ca aparam
      integer ierr,irecl,iunit,lfil,lrec
      character*(*)     filnam
      character*4       mode
      logical           eflag

      character*12      form, stat
      character*1       acc, dir, frm, loc

*---- Unpack status flags.
      eflag = .false.
      acc = mode(1:1)
      dir = mode(2:2)
      frm = mode(3:3)
      loc = mode(4:4)
      if (dir .eq. 'R') then
        stat = 'OLD'
      else
        stat = 'UNKNOWN'
      endif
      if (frm .eq. 'F') then
        form = 'FORMATTED'
      else
        form = 'UNFORMATTED'
      endif
      ierr = 0
+if slac
*WNT- DEC and VAX specify record length in 4-byte words,
*WNT  and have special flags to permit multi-read access.
*WNT  IF (ACC .EQ. 'D') THEN
*WNT    IF (DIR .EQ. 'R') THEN
*WNT      OPEN (UNIT = IUNIT, FILE = FILNAM, STATUS = STAT,
*WNT +      FORM = FORM, SHARED, READONLY, ACCESS = 'DIRECT',
*WNT +      RECL = LREC, IOSTAT = IERR)
*WNT    ELSE
*WNT      OPEN (UNIT = IUNIT, FILE = FILNAM, STATUS = STAT,
*WNT +      FORM = FORM, ACCESS = 'DIRECT', RECL = LREC,
*WNT +      IOSTAT = IERR)
*WNT    ENDIF
*WNT  ELSE
*WNT    IF (DIR .EQ. 'R') THEN
*WNT      OPEN (UNIT = IUNIT, FILE = FILNAM, STATUS = STAT,
*WNT +      FORM = FORM, SHARED, READONLY,
*WNT +      ACCESS = 'SEQUENTIAL', IOSTAT = IERR)
*WNT    ELSE
*WNT      OPEN (UNIT = IUNIT, FILE = FILNAM, STATUS = STAT,
*WNT +      FORM = FORM, ACCESS = 'SEQUENTIAL', IOSTAT = IERR)
*WNT    ENDIF
*WNT  ENDIF
*---- Standard unix systems specify record length in bytes.     ! *AIX
      if (acc .eq. 'D') then                                    ! *AIX
        irecl = 4 * lrec                                        ! *AIX
        open (unit = iunit, file = filnam, status = stat,       ! *AIX
     +    form = form, access = 'DIRECT', recl = irecl,         ! *AIX
     +    iostat = ierr)                                        ! *AIX
      else                                                      ! *AIX
        open (unit = iunit, file = filnam, status = stat,       ! *AIX
     +    form = form, access = 'SEQUENTIAL', iostat = ierr)    ! *AIX
      endif                                                     ! *AIX
+el
+if osf1
*---- DEC and VAX specify record length in 4-byte words,
*     and have special flags to permit multi-read access.
      if (acc .eq. 'D') then
        if (dir .eq. 'R') then
          open (unit = iunit, file = filnam, status = stat, form = form,
     +    shared, readonly, access = 'DIRECT', recl = lrec,
     +    iostat = ierr)
        else
          open (unit = iunit, file = filnam, status = stat, form = form,
     +    access = 'DIRECT', recl = lrec, iostat = ierr)
        endif
      else
        if (dir .eq. 'R') then
          open (unit = iunit, file = filnam, status = stat, form = form,
     +    shared, readonly, access = 'SEQUENTIAL', iostat = ierr)
        else
          open (unit = iunit, file = filnam, status = stat, form = form,
     +    access = 'SEQUENTIAL', iostat = ierr)
        endif
      endif
+el
*---- Standard unix systems specify record length in bytes.
      if (acc .eq. 'D') then
        irecl = 4 * lrec
        open (unit = iunit, file = filnam, status = stat, form = form,
     +    access = 'DIRECT', recl = irecl, iostat = ierr)
      else
        open (unit = iunit, file = filnam, status = stat, form = form,
     +    access = 'SEQUENTIAL', iostat = ierr)
      endif
+ei
+ei

*---- Test for error.
      eflag = ierr .ne. 0
      if (eflag) then
        close (unit = iunit)
      endif

      end
+dk fltell
      subroutine fltell
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   STATUS command: Print table of all files.                          *
*----------------------------------------------------------------------*
+ca aparam
+ca fltable
+ca zunit
      integer iunit

*---- List files.
      write (iqlog, 910)
      do 90 iunit = 1, maxfil
        if (iost(iunit) .ge. 0) then
          write (iqlog, 920) iunit, iofn(iunit), ioac(iunit),
     +                       iodr(iunit), iofr(iunit), iolc(iunit)
        endif
   90 continue

  910 format(' '/' FLTELL.  Known files:'/
     +       ' Stream',t16,'File name',t61,'  Status'/' ')
  920 format(' ',i6,t16,a,t61,4(' ',a1))

      end
+dk fltext
      subroutine fltext(filnam, dir, lrec, iunit, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Open text file. System-dependent routine.                          *
* Input:                                                               *
*   FILNAM    (char)    File name.                                     *
*   DIR       (char*1)  Process direction: 'R' = read, 'W' = write.    *
*   LREC      (integer) Record length in characters.                   *
*   IUNIT     (integer) Logical unit number.                           *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
* Modified: 30-APR-1999, M. Woodley (SLAC)                             *
*   NT and unix (AIX) specific code delineated with *WNT or *AIX       *
*----------------------------------------------------------------------*
+ca aparam
      integer ierr,iunit,lrec
      character*(*)     filnam
      character*1       dir
      logical           eflag
+ca fltable
      character*12      form, stat

      form = 'FORMATTED'
      if (dir .eq. 'R') then
        stat = 'OLD'
      else
        stat = 'UNKNOWN'
      endif
      ierr = 0
+if slac
*WNT- DEC and VAX systems required flags for multi-read access.
*WNT  IF (DIR .EQ. 'R') THEN
*WNT    OPEN (UNIT = IUNIT, FILE = FILNAM, STATUS = STAT,
*WNT +    FORM = FORM, SHARED, READONLY, ACCESS = 'SEQUENTIAL',
*WNT +    IOSTAT = IERR)
*WNT  ELSE
*WNT    OPEN (UNIT = IUNIT, FILE = FILNAM, STATUS = STAT,
*WNT +    FORM = FORM, ACCESS = 'SEQUENTIAL', IOSTAT = IERR)
*WNT  ENDIF
*---- Standard open.                                             ! *AIX
      open (unit = iunit, file = filnam, status = stat,          ! *AIX
     +  form = form, access = 'SEQUENTIAL', iostat = ierr)       ! *AIX
+el
+if osf1
*---- DEC and VAX systems required flags for multi-read access.
      if (dir .eq. 'R') then
        open (unit = iunit, file = filnam, status = stat, form = form,
     +    shared, readonly, access = 'SEQUENTIAL', iostat = ierr)
      else
        open (unit = iunit, file = filnam, status = stat, form = form,
     +    access = 'SEQUENTIAL', iostat = ierr)
      endif
+el
*---- Standard open.
      open (unit = iunit, file = filnam, status = stat, form = form,
     +  access = 'SEQUENTIAL', iostat = ierr)
+ei
+ei
*---- Test for error.
      eflag = ierr .ne. 0
      if (eflag) then
        close (unit = iunit)
      else
        iofn(iunit) = filnam
        ioac(iunit) = 'S'
        iodr(iunit) = dir
        iofr(iunit) = 'F'
        iolc(iunit) = 'D'
        iost(iunit) = 1
      endif

      end
+dk flwtfs
      subroutine flwtfs
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Write an internal MAD table in TFS format. ARCHIVE command.        *
* Attributes:                                                          *
*   TABLE     (name)    Name of table to be written.                   *
*   FILENAME  (string)  Name to be given to the TFS file.              *
*----------------------------------------------------------------------*
+ca aparam
+ca message
+ca refer
+ca status
      integer ileng,iunit

      character         tabnam*(mcnam), strnam*(mcfil), filnam*(mcfil)

*---- Get attributes.
      tabnam = 'TWISS'
      call utgnam(lccmd, 1, 1, tabnam)
      strnam = tabnam
      call utgstr(lccmd, 2, 2, strnam)

*---- Open file.
      call flopen(strnam, 'SWFD', 2048, 0, iunit, error)
      if (.not. error) then
        call flname(iunit, filnam)

*---- Write table on file.
        call tbwtfs(tabnam, iunit)
        call flclos(iunit, error)
        if (.not. error) then
          call utleng(tabnam, ileng)
          msg(1) = 'Table "' // tabnam(1:ileng)
     +    // '" written on file: ' // filnam
          call aainfo('FLWTFS', 1, msg)
        endif
      endif

      end
+dk flxcit
      subroutine flxcit(iopt)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Set parameter definitions from a TFS file.                         *
*   EXCITE or INCREMENT command.                                       *
* Attributes:                                                          *
*   TFSFILE   (string)  Stream name to be read.                        *
*   NAME      (name)    Name of column containing parameter names.     *
*   VALUE     (name)    Name of column for settings or increments.     *
* Input:                                                               *
*   IOPT      (integer) 1: EXCITE, 2: INCREMENT.                       *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca message
+ca fllink
+ca keyword
+ca mchpar
+ca option
+ca refer
+ca status
+ca datatype
+ca tbpara
      integer ibias1,ibias2,ibias3,idir,iform1,iform2,iform3,ikat,ikey,
     +ileng,iln,iopt,ipr,isp,iunit,jleng,jrow,leng,nkat,nrow,nset
      double precision factor,valnew,valold

      character*(mcnam) colnam(3), parnam, attnam, tabnam
      character*(mcfil) strnam, filnam
      logical           attflg

*---- Retrieve attributes.
      strnam = 'excite'
      call utgstr(lccmd, 1, 1, strnam)
      colnam(1) = 'NAME'
      colnam(2) = 'ATTRIBUTE'
      colnam(3) = 'VALUE'
      call utgnam(lccmd, 2, 4, colnam)
      factor = 1.0
      call utgflt(lccmd, 5, 5, factor)

*---- Read table file.
      call flopen(strnam, 'SRFD', 0, 0, iunit, error)
      if (.not. error) then
        call flname(iunit, filnam)
        tabnam = '*TEMP TABLE*'
        call tbrtfs(tabnam, iunit)
        call flclos(iunit, error)

*---- Find name and value columns.
        call tbopen(tabnam, 1, lfltab)
        call utleng(colnam(1), leng)
        call tbcol(lfltab, colnam(1)(1:leng), iform1, ibias1)
        if (iform1 .ne. 5) then
          call utleng(colnam(1), ileng)
          if (iform1 .eq. 0) then
            msg(1) = 'Column "' // colnam(1)(1:ileng) // '" not found.'
          else
            msg(1) =
     +      'Column "' // colnam(1)(1:ileng) // '" should be string.'
          endif
          call aafail('FLXCIT', 1, msg)
        endif

        call utleng(colnam(2), leng)
        call tbcol(lfltab, colnam(2)(1:leng), iform2, ibias2)
        attflg = iform2 .eq. 5

        call utleng(colnam(3), leng)
        call tbcol(lfltab, colnam(3)(1:leng), iform3, ibias3)
        if (iform3 .ne. 3  .and.  iform3 .ne. 4) then
          call utleng(colnam(3), ileng)
          if (iform3 .eq. 0) then
            msg(1) = 'Column "' // colnam(3)(1:ileng) // '" not found.'
          else
            msg(1) =
     +      'Column "' // colnam(3)(1:ileng) // '" should be real.'
          endif
          call aafail('FLXCIT', 1, msg)
        endif

*---- Find 'PARAMETER' keyword.
        nset = 0
        if (.not. error) then
          call difind(ldkey, 'PARAMETER', ikey, lckey)
          nrow = iq(lfltab+mtbrow)

*---- Loop over table rows.
          do 90 jrow = 1, nrow
            call tbset(lfltab, jrow, 1, lflbuf)
            call uhtoc(q(lflbuf+ibias1+1), mcwrd, parnam, mcnam)
            call uhtoc(q(lflbuf+ibias2+1), mcwrd, attnam, mcnam)
            if (iform3 .eq. 3) then
              valnew = q(lflbuf+ibias3+1)
            else
              call ucopy(q(lflbuf+ibias3+1), valnew, mwflt)
            endif

*---- Skip unset values.
            if (parnam .eq. '~'  .or.  valnew .gt. 0.9 * fltmax) then

*---- Find parameter PARNAM, or make a new one.
            else if (attnam .eq. ' ') then
              call direfe(ldbnk, parnam, idir)
              lcelm = lq(ldbnk(3)-idir)
              if (lcelm .eq. 0) then
                call kwget(lckey, iln, ipr, isp, nkat)
                call aabook(lcelm, parnam, ipr, isp, lckey, 1)
                lq(ldbnk(3)-idir) = lcelm
                iq(lcelm+mbnam) = idir
              endif

*---- For INCREMENT command get old value.
              if (iopt .eq. 2) then
                call utgflt(lcelm, 1, 1, valold)
                valnew = valold + valnew * factor
              endif

*---- Store new value and mark bank as modified.
              call utpflt(lcelm, 1, 1, valnew)
              call utleng(parnam, ileng)
              nset = nset + 1
              lcexp = lq(lcelm-1)
              if (lcexp .ne. 0) then
                msg(1) = 'Parameter "' // parnam(1:ileng) //
     +                   '" becomes independent.'
                call aawarn('FLXCIT', 1, msg(1))
                call aadrop(lcexp)
              endif

*---- Define dump option.
              if (ideffl .eq. 1  .or.  ideffl .eq. 3) then
                call aadump(lcelm)
              endif
              if (ideffl .eq. 2  .or.  ideffl .eq. 3) then
                call dzshow('parameter', 0, lcelm, 'V', 0, 0, 0, 0)
              endif

*---- Try to find a known bank with known attribute.
            else if (attflg) then
              call difind(ldbnk, parnam, idir, lcelm)
              if (lcelm .eq. 0) then
                write (msg, 910) parnam
  910           format('Unknown bank name "',a,'".')
                call aafail('FLXCIT', 1, msg)
              else
                call utleng(parnam, ileng)
                call kwget(lq(lcelm+1), iln, ipr, isp, nkat)
                call utleng(attnam, jleng)
                call utlook(attnam(1:jleng), katnam, nkat, ikat)
                if (ikat .eq. 0) then
                  write (msg, 920) parnam(1:ileng), attnam(1:jleng)
  920           format('Unknown attribute "',a,'[',a,']".')
                  call aafail('FLXCIT', 1, msg)
                else if (iatype(ikat) .ne. mtflt) then
                  write (msg, 930) parnam(1:ileng), attnam(1:jleng)
  930           format('Attribute "',a,'[',a,']" is not real.')
                  call aafail('FLXCIT', 1, msg)
                else
                  if (iopt .eq. 2) then
                    call utgflt(lcelm, ikat, ikat, valold)
                    valnew = valold + valnew * factor
                  endif
                  call utpflt(lcelm, ikat, ikat, valnew)
                  nset = nset + 1
                  lcexp = lq(lcelm-1)
                  if (lcexp .ne. 0) then
                    msg(1) = 'Attribute "' // parnam(1:ileng) // '[' //
     +                      attnam(1:jleng) // ']" becomes independent.'
                    call aawarn('FLXCIT', 1, msg(1))
                    call aadrop(lcexp)
                  endif
                endif
              endif
            endif
   90     continue
        endif

*---- All done. Delete table from storage.
        call tbdrop(lfltab)
        write (msg, 940) nset, filnam
  940   format(i5,' Parameters set from file: ',a)
        call aainfo('FLXCIT', 1, msg)
      endif

      end
+dk flzzzz
+dk haaaaa
+dk haatun
      subroutine haatun(iprint, dqxdex, dqydey, dqydex)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Compute tune shift with amplitude.                                 *
* Input:                                                               *
*   IPRINT    (integer) Print flag.                                    *
* Output:                                                              *
*   DQXDEX    (real)    d(Qx)/d(Ex).                                   *
*   DQYDEY    (real)    d(Qy)/d(Ey).                                   *
*   DQYDEX    (real)    d(Qy)/d(Ex).                                   *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca prcgroup
+ca beam
+ca halink
+ca hasbuf
+ca range
+ca refer
+ca zunit
      integer ienum,iflag,iocc,ipos,iprint,irg
      double precision amux,amuy,angle,c10,c1m2,c1p2,c30,cg01,cg02,cg10,
     +cg1m2,cg1p2,cg20,cg30,dqxdex,dqydex,dqydey,f1a,f2a,f3a,f4a,f5a,
     +f6a,fc1,fc2,fc3,fc4,fc5,fs1,fs2,fs3,fs4,fs5,pgamh,pgamv,q02,q10,
     +q20,q30,s10,s1m2,s1p2,s30,sg01,sg02,sg10,sg1m2,sg1p2,sg20,sg30,
     +sk1l,sk2l,sk3l,sk4l,temp,twopi,v0120,v1002,v1011,v1020,v2100,
     +v21111,v3000,x1,x2,x3

+ca pi
      parameter         (twopi = 2.0d0 * pi)
      character*(mcnam) elmnam
      logical           mirror

      q10 = pi * qx / nsup
      q20 = 2.0 * q10
      q30 = 3.0 * q10
      q02 = twopi * qy / nsup
      c10 = cos(q10)
      s10 = sin(q10)
      c30 = cos(q30)
      s30 = sin(q30)
      c1p2 = cos(q10+q02)
      s1p2 = sin(q10+q02)
      c1m2 = cos(q10-q02)
      s1m2 = sin(q10-q02)

*---- Clear single sums.
      fc1 = 0.0
      fc2 = 0.0
      fc3 = 0.0
      fc4 = 0.0
      fc5 = 0.0
      fs1 = 0.0
      fs2 = 0.0
      fs3 = 0.0
      fs4 = 0.0
      fs5 = 0.0

*---- Clear double sums.
      f1a = 0.0
      f2a = 0.0
      f3a = 0.0
      f4a = 0.0
      f5a = 0.0
      f6a = 0.0

      mirror = .false.
   10 continue
        do 90 irg = irg1, irg2
          if (mirror) then
            ipos = irg2 + irg1 - irg
          else
            ipos = irg
          endif
          call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
          if (iq(lcelm+mbpr) .eq. mpelm) then
            call hastrg(angle, sk1l, sk2l, sk3l, sk4l)
            if (sk2l .ne. 0.0) then
              call tbset(lhastb, ipos, 1, lhasbf)
              call ucopy(q(lhasbf+1), bxb, iq(lhasbf-1))
              temp  = sqrt(bxb) * sk2l
              pgamh = temp * bxb
              pgamv = temp * byb
              if (mirror) then
                amux = q20 - amuxb
                amuy = q02 - amuyb
              else
                amux = amuxb
                amuy = amuyb
              endif

              cg10 = cos(amux)
              sg10 = sin(amux)
              cg01 = cos(amuy)
              sg01 = sin(amuy)
              cg20 = cg10 * cg10 - sg10 * sg10
              sg20 = 2.0 * cg10 * sg10
              cg02 = cg01 * cg01 - sg01 * sg01
              sg02 = 2.0 * cg01 * sg01
              cg30 = cg10 * cg20 - sg10 * sg20
              sg30 = sg10 * cg20 + cg10 * sg20
              cg1p2 = cg10 * cg02 - sg10 * sg02
              sg1p2 = sg10 * cg02 + cg10 * sg02
              cg1m2 = cg10 * cg02 + sg10 * sg02
              sg1m2 = sg10 * cg02 - cg10 * sg02

*---- Accumulate single sums.
              fc1 = fc1 + pgamh * cg30
              fs1 = fs1 + pgamh * sg30
              fc2 = fc2 + pgamh * cg10
              fs2 = fs2 + pgamh * sg10
              fc3 = fc3 + pgamv * cg1p2
              fs3 = fs3 + pgamv * sg1p2
              fc4 = fc4 + pgamv * cg1m2
              fs4 = fs4 + pgamv * sg1m2
              fc5 = fc5 + pgamv * cg10
              fs5 = fs5 + pgamv * sg10

*---- Accumulate double sums.
              f1a = f1a + pgamh * ((c30 * cg30 + s30 * sg30) * fc1 -
     +                             (s30 * cg30 - c30 * sg30) * fs1 -
     +                             c30 * pgamh / 2.0)
              f2a = f2a + pgamh * ((c10 * cg10 + s10 * sg10) * fc2 -
     +                             (s10 * cg10 - c10 * sg10) * fs2 -
     +                             c10 * pgamh / 2.0)
              f3a = f3a + pgamv * ((c1p2 * cg1p2 + s1p2 * sg1p2) * fc3 -
     +                             (s1p2 * cg1p2 - c1p2 * sg1p2) * fs3 -
     +                             c1p2 * pgamv / 2.0)
              f4a = f4a + pgamv * ((c1m2 * cg1m2 + s1m2 * sg1m2) * fc4 -
     +                             (s1m2 * cg1m2 - c1m2 * sg1m2) * fs4 -
     +                             c1m2 * pgamv / 2.0)
              f5a = f5a + pgamv * ((c10 * cg10 + s10 * sg10) * fc5 -
     +                             (s10 * cg10 - c10 * sg10) * fs5 -
     +                             c10 * pgamv / 2.0)
              f6a = f6a + pgamv * ((c10 * cg10 + s10 * sg10) * fc2 -
     +                             (s10 * cg10 - c10 * sg10) * fs2)
     +                  + pgamh * ((c10 * cg10 + s10 * sg10) * fc5 -
     +                             (s10 * cg10 - c10 * sg10) * fs5 -
     +                             c10 * pgamv)
            endif
          endif
   90   continue
        mirror = .not. mirror
      if (symm .and. mirror) go to 10

      x1 = nsup / (2304.0 * pi)
      x2 = 9.0 * x1
      x3 = 4.0 * x2
      f1a = f1a * x1 / s30
      f2a = f2a * x2 / s10
      f3a = f3a * x2 / s1p2
      f4a = f4a * x2 / s1m2
      f5a = f5a * x3 / s10
      f6a = f6a * x3 / s10
      dqxdex = 4.0 * (- 9.0 * f1a - 3.0 * f2a)
      dqydey = 4.0 * (- f3a - f4a - f5a)
      dqydex = 2.0 * (- 4.0 * f3a + 4.0 * f4a + f6a)
      if (iprint .gt. 0) then
        write (iqpr2, 910)
        if (iprint .gt. 1) then
          v3000 = - 36.0 * f1a
          v2100 = - 12.0 * f2a
          v1020 = -  4.0 * f3a
          v1002 = -  4.0 * f4a
          v1011 = -  4.0 * f5a
          v0120 =    4.0 * f4a
          v21111 = f6a
          write (iqpr2, 920) v3000,  v1020,  v1020,
     +                       v2100,  v1002,  v0120,
     +                               v1011,  v21111,
     +                       dqxdex, dqydey, dqydex
        else
          write (iqpr2, 930) dqxdex, dqydey, dqydex
        endif
      endif

  910 format(' '/' Tune shift with amplitude:'/
     +       6x,'d(Qx)/d(Ex)',5x,'d(Qy)/(dEy)',5x,'d(Qy)/d(Ex)')
  920 format(' ',1p,3e16.6,' (V3000, V1020, V1020)'/
     +       ' ',1p,3e16.6,' (V2100, V1002, V0120)'/
     +       17x,1p,2e16.6,' (V1011, V2100-01111)'/
     +       ' ',1p,3e16.6,' (total)'/' ')
  930 format(' ',1p,3e16.6/' ')

      end
+dk habegn
      subroutine habegn
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initialize HARMON mode; HARMON command.                            *
* Attributes:                                                          *
*   FX        (real)    Number of horizontal sigmas.                   *
*   FY        (real)    Number of vertical sigmas.                     *
*   FE        (real)    Number of longitudinal sigmas.                 *
*----------------------------------------------------------------------*
+ca aparam
+ca hacomm
+ca hafbad
+ca mtcflg
+ca range
+ca refer
+ca status
+ca zunit
      integer i

*---- Is main beam line set?
      call lnchck('HARMON', error)
      if (error) go to 9999

*---- Initialize beam data.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Fetch emittance factors.
      ensigx = 0.0
      ensigy = 0.0
      ensige = 0.0
      call utgflt(lccmd, 1, 3, ensigx)
      if (ensigx .eq. 0.) ensigx = 1.0
      if (ensigy .eq. 0.) ensigy = 1.0
      if (ensige .eq. 0.) ensige = 1.0

*---- Set up internal lattice function tables.
      lngnam = 'HARM-LNG'
      call halong
      if (error) go to 9999
      shtnam = 'HARM-SHT'
      call hashrt

*---- Initialize matching module.
      mtdbfl = 0
      call mtinit

*---- Initialize weights and desired values for penalty functions.
      do 90 i = 1, mhfun
        hwei(i) = 0.0
        hdes(i) = 0.0
   90 continue
      hwei(1) = 1.0
      hwei(2) = 1.0

 9999 end
+dk hacell
      subroutine hacell
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Control routine for HARMON minimization. HCELL command.            *
* Attributes:                                                          *
*   TOLERANCE (real)    Tolerance desired.                             *
*   CALLS     (integer) Call limit for penalty function.               *
* Desired values for penalty functions:                                *
*   QX',   QY'               First momentum derivatives of tunes.      *
*   QX'',  QY''              Second momentum derivatives of tunes.     *
*   QX''', QY'''             Third momentum derivatives of tunes.      *
*   DQXDEX, DQYDEY, DQYDEX   Anharmonicities.                          *
*   DX'I,  DX''I             Derivatives of dispersion (int. point).   *
*   BX'I,  BY'I              Derivatives of beta's     (int. point).   *
*   RXI,   RYI               Resonances                (int. point).   *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca message
+ca beam
+ca hacomm
+ca hafbad
+ca halink
+ca mchpar
+ca minuit
+ca refer
+ca status
+ca wstack
+ca zunit
      integer idiag,idx,ifjac,ifvec,ipvt,iqtf,iwa1,iwa2,iwa3,iwa4,ixvec,
     +ncalls
      double precision one,precis

      parameter         (precis = 1.0d-8)
      parameter         (one    = 1.0d0)
      external          hafcn
      logical           skip

*---- Retrieve attributes.
      tol = precis
      call utgflt(lccmd, 1, 1, tol)
      tol = max(tol,sqrt(epsmch))
      ncalls = 1000
      call utgint(lccmd, 2, 2, ncalls)
      call uzero(hdes, 1, mhfun * mwflt)
      call utgflt(lccmd, 3, 23, hdes)

*---- Coefficients for tune shifts.
      hfac(1) = sige * ensige * hwei(1)
      hfac(2) = sige * ensige * hwei(2)
      hfac(3) = (sige * ensige)**2 * hwei(3)
      hfac(4) = (sige * ensige)**2 * hwei(4)
      hfac(5) = (sige * ensige)**3 * hwei(5)
      hfac(6) = (sige * ensige)**3 * hwei(6)
      hfac(7) = (ex * ensigx**2) * hwei(7)
      hfac(8) = (ey * ensigy**2) * hwei(8)
      hfac(9) = (ex * ensigx**2) * hwei(9) / 2.0

*---- Coefficients for quantities at interaction point.
      hfac(10) = (sige * ensige)    * hwei(10)
      hfac(11) = (sige * ensige)**2 * hwei(11)
      hfac(12) = (sige * ensige)    * hwei(12)
      hfac(13) = (sige * ensige)    * hwei(13)
      hfac(14) = hwei(14) / 100.0
      hfac(15) = hwei(15) / 100.0

*---- Coefficients for quantities at symmetry point.
      hfac(16) = (sige * ensige)    * hwei(16)
      hfac(17) = (sige * ensige)**2 * hwei(17)
      hfac(18) = (sige * ensige)    * hwei(18)
      hfac(19) = (sige * ensige)    * hwei(19)
      hfac(20) = hwei(20) / 100.0
      hfac(21) = hwei(21) / 100.0

*---- Penalty before match.
      call haprnt('before')

*---- Print data.
      write (iqpr2, 910)
      write (iqpr2, 920) ex, ey, sige
      write (iqpr2, 930) ensigx, ensigy, ensige

*---- Any variable parameters?
      skip = .false.
      ncon = mhfun
      if (nvar .le. 0) then
        call aawarn('HACELL', 1,
     +  'Unable to adjust multipoles --- Need at least one variable.')
        skip = .true.
      endif
      if (skip .or. error .or. scan) go to 9999

*---- Allocate working space.
      ixvec  = iwork
      idx    = ixvec  + nvar
      ifvec  = idx    + nvar
      idiag  = ifvec  + ncon
      ifjac  = idiag  + nvar
      ipvt   = ifjac  + nvar * ncon
      iqtf   = ipvt   + nvar
      iwa1   = iqtf   + nvar
      iwa2   = iwa1   + nvar
      iwa3   = iwa2   + nvar
      iwa4   = iwa3   + nvar
      iwork  = iwa4   + ncon
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Call minimization routine.
      nfcnmx = ncalls
      nfcn = 0
      call mtgeti(nvar, dq(ixvec+1), dq(idx+1))
      call lmdif(hafcn, ncon, nvar, dq(ixvec+1), dq(ifvec+1),
     +           precis, dq(idiag+1), one,
     +           dq(ifjac+1), ncon, dq(ipvt+1), dq(iqtf+1),
     +           dq(iwa1+1), dq(iwa2+1), dq(iwa3+1), dq(iwa4+1))

*---- Penalty after match.
      call haprnt('after')
      write (msg, 940) fmin
      call aainfo('HACELL', 1, msg)

*---- Release working storage.
      iwork = ixvec

  910 format(' '/' Minimisation data')
  920 format(' ',14x,'Ex',14x,'Ey',8x,'sigma(p)'/' ',1p,3e16.6)
  930 format(' ',7x,'factor(x)',7x,'factor(y)',7x,'factor(p)'/
     +       ' ',3f16.3)
  940 format('Last value of penalty function: ',1p,e14.6)

 9999 end
+dk hacfit
      subroutine hacfit(show, xix, xiy, prc)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Adjust chromaticities to desired values.                           *
* Input:                                                               *
*   SHOW      (logical) Print switch.                                  *
*   XIX       (real)    Desired horizontal chromaticity.               *
*   XIY       (real)    Desired vertical chromaticity.                 *
*   PRC       (real)    Tolerance for fit.                             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ijacx,ijacy,iter,itvec,ixvec,level,maxit,nfcnsv
      double precision alamx,alamy,cxx,cxy,cyy,det,edmsv,eps,errx,erry,
     +fminsv,h,prc,temp,xix,xix0,xixt,xiy,xiy0,xiyt
      logical           show
+ca memdum
+ca message
+ca mchpar
+ca minuit
+ca wstack
+ca zunit

      parameter         (maxit = 10)
      character         crtsv*8, cstsv*16

*---- Assign working space.
      ixvec = iwork
      itvec = ixvec + nvar
      ijacx = itvec
      ijacy = ijacx + nvar
      iwork = ijacy + nvar
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Fetch initial values of variables.
      call mtgeti(nvar, dq(ixvec+1), dq(itvec+1))

*---- Save variables for minimization.
      crtsv = crout
      cstsv = cstat
      nfcnsv = nfcn
      fminsv = fmin
      edmsv = edm

*---- Begin iteration.
      crout = 'HTUNE'
      cstat = 'start'
      nfcn = 0
      eps = max(prc, sqrt(epsmch))
      do 90 iter = 1, maxit

*---- New point.
        call mtputi(nvar, dq(ixvec+1))
        call hachcl(xix0, xiy0)
        nfcn = nfcn + 1
        errx = xix0 - xix
        erry = xiy0 - xiy
        fmin = errx**2 + erry**2
        edm = fmin
        if (fmin .le. prc) then
          cstat = 'converged'
          go to 100
        endif

*---- Print iteration status.
        if (show) then
          level = 2
          if (iter .eq. 1) level = 1
          if (ilevel .ge. level) call mtprnt(nvar, dq(ixvec+1))
          cstat = 'progress'
          nfcn = nfcn + nvar
        endif

*---- Find Jacobian matrix.
        do 20 i = 1, nvar
          temp = dq(ixvec+i)
          h = eps * abs(temp)
          if (h .eq. 0.0) h = eps
          dq(ixvec+i) = temp + h
          call mtputi(nvar, dq(ixvec+1))
          call hachcl(xixt, xiyt)
          dq(ijacx+i) = (xixt - xix0) / h
          dq(ijacy+i) = (xiyt - xiy0) / h
          dq(ixvec+i) = temp
   20   continue

*---- Calculate Lagrange multipliers.
        cxx = 0.0
        cxy = 0.0
        cyy = 0.0
        do 70 i = 1, nvar
          cxx = cxx + dq(ijacx+i) * dq(ijacx+i)
          cxy = cxy + dq(ijacx+i) * dq(ijacy+i)
          cyy = cyy + dq(ijacy+i) * dq(ijacy+i)
   70   continue
        det = cxx * cyy - cxy * cxy
        if (abs(det) .lt. 1.0e-8) then
          call aawarn('HACFIT', 1,
     +    'Unable to tune chromaticity, variables have no effect.')
          cstat = 'failed'
          go to 100
        endif
        alamx = (cyy * errx - cxy * erry) / det
        alamy = (cxx * erry - cxy * errx) / det

*---- Corrections such as to minimize norm of correction vector.
        do 80 i = 1, nvar
          dq(ixvec+i) = dq(ixvec+i) -
     +      (alamx * dq(ijacx+i) + alamy * dq(ijacy+i))
   80   continue
   90 continue

*---- Final output.
  100 continue
      if (show) then
        if (ilevel .ge. 1) call mtprnt(nvar, dq(ixvec+1))
        write (iqpr2, 910) xix0, xiy0
        if (iqlog .ne. iqpr2) write (iqlog, 910) xix, xiy
      endif

*---- Restore variables for minimization.
      crout = crtsv
      cstat = cstsv
      nfcn = nfcnsv
      fmin = fminsv
      edm = edmsv

*---- Release working space.
      iwork = ixvec

  910 format(' '/' Chromaticity: Horizontal = ',f12.6,
     +       ',  vertical = ',f12.6/' ')

      end
+dk hachcl
      subroutine hachcl(xix, xiy)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Calculate chromaticities.                                          *
* Output:                                                              *
*   XIX       (real)    Horizontal chromaticity.                       *
*   XIY       (real)    Vertical chromaticity.                         *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca prcgroup
+ca halbuf
+ca halink
+ca option
+ca range
+ca refer
      integer ienum,iflag,iocc,ipos,isp
      double precision angle,bgx,bgy,dint,dxx,dyy,el,fact,fourpi,gx1,
     +gx2,gy1,h,sk1l,sk2l,sk3l,sk4l,sqx,sqy,ss,twopi,xix,xiy
      double precision an2

+ca pi
      parameter         (fourpi = 4.0 * pi, twopi = 2.0 * pi)
      character*(mcnam) elmnam

      xix = 0.0
      xiy = 0.0

*---- Deal with all elements.
      do 90 ipos = irg1 + 1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)

*---- Physical element?
        if (iq(lcelm+mbpr) .eq. mpelm) then
          isp = iq(lcelm+mbsp)

*---- Fetch lattice functions at both ends.
          call tbset(lhaltb, ipos - 1, 1, lhalbf)
          call ucopy(q(lhalbf+1), bx1, iq(lhalbf-1))
          call tbset(lhaltb, ipos, 1, lhalbf)
          call ucopy(q(lhalbf+1), bx2, iq(lhalbf-1))
          gx1 = (1.0 + ax1**2) / bx1
          gx2 = (1.0 + ax2**2) / bx2
          gy1 = (1.0 + ay1**2) / by1

*---- Fetch field strength coefficients.
          call hastrg(angle, sk1l, sk2l, sk3l, sk4l)

*---- Quadrupole.
          el = s2 - s1
          if (isp .eq. 5) then
            xix = xix - ((el * gx1 + sk1l * bx1) + (ax2 - ax1)) / 2.0
            xiy = xiy - ((el * gy1 - sk1l * by1) + (ay2 - ay1)) / 2.0

*---- Sextupole.
          else if (isp .eq. 6) then
            dxx = + (1.0/2.0) * (bx1*dx1 + bx2*dx2 -
     +      (el/6.0) * (bx2*dpx2 - bx1*dpx1 - 2.0*(ax2*dx2 - ax1*dx1)))
            dyy = - (1.0/2.0) * (by1*dx1 + by2*dx2 -
     +      (el/6.0) * (by2*dpx2 - by1*dpx1 - 2.0*(ay2*dx2 - ay1*dx1)))
            xix = xix + dxx * sk2l
            xiy = xiy + dyy * sk2l
            dxx = dxx * el
            dyy = dyy * el

*---- Multipole.
          else if (isp .eq. 8) then
            dxx = + bx1 * dx1
            dyy = - by1 * dx1
            xix = xix - bx1 * sk1l + dxx * sk2l
            xiy = xiy + by1 * sk1l + dyy * sk2l

*---- Dipole.
          else if (isp .eq. 2  .or.  isp .eq. 3) then
*--- HG001026: arc length to rectangular bend
            if (isp .eq. 2)  then
              an2 = angle / 2.d0
              if (an2 .ne. 0.d0 .and. rbarc)  el = el * an2 / sin(an2)
            endif
            h   = angle / el
            sqx = + sk1l / el + h ** 2
            sqy = - sk1l / el
            ss  = sk2l / el
            bgx = bx1 * sqx + gx1
            bgy = by1 * sqy + gy1
            dxx = + (el/2.0) * (bx1*dx1 + bx2*dx2 -
     +      (el/6.0) * (bx2*dpx2 - bx1*dpx1 - 2.0*(ax2*dx2 - ax1*dx1)))
            dyy = - (el/2.0) * (by1*dx1 + by2*dx2 -
     +      (el/6.0) * (by2*dpx2 - by1*dpx1 - 2.0*(ay2*dx2 - ay1*dx1)))
            dint = (el/2.0) * (dx2 + dx1 - (el/6.0) * (dpx2 - dpx1))
            xix = xix
     +          - (el * bgx + ax2 - ax1) / 2.0
     +          + (ss + h * sqx - 2.0 * h**3) * dxx
     +          - h*el * (ax2*dpx2 + ax1*dpx1 - (el/6.0) *
     +            (h * (ax2 - ax1) - dpx2*gx2 + dpx1*gx1 +
     +            sqx*(dpx2*bx2 - dpx2*bx1 - dx2*ax2 + dx1*ax1)))
     +          + h * bgx * dint
            xiy = xiy
     +          - (el * bgy + ay2 - ay1) / 2.0
     +          + ss * dyy
     +          - h * (dpx2 * by2 - dpx1 * by1)
     +          + h * bgy * dint
          endif
        endif
   90 continue

*---- Deal with symmetry and global factors.
      if (symm) then
        fact = nsup / twopi
      else
        fact = nsup / fourpi
      endif
      xix = fact * xix
      xiy = fact * xiy

      end
+dk hachrm
      subroutine hachrm
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Calculate chromaticity; HCHROM command (no attributes).            *
*----------------------------------------------------------------------*
+ca aparam
+ca zunit
      double precision xix,xiy

      call hachcl(xix, xiy)
      if (iqlog .ne. iqpr2) write (iqlog, 910) xix, xiy
      write (iqpr2, 910) xix, xiy

  910 format(' '/' Chromaticity: Horizontal = ',f12.6,
     +       ',  vertical = ',f12.6/' ')

      end
+dk hadbet
      subroutine hadbet(iprint, dbx1, dby1, dbx2, dby2)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*            1       d(beta)                                           *
*  Compute ------ * ---------- over the full HARMON table.             *
*           beta     d(delta)                                          *
* Input:                                                               *
*   IPRINT    (integer) Print flag.                                    *
* Output:                                                              *
*   DBX1      (real)    d(betax)/d(delta) at i.p.                      *
*   DBY1      (real)    d(betay)/d(delta) at i.p.                      *
*   DBX2      (real)    d(betax)/d(delta) at s.p.                      *
*   DBY2      (real)    d(betay)/d(delta) at s.p.                      *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca prcgroup
+ca beam
+ca halbuf
+ca halink
+ca hasbuf
+ca range
+ca refer
+ca zunit
      integer ienum,iflag,iocc,ipos,ipos1,iprint
      double precision angle,c2qxn,c2qyn,cmux,cmuy,cqxn,cqyn,csumx,
     +csumxh,csumy,csumyh,dbx1,dbx2,dbxmx,dby1,dby2,dbymx,factx,facty,
     +qxn,qyn,s2qxn,s2qyn,sk1l,sk2l,sk3l,sk4l,smux,smuy,sqxn,sqyn,ssumx,
     +ssumxh,ssumy,ssumyh,termx,termy,two,twopi

+ca pi
      parameter         (two = 2.0d0, twopi = two * pi)
      character         elmnam*(mcnam)

*---- Fetch values at ends of system.
      ipos1 = max(irg1-1,1)
      call tbset(lhaltb, ipos1, 1, lhalbf)
      call ucopy(q(lhalbf+1), bx1, iq(lhalbf-1))
      call tbset(lhaltb, irg2, 1, lhalbf)
      call ucopy(q(lhalbf+1), bx2, iq(lhalbf-1))

*---- Initialize.
      qxn = twopi * qx / nsup
      qyn = twopi * qy / nsup
      cqxn = cos(qxn)
      cqyn = cos(qyn)
      sqxn = sin(qxn)
      sqyn = sin(qyn)
      c2qxn = cqxn * cqxn - sqxn * sqxn
      c2qyn = cqyn * cqyn - sqyn * sqyn
      s2qxn = two * cqxn * sqxn
      s2qyn = two * cqyn * sqyn

*---- Accumulate integrals over (half) superperiod.
      csumx = 0.0
      csumy = 0.0
      ssumx = 0.0
      ssumy = 0.0

      do 40 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        if (iq(lcelm+mbpr) .eq. mpelm) then
          call hastrg(angle, sk1l, sk2l, sk3l, sk4l)
          if (sk1l .ne. 0.0  .or.  sk2l .ne. 0.0) then
            call tbset(lhastb, ipos, 1, lhasbf)
            call ucopy(q(lhasbf+1), bxb, iq(lhasbf-1))
            factx = bxb * (sk1l - sk2l * dxb)
            facty = byb * (sk1l - sk2l * dxb)
            csumx = csumx + factx * cos(two*amuxb)
            csumy = csumy + facty * cos(two*amuyb)
            ssumx = ssumx + factx * sin(two*amuxb)
            ssumy = ssumy + facty * sin(two*amuyb)
          endif
        endif
   40 continue

*---- Symmetric lattice.
      if (symm) then
        dbx1 =   (csumx * cqxn + ssumx * sqxn) / sqxn
        dby1 = - (csumy * cqyn + ssumy * sqyn) / sqyn
        dbx2 =   csumx / sqxn
        dby2 = - csumy / sqyn

*---- Asymmetric lattice.
      else
        dbx1 =   (csumx * cqxn + ssumx * sqxn) / (2.0 * sqxn)
        dby1 = - (csumy * cqyn + ssumy * sqyn) / (2.0 * sqyn)
        dbx2 = dbx1
        dby2 = dby1
      endif

      dbxmx = 0.0
      dbymx = 0.0

*---- Step around the ring.
      if (iprint .gt. 1) then
        csumxh = csumx
        csumyh = csumy
        ssumxh = ssumx
        ssumyh = ssumy

        do 90 ipos = irg1, irg2
          call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
          if (iq(lcelm+mbpr) .eq. mpelm) then
            call tbset(lhastb, ipos, 2, lhasbf)
            call ucopy(q(lhasbf+1), bxb, iq(lhasbf-1))

*---- Advance phase for accumulated sum.
            cmux = cos(two*amuxb)
            cmuy = cos(two*amuyb)
            smux = sin(two*amuxb)
            smuy = sin(two*amuyb)
            termx = (cqxn * cmux - sqxn * smux) * csumx
     +            + (sqxn * cmux + cqxn * smux) * ssumx
            termy = (cqyn * cmuy - sqyn * smuy) * csumy
     +            + (sqyn * cmuy + cqyn * smuy) * ssumy
            if (symm) then
              termx = (cqxn * cmux + sqxn * smux) * csumxh
     +              + (sqxn * cmux - cqxn * smux) * ssumxh + termx
              termy = (cqyn * cmuy + sqyn * smuy) * csumyh
     +              + (sqyn * cmuy - cqyn * smuy) * ssumyh + termy
            endif

*---- Store values for this element.
            bxbp =   termx / (two * sqxn)
            bybp = - termy / (two * sqyn)
            if (abs(bxbp) .gt. dbxmx) dbxmx = abs(bxbp)
            if (abs(bybp) .gt. dbymx) dbymx = abs(bybp)
            call ucopy(bxb, q(lhasbf+1), iq(lhasbf-1))

*---- Advance over this element.
            call hastrg(angle, sk1l, sk2l, sk3l, sk4l)
            factx = bxb * (sk1l - sk2l * dxb)
            facty = byb * (sk1l - sk2l * dxb)
            csumx = csumx + factx * (cmux*c2qxn - smux*s2qxn - cmux)
            csumy = csumy + facty * (cmuy*c2qyn - smuy*s2qyn - cmuy)
            ssumx = ssumx + factx * (smux*c2qxn + cmux*s2qxn - smux)
            ssumy = ssumy + facty * (smuy*c2qyn + cmuy*s2qyn - smuy)
          endif
   90   continue
      endif

*---- Optional print.
      if (iprint .gt. 0) then
        write (iqpr2, 910)
        write (iqpr2, 920) dbx1, dby1
        if (symm) write (iqpr2, 930) dbx2, dby2
        if (iprint .gt. 1) then
          write (iqpr2, 940) dbxmx, dbymx
        else
          write (iqpr2, 950)
        endif
      endif

  910 format(' '/' d(beta)/d(delta) / beta:',
     +       t37,'horizontal',t55,'vertical')
  920 format(' at interaction point',t31,1p,2e16.6)
  930 format(' at symmetry point',t31,1p,2e16.6)
  940 format(' maximum',t31,1p,2e16.6/' ')
  950 format(' ')

      end
+dk haddsp
      subroutine haddsp(iprint, dxp1, dxpp1, dxp2, dxpp2)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*             d(D)            d**2(D)                                  *
*   Compute ---------- and ------------- over the full HARMON table.   *
*            d(delta)       d(delta)**2                                *
* Input:                                                               *
*   IPRINT    (integer) Print flag.                                    *
* Output:                                                              *
*   DXP1      (real)    d(Dx)/d(delta) at i.p.                         *
*   DXPP1     (real)    d**2(Dx)/d(delta**2) at i.p.                   *
*   DXP2      (real)    d(Dx)/d(delta) at s.p.                         *
*   DXPP2     (real)    d**2(Dx)/d(delta**2) at s.p.                   *
*   DXPMX     (real)    d(Dx)/d(delta) (maximum).                      *
*   DXPPMX    (real)    d**2(Dx)/d(delta**2) (maximum).                *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca prcgroup
+ca beam
+ca halbuf
+ca halink
+ca hasbuf
+ca range
+ca refer
+ca zunit
      integer ideriv,ienum,iflag,iocc,ipos,ipos1,iprint
      double precision angle,cmux,cqxn,cqxnh,csum,csumh,dxp1,dxp2,dxpmx,
     +dxpp1,dxpp2,dxppmx,fact,half,qxnh,sixth,sk1l,sk2l,sk3l,sk4l,smux,
     +sqxn,sqxnh,ssum,ssumh,term1,term2,two

+ca pi
      parameter         (two = 2.d0, half = .5d0, sixth = 1.d0/6.d0)
      character         elmnam*(mcnam)

*---- Fetch values at ends of system.
      ipos1 = max(irg1-1,1)
      call tbset(lhaltb, ipos1, 1, lhalbf)
      call ucopy(q(lhalbf+1), bx1, iq(lhalbf-1))
      call tbset(lhaltb, irg2, 1, lhalbf)
      call ucopy(q(lhalbf+1), bx2, iq(lhalbf-1))

*---- Initialize.
      qxnh = pi * qx / nsup
      cqxnh = cos(qxnh)
      sqxnh = sin(qxnh)
      cqxn = cqxnh * cqxnh - sqxnh * sqxnh
      sqxn = two * cqxnh * sqxnh
      dxpmx = 0.0
      dxppmx = 0.0

*---- Loop for first and second derivatives.
      do 100 ideriv = 1, 2

*---- Accumulate integrals over (half) superperiod.
        csum = 0.0
        ssum = 0.0
        do 40 ipos = irg1, irg2
          call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
          if (iq(lcelm+mbpr) .eq. mpelm) then
            call hastrg(angle, sk1l, sk2l, sk3l, sk4l)
            if (sk1l .ne. 0.0  .or.  sk2l .ne. 0.0  .or.
     +          sk3l .ne. 0.0) then
              call tbset(lhastb, ipos, 1, lhasbf)
              call ucopy(q(lhasbf+1), bxb, iq(lhasbf-1))
              if (ideriv .eq. 1) then
                fact = (sk1l - half * sk2l * dxb) * dxb * sqrt(bxb)
              else
                fact = ((sk1l - sk2l * dxb) * dxbp -
     +            sixth * sk3l * dxb**3) * sqrt(bxb)
              endif
              csum = csum + fact * cos(amuxb)
              ssum = ssum + fact * sin(amuxb)
            endif
          endif
   40   continue

*---- Symmetric lattice.
        if (symm) then
          term1 = (csum * cqxnh + ssum * sqxnh) * sqrt(bx1) / sqxnh
          term2 = csum * sqrt(bx2) / sqxnh
          if (ideriv .eq. 1) then
            dxp1 = term1 - dx1
            dxp2 = term2 - dx2
          else
            dxpp1 = term1 - dxp1
            dxpp2 = term2 - dxp2
          endif

*---- Asymmetric lattice.
        else
          term1 = (csum * cqxnh + ssum * sqxnh) * sqrt(bx1) /
     +            (two * sqxnh)
          if (ideriv .eq. 1) then
            dxp1 = term1 - dx1
            dxp2 = dxp1
          else
            dxpp1 = term1 - dxp1
            dxpp2 = dxpp1
          endif
        endif

*---- Step around the ring.
        csumh = csum
        ssumh = ssum

        do 90 ipos = irg1, irg2
          call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
          if (iq(lcelm+mbpr) .eq. mpelm) then
            call tbset(lhastb, ipos, 2, lhasbf)
            call ucopy(q(lhasbf+1), bxb, iq(lhasbf-1))

*---- Advance phase four accumulated sum.
            cmux = cos(amuxb)
            smux = sin(amuxb)
            term1 = (cqxnh * cmux - sqxnh * smux) * csum
     +            + (sqxnh * cmux + cqxnh * smux) * ssum
            if (symm) then
              term1 = (cqxnh * cmux + sqxnh * smux) * csumh
     +              + (sqxnh * cmux - cqxnh * smux) * ssumh + term1
            endif

*---- Store values for this element.
            term1 = term1 * sqrt(bxb) / (two * sqxnh)
            if (ideriv .eq. 1) then
              dxbp = term1 - dxb
              if (abs(dxbp) .gt. dxpmx) dxpmx = abs(dxbp)
            else
              dxbpp = term1 - dxbp
              if (abs(dxbpp) .gt. dxppmx) dxppmx = abs(dxbpp)
            endif
            call ucopy(bxb, q(lhasbf+1), iq(lhasbf-1))

*---- Advance over this element.
            call hastrg(angle, sk1l, sk2l, sk3l, sk4l)
            if (ideriv .eq. 1) then
              fact = (sk1l - half * sk2l * dxb) * dxb * sqrt(bxb)
            else
              fact = ((sk1l - sk2l * dxb) * dxbp -
     +          sixth * sk3l * dxb**3) * sqrt(bxb)
            endif
            csum = csum + fact * (cmux*cqxn - smux*sqxn - cmux)
            ssum = ssum + fact * (smux*cqxn + cmux*sqxn - smux)
          endif
   90   continue
  100 continue

*---- Optional print.
      if (iprint .gt. 0) then
        write (iqpr2, 910)
        write (iqpr2, 920) dx1, dxp1, dxpp1
        if (symm) write (iqpr2, 930) dx2, dxp2, dxpp2
        write (iqpr2, 940) dxpmx, dxppmx
      endif

  910 format(' '/' Horizontal dispersion:',
     +       t42,'first',t57,'second',t74,'third')
  920 format(' at interaction point',t31,1p,3e16.6)
  930 format(' at symmetry point',t31,1p,3e16.6)
  940 format(' maximum',t47,1p,2e16.6/' ')

      end
+dk hadtun
      subroutine hadtun(xix2, xiy2, xix3, xiy3)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Tune shift versus momentum (second and third derivatives).         *
*   This routine integrates the former routines CURVE, DOUBLE, TRIPLE. *
* Output:                                                              *
*   XIX2(2)   (real)    d**2(Qx)/d(delta)**2 contributions.            *
*   XIY2(2)   (real)    d**2(Qy)/d(delta)**2 contributions.            *
*   XIX3(3)   (real)    d**3(Qx)/d(delta)**3 contributions.            *
*   XIY3(3)   (real)    d**3(Qy)/d(delta)**3 contributions.            *
*----------------------------------------------------------------------*
+ca aparam
      integer ienum,iflag,iocc,ipos,irg
      double precision amux,amuy,angle,cqxn,cqyn,cx,cy,f11x,f11y,f1cx,
     +f1cy,f1sx,f1sy,f1x1,f1x2,f1y1,f1y2,fc1x,fc1y,fccx,fccy,fcsx,fcsy,
     +fcx1,fcx2,fcy1,fcy2,fs1x,fs1y,fscx,fscy,fssx,fssy,fsx1,fsx2,fsy1,
     +fsy2,half,pgamx1,pgamx2,pgamx3,pgamy1,pgamy2,pgamy3,pi02,pi04,
     +pi08,pi16,qxn,qyn,sdb2x,sdb2y,sdb3x,sdb3y,sixth,sk1l,sk2l,sk3l,
     +sk4l,sqxn,sqyn,ssg2x,ssg2y,ssg3x,ssg3y,str3x,str3y,sx,sy,two,xix2,
     +xix3,xiy2,xiy3
      dimension         xix2(2), xiy2(2), xix3(3), xiy3(3)
+ca memdum
+ca bankhead
+ca prcgroup
+ca beam
+ca halink
+ca hasbuf
+ca range
+ca refer

+ca pi
      parameter         (two = 2.0d0, half = .5d0, sixth = 1.d0/6.d0)
      parameter         (pi02 = 2.0d0 * pi, pi04 =  4.0d0 * pi)
      parameter         (pi08 = 8.0d0 * pi, pi16 = 16.0d0 * pi)

      character*(mcnam) elmnam
      logical           mirror

*---- Cosines and sines of (2*pi*Q/Nsup).
      qxn = pi02 * qx / nsup
      qyn = pi02 * qy / nsup
      cqxn = cos(qxn)
      sqxn = sin(qxn)
      cqyn = cos(qyn)
      sqyn = sin(qyn)

*---- Clear single integrals.
      ssg2x = 0.0
      ssg3x = 0.0
      ssg2y = 0.0
      ssg3y = 0.0

*---- Clear single sums.
      fcx1 = 0.0
      fsx1 = 0.0
      f1x1 = 0.0
      fcx2 = 0.0
      fsx2 = 0.0
      f1x2 = 0.0
      fcy1 = 0.0
      fsy1 = 0.0
      f1y1 = 0.0
      fcy2 = 0.0
      fsy2 = 0.0
      f1y2 = 0.0

*---- Clear double integrals.
      sdb3x = 0.0
      sdb3y = 0.0

*---- Clear double sums.
      fccx = 0.
      fcsx = 0.
      fc1x = 0.
      fscx = 0.
      fssx = 0.
      fs1x = 0.
      f1cx = 0.
      f1sx = 0.
      f11x = 0.
      fccy = 0.
      fcsy = 0.
      fc1y = 0.
      fscy = 0.
      fssy = 0.
      fs1y = 0.
      f1cy = 0.
      f1sy = 0.
      f11y = 0.

*---- Clear triple integrals.
      str3x = 0.
      str3y = 0.

      mirror = .false.
  110 continue
        do 190 irg = irg1, irg2
          if (mirror) then
            ipos = irg2 + irg1 - irg
          else
            ipos = irg
          endif
          call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
          if (iq(lcelm+mbpr) .eq. mpelm) then
            call hastrg(angle, sk1l, sk2l, sk3l, sk4l)
            if (sk1l .ne. 0.0  .or.  sk2l .ne. 0.0  .or.
     +          sk3l .ne. 0.0  .or.  sk4l .ne. 0.0) then
              call tbset(lhastb, ipos, 1, lhasbf)
              call ucopy(q(lhasbf+1), bxb, iq(lhasbf-1))

*---- Strength coefficients.
              pgamx1 = bxb * (sk1l - sk2l * dxb)
              pgamy1 = byb * (sk1l - sk2l * dxb)
              pgamx2 = - pgamx1 - bxb * (sk2l*dxbp + half*sk3l*dxb**2)
              pgamy2 = - pgamy1 - byb * (sk2l*dxbp + half*sk3l*dxb**2)
              pgamx3 = - pgamx2 -
     +          bxb * (sk2l*dxbpp + sk3l*dxb*dxbp + sixth*sk4l*dxb**3)
              pgamy3 = - pgamy2 -
     +          byb * (sk2l*dxbpp + sk3l*dxb*dxbp + sixth*sk4l*dxb**3)

*---- Phase coefficients.
              if (mirror) then
                amux = two * (qxn - amuxb)
                amuy = two * (qyn - amuyb)
              else
                amux = two * amuxb
                amuy = two * amuyb
              endif
              cx = cos(amux)
              sx = sin(amux)
              cy = cos(amuy)
              sy = sin(amuy)

*---- Single integrals.
              ssg2x = ssg2x + pgamx2
              ssg2y = ssg2y + pgamy2
              ssg3x = ssg3x + pgamx3
              ssg3y = ssg3y + pgamy3

*---- Single sums.
              fcx1 = fcx1 + pgamx1 * cx
              fsx1 = fsx1 + pgamx1 * sx
              f1x1 = f1x1 + pgamx1
              fcx2 = fcx2 + pgamx2 * cx
              fsx2 = fsx2 + pgamx2 * sx
              f1x2 = f1x2 + pgamx2

              fcy1 = fcy1 + pgamy1 * cy
              fsy1 = fsy1 + pgamy1 * sy
              f1y1 = f1y1 + pgamy1
              fcy2 = fcy2 + pgamy2 * cy
              fsy2 = fsy2 + pgamy2 * sy
              f1y2 = f1y2 + pgamy2

*---- Double integrals.
              sdb3x = sdb3x +
     +                pgamx2 * (fcx1 * (cx * cqxn + sx * sqxn) +
     +                          fsx1 * (sx * cqxn - cx * sqxn) -
     +                          f1x1 * cqxn) +
     +                pgamx1 * (fcx2 * (cx * cqxn + sx * sqxn) +
     +                          fsx2 * (sx * cqxn - cx * sqxn) -
     +                          f1x2 * cqxn)

              sdb3y = sdb3y +
     +                pgamy2 * (fcy1 * (cy * cqyn + sy * sqyn) +
     +                          fsy1 * (sy * cqyn - cy * sqyn) -
     +                          f1y1 * cqyn) +
     +                pgamy1 * (fcy2 * (cy * cqyn + sy * sqyn) +
     +                          fsy2 * (sy * cqyn - cy * sqyn) -
     +                          f1y2 * cqyn)

*---- Double sums.
              fccx = fccx + pgamx1 * cx * fcx1
              fcsx = fcsx + pgamx1 * cx * fsx1
              fc1x = fc1x + pgamx1 * cx * f1x1
              fscx = fscx + pgamx1 * sx * fcx1
              fssx = fssx + pgamx1 * sx * fsx1
              fs1x = fs1x + pgamx1 * sx * f1x1
              f1cx = f1cx + pgamx1 * fcx1
              f1sx = f1sx + pgamx1 * fsx1
              f11x = f11x + pgamx1 * f1x1

              fccy = fccy + pgamy1 * cy * fcy1
              fcsy = fcsy + pgamy1 * cy * fsy1
              fc1y = fc1y + pgamy1 * cy * f1y1
              fscy = fscy + pgamy1 * sy * fcy1
              fssy = fssy + pgamy1 * sy * fsy1
              fs1y = fs1y + pgamy1 * sy * f1y1
              f1cy = f1cy + pgamy1 * fcy1
              f1sy = f1sy + pgamy1 * fsy1
              f11y = f11y + pgamy1 * f1y1

*---- Triple integrals.
              str3x = str3x + pgamx1 *
     +          (sqxn * (fccx + fssx) + cqxn * (fcsx - fscx) +
     +          (sqxn * cx - cqxn * sx) * (fc1x - f1cx) +
     +          (cqxn * cx + sqxn * sx) * (fs1x - f1sx) - sqxn * f11x)

              str3y = str3y + pgamy1 *
     +          (sqyn * (fccy + fssy) + cqyn * (fcsy - fscy) +
     +          (sqyn * cy - cqyn * sy) * (fc1y - f1cy) +
     +          (cqyn * cy + sqyn * sy) * (fs1y - f1sy) - sqyn * f11y)
            endif
          endif
  190   continue
        mirror = .not. mirror
      if (symm .and. mirror) go to 110

*---- Apply constant factors.
      sdb2x = cqxn * (fccx + fssx - f11x) + sqxn * (fscx - fcsx)
      sdb2y = cqyn * (fccy + fssy - f11y) + sqyn * (fscy - fcsy)

      xix2(1) = - nsup * ssg2x / pi04
      xix2(2) = - nsup * sdb2x / (pi08 * sqxn)
      xix3(1) = - nsup * ssg3x / pi04
      xix3(2) = - nsup * sdb3x / (pi08 * sqxn)
      xix3(3) = - nsup * str3x / (pi16 * sqxn)

      xiy2(1) =   nsup * ssg2y / pi04
      xiy2(2) = - nsup * sdb2y / (pi08 * sqyn)
      xiy3(1) =   nsup * ssg3y / pi04
      xiy3(2) = - nsup * sdb3y / (pi08 * sqyn)
      xiy3(3) =   nsup * str3y / (pi16 * sqyn)

      end
+dk hafcn
      subroutine hafcn(nf, nx, x, fvec, iflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Calculate the penalty functions to be minimized.                   *
* Input:                                                               *
*   NF        (integer) Number of penalty functions.                   *
*   NX        (integer) Number of parameters.                          *
*   X(NX)     (real)    Parameter values.                              *
* Output:                                                              *
*   FVEC(NF)  (real)    The penalty functions.                         *
*   IFLAG     (integer) Error flag (always set to 0, i.e. OK).         *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iflag,iprint,nf,nx
      double precision fvec,x,xix2,xix3,xiy2,xiy3
      dimension         x(nx), fvec(nf)
+ca hafbad
+ca minuit

      dimension         xix2(2), xiy2(2), xix3(3), xiy3(3)

*---- Set new parameter values.
      call mtputi(nx, x)

*---- Clear functions of penalty.
      call uzero(fvec, 1, mwflt * nf)
      iprint = 0

*---- First order chromaticity.
      call hachcl(hfun(1), hfun(2))

*---- HADDSP must always be run first; results are used by others.
      call haddsp(iprint, hfun(10), hfun(11), hfun(16), hfun(17))

*---- Derivatives of beta w.r.t. delta.
      if (hfac(12) .ne. 0.0  .or.  hfac(13) .ne. 0.0  .or.
     +    hfac(18) .ne. 0.0  .or.  hfac(19) .ne. 0.0) then
        call hadbet(iprint, hfun(12), hfun(13), hfun(18), hfun(19))
      endif

*---- Resonances.
      if (hfac(14) .ne. 0.0  .or.  hfac(15) .ne. 0.0  .or.
     +    hfac(20) .ne. 0.0  .or.  hfac(21) .ne. 0.0) then
        call hareso(iprint, hfun(14), hfun(15), hfun(20), hfun(21))
      endif

*---- Derivatives of tunes w.r.t. delta.
      if (hfac(3) .ne. 0.0  .or.  hfac(4) .ne. 0.0  .or.
     +    hfac(5) .ne. 0.0  .or.  hfac(6) .ne. 0.0) then
        call hadtun(xix2, xiy2, xix3, xiy3)
        hfun(3) = xix2(1) + xix2(2)
        hfun(4) = xiy2(1) + xiy2(2)
        hfun(5) = xix3(1) + xix3(2) + xix3(3)
        hfun(6) = xiy3(1) + xiy3(2) + xiy3(3)
      endif

*---- Amplitude-dependence of tunes.
      if (hfac(7) .ne. 0.0  .or.  hfac(8) .ne. 0.0  .or.
     +    hfac(9) .ne. 0.0) then
        call haatun(iprint, hfun(7), hfun(8), hfun(9))
      endif

*---- How bad are things?
      do 10 i = 1, mhfun
        fvec(i) = (hfun(i) - hdes(i)) * hfac(i)
   10 continue
      iflag = 0

      end
+dk hafunc
      subroutine hafunc
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Compute the "HARMON" functions; HFUNCT command.                    *
* Attribute:                                                           *
*   DETAIL    (logical) Detail flag.                                   *
*                       False: print summary only.                     *
*                       True:  print also details.                     *
*----------------------------------------------------------------------*
+ca aparam
+ca range
+ca refer
      integer iprint,nline
      double precision zero

      parameter         (zero = 0.0d0)
      character*(*)     title
      logical           detail

      parameter         (title = 'HARMON functions.')

*---- Retrieve print flag.
      iprint = 1
      detail = .false.
      call utglog(lccmd, 1, 1, detail)
      if (detail) iprint = 2

*---- Print page title.
      if (iprint .gt. 0) then
        call prhead('HFUNCT', title, zero, 0, nline, 1)
      endif

*---- Compute and print the "HARMON functions".
      call hathin(iprint)

*---- Print table of averaged lattice functions.
      if (iprint .gt. 1) call hapave

      end
+dk halong
      subroutine halong
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Set up "long" table of linear lattice functions for HARMON.        *
*   This routine assumes that the temporary links for HARMON are       *
*   already active.                                                    *
*   It ignores synchrotron radiation and imperfections, and considers  *
*   RF cavities only to compute synchrotron tunes.                     *
*----------------------------------------------------------------------*
* Modified: 19-JUL-1999, T. Raubenheimer [SLAC]                        *
*    Added /SYNCH/ common and reset BLEN before TMMAP call             *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca prcgroup
+ca seqgroup
+ca beam
+ca hacomm
+ca halbuf
+ca halink
+ca mapelm
+ca optic0
+ca optic1
+ca range
+ca refer
+ca status
+ca stflag
+ca synch
      integer i,ienum,iflag,iocc,ipos,nline,nrow
      double precision el,twopi,zero

+ca pi
      parameter         (twopi = 2.0 * pi, zero = 0.0)
      character*(mcnam) colnam(mlcol), elmnam
      character*(*)     title
      integer           icform(mlcol)
      logical           fmap

      parameter         (title = 'HARMON startup.')

      data colnam
     +   / 'BETX', 'ALFX', 'AMUX', 'BETY', 'ALFY', 'AMUY',
     +     'X',    'PX',   'Y',    'PY',   'T',    'PT',
     +     'DX',   'DPX',  'DY',   'DPY',  'S'              /
      data icform       / mlcol * mreal /

*---- Set status flags to ignore all effects but field errors.
      do 10 i = 1, maxdof
        doflag(i) = .false.
   10 continue
      dofld = .true.

*---- Fix up environment and find initial values for tracking.
      call prhead('HARMON', title, zero, 0, nline, 1)
      call enfix
      if (error) return
      call enfreq(zero)
      call tmturn(lcseq, zero, error)
      if (error) return
      if (iq(lcseq+msym) .ne. 0) call tmmksm(.true.)
      call twbtin(lcseq, .false., error)
      if (.not. (stabx .and. staby)) then
        call aafail('HALONG', 1,
     +    'One or both planes unstable, cannot run HARMON.')
      endif
      if (error) return
      call enprgl
      call enprem
      call enprrf
      amux0 = zero
      amuy0 = zero
      suml = zero
      call ucopy(betx0, betx, 18*mwflt)

*---- Set up table buffer for optical functions.
      nrow = iq(lq(lcseq-msdir)-1)
      call tbcrea(lngnam, 1, nrow, mlcol, colnam, icform, 2, lhaltb)
      if (error) return

*---- Save lattice parameters at start of system.
*     (In case that first position is an element).
      if (irg1 .gt. 1) then
        call tbset(lhaltb, irg1 - 1, 3, lhalbf)
        if (lhalbf .ne. 0) then
          call ucopy(betx, bx1, mwflt * mlcol)
          s1 = suml
          call ucopy(bx1, q(lhalbf+1), iq(lhalbf-1))
        endif
      endif

*---- Loop on beam range.
      cplxy = .false.
      cplxt = .false.
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)

*---- Tor: set BLEN to zero ... it may get reset in TMMAP
        blen = zero

*---- Track lattice parameters.
        if (iq(lcelm+mbpr) .eq. mpelm) then
          call tmmap(.false., .false., orbit, fmap, el, ek, re, te)
          if (fmap) then
            suml = suml + el
            call twbttk(.false., .true.)
          endif
        endif

*---- Save lattice parameters.
        call tbset(lhaltb, ipos, 3, lhalbf)
        if (lhalbf .ne. 0) then
          call ucopy(betx, bx1, mwflt * mlcol)
          s1 = suml
          call ucopy(bx1, q(lhalbf+1), iq(lhalbf-1))
        endif
   90 continue

*---- Check for no coupling and no synchrotron motion.
      if (cplxy) then
        call aawarn('HALONG', 1,
     +  'HARMON will ignore transverse coupling.')
      endif
      if (cplxt) then
        call aawarn('HALONG', 1,
     +  'HARMON will ignore RF cavities except to compute Qs.')
      endif
      if (dorad) then
        call aawarn('HALONG', 1,
     +  'HARMON will ignore synchrotron radiation.')
      endif

*---- Store summary data.
      qx = nsup * amux / twopi
      qy = nsup * amuy / twopi
      circ = suml * nsup
      if (symm) then
        qx = qx + qx
        qy = qy + qy
        circ = circ + circ
      endif

      end
+dk hamain
      subroutine hamain(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Control routine for HARMON commands.                               *
* Input:                                                               *
*   IPR      (integer)  Process code.                                  *
*   ISP      (integer)  Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca message
+ca halink
+ca mtlink
+ca minuit
+ca option
+ca refer
+ca status
      integer ihaflg,ipr,isp

      data ihaflg       / 0 /

*---- Initialize link area for HARMON module.
      if (ihaflg .eq. 0) then
        call mzlink(0, '/HALINK/', lhaltb, lhaltb, lhasbf)
        ihaflg = 1
      endif

*---- Check valid use of command.
      if (isp .ne. 1  .and.  imodul .ne. ipr) then
        msg(1) =
     +  'Cannot run HARMON subcommand outside a HARMON process,'
        msg(2) = 'HARMON command required first.'
        call aafail('HAMAIN', 2, msg)
      else if (isp .eq. 1  .and.  imodul .ne. 0) then
        msg(1) =
     +  'Cannot initiate HARMON while previous process not complete,'
        msg(2) = 'Enter proper ENDxxxx command first.'
        call aafail('HAMAIN', 2, msg)

*---- HARMON --- Enter HARMON mode.
      else if (isp .eq. 1) then
        call habegn

*---- Timing information.
        if (.not. error) then
          call timex(time1)
          if (trace) then
            write (msg, 910) time1
  910       format('Begin HARMON mode, time = ',f12.3)
            call aainfo('HAMAIN', 1, msg)
          endif
          imodul = ipr
        endif

*---- ENDHARMON --- End of harmon command sequence.
      else if (isp .eq. 2) then

*---- Drop HARMON tables.
        if (lsmat .ne. 0) call mzdrop(0, lsmat, ' ')
        call tbdrop(lhaltb)
        call tbdrop(lhastb)

*---- Timing information.
        call timex(time2)
        if (trace) then
          write (msg, 920) time2, time2 - time1
  920     format('End HARMON mode, time = ',f12.3,
     +           ', time for HARMON = ',f12.3,' seconds')
          call aainfo('HAMAIN', 1, msg)
        endif
        imodul = 0

*---- HRESONANCE --- Resonance calculation.
      else if (isp .eq. 3) then
        call haresc

*---- HCHROMATICITY --- Chromaticity calculation.
      else if (isp .eq. 4) then
        call hachrm

*---- HFUNCTION --- Calculate resonance functions.
      else if (isp .eq. 5) then
        call hafunc

*---- HTUNE --- Tune sextupoles for desired chromaticity.
      else if (isp .eq. 6) then
        call hatune

*---- HVARY --- Vary sextupole.
      else if (isp .eq. 7) then
        call havary

*---- HCELL --- Minimize for periodic system.
      else if (isp .eq. 8) then
        call hacell

*---- HWEIGHT --- Set matching weights.
      else if (isp .eq. 9) then
        call haweig

*---- HLEVEL --- Set printing level.
      else if (isp .eq. 10) then
        call utgint(lccmd, 1, 1, ilevel)

*---- User-defined code.
      else
        call usercm(ipr, isp)
      endif

      end
+dk hapave
      subroutine hapave
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print table of averaged lattice functions.                         *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca prcgroup
+ca halink
+ca hasbuf
+ca range
+ca refer
+ca zunit
      integer ienum,iflag,iocc,ipos

      character*(mcnam) elmnam

*---- Loop over table.
      write (iqpr2, 910)
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        if (iq(lcelm+mbpr) .eq. mpelm) then
          call tbset(lhastb, ipos, 1, lhasbf)
          call ucopy(q(lhasbf+1), bxb, iq(lhasbf-1))
          write (iqpr2, 920)
     +      elmnam, bxb, bxbp, byb, bybp, dxb, dxbp, dxbpp
        endif
   90 continue

  910 format('1Element',t21,'betx',t36,'dbetx',t51,'bety',t66,
     +       'dbety',t81,'Dx',t96,'dDx',t111,'d2Dx')
  920 format(' ',a16,1p,7e15.6)

      end
+dk haprnt
      subroutine haprnt(word2)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print results of minimization.                                     *
* Input:                                                               *
*   WORD      (char)    String "before" or "after".                    *
*----------------------------------------------------------------------*
+ca aparam
      integer i,nline
      double precision badtot,hcon,zero
      character*(*)     word2
+ca hafbad
+ca range
+ca zunit

      character         word1*(*), word3*(*), title*24
      dimension         hcon(mhfun)

      parameter         (zero = 0.0d0)
      parameter         (word1 = 'HARMON ', word3 = ' matching.')

*---- Print page header.
      title = word1 // word2 // word3
      call prhead('HCELL', title, zero, 0, nline, 1)

*---- Print out results obtained.
      call hathin(1)

*---- Print page header.
      call prhead('HCELL', title, zero, 0, nline, 2)

*---- Output the functions of penalty.
      badtot = 0.0
      hfac(1) = 1.0
      hfac(2) = 1.0
      do 10 i = 1, mhfun
        hcon(i) = ((hfun(i) - hdes(i)) * hfac(i)) ** 2
        badtot = badtot + hcon(i)
   10 continue
      write (iqpr2, 910)
      write (iqpr2, 920)
     +  (hdes(i), hfun(i), hwei(i), hcon(i), i = 1, 9)
      write (iqpr2, 930) 'interaction',
     +  (hdes(i), hfun(i), hwei(i), hcon(i), i = 10, 15)
      if (symm) then
        write (iqpr2, 930) 'symmetry',
     +    (hdes(i), hfun(i), hwei(i), hcon(i), i = 16, 21)
      endif
      write (iqpr2, 940) badtot

  910 format(' '/' Penalty:'/7x,'design',11x,'value',10x,'weight',
     +       4x,'contribution',t68,'meaning')
  920 format(' '/' Tune shifts:'/1p,
     +       ' ',4e16.6,'  d(Qx)/d(delta)'/
     +       ' ',4e16.6,'  d(Qy)/d(delta)'/
     +       ' ',4e16.6,'  d**2(Qx)/d(delta)**2'/
     +       ' ',4e16.6,'  d**2(Qy)/d(delta)**2'/
     +       ' ',4e16.6,'  d**3(Qx)/d(delta)**3'/
     +       ' ',4e16.6,'  d**3(Qy)/d(delta)**3'/
     +       ' ',4e16.6,'  d(Qx)/d(Ex)'/
     +       ' ',4e16.6,'  d(Qy)/d(Ey)'/
     +       ' ',4e16.6,'  d(Qy)/d(Ex)')
  930 format(' '/' At ',a,' point:'/1p,
     +       ' ',4e16.6,'  d(Dx)/d(delta)'/
     +       ' ',4e16.6,'  d**2(Dx)/d(delta)**2'/
     +       ' ',4e16.6,'  d(betax)/d(delta) / betax'/
     +       ' ',4e16.6,'  d(betay)/d(delta) / betay'/
     +       ' ',4e16.6,'  x resonances',/
     +       ' ',4e16.6,'  y resonances')
  940 format(' '/' Total penalty function: ',1p,e16.6/' ')

      end
+dk haresc
      subroutine haresc
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   This subroutine does the resonance calculations.                   *
*   HRESONANCE command.                                                *
* Attributes:                                                          *
*   ORDER     (integer) Order of resonances to be calculated.          *
*   DISP      (logical) True: Include dispersion in resonance coeffs.  *
*----------------------------------------------------------------------*
+ca aparam
+ca message
+ca beam
+ca hacomm
+ca range
+ca refer
+ca zunit
      integer i,ipass,n1,n2,norder,np
      double precision beat,der,des,dqr,dqr20,dqs,dqs20,ex0,ey0,fact,
     +fact1,fact2,fact3,factor,fn1,fn2,rsum,sum,summ,sup

      logical           acode
      dimension         beat(5), fact(5)
      dimension         sum(2)

      data beat
     +  / 1.0d0,      1.0d0,      2.0d0, 1.553774d0, 1.384812d0 /
      data fact
     +  / 1.0d0, 5.545455d0, 2.066667d0, 1.446735d0, 1.194130d0 /

*---- Retrieve command attributes.
      norder = 3
      call utgint(lccmd, 1, 1, norder)
      acode = .false.
      call utglog(lccmd, 2, 2, acode)

*---- Emittances.
      ex0 = ex * ensigx**2
      ey0 = ey * ensigy**2
      if (ex0 .le. 0.0  .or.  ey0 .le. 0.0) then
        write (msg, 910) ex0, ey0
        call aawarn('HARESC', 2, msg)
        go to 9999
      endif

      sup = nsup
      do 100 ipass = 1, 2
        write (iqpr2, 920) norder, ex0, ey0
        if (acode) then
          write (iqpr2, 930) 'in'
        else
          write (iqpr2, 930) 'ex'
        endif

*---- Sum resonances.
        do 40 n2 = 0, norder, 2
          n1 = norder - n2
          fact1 = 1.0 / (2.0**(norder - 1) * factor(n1) * factor(n2))
          fn1 = n1
          fn2 = n2
          np = nsup * int((fn1 * qx + fn2 * qy) / sup)
          if (ipass .eq. 2) np = np + nsup
          write (iqpr2, 940) n1, n2, np
          call harsig(acode, n1, n2, np, sum, rsum)
          sum(1) = sum(1) * fact1
          sum(2) = sum(2) * fact1
          rsum = rsum * fact1
          summ = sqrt(sum(1)**2 + sum(2)**2)

          fact2 = (fn1**2 / ex0 + fn2**2 / ey0) *
     +            (sqrt(ex0)**n1 * sqrt(ey0)**n2)
          fact3 = 1.0
          if (norder .gt. 2  .and.  norder .lt. 6) then
            fact2 = fact2 * beat(norder)**(norder-2)
            fact3 = fact(norder)
          endif
          des = summ * fact2
          der = rsum * fact2
          dqs = des / sqrt(fn1**2+fn2**2)
          dqr = der / sqrt(fn1**2+fn2**2)
          dqs20 = dqs * fact3
          dqr20 = dqr * fact3
          write (iqpr2, 950) sum, summ, rsum,
     +                       des, der, dqs, dqr, dqs20, dqr20
   40   continue

*---- Difference resonances.
        do 90 i = 2, norder - 1, 2
          n2 = i
          n1 = norder - n2
          fact1 = 1.0 / (2.0**(norder - 1) * factor(n1) * factor(n2))
          if (n2 .gt. n1) n1 = - n1
          if (n2 .le. n1) n2 = - n2
          fn1 = n1
          fn2 = n2
          np = nsup * int((fn1 * qx + fn2 * qy) / sup)
          if (ipass .eq. 2) np = np + nsup
          write (iqpr2, 960) n1, n2, np
          call harsig(acode, n1, n2, np, sum, rsum)
          sum(1) = sum(1) * fact1
          sum(2) = sum(2) * fact1
          rsum = rsum * fact1
          summ = sqrt(sum(1)**2 + sum(2)**2)
          write (iqpr2, 970) sum, summ, rsum
   90   continue
  100 continue

*---- Fourth order effects of sextupoles.
      if (norder .eq. 3) call ha4ana

  910 format('Emittances should be greater than zero.'/
     +       'Actual values = ',1p,2e12.6)
  920 format(' '/' Fourier analysis, order of resonance',19x,
     +       'Ex0',9x,'Ey0'/32x,i5,10x,1p,2e12.4)
  930 format(' '/' Dispersion effects are ',a,'cluded.')
  940 format(' '/' n1 = ',i5,'  n2 = ',i5,'  p = ',i5/
     +       7x,'cosine',8x,'sine',5x,'modulus',6x,'random',
     +       7x,'dE(s)',7x,'dE(r)',7x,'dQ(s)',7x,'dQ(r)',5x,
     +       'dQ20(s)',5x,'dQ20(r)')
  950 format(' ',1p,10e12.4)
  960 format(' '/' n1 = ',i5,'  n2 = ',i5,'  p = ',i5/
     +       7x,'cosine',8x,'sine',5x,'modulus',6x,'random')
  970 format(' ',1p,4e12.4)

 9999 end
+dk hareso
      subroutine hareso(iprint, dh1, dv1, dh2, dv2)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Calculation of 1/3rd integer resonances due to sextupoles.         *
*   Penalty of the configuration is expressed as distortion of         *
*   The 4-dimensional phase space.                                     *
*   A = - n1 / sin(2*pi*Q*N) * integral over one superperiod of        *
*       G * beta**(k/2) * K2 * complex exponent of                     *
*       N*Q * (pi + phi - psi) * ds.                                   *
*   Horizontal distortion is:                                          *
*   (emittance)**(k2/2) / eh * A.                                      *
*   Vertical distortion is                                             *
*   (emittance)**(k2/2) / ev * A.                                      *
*     N1 = phase integer, horz or vert.                                *
*     N  = ditto          combined.                                    *
*     K  = amplitude integer, combined.                                *
* Input:                                                               *
*   IPRINT    (integer) Print flag.                                    *
* Output:                                                              *
*   DH1       (real)    Horizontal resonances at i.p.                  *
*   DV1       (real)    Vertical resonances   at i.p.                  *
*   DH2       (real)    Horizontal resonances at s.p.                  *
*   DV2       (real)    Vertical resonances   at s.p.                  *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca prcgroup
+ca beam
+ca hacomm
+ca halink
+ca hasbuf
+ca range
+ca refer
+ca zunit
      integer i,ienum,iflag,iocc,ipos,iprint,nres
      double precision aa,angle,c2x,c2y,cb,cg,cmux,cmuy,dh1,dh2,disth1,
     +disth2,distv1,distv2,dv1,dv2,h,pbet,qxn,qy2n,s2x,s2y,sb,sg,sk1l,
     +sk2l,sk3l,sk4l,smux,smuy,src,srs,sum1,sum2,twopi,v,w1

+ca pi
      parameter         (twopi = 2.0d0 * pi)

*---- Local variables.
      parameter         (nres = 5)
      dimension         src(nres), srs(nres), pbet(nres),
     +                  cb(nres), sb(nres), aa(nres),
     +                  cg(nres), sg(nres), sum1(5), sum2(5),
     +                  disth1(nres), distv1(nres),
     +                  disth2(nres), distv2(nres)
      character*(mcnam) elmnam
*     SRC, SRS          Accumulation of cos & sin components of sums.
*     PBET              K2 * beta**(k/2).
*     CB, SB            Sin & cos of (n*pi*Q).
*     AA                1 / (2 * sin(n*pi*Q)).
*     CG, SG            cos and sin(n*Q*psi).
*     SUM1, SUM2        Summation at I.P. and symmmetry point.
*     DISTH1, DISTV1    Distortion horz/vert at I.P.
*     DISTH2, DISTV2    Ditto at symmetry point.

*---- Clear the sums.
      do 10 i = 1, nres
        src(i) = 0.0
        srs(i) = 0.0
   10 continue

*---- Accumulate the integrals.
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        if (iq(lcelm+mbpr) .eq. mpelm) then
          call hastrg(angle, sk1l, sk2l, sk3l, sk4l)
          if (sk2l .ne. 0.0) then
            call tbset(lhastb, ipos, 1, lhasbf)
            call ucopy(q(lhasbf+1), bxb, iq(lhasbf-1))
            pbet(1) = sk2l * sqrt(bxb) * bxb
            pbet(2) = pbet(1)
            pbet(3) = sk2l * sqrt(bxb) * byb
            pbet(4) = pbet(3)
            pbet(5) = pbet(3)
            cmux = cos(amuxb)
            smux = sin(amuxb)
            cmuy = cos(amuyb)
            smuy = sin(amuyb)
            c2x = cmux * cmux - smux * smux
            s2x = smux * cmux + cmux * smux
            c2y = cmuy * cmuy - smuy * smuy
            s2y = smuy * cmuy + cmuy * smuy
            cg(1) = cmux * c2x - smux * s2x
            cg(2) = cmux
            cg(3) = cmux * c2y - smux * s2y
            cg(4) = cmux * c2y + smux * s2y
            cg(5) = cg(2)
            sg(1) = smux * c2x + cmux * s2x
            sg(2) = smux
            sg(3) = smux * c2y + cmux * s2y
            sg(4) = smux * c2y - cmux * s2y
            sg(5) = sg(2)
            do 20 i = 1, nres
              src(i) = src(i) + pbet(i) * cg(i)
              srs(i) = srs(i) + pbet(i) * sg(i)
   20       continue
          endif
        endif
   90 continue

*---- Set up (n*pi*Q).
      qxn = pi * qx / nsup
      qy2n = twopi * qy / nsup
      aa(1) = 3.0 * qxn
      aa(2) = qxn
      aa(3) = qxn + qy2n
      aa(4) = qxn - qy2n
      aa(5) = qxn
      if (symm) then
        w1 = - 1.0
      else
        w1 = - 0.5
      endif
      do 110 i = 1, nres
        cb(i) = cos(aa(i))
        sb(i) = sin(aa(i))
        aa(i) = w1 / sb(i)
  110 continue
      aa(1) = aa(1) / (4.0 * 6.0)
      aa(2) = aa(2) / (4.0 * 2.0)
      aa(3) = aa(3) / (4.0 * 2.0)
      aa(4) = aa(4) / (4.0 * 2.0)
      aa(5) = aa(5) / 4.0

*---- Get the functions by using the sums.
      do 120 i = 1, nres
        sum1(i) = (src(i) * cb(i) + srs(i) * sb(i)) * aa(i)
        if (symm) then
          sum2(i) = src(i) * aa(i)
        else
          sum2(i) = sum1(i)
        endif
  120 continue

*---- Actual distortion.
      h = sqrt(ex) * ensigx
      v = ey * ensigy**2 / h
      disth1(1) = h * sum1(1) * 3.0
      disth1(2) = h * sum1(2)
      disth1(3) = v * sum1(3)
      disth1(4) = v * sum1(4)
      disth1(5) = v * sum1(5)
      distv1(1) = 0.0
      distv1(2) = 0.0
      distv1(3) = h * sum1(3) * 2.0
      distv1(4) = h * sum1(4) * 2.0
      distv1(5) = 0.0
      disth2(1) = h * sum2(1) * 3.0
      disth2(2) = h * sum2(2)
      disth2(3) = v * sum2(3)
      disth2(4) = v * sum2(4)
      disth2(5) = v * sum2(5)
      distv2(1) = 0.0
      distv2(2) = 0.0
      distv2(3) = h * sum2(3) * 2.0
      distv2(4) = h * sum2(4) * 2.0
      distv2(5) = 0.0

*---- Sum up.
      dh1 = sqrt(disth1(1)**2 + disth1(2)**2 + disth1(3)**2 +
     +           disth1(4)**2 + disth1(5)**2)
      dh2 = sqrt(disth2(1)**2 + disth2(2)**2 + disth2(3)**2 +
     +           disth2(4)**2 + disth2(5)**2)
      dv1 = sqrt(distv1(1)**2 + distv1(2)**2 + distv1(3)**2 +
     +           distv1(4)**2 + distv1(5)**2)
      dv2 = sqrt(distv2(1)**2 + distv2(2)**2 + distv2(3)**2 +
     +           distv2(4)**2 + distv2(5)**2)

*---- Output.
      if (iprint .gt. 0) then
        write (iqpr2, 910)
        write (iqpr2, 930)
        write (iqpr2, 940) (sum1(i), i = 1, nres)
        write (iqpr2, 950) (disth1(i), i = 1, nres)
        write (iqpr2, 960) (distv1(i), i = 1, nres)
        if (symm) then
          write (iqpr2, 920)
          write (iqpr2, 930)
          write (iqpr2, 940) (sum2(i), i = 1, nres)
          write (iqpr2, 950) (disth2(i), i = 1, nres)
          write (iqpr2, 960) (distv2(i), i = 1, nres)
        endif
      endif

  910 format(' '/' '/' Resonance coefficients at interaction point:')
  920 format(' '/' Resonance coefficients at symmetry point:')
  930 format(' resonances',t38,'3000',12x,'2100',12x,'1020',12x,
     +                         '1002',12x,'1011')
  940 format(' coefficients',t26,1p,5e16.6)
  950 format(' horizontal  ',t26,1p,5e16.6)
  960 format(' vertical    ',t26,1p,5e16.6)

      end
+dk harsig
      subroutine harsig(acode, n1, n2, np, sum, rsum)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Integrate resonance functions along all specified sextupoles.      *
* Input:                                                               *
*   ACODE     (logical) True: Include dispersion.                      *
*   CLASS     (char)    Name of sextupole class.                       *
*   N1,N2,NP  (integer  Resonance integers:                            *
*                       N1 * QX + N2 * QY = NP.                        *
* Output:                                                              *
*   SUM(2)    (real)    Cosine and sine terms of resonance integral.   *
*   RSUM      (real)    Random terms of resonance integral.            *
*----------------------------------------------------------------------*
+ca aparam
      integer ienum,iflag,iocc,ipos,n1,n2,na1,na2,np
      double precision a1,a2,angle,ans1,ans2,b1,b2,el,fb1,fb2,fn1,fn2,
     +fnp,fs,rsum,sk1l,sk2l,sk3l,sk4l,sum,th1,th2,twelve,two,twopi
      logical           acode
      dimension         sum(2)
+ca memdum
+ca bankhead
+ca prcgroup
+ca beam
+ca halbuf
+ca halink
+ca optic0
+ca range
+ca refer

+ca pi
      parameter         (two = 2.0d0, twelve = 12.0, twopi = two * pi)

      character*(mcnam) elmnam

*---- Loop for all elements.
      sum(1) = 0.0
      sum(2) = 0.0
      rsum = 0.0
      fn1 = n1
      fn2 = n2
      fnp = np
      na1 = abs(n1)
      na2 = abs(n2)

      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        if (iq(lcelm+mbpr) .eq. mpelm) then

*---- Find sextupole strength.
          call hastrg(angle, sk1l, sk2l, sk3l, sk4l)
          if (sk2l .ne. 0.0) then

*---- Fetch lattice functions at both ends.
            call tbset(lhaltb, ipos - 1, 1, lhalbf)
            call ucopy(q(lhalbf+1), bx1, iq(lhalbf-1))
            call tbset(lhaltb, ipos, 1, lhalbf)
            call ucopy(q(lhalbf+1), bx2, iq(lhalbf-1))

*---- If DISP has not been specified, change dispersion to 1.
            if (.not. acode) then
              dx1 = 1.0
              dx2 = 1.0
              dpx1 = 0.0
              dpx2 = 0.0
            endif

*---- Integrate over long element.
            el = s2 - s1
            fb1 = sk2l * sqrt(bx1)**na1 * sqrt(by1)**na2
            fb2 = sk2l * sqrt(bx2)**na1 * sqrt(by2)**na2
            fs = twopi * (fn1*qx + fn2*qy - fnp) / circ
            th1 = fn1*amux1 + fn2*amuy1 - fs*s1
            th2 = fn1*amux2 + fn2*amuy2 - fs*s2
            a1 = dx1 * (fn1/bx1 + fn2/by1 - fs) * el / twelve
            a2 = dx2 * (fn1/bx2 + fn2/by2 - fs) * el / twelve
            b1 = dx1/two + (el/twelve) *
     +           (dpx1 - dx1 * (fn1*ax1/bx1 + fn2*ay1/by1))
            b2 = dx2/two - (el/twelve) *
     +           (dpx2 - dx2 * (fn1*ax2/bx2 + fn2*ay2/by2))
            ans1 = fb1 * (b1*cos(th1) - a1*sin(th1))
     +           + fb2 * (b2*cos(th2) + a2*sin(th2))
            ans2 = fb1 * (b1*sin(th1) + a1*cos(th1))
     +           + fb2 * (b2*sin(th2) - a2*cos(th2))

*---- Sum up.
            sum(1) = sum(1) + ans1
            sum(2) = sum(2) + ans2
            rsum = rsum + ans1**2 + ans2**2
          endif
        endif
   90 continue

*---- Apply constant coefficients.
      if (symm) then
        sum(1) = nsup * sum(1) / pi
        sum(2) = 0.0
        rsum = sqrt(two * nsup * rsum) / pi
      else
        sum(1) = nsup * sum(1) / twopi
        sum(2) = nsup * sum(2) / twopi
        rsum = sqrt(nsup * rsum) / pi
      endif

      end
+dk hashrt
      subroutine hashrt
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Set up "short" table of linear lattice functions for HARMON.       *
*   This routine assumes that the temporary links for HARMON are       *
*   already active; and that the "long" table has been set up.         *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca prcgroup
+ca seqgroup
+ca hacomm
+ca halbuf
+ca halink
+ca hasbuf
+ca range
+ca refer
+ca status
      integer ienum,iflag,iocc,ipos,nrow
      double precision el,twopi

+ca pi
      parameter         (twopi = 2.0 * pi)
      character*(mcnam) colnam(mscol), elmnam
      integer           icform(mscol)

      data colnam
     +  / 'BXBAR',  'BYBAR',  'DXBAR',  'DYBAR',   'MUXBAR', 'MUYBAR',
     +    'BXBARP', 'BYBARP', 'DXBARP', 'DXBARPP', 'DYBARP', 'DYBARPP' /
      data icform       / mscol * mreal /

*---- Set up table buffer for averaged optical functions.
*     "long" table is already open.
      nrow = iq(lq(lcseq-msdir)-1)
      call tbcrea(shtnam, 1, nrow, mscol, colnam, icform, 1, lhastb)
      if (error) go to 9999

*---- Loop on beam range.
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)

*---- Fetch lattice parameters for both ends.
        if (iq(lcelm+mbpr) .eq. mpelm) then
          call tbset(lhaltb, ipos - 1, 1, lhalbf)
          call ucopy(q(lhalbf+1), bx1, iq(lhalbf-1))
          call tbset(lhaltb, ipos, 1, lhalbf)
          call ucopy(q(lhalbf+1), bx2, iq(lhalbf-1))

*---- Calculate averaged lattice parameters.
          el = s2 - s1
          bxb = (bx1 + bx2) / 2.0 + (ax2 - ax1) * el/6.0
          byb = (by1 + by2) / 2.0 + (ay2 - ay1) * el/6.0
          dxb = (dx1 + dx2) / 2.0 - (dpx2 - dpx1) * el/12.0
          dyb = (dy1 + dy2) / 2.0 - (dpy2 - dpy1) * el/12.0
          amuxb = (amux1 + amux2) / 2.0 - (el / bx2 - el / bx1) / 12.0
          amuyb = (amuy1 + amuy2) / 2.0 - (el / by2 - el / by1) / 12.0

*---- Save averaged lattice parameters.
          call tbset(lhastb, ipos, 3, lhasbf)
          if (lhasbf .ne. 0) then
            call ucopy(bxb, q(lhasbf+1), iq(lhasbf-1))
          endif
        endif
   90 continue

*---- Tables remain open.

 9999 end
+dk hastrg
      subroutine hastrg(angle, sk1l, sk2l, sk3l, sk4l)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Return multipole strengths (dipole through octupole).              *
*   Uses current element pointer.                                      *
* Output:                                                              *
*   ANGLE     (real)    Deflection angle for dipole    (K0 * L).       *
*   SK1L      (real)    Integrated quadrupole strength (K1 * L).       *
*   SK2L      (real)    Integrated sextupole strength  (K2 * L).       *
*   SK3L      (real)    Integrated octupole strength   (K3 * L).       *
*   SK4L      (real)    Integrated decapole strength   (K4 * L).       *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca option
+ca prcgroup
+ca refer
      integer isp
      double precision an2,angle,el,sk1,sk1l,sk2,sk2l,sk3,sk3l,sk4l

*---- Initialize.
      angle = 0.0
      sk1l  = 0.0
      sk2l  = 0.0
      sk3l  = 0.0
      sk4l  = 0.0

*---- Test for beam element.
      if (iq(lcelm+mbpr) .eq. mpelm) then
        isp = iq(lcelm+mbsp)

*---- Quadrupole.
        if (isp .eq. 5) then
          call ucopy(q(lcelm+melen), el, mwflt)
          call ucopy(q(lcelm+mek1q), sk1, mwflt)
          sk1l = el * sk1

*---- Sextupole.
        else if (isp .eq. 6) then
          call ucopy(q(lcelm+melen), el, mwflt)
          call ucopy(q(lcelm+mek2s), sk2, mwflt)
          sk2l = el * sk2
*---- Octupole.
        else if (isp .eq. 7) then
          call ucopy(q(lcelm+melen), el, mwflt)
          call ucopy(q(lcelm+mek3o), sk3, mwflt)
          sk3l = el * sk3

*---- Multipole.
        else if (isp .eq. 8) then
          call ucopy(q(lcelm+meklm), angle, mwflt)
          call ucopy(q(lcelm+meklm+2*mcsiz), sk1l, mwflt)
          call ucopy(q(lcelm+meklm+4*mcsiz), sk2l, mwflt)
          call ucopy(q(lcelm+meklm+6*mcsiz), sk3l, mwflt)
          call ucopy(q(lcelm+meklm+8*mcsiz), sk4l, mwflt)

*---- Dipole.
        else if (isp .eq. 2  .or.  isp .eq. 3) then
          call ucopy(q(lcelm+meangb), angle, mwflt)
          call ucopy(q(lcelm+melen), el, mwflt)
          call ucopy(q(lcelm+mek1b), sk1, mwflt)
          call ucopy(q(lcelm+mek2b), sk2, mwflt)
          call ucopy(q(lcelm+mek3b), sk3, mwflt)
*--- HG001026: arc length to rectangular bend
          if (isp .eq. 2)  then
            an2 = angle / 2.d0
            if (an2 .ne. 0.d0 .and. rbarc)  el = el * an2 / sin(an2)
          endif
          sk1l = el * sk1
          sk2l = el * sk2
          sk3l = el * sk3

*---- General bend (dipole, quadrupole, and skew quadrupole).
        else if (isp .eq. 26) then
          call ucopy(q(lcelm+meangg), angle, mwflt)
          call ucopy(q(lcelm+melen), el, mwflt)
          call ucopy(q(lcelm+mek1g), sk1, mwflt)
          sk1l = el * sk1
        endif
      endif

      end
+dk hathin
      subroutine hathin(iprint)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print results of HARMON functions.                                 *
* Input:                                                               *
* IPRINT      (integer) Print flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
+ca hafbad
+ca zunit
      integer iprint
      double precision xix2,xix3,xiy2,xiy3

      dimension         xix2(2), xiy2(2), xix3(3), xiy3(3)

*---- Dispersion function of order two and three.
*     HADDSP must always be run first.
      call haddsp(iprint, hfun(10), hfun(11), hfun(16), hfun(17))

*---- (delta beta)/beta.
      call hadbet(iprint, hfun(12), hfun(13), hfun(18), hfun(19))

*---- Resonance parameters.
      call hareso(iprint, hfun(14), hfun(15), hfun(20), hfun(21))

*---- Tune shift with momentum.
      call hachcl(hfun(1), hfun(2))
      call hadtun(xix2, xiy2, xix3, xiy3)
      hfun(3) = xix2(1) + xix2(2)
      hfun(4) = xiy2(1) + xiy2(2)
      hfun(5) = xix3(1) + xix3(2) + xix3(3)
      hfun(6) = xiy3(1) + xiy3(2) + xiy3(3)
      if (iprint .gt. 0) then
        write (iqpr2, 910)
        if (iprint .gt. 1) then
          write (iqpr2, 920) hfun(1), xix2(1), xix3(1),
     +                       hfun(2), xiy2(1), xiy3(1)
          write (iqpr2, 930) xix2(2), xix3(2), xiy2(2), xiy3(2)
          write (iqpr2, 940) xix3(3), xiy3(3)
          write (iqpr2, 950) hfun(1), hfun(3), hfun(5),
     +                       hfun(2), hfun(4), hfun(6)
        else
          write (iqpr2, 960) hfun(1), hfun(3), hfun(5),
     +                       hfun(2), hfun(4), hfun(6)
        endif
      endif

*---- Tune shift with amplitude.
      call haatun(iprint, hfun(7), hfun(8), hfun(9))

  910 format(' '/' Derivatives of tune w.r.t. momentum:'/
     +       t19,'h o r i z o n t a l',t69,'v e r t i c a l'/
     +       t13,'first',t28,'second',t45,'third',
     +       t61,'first',t76,'second',t93,'third')
  920 format(' ',1p,6e16.6,' (simple integrals)')
  930 format(' ',1p,16x,2e16.6,16x,2e16.6,' (double integrals)')
  940 format(' ',1p,32x,e16.6,32x,e16.6,' (triple integrals)')
  950 format(' ',1p,6e16.6,' (total)'/' ')
  960 format(' ',1p,6e16.6/' ')

      end
+dk hatune
      subroutine hatune
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Tune sextupole classes to adjust chromaticities; HTUNE command.    *
* Attributes:                                                          *
*   QX'       (real)    Horizontal chromaticity desired.               *
*   QY'       (real)    Vertical chromaticity desired.                 *
*   TOLERANCE (real)    Tolerance permitted.                           *
*----------------------------------------------------------------------*
+ca aparam
+ca mchpar
+ca minuit
+ca refer
+ca status
+ca zunit
      double precision data,prc,xix,xiy

      dimension         data(3)

*---- Retrieve desired chromaticitiy values.
      data(1) = 0.0
      data(2) = 0.0
      data(3) = 0.0
      call utgflt(lccmd, 1, 3, data)
      xix = data(1)
      xiy = data(2)
      prc = max(data(3),epsmch)

*---- Check for presence of variables.
      if (nvar .lt. 2) then
        call aawarn(crout, 1,
     +  'Cannot tune chromaticities, need at least 2 variables.')

*---- Execute fit.
      else
        call prpage(iqpr2)
        call prline(iqpr2)
        write (iqpr2, 910) xix, xiy
        call hacfit(.true., xix, xiy, prc)
      endif

  910 format(' '/' Tuning sextupoles for Qx'' = ',f12.6,', Qy'' = ',
     +       f12.6,'.')

      end
+dk havary
      subroutine havary
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Define variable sextupole; HVARY command.                          *
* Attributes:                                                          *
*   NAME      (name)    Parameter name.                                *
*   STEP      (real)    Step size (ignored).                           *
*   LOWER     (real)    Lower limit.                                   *
*   UPPER     (real)    Upper limit.                                   *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca matgroup
+ca prcgroup
+ca vargroup
+ca message
+ca keyword
+ca mtlink
+ca mtcvar
+ca minuit
+ca refer
+ca status
+ca wstack
+ca datatype
      integer idata,iref,jref
      double precision temp

      character*(mcnam) atrnam
      logical           isnotk, isleng, skip

*---- Variable name is required.
      call mtvfnd('HVARY', skip)
      if (.not. (skip .or. error)) then

*---- Parameter should be sextupole strength.
        lref = lq(lptr-1)
        isnotk = .true.
        isleng = .false.
        if (iq(lref+mbpr) .eq. mpelm) then
          call uhtoc(q(lptr+mvattr), mcwrd, atrnam, mcnam)
          isnotk = atrnam(1:1) .ne. 'K'
          isleng = atrnam .eq. 'L'
        endif
        if (isnotk) then
          msg(1) = 'Parameter may not refer to a multipole strength,'
          msg(2) = 'Variation may perturb the linear optics.'
          call rdwarn('HAVARY', 2, msg)
        endif

*---- Parameter should be real.
        iref = iq(lptr+mvbias)
        jref = mbat + (iref - 1) * mcsiz
        if (iq(lref+jref+mctyp) / 10 .ne. mtflt) then
          call rdfail('HAVARY', 1, 'Parameter is not real value.')
          go to 9999
        endif

*---- Dependent parameter becomes independent, if varied.
        lcexp = lq(lref-iref)
        if (lcexp .ne. 0) then
          call rdwarn('HAVARY', 1,
     +    'Parameter depends on other values --- dependence ignored.')
          call aadrop(lcexp)
          iq(lref+iref+mctyp) = 10*mtflt + 1

*---- Should not vary an element length directly.
        else if (isleng) then
          msg(1) = 'You are varying an element length,'
          msg(2) = 'This may cause the system length to change.'
          call rdwarn('HAVARY', 2, msg)
        endif

*---- Check step size and limits.
        vstep = 0.0
        vmin = 0.0
        vmax = 0.0
        call utgflt(lccmd, 2, 4, vstep)
        ivcode = 0
        idata = mbat + 2*mcsiz
        if (mod(iq(lccmd+idata+mctyp),10) .ne. 0) ivcode = ivcode + 1
        idata = idata + mcsiz
        if (mod(iq(lccmd+idata+mctyp),10) .ne. 0) ivcode = ivcode + 2
        if (ivcode .eq. 3  .and.  vmin .gt. vmax) then
          msg(1) = 'Upper and lower limits interchanged.'
          call rdwarn('HAVARY', 1, msg)
          temp = vmin
          vmin = vmax
          vmax = temp
        endif

*---- Previously variable parameter?
        if (lvar .ne. 0) then
          call rdwarn('HAVARY', 1,
     +    'Parameter is already variable --- new data will been used.')
        else
          call mzbook(2, lvar, lmvar, 1, 'BVAR', 1, 0, mmsiz, 7, 0)
          nvar = nvar + 1
        endif

*---- Copy data to variable bank.
        lq(lvar-1) = lref
        iq(lvar+mmf1) = 16*2 + 2
        iq(lvar+mmcode) = ivcode
        iq(lvar+mmbias) = iref
        iq(lvar+mmf2) = 16*3*mwflt + mreal
        call ucopy(vstep, q(lvar+mmdata), 3*mwflt)
        iq(lvar+mmf3) = 16*2*mwnam + 5
        call ucopy(q(lptr+mvbank), q(lvar+mmbnam), 2*mwnam)

*---- Mark working space as outdated.
        iwork = 0
        nwork = 0
        icovar = 0
      endif

 9999 end
+dk haweig
      subroutine haweig
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Set the weights for minimization. HWEIGHT command.                 *
* Weights for penalty functions:                                       *
*   QX'',  QY''              Second momentum derivatives of tunes.     *
*   QX''', QY'''             Third momentum derivatives of tunes.      *
*   DQXDEX, DQYDEY, DQYDEX   Anharmonicities.                          *
*   DX'I,  DX''I             Derivatives of dispersion (int. point).   *
*   BX'I,  BY'I              Derivatives of beta's     (int. point).   *
*   RXI,   RYI               Resonances                (int. point).   *
*----------------------------------------------------------------------*
+ca aparam
+ca hafbad
+ca refer
      integer i

      hwei(1) = 1.0
      hwei(2) = 1.0
      do 10 i = 3, mhfun
        hwei(i) = 0.0
   10 continue
      call utgflt(lccmd, 1, mhfun, hwei)

      end
+dk ha4ana
      subroutine ha4ana
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Analyse the fourth order effects of sextupoles,                    *
*   Fourth order meaning octupole effects = quarter integer effects.   *
*----------------------------------------------------------------------*
+ca aparam
+ca beam
+ca hacomm
+ca range
+ca zunit
      integer igo,ip,j0,k0,l0,m0,n1,n2,np
      double precision ans1,ans2,ans3,beat4,des,dqde,dqdy,dqs,dqs20,
     +dqx4,dqxdey,dqy4,dqydex,ex0,ey0,fact4,fn1,fn2,g,g0022,g0040,g1111,
     +g2002,g2020,g2200,g4000,gmod

      parameter         (beat4 = 1.553774d0, fact4 = 1.446735d0)

      dimension         ans1(2),  ans2(2),  ans3(2),  g(2)
      dimension         g2200(2), g0022(2), g1111(2), g4000(2),
     +                  g0040(2), g2020(2), g2002(2)
      logical first

*---- Fourth order effects of sextupoles.
      write (iqpr2, 910)
      ex0 = ex * ensigx**2
      ey0 = ey * ensigy**2

*==== Q shift effects.
*---- G2200.
      write (iqpr2, 920)
*     IF (.NOT. SKEW) THEN
        call ha4sum(3, 0, 0, 0, 0, 3, 0, 0, 0, ans1)
        call ha4sum(2, 1, 0, 0, 1, 2, 0, 0, 0, ans2)
        g2200(1) = - 9.0*ans1(1) - 3.0*ans2(1)
        g2200(2) = - 9.0*ans1(2) - 3.0*ans2(2)
*     ELSE
*       CALL HA4SUM(2, 0, 1, 0, 0, 2, 0, 1, 0, ANS1)
*       CALL HA4SUM(0, 2, 1, 0, 2, 0, 0, 1, 0, ANS2)
*       CALL HA4SUM(1, 1, 1, 0, 1, 1, 0, 1, 0, ANS3)
*       G2200(1) = - (ANS1(1) + ANS2(1) + ANS3(1))
*       G2200(2) = - (ANS1(2) + ANS2(2) + ANS3(2))
*     ENDIF
      dqde = 2.0 * g2200(1)
      dqx4 = dqde * ex0
      write (iqpr2, 930) g2200, dqde, dqx4

*---- G00220.
*     IF (.NOT. SKEW) THEN
        call ha4sum(1, 0, 2, 0, 0, 1, 0, 2, 0, ans1)
        call ha4sum(1, 0, 0, 2, 0, 1, 2, 0, 0, ans2)
        call ha4sum(1, 0, 1, 1, 0, 1, 1, 1, 0, ans3)
        g0022(1) = - (ans1(1) + ans2(1) + ans3(1))
        g0022(2) = - (ans1(2) + ans2(2) + ans3(2))
*     ELSE
*       CALL HA4SUM(0, 0, 3, 0, 0, 0, 0, 3, 0, ANS1)
*       CALL HA4SUM(0, 0, 2, 1, 0, 0, 1, 2, 0, ANS2)
*       G0022(1) = - 9.0*ANS1(1) - 3.0ANS2(1)
*       G0022(2) = - 9.0*ANS1(2) - 3.*ANS2(2)
*     ENDIF
      dqde = 2.0 * g0022(1)
      dqdy = dqde * ey0
      write (iqpr2, 940) g0022, dqde, dqdy

*---- G11110.
*     IF (.NOT. SKEW) THEN
        call ha4sum(1, 0, 2, 0, 0, 1, 0, 2, 0, ans1)
        call ha4sum(0, 1, 2, 0, 1, 0, 0, 2, 0, ans2)
        call ha4sum(2, 1, 0, 0, 0, 1, 1, 1, 0, ans3)
*     ELSE
*       CALL HA4SUM(2, 0, 0, 1, 0, 2, 1, 0, 0, ANS1)
*       CALL HA4SUM(2, 0, 1, 0, 0, 2, 0, 1, 0, ANS2)
*       CALL HA4SUM(0, 0, 2, 1, 1, 1, 0, 1, 0, ANS3)
*     ENDIF

*---- Third term is 2 * (ANS3 + CONJG(ANS3)).
      g1111(1) = - 4.0 * (ans1(1) + ans2(1) + ans3(1))
      g1111(2) = - 4.0 * (ans1(2) + ans2(2))
      dqxdey = g1111(1)
      dqydex = dqxdey
      dqx4 = dqxdey * ey0
      dqy4 = dqydex * ex0
      write (iqpr2, 950) g1111, dqxdey, dqydex, dqx4, dqy4

*==== Resonance effects.
      first = .true.

*---- G4000p.
   70 continue
      write (iqpr2, 960)
      np = int(4.0 * qx / nsup)
      if (.not. first) np = np + 1
*     IF (.NOT. SKEW) THEN
        call ha4sum(2, 1, 0, 0, 3, 0, 0, 0, np, g4000)
        g(1) = 3.0 * g4000(1)
        g(2) = 3.0 * g4000(2)
*     ELSE
*       CALL HA4SUM(2, 0, 0, 1, 2, 0, 1, 0, NP, G4000)
*       G(1) = G4000(1)
*       G(2) = G4000(2)
*     ENDIF
      j0 = 4
      k0 = 0
      l0 = 0
      m0 = 0
      assign 80 to igo
      go to 120

*---- G0040p.
   80 continue
      np = int(4.0 * qy / nsup)
      if (.not. first) np = np + 1
*     IF (.NOT. SKEW) THEN
        call ha4sum(0, 1, 2, 0, 1, 0, 2, 0, np, g0040)
        g(1) = g0040(1)
        g(2) = g0040(2)
*     ELSE
*       CALL HA4SUM(0, 0, 2, 1, 0, 0, 3, 0, NP, G0040)
*       G(1) = 3.0 * G0040(1)
*       G(2) = 3.0 * G0040(2)
*     ENDIF
      j0 = 0
      l0 = 4
      assign 90 to igo
      go to 120

*---- G2020.
   90 continue
      np = int((2.0 * qx + 2.0 * qy) / nsup)
      if (.not. first) np = np + 1
*     IF (.NOT. SKEW) THEN
        call ha4sum(2, 1, 0, 0, 1, 0, 2, 0, np, ans1)
        call ha4sum(0, 1, 2, 0, 3, 0, 0, 0, np, ans2)
        call ha4sum(1, 0, 1, 1, 1, 0, 2, 0, np, ans3)
        g2020(1) = ans1(1) + 3.0*ans2(1) + 2.0*ans3(1)
        g2020(2) = ans1(2) + 3.0*ans2(2) + 2.0*ans3(2)
*     ELSE
*       CALL HA4SUM(1, 1, 1, 0, 2, 0, 1, 0, NP, ANS1)
*       CALL HA4SUM(0, 0, 2, 1, 2, 0, 1, 0, NP, ANS2)
*       CALL HA4SUM(2, 0, 0, 1, 0, 0, 3, 0, NP, ANS3)
*       G2020(1) = 2.0*ANS1(1) + ANS2(1) + 3.0*ANS3(1)
*       G2020(2) = 2.0*ANS1(2) + ANS2(2) + 3.0*ANS3(2)
*     ENDIF
      j0 = 2
      l0 = 2
      g(1) = g2020(1)
      g(2) = g2020(2)
      assign 150 to igo

*==== Resonance widths.
  120 continue
      n1 = j0 + k0
      n2 = l0 + m0
      fn1 = n1
      fn2 = n2
      g(1) = - g(1)
      g(2) = - g(2)
      gmod = sqrt(g(1)**2 + g(2)**2)
      des = gmod * sqrt(ex0)**n1 * sqrt(ey0)**n2 *
     +      (fn1**2 / ex0 + fn2**2 / ey0)
      dqs = des * beat4**2 / sqrt(fn1**2 + fn2**2)
      dqs20 = dqs * fact4
      ip = nsup * np
      write (iqpr2, 970) j0, k0, l0, m0, ip, g, des, dqs, dqs20
      go to igo, (80, 90, 150)

*==== Difference resonances.
*---- G2002.
  150 continue
      np = int((2.0 * qx - 2.0 * qy) / nsup)
      if (.not. first) np = np + 1
*     IF (.NOT. SKEW) THEN
        call ha4sum(2, 1, 0, 0, 1, 0, 0, 2, np, ans1)
        call ha4sum(0, 1, 0, 2, 3, 0, 0, 0, np, ans2)
        call ha4sum(1, 0, 1, 1, 1, 0, 0, 2, np, ans3)
        g2002(1) = ans1(1) + 3.0*ans2(1) + 2.0*ans3(1)
        g2002(2) = ans1(2) + 3.0*ans2(2) + 2.0*ans3(2)
*     ELSE
*       CALL HA4SUM(1, 1, 0, 1, 2, 0, 0, 1, NP, ANS1)
*       CALL HA4SUM(0, 0, 1, 2, 2, 0, 0, 1, NP, ANS2)
*       CALL HA4SUM(2, 0, 1, 0, 0, 0, 0, 3, NP, ANS3)
*       G2002(1) = 2.0*ANS1(1) + ANS2(1) + 3.0*ANS3(1)
*       G2002(2) = 2.0*ANS1(2) + ANS2(2) + 3.0*ANS3(2)
*     ENDIF
      gmod = sqrt(g2002(1)**2 + g2002(2)**2)
      ip = nsup * np
      write (iqpr2, 980) ip, g2002, gmod

*---- Set up for resonances above the working point.
      if (.not. first) return
      first = .false.
      go to 70

  910 format(' '/' Fourth order effects of sextupoles:')
  920 format(' '/' Q shift effects')
  930 format(' '/20x,'G95000',6x,'dQx/dEx',10x,'dQx'/1p,4e13.5)
  940 format(' '/20x,'G00950',6x,'dQy/dEy',10x,'dQy'/1p,4e13.5)
  950 format(' '/20x,'G11110',6x,'dQx/dEy',6x,'dQy/dEx',10x,'dQx',10x,
     +       'dQy'/1p,6e13.5)
  960 format(' '/' Resonance effects')
  970 format(' '/22x,'cos',9x,'sin',10x,'dE',10x,'dQ',6x,'dQ(20)'/
     +       ' G',4i1,',',i3,3x,1p,5e12.4)
  980 format(' '/22x,'cos',9x,'sin',5x,'modulus'/
     +       ' G2002',',',i3,3x,1p,3e12.4)

      end
+dk ha4sum
      subroutine ha4sum(jp, kp, lp, mp, jpp, kpp, lpp, mpp, ip, sm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Evaluate quarter integer resonances for use in HA4ANA.             *
* Input:                                                               *
*   JP,KP,LP,MP         Indices for first factor.                      *
*   JPP,KPP,LPP,MPP     Indices for second factor.                     *
*   IP                  Value of p in n1*Qx + n2*Qy = p.               *
* Output:                                                              *
*   SM(2)     (real)    Computed resonance integrals.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer ienum,iflag,iocc,ip,ipos,jp,jpp,kp,kpp,lp,lpp,mp,mpp,n1p,
     +n1pp,n2p,n2pp,na1p,na1pp,na2p,na2pp,np,npp
      double precision a1,a2,amuxb,amuyb,angle,b1,b2,betap,betapp,ccp,
     +ccpp,cospiq,el,factor,one,phip,phipp,scp,scpp,sinpiq,sk1l,sk2l,
     +sk3l,sk4l,sm,ssp,sspp,sum1,sum11,sum12,sum2,sum21,sum22,sup,tcp,
     +tcpp,thetan,tsp,tspp,tune,twelve,two,twopi
      dimension         sm(2)
+ca memdum
+ca bankhead
+ca prcgroup
+ca beam
+ca halbuf
+ca halink
+ca optic0
+ca range
+ca refer

+ca pi
      parameter         (one = 1.0d0, two = 2.0d0, twelve = 12.0d0)
      parameter         (twopi = two * pi)

      character*(mcnam) elmnam

      na1p   = jp + kp
      na2p   = lp + mp
      np     = na1p + na2p
      na1pp  = jpp + kpp
      na2pp  = lpp + mpp
      npp    = na1pp + na2pp
      n1p    = jp - kp
      n2p    = lp - mp
      n1pp   = jpp - kpp
      n2pp   = lpp - mpp
      sup    = nsup
      ccp    = sup * (- one) ** ((na2p + 1) / 2) / (two**np * pi *
     +         factor(jp) * factor(kp) * factor(lp) * factor(mp))
      ccpp   = sup * (- one) ** ((na2pp + 1) / 2) / (two**npp * pi *
     +         factor(jpp) * factor(kpp) * factor(lpp) * factor(mpp))

      tune = (n1p * qx + n2p * qy) / sup
      cospiq = cos(pi * tune)
      sinpiq = sin(pi * tune)

*---- Clear simple sums.
      scp = 0.0
      ssp = 0.0
      scpp = 0.0
      sspp = 0.0

*---- Clear double sums.
      sum1 = 0.0
      sum2 = 0.0
      sum11 = 0.0
      sum12 = 0.0
      sum21 = 0.0
      sum22 = 0.0

*---- Loop for all elements.
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        if (iq(lcelm+mbpr) .eq. mpelm) then

*---- Find sextupole strength.
          call hastrg(angle, sk1l, sk2l, sk3l, sk4l)
          if (sk2l .ne. 0.0) then

*---- Fetch lattice functions at both ends.
            call tbset(lhaltb, ipos - 1, 1, lhalbf)
            call ucopy(q(lhalbf+1), bx1, iq(lhalbf-1))
            call tbset(lhaltb, ipos, 1, lhalbf)
            call ucopy(q(lhalbf+1), bx2, iq(lhalbf-1))

*---- Averaged arc length.
            el = s2 - s1
            thetan = sup * pi * (s2 + s1) / circ

            b1 = sqrt(bx1)**na1p * sqrt(by1)**na2p
            b2 = sqrt(bx2)**na1p * sqrt(by2)**na2p
            a1 = na1p * ax1 / bx1 + na2p * ay1 / by1
            a2 = na1p * ax2 / bx2 + na2p * ay2 / by2
            betap = sk2l * ((b2 + b1) / two + el * (a2 - a1) / twelve)

            b1 = sqrt(bx1)**na1pp * sqrt(by1)**na2pp
            b2 = sqrt(bx2)**na1pp * sqrt(by2)**na2pp
            a1 = na1pp * ax1 / bx1 + na2pp * ay1 / by1
            a2 = na1pp * ax2 / bx2 + na2pp * ay2 / by2
            betapp = sk2l * ((b2 + b1) / two + el * (a2 - a1) / twelve)

*---- Averaged phase functions.
            amuxb = (amux2 + amux1)/two - el*(one/bx2 - one/bx1)/twelve
            amuyb = (amuy2 + amuy1)/two - el*(one/by2 - one/by1)/twelve
            phip = n1p * (amuxb - qx * thetan / sup)
     +           + n2p * (amuyb - qy * thetan / sup)
     +           + tune * thetan
            phipp = n1pp * (amuxb - qx * thetan / sup)
     +            + n2pp * (amuyb - qy * thetan / sup)
     +            + (ip - tune) * thetan

*---- Terms to be integrated.
            tcp = betap * cos(phip)
            tsp = betap * sin(phip)
            tcpp = betapp * cos(phipp)
            tspp = betapp * sin(phipp)

*---- Machine is symmetric.
            if (symm) then
              sum1 = sum1 + tcp  * (tcpp + two * scpp)
     +                    + tcpp * (tcp  + two * scp)
              sum2 = sum2 + tsp  * (tcpp + two * scpp)
     +                    - tspp * (tcp  + two * scp)

*---- Machine is asymmetric.
            else
              sum1 = sum1 + (tcp * tcpp - tsp * tspp)
              sum2 = sum2 + (tsp * tcpp + tcp * tspp)
              sum11 = sum11 + (tcp * scpp - tsp * sspp)
              sum12 = sum12 + (tcpp * scp - tspp * ssp)
              sum21 = sum21 + (tsp * scpp + tcp * sspp)
              sum22 = sum22 + (tspp * scp + tcpp * ssp)
            endif

*---- Accumulate partial sums for next pass (sum from 1 to i-1).
            ssp  = ssp  + tsp
            sspp = sspp + tspp
            scp  = scp  + tcp
            scpp = scpp + tcpp
          endif
        endif
   90 continue

      if (symm) then
        sm(1) = (twopi / (sup * sinpiq)) * ccp * ccpp *
     +          (cospiq * sum1 + sinpiq * sum2)
        sm(2) = 0.0
      else
        sm(1) = (pi / (sup * sinpiq)) * ccp * ccpp *
     +    (cospiq * (sum1 + sum11 + sum12) + sinpiq * (sum21 - sum22))
        sm(2) = (pi / (sup * sinpiq)) * ccp * ccpp *
     +    (cospiq * (sum2 + sum22 + sum21) + sinpiq * (sum12 - sum11))
      endif

      end
+dk hazzzz
+dk kwaaaa
+dk kwdim
      subroutine kwdim(ikat, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode keyword attribute types and dimensions.                     *
* Input:                                                               *
*   IKAT     (integer)  Attribute number.                              *
* Output:                                                              *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ikat,index,k,leng
      logical           eflag
+ca memdum
+ca message
+ca keyword
+ca stbuff
+ca datatype

      character*(mcnam) atrnam

      eflag = .false.

*---- Skip open parenthesis "(" or comma ",".
  100 continue
        jtok = jtok + 1

*---- Data type.
        k = index('NIRDLSBPCV', token(jtok))
        if (k .ne. 0  .and.  index('(*,', token(jtok+1)) .ne. 0) then
          iatype(ikat) = k
          jtok = jtok + 1

*---- Dimensions.
          iadim1(ikat) = 1
          iadim2(ikat) = 1
          iadim3(ikat) = 1
          if (token(jtok) .eq. '*') then
            jtok = jtok + 1
            call rdint(iadim1(ikat), eflag)
          else if (token(jtok) .eq. '(') then
            call dcindx(iadim1(ikat), iadim2(ikat), iadim3(ikat), eflag)
          endif
          if (eflag) go to 200

*---- New attribute name.
        else if (token(jtok) .eq. ':') then
          jtok = jtok + 1
          call rdword(atrnam, leng)
          if (leng .eq. 0) then
            call rdfail('KWDIM', 1,
     +      'New attribute name expected after ":".')
            go to 200
          else
            katnam(ikat) = atrnam
          endif

*---- Anything else is assumed to be data.
        else if (token(jtok).ne.')' .and. token(jtok).ne.';') then
          call rdfind(',);')
        endif
        if (token(jtok) .eq. ',') go to 100
        if (token(jtok) .eq. ')') go to 300
        msg(1)='Character "' // token(jtok) // '" is not allowed here.'
        call rdfail('KWDIM', 1, msg)

*---- Error recovery.
  200   continue
        call rdfind(',;)')
        eflag = .true.
      go to 100

*---- Skip closing parenthesis ")".
  300 continue
      jtok = jtok + 1

      end
+dk kwdump
      subroutine kwdump(lkey)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Dump a complete keyword bank.                                      *
* Input:                                                               *
*   LKEY(1)  (pointer)  Bank pointer.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer iln,ipr,isp,j,nkat
      integer           lkey(*)
+ca memdum
+ca bankhead
+ca keyword
+ca refer
+ca zunit

      character*(mcnam) label
      character*1       atype(10)
      data atype / 'N', 'I', 'R', 'D', 'L', 'S', 'B', 'R', 'C', 'V' /

*---- Copy data to local store.
      call diname(ldkey, iq(lkey(1)+mbnam), label)
      call kwget(lkey, iln, ipr, isp, nkat)

*---- Print header information.
      write (iqlog, 910) label, iln, ipr, isp

*---- Print attributes.
      if (nkat .gt. 0) then
        write (iqlog, 920)
        do 90 j = 1, nkat
          write (iqlog, 930) katnam(j), atype(iatype(j)),
     +      iadim1(j), iadim2(j), iadim3(j)
   90   continue
      endif
      write (iqlog, 940)

  910 format(' '/' KWDUMP.',t11,'Keyword name:',t31,a/
     +       t11,'Definition line:',t31,i8/
     +       t11,'Process code:',t31,i8/
     +       t11,'Subprocess code:',t31,i8)
  920 format(' '/t11,'Attribute',t23,'Type',t36,'Dim 1',t48,'Dim 2',
     +       t60,'Dim 3')
  930 format(t11,a,t24,a1,t36,i5,t48,i5,t60,i5)
  940 format(' ')

      end
+dk kwget
      subroutine kwget(lkey, iln, ipr, isp, nkat)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Get information for a keyword.                                     *
* Input:                                                               *
*   LKEY(1)  (pointer)  Bank pointer.                                  *
* Output:                                                              *
*   ILN      (integer)  Definition line.                               *
*   IPR      (integer)  Process code.                                  *
*   ISP      (integer)  Subprocess code.                               *
*   NKAT     (integer)  Number of attributes.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer ikat,iln,ipr,isp,l,nkat
      integer           lkey(*)
+ca memdum
+ca bankhead
+ca keygroup
+ca keyword

*---- Copy description words.
      iln = iq(lkey(1)+mbln)
      ipr = iq(lkey(1)+mbpr)
      isp = iq(lkey(1)+mbsp)
      nkat = iq(lkey(1)+mbat)

*---- Move attributes to keyword bank.
      l = lkey(1) + mbat
      do 90 ikat = 1, nkat
        iatype(ikat) = iq(l+mktype)
        iadim1(ikat) = iq(l+mkdim1)
        iadim2(ikat) = iq(l+mkdim2)
        iadim3(ikat) = iq(l+mkdim3)
        call uhtoc(q(l+mkname), mcwrd, katnam(ikat), mcnam)
        l = l + mksiz
   90 continue

      end
+dk kwgrp
      subroutine kwgrp(ikat, icat, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode keyword attribute group.                                    *
* Input:                                                               *
*   IKAT     (integer)  Attribute number (in keyword).                 *
*   ICAT     (integer)  Attribute number (in command).                 *
*   LCCMD    /REFER/    Pointer to keyword being decoded.              *
* Output:                                                              *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer i1,i2,icat,ikat,index,itype,jcat,k,kcode,lcat,nsize
      logical           eflag
+ca memdum
+ca message
+ca keyword
+ca refer
+ca stbuff
+ca datatype

      logical           sflag

      eflag = .false.
      kcode = 0
      nsize = iadim1(ikat) * iadim2(ikat) * iadim3(ikat)
      lcat = icat + nsize - 1
      jcat = icat

*---- Skip opening parenthesis "(" or comma ",".
  100 continue
        jtok = jtok + 1
        sflag = .false.

*---- Skip data type and dimensions.
        k = index('NIRDLSBPCV', token(jtok))
        if (k .ne. 0  .and.  index('(*,', token(jtok+1)) .ne. 0) then
          jtok = jtok + 1
          if (token(jtok) .eq. '(') then
            call rdform(i1, i2, sflag)
            if (sflag) go to 200
          endif
          call rdfind(',);')

*---- Skip attribute name.
        else if (token(jtok) .eq. ':') then
          call rdfind(',);')

*---- Anything else must be data.
        else
          if (token(jtok) .eq. '=') then
            jtok = jtok + 1
            kcode = 1
          endif
          if (kcode .ne. 0) then
            itype = iatype(ikat)
            call dcattr(itype, lq(lccmd-2), jcat, lcat, sflag)
            if (sflag) go to 200
          endif
        endif
        if (token(jtok) .eq. ',') go to 100
        if (token(jtok) .eq. ')') go to 300
        msg(1) =
     +  'Character "' // token(jtok) // '" is not allowed here.'
        call rdfail('KWGRP', 1, msg)

*---- Error recovery.
  200   continue
        call rdfind(',;)')
        eflag = .true.
      go to 100

*---- Skip closing parenthesis ")".
  300 continue
      jtok = jtok + 1

      end
+dk kwmain
      subroutine kwmain(label)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode keyword definition.                                         *
*   Uses the pointers to current keyword and current command.          *
* Input:                                                               *
*   LABEL    (char)     Label for keyword definition.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer icat,ikat,ileng,iln,isp,isrc,ival,jmark,kpr,ksp,leng,nkat
      character*(mcnam) label
+ca memdum
+ca bankhead
+ca message
+ca keyword
+ca option
+ca refer
+ca status
+ca stbuff
+ca zunit
+ca datatype

      character*(mcnam) atrnam, key, source
      logical           eflag
      integer           ia1(maxat)

*==== PHASE 1: Initialize according to command type.
      kpr = 0
      ksp = 0
      nkat = 0

*---- ISP = 2: Edit existing keyword.
      isp = iq(lckey+mbsp)
      if (isp .eq. 2) then
        if (token(jtok) .eq. ',') then
          jtok = jtok + 1
          call rdword(source, leng)
        else
          leng = 0
        endif
        if (leng .eq. 0) then
          call diname(ldkey, iq(lckey+mbnam), key)
          msg(1) = 'Source missing for "KEYDIT" command.'
          call rdfail('KWMAIN', 1, msg)
          go to 9999
        endif

*---- Find source keyword.
        call difind(ldkey, source, isrc, lcsrc)
        if (lcsrc .eq. 0) then
          call utleng(source, ileng)
          msg(1) =
     +    'Source keyword "' // source(1:ileng) // '" not found.'
          call rdfail('KWMAIN', 1, msg)
          go to 9999
        endif

*---- Copy source keyword to local store.
        call kwget(lcsrc, iln, kpr, ksp, nkat)
        do 10 ikat = 1, nkat
          ia1(ikat) = 0
   10   continue
      endif

*==== PHASE 2: Process code, subprocess code, attribute groups.
  100 if (token(jtok) .eq. ',') then
        jtok = jtok + 1

*---- Attribute name and equals sign.
        call rdword(atrnam, leng)
        if (leng .eq. 0) then
          call rdfail('KWMAIN', 1, 'Attribute name expected.')
          go to 200
        else if (token(jtok) .ne. '=') then
          call rdfail('KWMAIN', 1, 'Equals sign "=" expected.')
          go to 200
        else
          jtok = jtok + 1

*---- Attribute group, type part.
          if (token(jtok) .eq. '(') then
            call utlook(atrnam(1:leng), katnam, nkat, ikat)
            if (ikat .eq. 0) then
              nkat = nkat + 1
              ikat = nkat
              katnam(ikat) = atrnam
              iatype(ikat) = mtflt
              iadim1(ikat) = 1
              iadim2(ikat) = 1
              iadim3(ikat) = 1
            else if (isp .eq. 1) then
              call rdwarn('KWMAIN', 1, 'Duplicate attribute.')
            endif

*---- Mark begin of attribute group, decode data type and dimensions.
            ia1(ikat) = jtok
            call kwdim(ikat, eflag)
            if (eflag) go to 200

*---- Process or subprocess code.
          else
            call rdint(ival, eflag)
            if (eflag) go to 200
            if (atrnam .eq. 'PR') then
              kpr = ival
            else if (atrnam .eq. 'SP') then
              ksp = ival
            else
              call rdfail('KWMAIN', 1, 'Invalid attribute name.')
              go to 200
            endif
          endif
        endif
        if (token(jtok) .eq. ','  .or.  token(jtok) .eq. ';') go to 100
        msg(1) =
     +  'Character "' // token(jtok) // '" is not allowed here.'
        call rdfail('KWMAIN', 1, msg)

*---- Error recovery.
  200   continue
        call rdfind(',;')
        error = .true.
        go to 100
      endif

*==== PHASE 3: Decode template and default data.
      if (error) go to 9999

*---- Build keyword, default, and template banks.
      call kwmake(label, kpr, ksp, nkat)
      if (error) go to 9999

*---- Decode default data and template.
      jmark = jtok
      icat = 1
      do 290 ikat = 1, nkat
        if (ia1(ikat) .ne. 0) then
          jtok = ia1(ikat)
          call kwgrp(ikat, icat, eflag)
          error = error .or. eflag
        endif
        icat = icat + iadim1(ikat) * iadim2(ikat) * iadim3(ikat)
  290 continue
      jtok = jmark

*---- Store attributes.
      call kwput(lccmd, nkat)

*---- KEYWORD dump.
      if (ikeyfl .eq. 1  .or.  ikeyfl .eq. 3) then
        call kwdump(lccmd)
      endif
      if (ikeyfl .eq. 2  .or.  ikeyfl .eq. 3) then
        call dzshow('keyword', 0, lccmd, 'V', 0, 0, 0, 0)
      endif

 9999 end
+dk kwmake
      subroutine kwmake(label, ipr, isp, nkat)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Create new keyword bank.                                           *
* Input:                                                               *
*   LABEL    (char)     Label for new keyword bank.                    *
*   IPR      (integer)  Process code.                                  *
*   ISP      (integer)  Subprocess code.                               *
*   NKAT     (integer)  Number of attributes.                          *
* Output:                                                              *
*   LCCMD    /REFER/    Pointer to new keyword bank.                   *
*   LCKEY    /REFER/    Pointer to master keyword.                     *
*   LCCLS    /REFER/    Pointer to class bank.                         *
*----------------------------------------------------------------------*
+ca aparam
      integer ipr,isp,l,nd,nkat
      character*(*)     label
+ca memdum
+ca bankhead
+ca keygroup
+ca prcgroup
+ca strgroup
+ca refer
+ca status
+ca stbuff

      character*4       name
      character*(mcnam) defalt

*---- Lift bank and link it to KEYWORD chain.
      nd = mbat + nkat * mksiz
      lckey = lq(lroot-mrkey)
      name = label
      call mzbook(2, lccmd, lckey, -1, name, 3, 2, nd, 7, 0)

*---- Store bank description.
      iq(lccmd+mbfrm) = 16 * 5 + 2
      iq(lccmd+mbln) = lintok
      iq(lccmd+mbpr) = ipr
      iq(lccmd+mbsp) = isp
      iq(lccmd+mbat) = nkat

*---- Link to directory.
      call didefi(ldkey, label, lccmd)
      if (error) go to 9999

*---- Banks for current values.
      defalt = 'DEFAULTS'
      call aabook(l, defalt, ipr, isp, lccmd, 2)

*---- Class element (for element definitions only).
      if (ipr .eq. mpelm) then
        call aabook(lccls, label, ipr, isp, lccmd, 1)
        lq(lccmd-3) = lccls
        call didefi(ldbnk, label, lccls)
      endif

 9999 end
+dk kwput
      subroutine kwput(lkey, nkat)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Fill in a keyword bank.                                            *
* Input:                                                               *
*   LKEY(1)  (pointer)  Bank pointer.                                  *
*   NKAT     (integer)  Number of attributes.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,ikat,nkat
      integer           lkey(*)
+ca memdum
+ca bankhead
+ca keygroup
+ca keyword

*---- Move attributes to keyword bank.
      ibias = mbat
      do 90 ikat = 1, nkat
        iq(lkey(1)+ibias+mkf1) = 16 * 4 + 2
        iq(lkey(1)+ibias+mktype) = iatype(ikat)
        iq(lkey(1)+ibias+mkdim1) = iadim1(ikat)
        iq(lkey(1)+ibias+mkdim2) = iadim2(ikat)
        iq(lkey(1)+ibias+mkdim3) = iadim3(ikat)
        iq(lkey(1)+ibias+mkf2) = 16 * mwnam + 5
        call uctoh(katnam(ikat), iq(lkey(1)+ibias+mkname), mcwrd, mcnam)
        ibias = ibias + mksiz
   90 continue

      end
+dk kwzzzz
+dk laaaaa
+dk labeta
      subroutine labeta(nord, ap, am, bp, bm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Extract betatron portion of a Lie-algebraic map.                   *
* Source:     MARYLIE, version 3.0 (routine BETMAP).                   *
* Author:     Alex Dragt, August 1986.                                 *
* Input:                                                               *
*   NORD      (integer) Order of the map A (at most 4).                *
*   AP, AM    (map)     Map about a fixed point.                       *
* Output:                                                              *
*   BP, BM    (map)     Betatron portion of map A, i.e. the map which  *
*                       transforms A to normal form.                   *
*----------------------------------------------------------------------*
+ca aparam
      integer isave,itm,itp,nord
      double precision am,ap,bm,bp
      dimension         ap(*), am(6,6), bp(*), bm(6,6)
+ca memdum
+ca pa6lnk
+ca wstack

*---- Allocate working space.
      isave = iwork
      itm   = iwork
      itp   = itm + 36
      iwork = itp + itop6(nord)
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Extraction of betatron term B.
      call pa6clr(bp, -nord)
      call m66cpy(am, bm)

*---- First pass: terms linear in PT.
      if (nord .ge. 3) then
        bp(33) = ap(33)
        bp(38) = ap(38)
        bp(42) = ap(42)
        bp(45) = ap(45)
        bp(53) = ap(53)
        bp(57) = ap(57)
        bp(60) = ap(60)
        bp(67) = ap(67)
        bp(70) = ap(70)
        bp(76) = ap(76)

*---- Second pass: terms quadratic in PT.
        if (nord .ge. 4) then
          call lminv(nord, bp,bm, dq(itp+1),dq(itm+1))
          call lmcat(nord,dq(itp+1),dq(itm+1),ap,am,dq(itp+1),dq(itm+1))
          bp(104) = dq(itp+104)
          bp(119) = dq(itp+119)
          bp(129) = dq(itp+129)
          bp(135) = dq(itp+135)
          bp(154) = dq(itp+154)
          bp(164) = dq(itp+164)
          bp(170) = dq(itp+170)
          bp(184) = dq(itp+184)
          bp(190) = dq(itp+190)
          bp(200) = dq(itp+200)
        endif
      endif

*---- Drop working storage.
      iwork = isave

      end
+dk labrks
      subroutine labrks(nord, hp, pbh, ndim)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Compute Poisson brackets of transfer map generator with vector Z.  *
* Input:                                                               *
*   H(*)      (poly)    Transfer map generator of order NORD.          *
* Output:                                                              *
*   PBH(NDIM,6)         Resulting Poisson brackets.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer isave,itemp,j,jord,jqind,ndim,nord
      double precision hp,one,pbh
      dimension         hp(*), pbh(ndim,6)
+ca memdum
+ca pa6lnk
+ca wstack

      parameter         (one = 1.0d0)

*---- Make identity operation for all six variables.
      isave = iwork
      do 10 j = 1, 6
        call pa6clr(pbh(1,j), -nord)
        pbh(j,j) = 1.0
   10 continue

*---- Short-cut for order 3.
      if (nord .eq. 3) then
        do 20 jqind = 1, 5, 2
          call pa6dif (hp, jqind+1, 3, pbh(1,jqind))
          call pa6scl(-one, pbh(1,jqind), 2, pbh(1,jqind))
          call pa6dif (hp, jqind, 3, pbh(1,jqind+1))
   20   continue

*---- For NORD > 3, build Poisson brackets in reverse order.
      else if (nord .gt. 3) then

*---- Allocate working space.
        itemp = iwork
        iwork = itemp + itop6(nord-1)
        if (iwork .gt. nwork) then
          call mzwork(0, dq(1), dq(iwork+1), 2)
          nwork = iwork
        endif

*---- Loop for all six dynamic variables.
        do 90 j = 1, 6
          do 80 jord = nord, 3, -1
            call lmexpo(hp, jord, pbh(1,j), -nord, dq(itemp+1), nord-1)
            call pa6cpy(dq(itemp+1), -nord, pbh(1,j))
   80     continue
   90   continue
      endif

*---- Drop working storage.
      iwork = isave

      end
+dk lachrm
      subroutine lachrm(nord, fp, fm, a1m, a2m)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Chromatic expansion of a Lie-algebraic map, when the F3 and F4     *
*   parts contain only terms linear and quadratic in PT, respectively. *
* Source:     MARYLIE, version 3.0 (routine CHREXP).                   *
* Input:                                                               *
*   NORD      (integer) Order of the map F (at most 4).                *
*   FP, FM    (map)     The map to be expanded.                        *
* Output:                                                              *
*   A1M(6,6)  (real)    1'st derivative of transfer matrix.            *
*   A2M(6,6)  (real)    2'nd derivative of transfer matrix.            *
*----------------------------------------------------------------------*
+ca aparam
      integer isave,it1m,it1p,it2m,nord
      double precision a1m,a2m,fm,fp,half
      dimension         fp(*), fm(6,6), a1m(6,6), a2m(6,6)
+ca memdum
+ca pa6lnk
+ca wstack

      parameter         (half = 0.5d0)

*---- Allocate working space.
      isave = iwork
      it2m  = iwork
      it1m  = it2m + 36
      it1p  = it1m + 36
      iwork = it1p + itop6(nord)
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Calculate matrix T1M associated with PT*F2 terms in F.
      call pa6clr(dq(it1p+1), -nord)
      if (nord .ge. 3) then
        dq(it1p+7) = fp(33)
        dq(it1p+8) = fp(38)
        dq(it1p+9) = fp(42)
        dq(it1p+10) = fp(45)
        dq(it1p+13) = fp(53)
        dq(it1p+14) = fp(57)
        dq(it1p+15) = fp(60)
        dq(it1p+18) = fp(67)
        dq(it1p+19) = fp(70)
        dq(it1p+22) = fp(76)
      endif
      call m66mak(dq(it1p+1), dq(it1m+1))

*---- Compute A1M = T1M * FM.
      call m66mpy(dq(it1m+1), fm, a1m)

*---- Calculate matrix T2M associated with (PT**2)*F2 terms in F.
      call pa6clr(dq(it1p+1), -nord)
      if (nord .ge. 4) then
        dq(it1p+7) = fp(104)
        dq(it1p+8) = fp(119)
        dq(it1p+9) = fp(129)
        dq(it1p+10) = fp(135)
        dq(it1p+13) = fp(154)
        dq(it1p+14) = fp(164)
        dq(it1p+15) = fp(170)
        dq(it1p+18) = fp(184)
        dq(it1p+19) = fp(190)
        dq(it1p+22) = fp(200)
      endif
      call m66mak(dq(it1p+1), dq(it2m+1))

*---- Compute A2M = (T2M + T1M**2 / 2.0) * FM
      call m66mpy(dq(it1m+1), dq(it1m+1), dq(it1m+1))
      call m66scl(half, dq(it1m+1), dq(it1m+1))
      call m66add(dq(it2m+1), dq(it1m+1), dq(it1m+1))
      call m66mpy(dq(it1m+1), fm, a2m)

*---- Drop working storage.
      iwork = isave

      end
+dk ladc2r
      subroutine ladc2r(nord, f, g)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Transform from a Cartesian basis to a dynamic resonance basis.     *
* Source:     MARYLIE, version 3.0 (routine CTODR).                    *
* Author:     Filippo Neri, June 1986.                                 *
* Input:                                                               *
*   NORD      (integer) Order of the map F (at most 4).                *
*   F(*)      Cartesian basis coefficients.                            *
* Output:                                                              *
*   G(*)      Dynamic resonance basis coefficients.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision by2,by4,by8,f,g
      dimension         f(*), g(*)

      parameter         (by2 = 1.0d0 / 2.0d0)
      parameter         (by4 = 1.0d0 / 4.0d0)
      parameter         (by8 = 1.0d0 / 8.0d0)

      g(1) = f(1)
      g(2) = f(2)
      g(3) = f(3)
      g(4) = f(4)
      g(5) = f(5)
      g(6) = f(6)
      if (nord .ge. 2) then
        g(7) = by2 * (f(13)+f(7))
        g(8) = by2 * (f(22)+f(18))
        g(9) = by2 * (f(27)+f(25))
        g(10) = by2 * (-f(27)+f(25))
        g(11) = by2 * f(26)
        g(12) = by2 * (-f(17)+f(11))
        g(13) = by2 * (f(16)+f(12))
        g(14) = by2 * (f(17)+f(11))
        g(15) = by2 * (f(16)-f(12))
        g(16) = by2 * (-f(24)+f(20))
        g(17) = by2 * (f(23)+f(21))
        g(18) = by2 * (f(24)+f(20))
        g(19) = by2 * (f(23)-f(21))
        g(20) = by2 * (-f(13)+f(7))
        g(21) = by2 * f(8)
        g(22) = by2 * (-f(22)+f(18))
        g(23) = by2 * f(19)
        g(24) = by2 * (-f(15)+f(9))
        g(25) = by2 * (f(14)+f(10))
        g(26) = by2 * (f(15)+f(9))
        g(27) = by2 * (f(14)-f(10))
        if (nord .ge. 3) then
          g(28) = by2 * (f(52)+f(32))
          g(29) = by2 * (f(53)+f(33))
          g(30) = by2 * (f(75)+f(66))
          g(31) = by2 * (f(76)+f(67))
          g(32) = by4 * (-f(82)+f(80))
          g(33) = by4 * (-f(83)+f(81))
          g(34) = by4 * (f(82) + 3.0*f(80))
          g(35) = by4 * (f(81) + 3.0*f(83))
          g(36) = by2 * (f(48)+f(46))
          g(37) = by2 * (f(63)+f(61))
          g(38) = by2 * (f(73)+f(71))
          g(39) = by2 * (f(79)+f(77))
          g(40) = by4 * (-f(62)-f(48)+f(46))
          g(41) = by4 * (-f(63)+f(61)+f(47))
          g(42) = by4 * (f(62)-f(48)+f(46))
          g(43) = by4 * (-f(63)+f(61)-f(47))
          g(44) = by4 * (-f(78)-f(73)+f(71))
          g(45) = by4 * (-f(79)+f(77)+f(72))
          g(46) = by4 * (f(78)-f(73)+f(71))
          g(47) = by4 * (-f(79)+f(77)-f(72))
          g(48) = by4 * (-f(52)-f(38)+f(32))
          g(49) = by4 * (-f(53)+f(37)+f(33))
          g(50) = by4 * (-f(52)+f(38)+f(32))
          g(51) = by4 * (f(53)+f(37)-f(33))
          g(52) = by4 * (-f(75)-f(70)+f(66))
          g(53) = by4 * (-f(76)+f(69)+f(67))
          g(54) = by4 * (-f(75)+f(70)+f(66))
          g(55) = by4 * (f(76)+f(69)-f(67))
          g(56) = by4 * (-f(59)-f(57)-f(45)+f(41))
          g(57) = by4 * (-f(60)+f(56)+f(44)+f(42))
          g(58) = by4 * (-f(59)+f(57)+f(45)+f(41))
          g(59) = by4 * (f(60)+f(56)+f(44)-f(42))
          g(60) = by4 * (f(59)-f(57)+f(45)+f(41))
          g(61) = by4 * (f(60)+f(56)-f(44)+f(42))
          g(62) = by4 * (f(59)+f(57)-f(45)+f(41))
          g(63) = by4 * (-f(60)+f(56)-f(44)-f(42))
          g(64) = by4 * (f(34) + 3.0*f(28))
          g(65) = by4 * (f(29) + 3.0*f(49))
          g(66) = by4 * (f(68) + 3.0*f(64))
          g(67) = by4 * (f(65) + 3.0*f(74))
          g(68) = by2 * (f(43)+f(39))
          g(69) = by2 * (f(58)+f(54))
          g(70) = by2 * (f(50)+f(30))
          g(71) = by2 * (f(51)+f(31))
          g(72) = by4 * (-f(34)+f(28))
          g(73) = by4 * (-f(49)+f(29))
          g(74) = by4 * (-f(68)+f(64))
          g(75) = by4 * (-f(74)+f(65))
          g(76) = by4 * (-f(50)-f(36)+f(30))
          g(77) = by4 * (-f(51)+f(35)+f(31))
          g(78) = by4 * (-f(55)-f(43)+f(39))
          g(79) = by4 * (-f(58)+f(54)+f(40))
          g(80) = by4 * (-f(50)+f(36)+f(30))
          g(81) = by4 * (f(51)+f(35)-f(31))
          g(82) = by4 * (f(55)-f(43)+f(39))
          g(83) = by4 * (-f(58)+f(54)-f(40))
          if (nord .ge. 4) then
            g(84) = by8 * (f(90) + 3.0*(f(140)+f(84)))
            g(85) = by8 * (f(179) + 3.0*(f(195)+f(175)))
            g(86) = by8 * (f(207) + 3.0*(f(209)+f(205)))
            g(87) = by4 * (f(149)+f(145)+f(99)+f(95))
            g(88) = by4 * (f(154)+f(152)+f(104)+f(102))
            g(89) = by4 * (f(200)+f(198)+f(184)+f(182))
            g(90) = by4 * (-f(154)+f(152)-f(104)+f(102))
            g(91) = by4 * (f(153)+f(103))
            g(92) = by4 * (-f(200)+f(198)-f(184)+f(182))
            g(93) = by4 * (f(199)+f(183))
            g(94) = by8 * (f(209)-f(207)+f(205))
            g(95) = by8 * (-f(208)+f(206))
            g(96) = by2 * (-f(209)+f(205))
            g(97) = by4 * (f(208)+f(206))
            g(98) = by8 * (f(174)-f(172)-f(138)+f(136))
            g(99) = by8 * (-f(173)+f(171)-f(139)+f(137))
            g(100) = by8 * (-f(174)+f(172)-f(138)+f(136))
            g(101) = by8 * (-f(173)+f(171)+f(139)-f(137))
            g(102) = by8 * (f(204)-f(202)-f(193)+f(191))
            g(103) = by8 * (-f(203)+f(201)-f(194)+f(192))
            g(104) = by8 * (-f(204)+f(202)-f(193)+f(191))
            g(105) = by8 * (-f(203)+f(201)+f(194)-f(192))
            g(106) = by8 * ((-f(172)+f(138)) + 3.0*(-f(174)+f(136)))
            g(107) = by8 * ((f(173)+f(137)) + 3.0*(f(171)+f(139)))
            g(108) = by8 * ((f(172)+f(138)) + 3.0*(f(174)+f(136)))
            g(109) = by8 * ((f(173)-f(137)) + 3.0*(f(171)-f(139)))
            g(110) = by8 * ((-f(202)+f(193)) + 3.0*(-f(204)+f(191)))
            g(111) = by8 * ((f(203)+f(192)) + 3.0*(f(201)+f(194)))
            g(112) = by8 * ((f(202)+f(193)) + 3.0*(f(204)+f(191)))
            g(113) = by8 * ((f(203)-f(192)) + 3.0*(f(201)-f(194)))
            g(114) = by4 * (-f(154)-f(152)+f(104)+f(102))
            g(115) = by4 * (f(119)+f(117))
            g(116) = by4 * (-f(200)-f(198)+f(184)+f(182))
            g(117) = by4 * (f(190)+f(188))
            g(118) = by8 * (f(154)-f(152)-f(118)-f(104)+f(102))
            g(119) = by8 * (-f(153)-f(119)+f(117)+f(103))
            g(120) = by8 * (f(154)-f(152)+f(118)-f(104)+f(102))
            g(121) = by8 * (f(153)-f(119)+f(117)-f(103))
            g(122) = by8 * (f(200)-f(198)-f(189)-f(184)+f(182))
            g(123) = by8 * (-f(199)-f(190)+f(188)+f(183))
            g(124) = by8 * (f(200)-f(198)+f(189)-f(184)+f(182))
            g(125) = by8 * (f(199)-f(190)+f(188)-f(183))
            g(126) = by4 * (-f(170)-f(168)+f(129)+f(127))
            g(127) = by4 * (f(164)+f(162)+f(135)+f(133))
            g(128) = by4 * (f(170)+f(168)+f(129)+f(127))
            g(129) = by4 * (f(164)+f(162)-f(135)-f(133))
            g(130) = by8 * (f(170)-f(168)-f(163)-f(134)-f(129)+f(127))
            g(131) = by8 * (-f(169)-f(164)+f(162)-f(135)+f(133)+f(128))
            g(132) = by8 * (f(170)-f(168)+f(163)+f(134)-f(129)+f(127))
            g(133) = by8 * (f(169)-f(164)+f(162)-f(135)+f(133)-f(128))
            g(134) = by8 * (-f(170)+f(168)-f(163)+f(134)-f(129)+f(127))
            g(135) = by8 * (f(169)-f(164)+f(162)+f(135)-f(133)+f(128))
            g(136) = by8 * (-f(170)+f(168)+f(163)-f(134)-f(129)+f(127))
            g(137) = by8 * (-f(169)-f(164)+f(162)+f(135)-f(133)-f(128))
            g(138) = by8 * ((f(108)-f(94)) + 3.0*(-f(144)+f(88)))
            g(139) = by8 * ((f(109)+f(93)) + 3.0*(f(143)+f(89)))
            g(140) = by8 * ((f(108)+f(94)) + 3.0*(f(144)+f(88)))
            g(141) = by8 * ((-f(109)+f(93)) + 3.0*(f(143)-f(89)))
            g(142) = by8 * ((f(186)-f(181)) + 3.0*(-f(197)+f(177)))
            g(143) = by8 * ((f(187)+f(180)) + 3.0*(f(196)+f(178)))
            g(144) = by8 * ((f(186)+f(181)) + 3.0*(f(197)+f(177)))
            g(145) = by8 * ((-f(187)+f(180)) + 3.0*(f(196)-f(178)))
            g(146) = by4 * (-f(167)-f(158)+f(131)+f(122))
            g(147) = by4 * (f(166)+f(157)+f(132)+f(123))
            g(148) = by4 * (f(167)+f(158)+f(131)+f(122))
            g(149) = by4 * (f(166)+f(157)-f(132)-f(123))
            g(150) = by4 * (-f(151)+f(147)-f(101)+f(97))
            g(151) = by4 * (f(150)+f(148)+f(100)+f(98))
            g(152) = by4 * (f(151)+f(147)+f(101)+f(97))
            g(153) = by4 * (f(150)-f(148)+f(100)-f(98))
            g(154) = by8 * (f(144)-f(108)-f(94)+f(88))
            g(155) = by8 * (-f(143)-f(109)+f(93)+f(89))
            g(156) = by8 * (-f(144)-f(108)+f(94)+f(88))
            g(157) = by8 * (-f(143)+f(109)+f(93)-f(89))
            g(158) = by8 * (f(197)-f(186)-f(181)+f(177))
            g(159) = by8 * (-f(196)-f(187)+f(180)+f(178))
            g(160) = by8 * (-f(197)-f(186)+f(181)+f(177))
            g(161) = by8 * (-f(196)+f(187)+f(180)-f(178))
            g(162) = by8 * (f(151)-f(147)-f(115)-f(113)-f(101)+f(97))
            g(163) = by8 * (-f(150)-f(148)-f(116)+f(112)+f(100)+f(98))
            g(164) = by8 * (-f(151)-f(147)-f(115)+f(113)+f(101)+f(97))
            g(165) = by8 * (-f(150)+f(148)+f(116)+f(112)+f(100)-f(98))
            g(166) = by8 * (f(167)-f(160)-f(158)-f(131)-f(126)+f(122))
            g(167) = by8 * (-f(166)-f(161)+f(157)-f(132)+f(125)+f(123))
            g(168) = by8 * (-f(167)-f(160)+f(158)-f(131)+f(126)+f(122))
            g(169) = by8 * (-f(166)+f(161)+f(157)+f(132)+f(125)-f(123))
            g(170) = by8 * (-f(151)-f(147)+f(115)-f(113)+f(101)+f(97))
            g(171) = by8 * (f(150)-f(148)+f(116)+f(112)-f(100)+f(98))
            g(172) = by8 * (f(151)-f(147)+f(115)+f(113)-f(101)+f(97))
            g(173) = by8 * (f(150)+f(148)-f(116)+f(112)-f(100)-f(98))
            g(174) = by8 * (-f(167)+f(160)+f(158)-f(131)-f(126)+f(122))
            g(175) = by8 * (-f(166)-f(161)+f(157)+f(132)-f(125)-f(123))
            g(176) = by8 * (f(167)+f(160)-f(158)-f(131)+f(126)+f(122))
            g(177) = by8 * (-f(166)+f(161)+f(157)-f(132)-f(125)+f(123))
            g(178) = by2 * (-f(140)+f(84))
            g(179) = by4 * (f(105)+f(85))
            g(180) = by2 * (-f(195)+f(175))
            g(181) = by4 * (f(185)+f(176))
            g(182) = by4 * (-f(149)-f(145)+f(99)+f(95))
            g(183) = by4 * (f(114)+f(110))
            g(184) = by4 * (-f(149)+f(145)-f(99)+f(95))
            g(185) = by4 * (f(146)+f(96))
            g(186) = by8 * ((f(106)-f(92)) + 3.0*(-f(142)+f(86)))
            g(187) = by8 * ((f(107)+f(91)) + 3.0*(f(141)+f(87)))
            g(188) = by8 * ((-f(156)+f(124)) + 3.0*(-f(165)+f(120)))
            g(189) = by8 * ((f(159)+f(121)) + 3.0*(f(155)+f(130)))
            g(190) = by8 * ((f(106)+f(92)) + 3.0*(f(142)+f(86)))
            g(191) = by8 * ((-f(107)+f(91)) + 3.0*(f(141)-f(87)))
            g(192) = by8 * ((f(156)+f(124)) + 3.0*(f(165)+f(120)))
            g(193) = by8 * ((f(159)-f(121)) + 3.0*(f(155)-f(130)))
            g(194) = by8 * (f(140)-f(90)+f(84))
            g(195) = by8 * (-f(105)+f(85))
            g(196) = by8 * (f(195)-f(179)+f(175))
            g(197) = by8 * (-f(185)+f(176))
            g(198) = by8 * (f(142)-f(106)-f(92)+f(86))
            g(199) = by8 * (-f(141)-f(107)+f(91)+f(87))
            g(200) = by8 * (f(165)-f(156)-f(124)+f(120))
            g(201) = by8 * (-f(159)+f(155)-f(130)+f(121))
            g(202) = by8 * (-f(142)-f(106)+f(92)+f(86))
            g(203) = by8 * (-f(141)+f(107)+f(91)-f(87))
            g(204) = by8 * (-f(165)+f(156)-f(124)+f(120))
            g(205) = by8 * (-f(159)+f(155)+f(130)-f(121))
            g(206) = by8 * (f(149)-f(145)-f(111)-f(99)+f(95))
            g(207) = by8 * (-f(146)-f(114)+f(110)+f(96))
            g(208) = by8 * (f(149)-f(145)+f(111)-f(99)+f(95))
            g(209) = by8 * (f(146)-f(114)+f(110)-f(96))
          endif
        endif
      endif

      end
+dk ladeig
      subroutine ladeig(fm, reeig, aieig, am)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Return eigenvalues and eigenvectors of a 6x6 matrix.               *
* Input:                                                               *
*   FM(6,6)   (real)    Matrix to be transformed.                      *
* Output:                                                              *
*   REEIG(6)  (real)    Real parts of eigenvalues.                     *
*   AIEIG(6)  (real)    Imaginary parts of eigenvalues.                *
*   AM(6,6)   (real)    Transforming matrix, contains eigenvectors.    *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ihi,ilo,info,j,k,mdim,nn
      double precision aieig,aival,am,big,c,d,dt,dx,dy,fm,pb,reeig,
     +reval,s,tm
      dimension         fm(6,6), reeig(6), aieig(6), am(6,6)
+ca message

      parameter         (ilo = 1, ihi = 6, mdim = 6, nn = 6)
      dimension         tm(6,6), d(6), reval(6), aival(6)
      integer           kpnt(6)

*---- Compute eigenvalues and eigenvectors.
      call m66cpy(fm, tm)
      call orthes(mdim, nn, ilo, ihi, tm, d)
      call ortran(mdim, nn, ilo, ihi, tm, d, am)
      call hqr2(mdim, nn, ilo, ihi, tm, reval, aival, am, info)
      if (info .ne. 0) then
        write (msg, 910) ((fm(i,k), k = 1, 6), i = 1, 6)
  910   format('Unable to find eigenvalues for matrix:'/
     +         (6f12.6))
        call aafail('LADEIG', 7, msg)
        go to 9999
      endif

*---- Normalize the eigenvectors.
      do 30 k = 1, 5, 2
        pb = 0.0
        do 10 i = 1, 5, 2
          pb = pb + am(i,k) * am(i+1,k+1)
     +            - am(i+1,k) * am(i,k+1)
   10   continue
        s = sqrt(abs(pb))
        if (pb .lt. 0.0) then
          aival(k) = - aival(k)
          aival(k+1) = - aival(k+1)
        endif
        do 20 i = 1, 6
          am(i,k)   = am(i,k) / s
          am(i,k+1) = am(i,k+1) * (s / pb)
   20   continue
   30 continue

*---- Copy vectors to temporary array.
      call m66cpy(am, tm)

*---- Find the vector with the largest vertical component.
      big = 0.0
      kpnt(3) = 1
      do 40 i = 1, 5, 2
        c = tm(3,i)**2 + tm(3,i+1)**2 + tm(4,i)**2 + tm(4,i+1)**2
        if (c .gt. big) then
          big = c
          kpnt(3) = i
        endif
  40  continue

*---- Find  the vector with the largest horizontal component.
      kpnt(1) = 1
      big = 0.0
      do 50 i = 1, 5, 2
        if (i .ne. kpnt(3)) then
          c = tm(1,i)**2 + tm(1,i+1)**2 + tm(2,i)**2 + tm(2,i+1)**2
          if (c .gt. big) then
            big = c
            kpnt(1) = i
          endif
        endif
  50  continue

*---- Find the remaining vector.
      do 60 i = 1, 5, 2
        if (i .ne. kpnt(3)  .and.  i .ne. kpnt(1)) kpnt(5) = i
   60 continue

*---- Reorder vectors.
      do 80 i = 1, 5, 2
        k = kpnt(i)
        reeig(i) = reval(k)
        aieig(i) = aival(k)
        reeig(i+1) = reval(k+1)
        aieig(i+1) = aival(k+1)
        do 70 j = 1, 6
          am(j,i) = tm(j,k)
          am(j,i+1) = tm(j,k+1)
   70   continue
   80 continue

*---- Rephase the result.
      call m66one(tm)
      dx = sqrt(am(1,1)**2 + am(1,2)**2)
      tm(1,1) = am(1,1) / dx
      tm(2,1) = am(1,2) / dx
      tm(1,2) = - tm(2,1)
      tm(2,2) = tm(1,1)
      dy = sqrt(am(3,3)**2 + am(3,4)**2)
      tm(3,3) = am(3,3) / dy
      tm(4,3) = am(3,4) / dy
      tm(3,4) = - tm(4,3)
      tm(4,4) = tm(3,3)
      dt = sqrt(am(5,5)**2 + am(5,6)**2)
      tm(5,5) = am(5,5) / dt
      tm(6,5) = am(5,6) / dt
      tm(5,6) = - tm(6,5)
      tm(6,6) = tm(5,5)
      call m66mpy(am, tm, am)

 9999 end
+dk ladpur
      subroutine ladpur(nord, fp, fm, gp, gm, tp, tm, min, max)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Generic purifying routine for the dynamic resonance case.          *
* Source:     MARYLIE, version 3.0 (routine GDPUR).                    *
* Input:                                                               *
*   NORD      (integer) Order of the map F (at most 4).                *
*   FP, FM    (map)     Original map to be purified (unchanged).       *
*   MIN, MAX  (integer) Index range to be purified.                    *
* Output:                                                              *
*   GP, GM    (map)     Purified map.                                  *
*   TP, TM    (map)     Purifying map, i. e. G = T*F*T**(-1).          *
*----------------------------------------------------------------------*
+ca aparam
      integer i,isave,it1p,it2p,k,k1,k2,max,min,n,nord,nt,nx,ny
      double precision at,ax,ay,bt,bx,by,cth,det,detmin,fm,fp,gm,gp,sth,
     +tm,tp
      dimension         fp(*), fm(6,6), gp(*), gm(6,6), tp(*), tm(6,6)
+ca memdum
+ca message
+ca wstack

      parameter         (detmin = 1.0d-12)

      dimension         ax(-4:4), bx(-4:4), ay(-4:4), by(-4:4)
      dimension         at(-4:4), bt(-4:4)
      integer           idrexp(0:3,209)

      data (idrexp(i,1),   i = 0, 3) / 1, 1, 0, 0 /
      data (idrexp(i,2),   i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,3),   i = 0, 3) / 1, 0, 1, 0 /
      data (idrexp(i,4),   i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,5),   i = 0, 3) / 1, 0, 0, 1 /
      data (idrexp(i,6),   i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,7),   i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,8),   i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,9),   i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,10),  i = 0, 3) / 1, 0, 0, 2 /
      data (idrexp(i,11),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,12),  i = 0, 3) / 1, 1, 0, 1 /
      data (idrexp(i,13),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,14),  i = 0, 3) / 1, 1, 0, -1 /
      data (idrexp(i,15),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,16),  i = 0, 3) / 1, 0, 1, 1 /
      data (idrexp(i,17),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,18),  i = 0, 3) / 1, 0, 1, -1 /
      data (idrexp(i,19),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,20),  i = 0, 3) / 1, 2, 0, 0 /
      data (idrexp(i,21),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,22),  i = 0, 3) / 1, 0, 2, 0 /
      data (idrexp(i,23),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,24),  i = 0, 3) / 1, 1, 1, 0 /
      data (idrexp(i,25),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,26),  i = 0, 3) / 1, 1, -1, 0 /
      data (idrexp(i,27),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,28),  i = 0, 3) / 1, 0, 0, 1 /
      data (idrexp(i,29),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,30),  i = 0, 3) / 1, 0, 0, 1 /
      data (idrexp(i,31),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,32),  i = 0, 3) / 1, 0, 0, 3 /
      data (idrexp(i,33),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,34),  i = 0, 3) / 1, 0, 0, 1 /
      data (idrexp(i,35),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,36),  i = 0, 3) / 1, 1, 0, 0 /
      data (idrexp(i,37),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,38),  i = 0, 3) / 1, 0, 1, 0 /
      data (idrexp(i,39),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,40),  i = 0, 3) / 1, 1, 0, 2 /
      data (idrexp(i,41),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,42),  i = 0, 3) / 1, 1, 0, -2 /
      data (idrexp(i,43),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,44),  i = 0, 3) / 1, 0, 1, 2 /
      data (idrexp(i,45),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,46),  i = 0, 3) / 1, 0, 1, -2 /
      data (idrexp(i,47),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,48),  i = 0, 3) / 1, 2, 0, 1 /
      data (idrexp(i,49),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,50),  i = 0, 3) / 1, 2, 0, -1 /
      data (idrexp(i,51),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,52),  i = 0, 3) / 1, 0, 2, 1 /
      data (idrexp(i,53),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,54),  i = 0, 3) / 1, 0, 2, -1 /
      data (idrexp(i,55),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,56),  i = 0, 3) / 1, 1, 1, 1 /
      data (idrexp(i,57),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,58),  i = 0, 3) / 1, 1, 1, -1 /
      data (idrexp(i,59),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,60),  i = 0, 3) / 1, 1, -1, 1 /
      data (idrexp(i,61),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,62),  i = 0, 3) / 1, 1, -1, -1 /
      data (idrexp(i,63),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,64),  i = 0, 3) / 1, 1, 0, 0 /
      data (idrexp(i,65),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,66),  i = 0, 3) / 1, 0, 1, 0 /
      data (idrexp(i,67),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,68),  i = 0, 3) / 1, 1, 0, 0 /
      data (idrexp(i,69),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,70),  i = 0, 3) / 1, 0, 1, 0 /
      data (idrexp(i,71),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,72),  i = 0, 3) / 1, 3, 0, 0 /
      data (idrexp(i,73),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,74),  i = 0, 3) / 1, 0, 3, 0 /
      data (idrexp(i,75),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,76),  i = 0, 3) / 1, 2, 1, 0 /
      data (idrexp(i,77),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,78),  i = 0, 3) / 1, 1, 2, 0 /
      data (idrexp(i,79),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,80),  i = 0, 3) / 1, 2, -1, 0 /
      data (idrexp(i,81),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,82),  i = 0, 3) / 1, 1, -2, 0 /
      data (idrexp(i,83),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,84),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,85),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,86),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,87),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,88),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,89),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,90),  i = 0, 3) / 1, 0, 0, 2 /
      data (idrexp(i,91),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,92),  i = 0, 3) / 1, 0, 0, 2 /
      data (idrexp(i,93),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,94),  i = 0, 3) / 1, 0, 0, 4 /
      data (idrexp(i,95),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,96),  i = 0, 3) / 1, 0, 0, 2 /
      data (idrexp(i,97),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,98),  i = 0, 3) / 1, 1, 0, 3 /
      data (idrexp(i,99),  i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,100), i = 0, 3) / 1, 1, 0, -3 /
      data (idrexp(i,101), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,102), i = 0, 3) / 1, 0, 1, 3 /
      data (idrexp(i,103), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,104), i = 0, 3) / 1, 0, 1, -3 /
      data (idrexp(i,105), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,106), i = 0, 3) / 1, 1, 0, 1 /
      data (idrexp(i,107), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,108), i = 0, 3) / 1, 1, 0, -1 /
      data (idrexp(i,109), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,110), i = 0, 3) / 1, 0, 1, 1 /
      data (idrexp(i,111), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,112), i = 0, 3) / 1, 0, 1, -1 /
      data (idrexp(i,113), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,114), i = 0, 3) / 1, 2, 0, 0 /
      data (idrexp(i,115), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,116), i = 0, 3) / 1, 0, 2, 0 /
      data (idrexp(i,117), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,118), i = 0, 3) / 1, 2, 0, 2 /
      data (idrexp(i,119), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,120), i = 0, 3) / 1, 2, 0, -2 /
      data (idrexp(i,121), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,122), i = 0, 3) / 1, 0, 2, 2 /
      data (idrexp(i,123), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,124), i = 0, 3) / 1, 0, 2, -2 /
      data (idrexp(i,125), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,126), i = 0, 3) / 1, 1, 1, 0 /
      data (idrexp(i,127), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,128), i = 0, 3) / 1, 1, -1, 0 /
      data (idrexp(i,129), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,130), i = 0, 3) / 1, 1, 1, 2 /
      data (idrexp(i,131), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,132), i = 0, 3) / 1, 1, 1, -2 /
      data (idrexp(i,133), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,134), i = 0, 3) / 1, 1, -1, 2 /
      data (idrexp(i,135), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,136), i = 0, 3) / 1, 1, -1, -2 /
      data (idrexp(i,137), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,138), i = 0, 3) / 1, 1, 0, 1 /
      data (idrexp(i,139), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,140), i = 0, 3) / 1, 1, 0, -1 /
      data (idrexp(i,141), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,142), i = 0, 3) / 1, 0, 1, 1 /
      data (idrexp(i,143), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,144), i = 0, 3) / 1, 0, 1, -1 /
      data (idrexp(i,145), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,146), i = 0, 3) / 1, 1, 0, 1 /
      data (idrexp(i,147), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,148), i = 0, 3) / 1, 1, 0, -1 /
      data (idrexp(i,149), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,150), i = 0, 3) / 1, 0, 1, 1 /
      data (idrexp(i,151), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,152), i = 0, 3) / 1, 0, 1, -1 /
      data (idrexp(i,153), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,154), i = 0, 3) / 1, 3, 0, 1 /
      data (idrexp(i,155), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,156), i = 0, 3) / 1, 3, 0, -1 /
      data (idrexp(i,157), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,158), i = 0, 3) / 1, 0, 3, 1 /
      data (idrexp(i,159), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,160), i = 0, 3) / 1, 0, 3, -1 /
      data (idrexp(i,161), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,162), i = 0, 3) / 1, 2, 1, 1 /
      data (idrexp(i,163), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,164), i = 0, 3) / 1, 2, 1, -1 /
      data (idrexp(i,165), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,166), i = 0, 3) / 1, 1, 2, 1 /
      data (idrexp(i,167), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,168), i = 0, 3) / 1, 1, 2, -1 /
      data (idrexp(i,169), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,170), i = 0, 3) / 1, 2, -1, 1 /
      data (idrexp(i,171), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,172), i = 0, 3) / 1, 2, -1, -1 /
      data (idrexp(i,173), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,174), i = 0, 3) / 1, 1, -2, -1 /
      data (idrexp(i,175), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,176), i = 0, 3) / 1, 1, -2, 1 /
      data (idrexp(i,177), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,178), i = 0, 3) / 1, 2, 0, 0 /
      data (idrexp(i,179), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,180), i = 0, 3) / 1, 0, 2, 0 /
      data (idrexp(i,181), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,182), i = 0, 3) / 1, 2, 0, 0 /
      data (idrexp(i,183), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,184), i = 0, 3) / 1, 0, 2, 0 /
      data (idrexp(i,185), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,186), i = 0, 3) / 1, 1, 1, 0 /
      data (idrexp(i,187), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,188), i = 0, 3) / 1, 1, 1, 0 /
      data (idrexp(i,189), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,190), i = 0, 3) / 1, 1, -1, 0 /
      data (idrexp(i,191), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,192), i = 0, 3) / 1, 1, -1, 0 /
      data (idrexp(i,193), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,194), i = 0, 3) / 1, 4, 0, 0 /
      data (idrexp(i,195), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,196), i = 0, 3) / 1, 0, 4, 0 /
      data (idrexp(i,197), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,198), i = 0, 3) / 1, 3, 1, 0 /
      data (idrexp(i,199), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,200), i = 0, 3) / 1, 1, 3, 0 /
      data (idrexp(i,201), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,202), i = 0, 3) / 1, 3, -1, 0 /
      data (idrexp(i,203), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,204), i = 0, 3) / 1, 1, -3, 0 /
      data (idrexp(i,205), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,206), i = 0, 3) / 1, 2, 2, 0 /
      data (idrexp(i,207), i = 0, 3) / 0, 0, 0, 0 /
      data (idrexp(i,208), i = 0, 3) / 1, 2, -2, 0 /
      data (idrexp(i,209), i = 0, 3) / 0, 0, 0, 0 /

*---- Allocate working space.
      isave = iwork
      it1p  = iwork
      it2p  = it1p + 209
      iwork = it2p + 209
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Set up multiple angle arrays.
      ax(0) = 1.0
      bx(0) = 0.0
      ay(0) = 1.0
      by(0) = 0.0
      at(0) = 1.0
      bt(0) = 0.0
      ax(1) = fm(1,1)
      bx(1) = fm(1,2)
      ay(1) = fm(3,3)
      by(1) = fm(3,4)
      at(1) = fm(5,5)
      bt(1) = fm(5,6)
      do 10 n = 2, 4
        ax(n) = ax(1) * ax(n-1) - bx(1) * bx(n-1)
        bx(n) = bx(1) * ax(n-1) + ax(1) * bx(n-1)
   10 continue
      do 20 n = 2, 4
        ay(n) = ay(1) * ay(n-1) - by(1) * by(n-1)
        by(n) = by(1) * ay(n-1) + ay(1) * by(n-1)
   20 continue
      do 30 n = 2, 4
        at(n) = at(1) * at(n-1) - bt(1) * bt(n-1)
        bt(n) = bt(1) * at(n-1) + at(1) * bt(n-1)
   30 continue
      do 40 n = 1, 4
        ax(-n) =   ax(n)
        bx(-n) = - bx(n)
        ay(-n) =   ay(n)
        by(-n) = - by(n)
        at(-n) =   at(n)
        bt(-n) = - bt(n)
   40 continue

*---- Resonance decompose map.
      call ladc2r(nord, fp, dq(it1p+1))

*---- Set up map to remove offensive terms of index MIN->MAX.
      call pa6clr(dq(it2p+1), -nord)
      do 100 k = min, max
        if (idrexp(0,k) .ne. 0) then

*---- Compute CTH = COS(THETA) and STH=SIN(THETA) for
*     THETA = DREXP(1,K)*WX + DREXP(2,K)*WY + DREXP(3,K)*WT.
          nx = idrexp(1,k)
          ny = idrexp(2,k)
          nt = idrexp(3,k)
          cth = (ax(nx)*ay(ny) - bx(nx)*by(ny)) * at(nt)
     +        - (ax(nx)*by(ny) + bx(nx)*ay(ny)) * bt(nt)
          sth = (ax(nx)*ay(ny) - bx(nx)*by(ny)) * bt(nt)
     +        + (ax(nx)*by(ny) + bx(nx)*ay(ny)) * at(nt)

*---- Carry out rest of calculation.
          det = 2.0 * (1.0 - cth)
          k1 = k
          k2 = k + 1
          if (abs(det) .gt. detmin) then
            dq(it2p+k1) =
     +        ((1.0 - cth) * dq(it1p+k1) + sth * dq(it1p+k2)) / det
            dq(it2p+k2) =
     +        ((1.0 - cth) * dq(it1p+k2) - sth * dq(it1p+k1)) / det
          else
            write (msg, 910) k1, k2, det
  910       format('DET(',i3,',',i3,') = ',f16.8,' not removed.')
            call aawarn('LADPUR', 1, msg)
          endif
        endif
  100 continue

*---- Transfom map T2 to Cartesian basis; the result is the map T.
      call lmone(nord, tp, tm)
      call ladr2c(nord, dq(it2p+1), tp)

*---- Remove offensive terms (MIN->MAX).
      call lmsand(nord, tp, tm, fp, fm, gp, gm)

*---- Drop working storage.
      iwork = isave

      end
+dk ladpu2
      subroutine ladpu2(nord, fp, fm, gp, gm, tp, tm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Purify the matrix part of a dynamic Lie-algebraic map.             *
* Source:     MARYLIE, version 3.0 (routine DPUR2).                    *
* Input:                                                               *
*   NORD      (integer) Order of the map F (at most 4).                *
*   FP, FM    (map)     Original map, unchanged.                       *
* Output:                                                              *
*   GP, GM    (map)     Purified map.                                  *
*   TP, TM    (map)     Purifying map, i. e. G = T*F*T**(-1).          *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,nord
      double precision aieig,diff,fm,fp,gm,gp,reeig,tm,tol,tp
      dimension         fp(*), fm(6,6), gp(*), gm(6,6), tp(*), tm(6,6)
+ca message
+ca status

      parameter         (tol = 1.0d-8)
      dimension         reeig(6), aieig(6)

*---- Find the map T = A2.
      call ladeig(fm, reeig, aieig, tm)
      if (error) go to 999

*---- Go to Floquet variables.
      call pa6clr(tp, -nord)
      call lmsand(nord, tp, tm, fp, fm, gp, gm)

*---- If eigenvalues are off unit circle, print warning message.
      do 20 i = 1, 6
        if (abs(reeig(i)**2 + aieig(i)**2 - 1.0) .gt. tol) then
          write (msg, 910)
          do 10 j = 1, 6
            diff = sqrt(reeig(j)**2 + aieig(j)**2) - 1.0
            write (msg(j+2), 920) reeig(j), aieig(j), diff
   10     continue
          call aawarn('LADPU2', 8, msg)
          go to 999
        endif
   20 continue

  910 format('Eigenvalues not on unit circle:'/
     +       6x,'Real',12x,'Imaginary',5x,'Error')
  920 format(2f16.8,1p,e18.6)

  999 end
+dk ladpu3
      subroutine ladpu3(nord, fp, fm, gp, gm, tp, tm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Purify the F3 part of a dynamic Lie-algebraic map.                 *
* Source:     MARYLIE, version 3.0 (routine DPUR3).                    *
* Input:                                                               *
*   NORD      (integer) Order of the map F (at most 4).                *
*   FP, FM    (map)     Original map, unchanged.                       *
* Output:                                                              *
*   GP, GM    (map)     Purified map.                                  *
*   TP, TM    (map)     Purifying map, i. e. G = T*F*T**(-1).          *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision fm,fp,gm,gp,tm,tp

      dimension         fp(*), fm(6,6), gp(*), gm(6,6), tp(*), tm(6,6)

      if (nord .ge. 3) then
        call ladpur(nord, fp, fm, gp, gm, tp, tm, 28, 83)
      endif

      end
+dk ladpu4
      subroutine ladpu4(nord, fp, fm, gp, gm, tp, tm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Purify the F4 part of a dynamic Lie-algebraic map.                 *
* Source:     MARYLIE, version 3.0 (routine DPUR4).                    *
* Input:                                                               *
*   NORD      (integer) Order of the map F (at most 4).                *
*   FP, FM    (map)     Original map, unchanged.                       *
* Output:                                                              *
*   GP, GM    (map)     Purified map.                                  *
*   TP, TM    (map)     Purifying map, i. e. G = T*F*T**(-1).          *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision fm,fp,gm,gp,tm,tp

      dimension         fp(*), fm(6,6), gp(*), gm(6,6), tp(*), tm(6,6)

      if (nord .ge. 4) then
        call ladpur(nord, fp, fm, gp, gm, tp, tm, 90, 208)
      endif

      end
+dk ladr2c
      subroutine ladr2c(nord, g, f)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Transform from a dynamic resonance basis to a Cartesian basis.     *
* Source:     MARYLIE, version 3.0 (routine DRTOC).                    *
* Author:     Filippo Neri, June 1986.                                 *
* Input:                                                               *
*   NORD      (integer) Order of the map G (at most 4).                *
*   G(*)      Dynamic resonance basis coefficients.                    *
* Output:                                                              *
*   F(*)      Cartesian basis coefficients.                            *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision f,g
      dimension         f(*), g(*)

      f(1) = g(1)
      f(2) = g(2)
      f(3) = g(3)
      f(4) = g(4)
      f(5) = g(5)
      f(6) = g(6)
      if (nord .ge. 2) then
        f(7) = g(20)+g(7)
        f(8) = 2.0*g(21)
        f(9) = g(26)+g(24)
        f(10) = -g(27)+g(25)
        f(11) = g(14)+g(12)
        f(12) = -g(15)+g(13)
        f(13) = -g(20)+g(7)
        f(14) = g(27)+g(25)
        f(15) = g(26)-g(24)
        f(16) = g(15)+g(13)
        f(17) = g(14)-g(12)
        f(18) = g(22)+g(8)
        f(19) = 2.0*g(23)
        f(20) = g(18)+g(16)
        f(21) = -g(19)+g(17)
        f(22) = -g(22)+g(8)
        f(23) = g(19)+g(17)
        f(24) = g(18)-g(16)
        f(25) = g(10)+g(9)
        f(26) = 2.0*g(11)
        f(27) = -g(10)+g(9)
        if (nord .ge. 3) then
          f(28) = g(72)+g(64)
          f(29) = 3.0*g(73)+g(65)
          f(30) = g(80)+g(76)+g(70)
          f(31) = -g(81)+g(77)+g(71)
          f(32) = g(50)+g(48)+g(28)
          f(33) = -g(51)+g(49)+g(29)
          f(34) = -3.0*g(72)+g(64)
          f(35) = 2.0*(g(81)+g(77))
          f(36) = 2.0*(g(80)-g(76))
          f(37) = 2.0*(g(51)+g(49))
          f(38) = 2.0*(g(50)-g(48))
          f(39) = g(82)+g(78)+g(68)
          f(40) = 2.0*(-g(83)+g(79))
          f(41) = g(62)+g(60)+g(58)+g(56)
          f(42) = -g(63)+g(61)-g(59)+g(57)
          f(43) = -g(82)-g(78)+g(68)
          f(44) = -g(63)-g(61)+g(59)+g(57)
          f(45) = -g(62)+g(60)+g(58)-g(56)
          f(46) = g(42)+g(40)+g(36)
          f(47) = 2.0*(-g(43)+g(41))
          f(48) = -g(42)-g(40)+g(36)
          f(49) = -g(73)+g(65)
          f(50) = -g(80)-g(76)+g(70)
          f(51) = g(81)-g(77)+g(71)
          f(52) = -g(50)-g(48)+g(28)
          f(53) = g(51)-g(49)+g(29)
          f(54) = g(83)+g(79)+g(69)
          f(55) = 2.0*(g(82)-g(78))
          f(56) = g(63)+g(61)+g(59)+g(57)
          f(57) = g(62)-g(60)+g(58)-g(56)
          f(58) = -g(83)-g(79)+g(69)
          f(59) = g(62)+g(60)-g(58)-g(56)
          f(60) = -g(63)+g(61)+g(59)-g(57)
          f(61) = g(43)+g(41)+g(37)
          f(62) = 2.0*(g(42)-g(40))
          f(63) = -g(43)-g(41)+g(37)
          f(64) = g(74)+g(66)
          f(65) = 3.0*g(75)+g(67)
          f(66) = g(54)+g(52)+g(30)
          f(67) = -g(55)+g(53)+g(31)
          f(68) = -3.0*g(74)+g(66)
          f(69) = 2.0*(g(55)+g(53))
          f(70) = 2.0*(g(54)-g(52))
          f(71) = g(46)+g(44)+g(38)
          f(72) = 2.0*(-g(47)+g(45))
          f(73) = -g(46)-g(44)+g(38)
          f(74) = -g(75)+g(67)
          f(75) = -g(54)-g(52)+g(30)
          f(76) = g(55)-g(53)+g(31)
          f(77) = g(47)+g(45)+g(39)
          f(78) = 2.0*(g(46)-g(44))
          f(79) = -g(47)-g(45)+g(39)
          f(80) = g(34)+g(32)
          f(81) = 3.0*g(33)+g(35)
          f(82) = -3.0*g(32)+g(34)
          f(83) = g(35)-g(33)
          if (nord .ge. 4) then
            f(84) = g(194)+g(178)+g(84)
            f(85) = 2.0*g(179)+4.0*g(195)
            f(86) = g(202)+g(198)+g(190)+g(186)
            f(87) = -g(203)+g(199)-g(191)+g(187)
            f(88) = g(156)+g(154)+g(140)+g(138)
            f(89) = -g(157)+g(155)-g(141)+g(139)
            f(90) = 2.0*g(84)-6.0*g(194)
            f(91) = 3.0*(g(203)+g(199))+g(191)+g(187)
            f(92) = 3.0*(g(202)-g(198))+g(190)-g(186)
            f(93) = 3.0*(g(157)+g(155))+g(141)+g(139)
            f(94) = 3.0*(g(156)-g(154))+g(140)-g(138)
            f(95) = g(208)+g(206)+g(184)+g(182)+g(87)
            f(96) = 2.0*(-g(209)+g(207)+g(185))
            f(97) = g(172)+g(170)+g(164)+g(162)+g(152)+g(150)
            f(98) = -g(173)+g(171)-g(165)+g(163)-g(153)+g(151)
            f(99) = -g(208)-g(206)-g(184)+g(182)+g(87)
            f(100) = -g(173)-g(171)+g(165)+g(163)+g(153)+g(151)
            f(101) = -g(172)+g(170)+g(164)-g(162)+g(152)-g(150)
            f(102) = g(120)+g(118)+g(114)+g(90)+g(88)
            f(103) = 2.0*(-g(121)+g(119)+g(91))
            f(104) = -g(120)-g(118)+g(114)-g(90)+g(88)
            f(105) = 2.0*g(179)-4.0*g(195)
            f(106) = -3.0*(g(202)+g(198))+g(190)+g(186)
            f(107) = 3.0*(g(203)-g(199))-g(191)+g(187)
            f(108) = -3.0*(g(156)+g(154))+g(140)+g(138)
            f(109) = 3.0*(g(157)-g(155))-g(141)+g(139)
            f(110) = 2.0*(g(209)+g(207)+g(183))
            f(111) = 4.0*(g(208)-g(206))
            f(112) = 2.0*(g(173)+g(171)+g(165)+g(163))
            f(113) = 2.0*(g(172)-g(170)+g(164)-g(162))
            f(114) = 2.0*(-g(209)-g(207)+g(183))
            f(115) = 2.0*(g(172)+g(170)-g(164)-g(162))
            f(116) = 2.0*(-g(173)+g(171)+g(165)-g(163))
            f(117) = 2.0*(g(121)+g(119)+g(115))
            f(118) = 4.0*(g(120)-g(118))
            f(119) = 2.0*(-g(121)-g(119)+g(115))
            f(120) = g(204)+g(200)+g(192)+g(188)
            f(121) = 3.0*(-g(205)+g(201))-g(193)+g(189)
            f(122) = g(176)+g(174)+g(168)+g(166)+g(148)+g(146)
            f(123) = g(177)-g(175)-g(169)+g(167)-g(149)+g(147)
            f(124) = -3.0*(g(204)+g(200))+g(192)+g(188)
            f(125) = 2.0*(-g(177)-g(175)+g(169)+g(167))
            f(126) = 2.0*(g(176)-g(174)+g(168)-g(166))
            f(127) = g(136)+g(134)+g(132)+g(130)+g(128)+g(126)
            f(128) = 2.0*(-g(137)+g(135)-g(133)+g(131))
            f(129) = -g(136)-g(134)-g(132)-g(130)+g(128)+g(126)
            f(130) = g(205)-g(201)-g(193)+g(189)
            f(131) = -g(176)-g(174)-g(168)-g(166)+g(148)+g(146)
            f(132) = -g(177)+g(175)+g(169)-g(167)-g(149)+g(147)
            f(133) = -g(137)-g(135)+g(133)+g(131)-g(129)+g(127)
            f(134) = 2.0*(-g(136)+g(134)+g(132)-g(130))
            f(135) = g(137)+g(135)-g(133)-g(131)-g(129)+g(127)
            f(136) = g(108)+g(106)+g(100)+g(98)
            f(137) = 3.0*(-g(101)+g(99))-g(109)+g(107)
            f(138) = -3.0*(g(100)+g(98))+g(108)+g(106)
            f(139) = -g(109)+g(107)+g(101)-g(99)
            f(140) = g(194)-g(178)+g(84)
            f(141) = -g(203)-g(199)+g(191)+g(187)
            f(142) = -g(202)+g(198)+g(190)-g(186)
            f(143) = -g(157)-g(155)+g(141)+g(139)
            f(144) = -g(156)+g(154)+g(140)-g(138)
            f(145) = -g(208)-g(206)+g(184)-g(182)+g(87)
            f(146) = 2.0*(g(209)-g(207)+g(185))
            f(147) = -g(172)-g(170)-g(164)-g(162)+g(152)+g(150)
            f(148) = g(173)-g(171)+g(165)-g(163)-g(153)+g(151)
            f(149) = g(208)+g(206)-g(184)-g(182)+g(87)
            f(150) = g(173)+g(171)-g(165)-g(163)+g(153)+g(151)
            f(151) = g(172)-g(170)-g(164)+g(162)+g(152)-g(150)
            f(152) = -g(120)-g(118)-g(114)+g(90)+g(88)
            f(153) = 2.0*(g(121)-g(119)+g(91))
            f(154) = g(120)+g(118)-g(114)-g(90)+g(88)
            f(155) = g(205)+g(201)+g(193)+g(189)
            f(156) = 3.0*(g(204)-g(200))+g(192)-g(188)
            f(157) = g(177)+g(175)+g(169)+g(167)+g(149)+g(147)
            f(158) = -g(176)+g(174)+g(168)-g(166)+g(148)-g(146)
            f(159) = -3.0*(g(205)+g(201))+g(193)+g(189)
            f(160) = 2.0*(g(176)+g(174)-g(168)-g(166))
            f(161) = 2.0*(g(177)-g(175)+g(169)-g(167))
            f(162) = g(137)+g(135)+g(133)+g(131)+g(129)+g(127)
            f(163) = 2.0*(g(136)-g(134)+g(132)-g(130))
            f(164) = -g(137)-g(135)-g(133)-g(131)+g(129)+g(127)
            f(165) = -g(204)+g(200)+g(192)-g(188)
            f(166) = -g(177)-g(175)-g(169)-g(167)+g(149)+g(147)
            f(167) = g(176)-g(174)-g(168)+g(166)+g(148)-g(146)
            f(168) = g(136)+g(134)-g(132)-g(130)+g(128)-g(126)
            f(169) = 2.0*(-g(137)+g(135)+g(133)-g(131))
            f(170) = -g(136)-g(134)+g(132)+g(130)+g(128)-g(126)
            f(171) = g(109)+g(107)+g(101)+g(99)
            f(172) = 3.0*(g(100)-g(98))+g(108)-g(106)
            f(173) = -3.0*(g(101)+g(99))+g(109)+g(107)
            f(174) = g(108)-g(106)-g(100)+g(98)
            f(175) = g(196)+g(180)+g(85)
            f(176) = 2.0*g(181)+4.0*g(197)
            f(177) = g(160)+g(158)+g(144)+g(142)
            f(178) = -g(161)+g(159)-g(145)+g(143)
            f(179) = 2.0*g(85)-6.0*g(196)
            f(180) = 3.0*(g(161)+g(159))+g(145)+g(143)
            f(181) = 3.0*(g(160)-g(158))+g(144)-g(142)
            f(182) = g(124)+g(122)+g(116)+g(92)+g(89)
            f(183) = 2.0*(-g(125)+g(123)+g(93))
            f(184) = -g(124)-g(122)+g(116)-g(92)+g(89)
            f(185) = 2.0*g(181)-4.0*g(197)
            f(186) = -3.0*(g(160)+g(158))+g(144)+g(142)
            f(187) = 3.0*(g(161)-g(159))-g(145)+g(143)
            f(188) = 2.0*(g(125)+g(123)+g(117))
            f(189) = 4.0*(g(124)-g(122))
            f(190) = 2.0*(-g(125)-g(123)+g(117))
            f(191) = g(112)+g(110)+g(104)+g(102)
            f(192) = 3.0*(-g(105)+g(103))-g(113)+g(111)
            f(193) = -3.0*(g(104)+g(102))+g(112)+g(110)
            f(194) = -g(113)+g(111)+g(105)-g(103)
            f(195) = g(196)-g(180)+g(85)
            f(196) = -g(161)-g(159)+g(145)+g(143)
            f(197) = -g(160)+g(158)+g(144)-g(142)
            f(198) = -g(124)-g(122)-g(116)+g(92)+g(89)
            f(199) = 2.0*(g(125)-g(123)+g(93))
            f(200) = g(124)+g(122)-g(116)-g(92)+g(89)
            f(201) = g(113)+g(111)+g(105)+g(103)
            f(202) = 3.0*(g(104)-g(102))+g(112)-g(110)
            f(203) = -3.0*(g(105)+g(103))+g(113)+g(111)
            f(204) = g(112)-g(110)-g(104)+g(102)
            f(205) = g(96)+g(94)+g(86)
            f(206) = 2.0*g(97)+4.0*g(95)
            f(207) = 2.0*g(86)-6.0*g(94)
            f(208) = 2.0*g(97)-4.0*g(95)
            f(209) = -g(96)+g(94)+g(86)
          endif
        endif
      endif

      end
+dk ladyna
      subroutine ladyna(deltap, flag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Analysis of dynamic maps; DYNAMIC command.                         *
* Attributes:                                                          *
*   DELTAP    (real)    Average relative momentum error.               *
*   MAP       FLAG(1)   Print total transfer map.                      *
*   ORBIT     FLAG(2)   Print transfer map w.r.t. closed orbit.        *
*   A         FLAG(3)   Print normalizing map script A.                *
*   N         FLAG(4)   Print normal form map script N.                *
*   RESONANCE FLAG(5)   Print resonance excitation terms.              *
*   EXPONENT  FLAG(6)   Print normal form exponent.                    *
*   HAMILTON  FLAG(7)   Print pseudo-Hamiltonian.                      *
*   INVARIANT FLAG(8)   Print linear invariants.                       *
*   LONG      FLAG(9)   Long output.                                   *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,mord,nline
      double precision alft,alfx,alfy,bett,betx,bety,deltap,dq1de3,
     +dq2de3,dq3de3,epth,eptt,eptv,epxh,epxt,epxv,epyh,epyt,epyv,eth,
     +ett,etv,exh,ext,exv,eyh,eyt,eyv,gamt,gamx,gamy,tenp6,twopi,ws,wx,
     +wy
      logical           flag(*)
+ca beam
+ca lamaps
+ca largo
+ca optic0
+ca range
+ca refer
+ca status
+ca zunit

+ca pi
      parameter         (twopi = 2.0d0 * pi, mord = 4, tenp6 = 1.0d6)

      character*(*)     title
      parameter         (title = 'Dynamic analysis.')

*---- Check line definition.
      call lnchck('LADYNA', error)
      if (error) return
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- SYMM is not allowed.
      if (symm) then
        call aafail('LADYNA', 1,
     +    '"SYMM" cannot be set for "DYNAMIC" command.')
        return
      endif

*---- Initialize polynomial package.
      call painit(6)

*---- Fix up environment.
      call aapdrp
      call enfix
      if (error) go to 800
      call enfreq(deltap)

*---- Print page header.
      if (flag(10)) then
        call prhead('DYNAMIC', title, deltap, 4, nline, 1)
        call enprgl
        call enprem
        call enprrf
      endif

*---- Compute one-turn map to order 4.
      call laturn(lcseq, deltas, flag(9), mord, fp, fm)

*---- Output for "MAP" and "ORBIT".
      if (flag(1) .or. flag(2)) then
        write (iqpr2, 910) 'Transfer map about closed orbit'
        call lmprnt(iqpr2, mord, fp, fm)
      endif

*---- Beginning of calculation.
*     Remove offensive terms from matrix part of map.
      call ladpu2(mord, fp, fm, gp, gm, tp, tm)
      if (error) return

*---- Remove offending terms in F3 part of map.
      call ladpu3(mord, gp, gm, gp, gm, hp, hm)
      call lmcat(mord, hp, hm, tp, tm, tp, tm)

*---- Remove offending terms in F4 part of map.
      call ladpu4(mord, gp, gm, gp, gm, hp, hm)
      call lmcat(mord, hp, hm, tp, tm, tp, tm)

*---- Output for "A"; print map script A (normalizing map).
      if (flag(3)) then
        write (iqpr2, 910) 'Normalizing map script A'
        call lmprnt(iqpr2, mord, tp, tm)
      endif

*---- Output for "N"; print map script N (normal form map).
      if (flag(4)) then
        write (iqpr2, 910) 'Normal form map script N'
        call lmprnt(iqpr2, mord, gp, gm)
      endif

*---- Compute tunes.
      wx = atan2(gm(1,2),gm(1,1))
      qx = nsup * wx / twopi
      if (qx .lt. 0.0) qx = qx + nsup
      wy = atan2(gm(3,4),gm(3,3))
      qy = nsup * wy / twopi
      if (qy .lt. 0.0) qy = qy + nsup
      ws = atan2(gm(5,6),gm(5,5))
      qs = nsup * abs(ws) / twopi

*---- Compute envelopes.
      exh  = sqrt(ex * (tm(1,1)**2 + tm(1,2)**2))
      exv  = sqrt(ex * (tm(1,3)**2 + tm(1,4)**2))
      ext  = sqrt(ex * (tm(1,5)**2 + tm(1,6)**2))
      epxh = sqrt(ex * (tm(2,1)**2 + tm(2,2)**2))
      epxv = sqrt(ex * (tm(2,3)**2 + tm(2,4)**2))
      epxt = sqrt(ex * (tm(2,5)**2 + tm(2,6)**2))
      eyh  = sqrt(ey * (tm(3,1)**2 + tm(3,2)**2))
      eyv  = sqrt(ey * (tm(3,3)**2 + tm(3,4)**2))
      eyt  = sqrt(ey * (tm(3,5)**2 + tm(3,6)**2))
      epyh = sqrt(ey * (tm(4,1)**2 + tm(4,2)**2))
      epyv = sqrt(ey * (tm(4,3)**2 + tm(4,4)**2))
      epyt = sqrt(ey * (tm(4,5)**2 + tm(4,6)**2))
      eth  = sqrt(et * (tm(5,1)**2 + tm(5,2)**2))
      etv  = sqrt(et * (tm(5,3)**2 + tm(5,4)**2))
      ett  = sqrt(et * (tm(5,5)**2 + tm(5,6)**2))
      epth = sqrt(et * (tm(6,1)**2 + tm(6,2)**2))
      eptv = sqrt(et * (tm(6,3)**2 + tm(6,4)**2))
      eptt = sqrt(et * (tm(6,5)**2 + tm(6,6)**2))

*---- Output for "RESONANCE"; resonance decomposition of purified map.
      call ladc2r(mord, gp, hp)
      if (flag(5)) then
        write (iqpr2, 910)
     +    'Generating coefficients in dynamic resonance base'
        call lmdprt(iqpr2, mord, hp)
      endif

*---- Dependence of tune on betatron amplitude.
      dq1de1 = - (2.0 * (nsup / pi)) * hp(84)
      dq2de2 = - (2.0 * (nsup / pi)) * hp(85)
      dq3de3 = - (2.0 * (nsup / pi)) * hp(86)
      dq1de2 = - hp(87) * (nsup / pi)
      dq1de3 = - hp(88) * (nsup / pi)
      dq2de3 = - hp(89) * (nsup / pi)

*---- Short output ends here.
      if (.not. flag(9)) go to 800

*---- Compute Twiss parameters.
      call lminv(mord, tp, tm, tp, tm)

*---- Exponent for normal form.
      call pa6clr(gp, 2)
      gp(7)  = - wx / 2.0
      gp(13) = - wx / 2.0
      gp(18) = - wy / 2.0
      gp(22) = - wy / 2.0
      gp(25) = - ws / 2.0
      gp(27) = - ws / 2.0

*---- Output for "EXPONENT".
      if (flag(6)) then
        write (iqpr2, 910) 'Exponent for normal form'
        call pa6prt(gp, mord, iqpr2)
      endif

*---- Output for "HAMILTONIAN"; pseudo Hamiltonian for normal form.
      if (flag(7)) then
        call lafxfm(mord, tp, tm, gp, hp)
        write (iqpr2, 910) 'Pseudo Hamiltonian'
        call pa6prt(hp, mord, iqpr2)
      endif

*---- Print eigenvectors.
      write (iqpr2, 910) 'Eigenvectors'
      write (iqpr2, '(1X,6E16.8)') ((tm(i,j), j = 1, 6), i = 1, 6)

*---- Invariant for mode 1.
      call pa6clr(gp, 2)
      gp(7) = 1.0
      gp(13) = 1.0
      call pa6xfm(gp, 2, tm, hp)
      gamx = hp(7)
      alfx = hp(8) / 2.0
      betx = hp(13)

*---- Invariant for mode 2.
      call pa6clr(gp, 2)
      gp(18) = 1.0
      gp(22) = 1.0
      call pa6xfm(gp, 2, tm, hp)
      gamy = hp(18)
      alfy = hp(19) / 2.0
      bety = hp(22)

*---- Invariant for mode 3.
      call pa6clr(gp, 2)
      gp(25) = 1.0
      gp(27) = 1.0
      call pa6xfm(gp, 2, tm, hp)
      gamt = hp(25)
      alft = hp(26) / 2.0
      bett = hp(27)

*---- Output for "INVARIANT".
      if (flag(8)) then
        write (iqpr2, 910) 'Invariant polynomial for mode 1'
        call pa6prt(hp, 2, iqpr2)
        write (iqpr2, 910) 'Invariant polynomial for mode 2'
        call pa6prt(hp, 2, iqpr2)
        write (iqpr2, 910) 'Invariant polynomial for mode 3'
        call pa6prt(hp, 2, iqpr2)
      endif

*---- Print tunes.
  800 continue
      if (flag(10)) then
        write (iqpr2, 920) deltas, qx, qy, qs

*---- Print Twiss parameters and envelopes (long output only).
        if (flag(9)) then
          write (iqpr2, 930)
     +      betx, bety, bett, alfx, alfy, alft, gamx, gamy, gamt,
     +      tenp6 * ex, tenp6 * ey, tenp6 * et,
     +      exh, exv, ext, epxh, epxv, epxt,
     +      eyh, eyv, eyt, epyh, epyv, epyt,
     +      eth, etv, ett, epth, eptv, eptt
        endif

*---- Print anharmonicities.
        write (iqpr2, 940)
     +    dq1de1, dq1de2, dq2de2, dq1de3, dq2de3, dq3de3
      endif

  910 format(' '/' ',a,':'/' ')
  920 format(' '/' Delta(p)/p:',f16.8,
     +       t45,'M o d e   1',t75,'M o d e   2',t105,'M o d e   3'/
     +       ' Fractional tunes:',t31,'Q1      =',f16.8,
     +       t61,'Q2      =',f16.8,t91,'Q3      =',f16.8)
  930 format(t31,'Beta_1  =',e16.8,' m',t61,'Beta_2  =',e16.8,' m',
     +       t91,'Beta_3  =',e16.8,' m'/
     +       t31,'Alpha_1 =',e16.8,' m',t61,'Alpha_2 =',e16.8,' m',
     +       t91,'Alpha_2 =',e16.8,' m'/
     +       t31,'Gamma_1 =',e16.8,' m',t61,'Gamma_2 =',e16.8,' m',
     +       t91,'Gamma_2 =',e16.8,' m'/
     +       ' Emittances:',t40,e16.8,'pi*mm*mrad',
     +       t70,e16.8,'pi*mm*mrad',t100,e16.8,'pi*mm*mrad'/
     +       ' Horizontal extent:',
     +       t40,e16.8,' m  ',t70,e16.8,' m  ',t100,e16.8,' m  '/
     +       ' Horizontal divergence:',
     +       t40,e16.8,' rad',t70,e16.8,' rad',t100,e16.8,' rad'/
     +       ' Vertical extent:',
     +       t40,e16.8,' m  ',t70,e16.8,' m  ',t100,e16.8,' m  '/
     +       ' Vertical divergence:',
     +       t40,e16.8,' rad',t70,e16.8,' rad',t100,e16.8,' rad'/
     +       ' Longitudinal extent:',
     +       t40,e16.8,' m  ',t70,e16.8,' m  ',t100,e16.8,' m  '/
     +       ' Longitudinal divergence:',
     +       t40,e16.8,' rad',t70,e16.8,' rad',t100,e16.8,' rad')
  940 format(' Normalized anharmonicities:',t31,'dQ1/dE1 =',e16.8/
     +       t31,'dQ1/dE2 =',e16.8,t61,'dQ2/dE2 =',e16.8/
     +       t31,'dQ1/dE3 =',e16.8,t61,'dQ2/dE3 =',e16.8,
     +       t91,'dQ3/dE3 =',e16.8)

      end
+dk lafxfm
      subroutine lafxfm(nord, gp, gm, fp, hp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Transform a function F with a map G.                               *
* Source:     MARYLIE, version 3.0 (routine FXFORM).                   *
* Input:                                                               *
*   NORD      (integer) Order of the maps involved (at most 4).        *
*   GP, GM    (map)     Transforming map.                              *
*   FP        (poly)    Polynomial to be transformed.                  *
* Output:                                                              *
*   HP        (poly)    The result of H = exp(:G:) F.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer i,isave,it1p,it2p,it3p,nord
      double precision fp,gm,gp,hp
      dimension         gp(*), gm(6,6), fp(*), hp(*)
+ca memdum
+ca pa6lnk
+ca wstack

*---- Allocate working space.
      isave = iwork
      it1p  = iwork
      it2p  = it1p + itop6(nord)
      it3p  = it2p + itop6(nord)
      iwork = it3p + itop6(nord)
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Clear first order part.
      call pa6clr(hp, 1)

*---- Copy second order part and transform by GM.
      call pa6xfm(fp, 2, gm, hp)

*---- Third order part.
      if (nord .ge. 3) then

*---- Compute [G3,F2], accumulate, and transform by GM.
        call pa6brk(gp, 3, fp, 2, dq(it1p+1))
        do 20 i = 28, 83
          dq(it1p+i) = fp(i) + dq(it1p+i)
   20   continue
        call pa6xfm(dq(it1p+1), 3, gm, hp)

*---- Fourth order part.
        if (nord .ge. 4) then

*---- Compute [G3,F3], [G3,[G3,F2]], and [G4,F2].
          call pa6brk(gp, 3, fp, 3, dq(it2p+1))
          call pa6brk(gp, 3, dq(it1p+1), 3, dq(it3p+1))
          call pa6brk(gp, 4, fp, 2, dq(it1p+1))

*---- Accumulate and transform by GM.
          do 30 i = 84, 209
            dq(it1p+i) =
     +      fp(i) + dq(it2p+i) + dq(it3p+i) / 2.0 + dq(it1p+i)
   30     continue
          call pa6xfm(dq(it1p+1), 4, gm, hp)
        endif
      endif

*---- Drop working storage.
      iwork = isave

      end
+dk lalump
      subroutine lalump(nord, lseq, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find closed orbit and build Lie-algebraic map along the orbit.     *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   LSEQ(*)   (pointer) Expansion of the relevant beam line sequence.  *
* Output:                                                              *
*   FP, FM    (map)     Resulting map.                                 *
*----------------------------------------------------------------------*
+ca aparam
      integer icode,ienum,iflag,ihm,ihp,iocc,ipos,isave,itm,itp,jbit,
     +jbyt,nord
      double precision displ,el,fm,fp
      integer           lseq(*)
      dimension         fp(*), fm(6,6)
+ca memdum
+ca bankhead
+ca prcgroup
+ca seqflag
+ca seqgroup
+ca optic0
+ca optic1
+ca pa6lnk
+ca refer
+ca wstack
+ca zunit

      dimension         displ(6)
      character*(mcnam) elmnam
      logical           fprt

*---- Allocate working space.
      isave = iwork
      itm   = iwork
      itp   = itm + 36
      ihm   = itp + itop6(nord)
      ihp   = ihm + 36
      iwork = ihp + itop6(nord)
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Initialize.
      call ucopy(orbit0, orbit, 6*mwflt)
      call lmone(nord, fp, fm)
      lsali = lq(lseq(1)-msali)
      lsfld = lq(lseq(1)-msfld)
      lscom = lq(lseq(1)-mscom)
      lcali = 0
      lcfld = 0
      lccom = 0

*---- Loop on range.
      do 90 ipos = iq(lseq(1)+msr1), iq(lseq(1)+msr2)
        call utelem(lseq, ipos, iflag, elmnam, iocc, ienum)
        icode = jbyt(iflag, 1, mcode)
        if (lsali .ne. 0) lcali = lq(lsali-ipos)
        if (lsfld .ne. 0) lcfld = lq(lsfld-ipos)
        if (lscom .ne. 0) lccom = lq(lscom-ipos)
        fprt = jbit(iflag,mlump) .ne. 0
        if (fprt) write (iqlog, 910) elmnam

*---- Misalignment at entrance.
        if (icode .ne. 3  .and.  lcali .ne. 0) then
          call ucopy(q(lcali+1), displ, 6 * mwflt)
          call lmdsp1(ipos, nord, displ, dq(itp+1), dq(itm+1))
          call lamove(nord, dq(itp+1), dq(itm+1), orbit,
     +                dq(ihp+1), dq(ihm+1))
          if (fprt) then
            write (iqlog, 920) 'misalignment at entrance'
            call lmprnt(iqlog, nord, dq(ihp+1), dq(ihm+1))
          endif
          call lmcat(nord, fp, fm, dq(ihp+1), dq(ihm+1), fp, fm)
        endif

*---- Compute element map.
        if (icode .eq. 1) then
          call lmmap(nord, el, dq(itp+1), dq(itm+1))
          call lamove(nord, dq(itp+1), dq(itm+1), orbit,
     +                dq(ihp+1), dq(ihm+1))
          if (fprt) then
            write (iqlog, 920) 'element'
            call lmprnt(iqlog, nord, dq(ihp+1), dq(ihm+1))
          endif
          call lmcat(nord, fp, fm, dq(ihp+1), dq(ihm+1), fp, fm)
        endif

*---- Misalignment at exit.
        if (icode .ne. 2  .and.  lcali .ne. 0) then
          call ucopy(q(lcali+1), displ, 6 * mwflt)
          call lmdsp2(ipos, nord, displ, dq(itp+1), dq(itm+1))
          call lamove(nord, dq(itp+1), dq(itm+1), orbit,
     +                dq(ihp+1), dq(ihm+1))
          if (fprt) then
            write (iqlog, 920) 'misalignment at exit'
            call lmprnt(iqlog, nord, dq(ihp+1), dq(ihm+1))
          endif
          call lmcat(nord, fp, fm, dq(ihp+1), dq(ihm+1), fp, fm)
        endif
   90 continue

*---- Drop working storage.
      iwork = isave

  910 format(' '/' LALUMP.  Entering object: ',a)
  920 format(' Transfer map for ',a,':')

      end
+dk lamain
      subroutine lamain(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Switch routine for Lie algebraic analysis.                         *
* Input:                                                               *
*   IPR       (integer) Process code.                                  *
*   ISP       (integer) Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca largo
+ca message
+ca range
+ca refer
+ca status
+ca wstack
      integer i,ipr,isp
      double precision deltap,dq1de3,dq2de3

      logical           flag(20)

*---- ISP = 1, "DYNAMIC".
      if (isp .eq. 1) then

*---- Retrieve parameters.
        deltap = 0.0
        call utgflt(lccmd, 1, 1, deltap)
        do 10 i = 1, 9
          flag(i) = .false.
   10   continue
        call utglog(lccmd, 2, 10, flag)

*---- Execute.
        flag(10) = .true.
        call ladyna(deltap, flag)

*---- Make parameters accessible to VALUE and PUSH.
        call aasetp('Q1',     q1)
        call aasetp('Q2',     q2)
        call aasetp('Q3',     q3)
        call aasetp('Q1''',   xi1)
        call aasetp('Q2''',   xi2)
        call aasetp('Q3''',   xi3)
        call aasetp('Q1''''', xin1)
        call aasetp('Q2''''', xin2)
        call aasetp('Q3''''', xin3)
        call aasetp('DQ1DE1', dq1de1)
        call aasetp('DQ2DE2', dq2de2)
        call aasetp('DQ3DE3', dq2de2)
        call aasetp('DQ1DE2', dq1de2)
        call aasetp('DQ1DE3', dq1de3)
        call aasetp('DQ2DE3', dq2de3)

*---- ISP = 2, "STATIC".
      else if (isp .eq. 2) then

*---- Retrieve parameters.
        deltap = 0.0
        call utgflt(lccmd, 1, 1, deltap)
        do 20 i = 1, 14
          flag(i) = .false.
   20   continue
        call utglog(lccmd, 2, 15, flag)

*---- Execute.
        flag(15) = .true.
        call lastat(deltap, flag)

*---- Make parameters accessible to VALUE and PUSH.
        call aasetp('Q1',     q1)
        call aasetp('Q2',     q2)
        call aasetp('Q1''',   xi1)
        call aasetp('Q2''',   xi2)
        call aasetp('Q1''''', xin1)
        call aasetp('Q2''''', xin2)
        call aasetp('DQ1DE1', dq1de1)
        call aasetp('DQ2DE2', dq2de2)
        call aasetp('DQ1DE2', dq1de2)
      endif

      end
+dk lamove
      subroutine lamove(nord, fp, fm, orbit, hp, hm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Move through a Lie-algebraic map and return the map for the        *
*   vicinity of the orbit.                                             *
* Input:                                                               *
*   NORD      (integer) Order of the map F (at most 4).                *
*   FP, FM    (map)     Map for one element or turn.                   *
* Output:                                                              *
*   ORBIT(6)  (real)    The orbit found.                               *
*   HP, HM    (map)     Map for the vicinity of the orbit.             *
*----------------------------------------------------------------------*
+ca aparam
      integer ifj,ifk,isave,itm,nord
      double precision fm,fp,gp,gt,half,hm,hp,orbit
      dimension         fp(*), fm(6,6), orbit(*), hp(*), hm(6,6)
+ca memdum
+ca wstack

      parameter         (half = 0.5d0)
      dimension         gp(6), gt(6)
      logical           eflag

*---- Allocate working space.
      isave = iwork
      itm   = iwork
      ifj   = itm + 36
      ifk   = ifj + 209
      iwork = ifk + 209
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Transform orbit to a G1.
      gp(1) = fp(1) + orbit(2)
      gp(2) = fp(2) - orbit(1)
      gp(3) = fp(3) + orbit(4)
      gp(4) = fp(4) - orbit(3)
      gp(5) = fp(5) + orbit(6)
      gp(6) = fp(6) - orbit(5)

*---- Copy original map (F3 through F(NORD)).
      call pa6clr(hp, -nord)

*---- Move orbit across F2 term.
      call m66inv(fm, dq(itm+1))
      call pa6xfm(gp, 1, dq(itm+1), gt)
      call pa6cpy(gt, 1, hp)

*---- Terms of total rank 3.
      if (nord .ge. 3) then
        call lmexpo(gt, 1, fp, 3, dq(ifj+1), 3)
        call pa6add(hp, dq(ifj+1), -3, hp)

*---- Terms of total rank 4.
        if (nord .ge. 4) then
          call lmexpo(gt, 1, fp, 4, dq(ifk+1), 4)
          call pa6add(hp, dq(ifk+1), -4, hp)
          call pa6brk(dq(ifj+1), 1, dq(ifj+1), 2, dq(ifk+1))
          call pa6brk(dq(ifj+1), 1, dq(ifj+1), 3, dq(ifk+1))
          call pa6brk(dq(ifj+1), 3, dq(ifj+1), 2, dq(ifk+1))
          call pa6sum(half, dq(ifk+1), -3, hp)
        endif
      endif

*---- Calculate the matrix part of the factored exponential.
      call m66mak(hp, hm)
      call m66exp(hm, dq(itm+1), eflag)
      call m66mpy(dq(itm+1), fm, hm)

*---- Convert moved G1 to orbit.
      orbit(1) = - hp(2)
      orbit(2) = + hp(1)
      orbit(3) = - hp(4)
      orbit(4) = + hp(3)
      orbit(5) = - hp(6)
      orbit(6) = + hp(5)
      call pa6clr(hp, -2)

*---- Drop working storage.
      iwork = isave

      end
+dk lasc2r
      subroutine lasc2r(nord, f, g)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Transform from a Cartesian basis to a static resonance basis.      *
* Source:     MARYLIE, version 3.0 (routine CTOSR).                    *
* Input:                                                               *
*   NORD      (integer) Order of the map F (at most 4).                *
*   F(*)      Cartesian basis coefficients.                            *
* Output:                                                              *
*   G(*)      Static resonance basis coefficients.                     *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision by2,by4,by8,f,g
      dimension         f(*), g(*)

      parameter         (by2 = 1.0d0 / 2.0d0)
      parameter         (by4 = 1.0d0 / 4.0d0)
      parameter         (by8 = 1.0d0 / 8.0d0)

      g(1) = f(6)
      g(2) = f(1)
      g(3) = f(2)
      g(4) = f(3)
      g(5) = f(4)
      g(6) = f(5)
      if (nord .ge. 2) then
        g(7) = by2 * (f(13)+f(7))
        g(8) = by2 * (f(22)+f(18))
        g(9) = f(27)
        g(10) = f(12)
        g(11) = f(17)
        g(12) = f(21)
        g(13) = f(24)
        g(14) = by2 * (-f(13)+f(7))
        g(15) = by2 * f(8)
        g(16) = by2 * (-f(22)+f(18))
        g(17) = by2 * f(19)
        g(18) = by2 * (-f(15)+f(9))
        g(19) = by2 * (f(14)+f(10))
        g(20) = by2 * (f(15)+f(9))
        g(21) = by2 * (f(14)-f(10))
        g(22) = f(11)
        g(23) = f(16)
        g(24) = f(20)
        g(25) = f(23)
        g(26) = f(25)
        g(27) = f(26)
        if (nord .ge. 3) then
          g(28) = by2 * (f(53)+f(33))
          g(29) = by2 * (f(76)+f(67))
          g(30) = f(83)
          g(31) = f(48)
          g(32) = f(63)
          g(33) = f(73)
          g(34) = f(79)
          g(35) = by2 * (-f(53)+f(33))
          g(36) = by2 * f(38)
          g(37) = by2 * (-f(76)+f(67))
          g(38) = by2 * f(70)
          g(39) = by2 * (-f(60)+f(42))
          g(40) = by2 * (f(57)+f(45))
          g(41) = by2 * (f(60)+f(42))
          g(42) = by2 * (f(57)-f(45))
          g(43) = by4 * (f(34) + 3.0*f(28))
          g(44) = by4 * (f(29) + 3.0*f(49))
          g(45) = by4 * (f(68) + 3.0*f(64))
          g(46) = by4 * (f(65) + 3.0*f(74))
          g(47) = by2 * (f(43)+f(39))
          g(48) = by2 * (f(58)+f(54))
          g(49) = by2 * (f(50)+f(30))
          g(50) = by2 * (f(51)+f(31))
          g(51) = by4 * (-f(34)+f(28))
          g(52) = by4 * (-f(49)+f(29))
          g(53) = by4 * (-f(68)+f(64))
          g(54) = by4 * (-f(74)+f(65))
          g(55) = by4 * (-f(50)-f(36)+f(30))
          g(56) = by4 * (-f(51)+f(35)+f(31))
          g(57) = by4 * (-f(55)-f(43)+f(39))
          g(58) = by4 * (-f(58)+f(54)+f(40))
          g(59) = by4 * (-f(50)+f(36)+f(30))
          g(60) = by4 * (f(51)+f(35)-f(31))
          g(61) = by4 * (f(55)-f(43)+f(39))
          g(62) = by4 * (f(58)-f(54)+f(40))
          g(63) = f(32)
          g(64) = f(37)
          g(65) = f(41)
          g(66) = f(44)
          g(67) = f(46)
          g(68) = f(47)
          g(69) = f(52)
          g(70) = f(56)
          g(71) = f(59)
          g(72) = f(61)
          g(73) = f(62)
          g(74) = f(66)
          g(75) = f(69)
          g(76) = f(71)
          g(77) = f(72)
          g(78) = f(75)
          g(79) = f(77)
          g(80) = f(78)
          g(81) = f(80)
          g(82) = f(81)
          g(83) = f(82)
          if (nord .ge. 4) then
            g(84) = by2 * (f(154)+f(104))
            g(85) = by2 * (f(200)+f(184))
            g(86) = f(209)
            g(87) = by8 * (f(90) + 3.0*(f(140)+f(84)))
            g(88) = by8 * (f(179) + 3.0*(f(195)+f(175)))
            g(89) = by4 * (f(149)+f(145)+f(99)+f(95))
            g(90) = f(139)
            g(91) = f(174)
            g(92) = f(194)
            g(93) = f(204)
            g(94) = by2 * (-f(154)+f(104))
            g(95) = by2 * f(119)
            g(96) = by2 * (-f(200)+f(184))
            g(97) = by2 * f(190)
            g(98) = by2 * (-f(170)+f(129))
            g(99) = by2 * (f(164)+f(135))
            g(100) = by2 * (f(170)+f(129))
            g(101) = by2 * (f(164)-f(135))
            g(102) = by4 * (f(109) + 3.0*f(89))
            g(103) = by4 * (f(94) + 3.0*f(144))
            g(104) = by4 * (f(187) + 3.0*f(178))
            g(105) = by4 * (f(181) + 3.0*f(197))
            g(106) = by2 * (f(132)+f(123))
            g(107) = by2 * (f(167)+f(158))
            g(108) = by2 * (f(148)+f(98))
            g(109) = by2 * (f(151)+f(101))
            g(110) = by4 * (-f(109)+f(89))
            g(111) = by4 * (-f(144)+f(94))
            g(112) = by4 * (-f(187)+f(178))
            g(113) = by4 * (-f(197)+f(181))
            g(114) = by4 * (-f(148)-f(116)+f(98))
            g(115) = by4 * (-f(151)+f(113)+f(101))
            g(116) = by4 * (-f(161)-f(132)+f(123))
            g(117) = by4 * (-f(167)+f(158)+f(126))
            g(118) = by4 * (-f(148)+f(116)+f(98))
            g(119) = by4 * (f(151)+f(113)-f(101))
            g(120) = by4 * (f(161)-f(132)+f(123))
            g(121) = by4 * (f(167)-f(158)+f(126))
            g(122) = by2 * (-f(140)+f(84))
            g(123) = by4 * (f(105)+f(85))
            g(124) = by2 * (-f(195)+f(175))
            g(125) = by4 * (f(185)+f(176))
            g(126) = by4 * (-f(149)-f(145)+f(99)+f(95))
            g(127) = by4 * (f(114)+f(110))
            g(128) = by4 * (-f(149)+f(145)-f(99)+f(95))
            g(129) = by4 * (f(146)+f(96))
            g(130) = by8 * ((f(106)-f(92)) + 3.0*(-f(142)+f(86)))
            g(131) = by8 * ((f(107)+f(91)) + 3.0*(f(141)+f(87)))
            g(132) = by8 * ((-f(156)+f(124)) + 3.0*(-f(165)+f(120)))
            g(133) = by8 * ((f(159)+f(121)) + 3.0*(f(155)+f(130)))
            g(134) = by8 * ((f(106)+f(92)) + 3.0*(f(142)+f(86)))
            g(135) = by8 * ((-f(107)+f(91)) + 3.0*(f(141)-f(87)))
            g(136) = by8 * ((f(156)+f(124)) + 3.0*(f(165)+f(120)))
            g(137) = by8 * ((-f(159)+f(121)) + 3.0*(-f(155)+f(130)))
            g(138) = by8 * (f(140)-f(90)+f(84))
            g(139) = by8 * (-f(105)+f(85))
            g(140) = by8 * (f(195)-f(179)+f(175))
            g(141) = by8 * (-f(185)+f(176))
            g(142) = by8 * (f(142)-f(106)-f(92)+f(86))
            g(143) = by8 * (-f(141)-f(107)+f(91)+f(87))
            g(144) = by8 * (f(165)-f(156)-f(124)+f(120))
            g(145) = by8 * (-f(159)+f(155)-f(130)+f(121))
            g(146) = by8 * (-f(142)-f(106)+f(92)+f(86))
            g(147) = by8 * (-f(141)+f(107)+f(91)-f(87))
            g(148) = by8 * (-f(165)+f(156)-f(124)+f(120))
            g(149) = by8 * (f(159)-f(155)-f(130)+f(121))
            g(150) = by8 * (f(149)-f(145)-f(111)-f(99)+f(95))
            g(151) = by8 * (-f(146)-f(114)+f(110)+f(96))
            g(152) = by8 * (f(149)-f(145)+f(111)-f(99)+f(95))
            g(153) = by8 * (f(146)-f(114)+f(110)-f(96))
            g(154) = f(88)
            g(155) = f(93)
            g(156) = f(97)
            g(157) = f(100)
            g(158) = f(102)
            g(159) = f(103)
            g(160) = f(108)
            g(161) = f(112)
            g(162) = f(115)
            g(163) = f(117)
            g(164) = f(118)
            g(165) = f(122)
            g(166) = f(125)
            g(167) = f(127)
            g(168) = f(128)
            g(169) = f(131)
            g(170) = f(133)
            g(171) = f(134)
            g(172) = f(136)
            g(173) = f(137)
            g(174) = f(138)
            g(175) = f(143)
            g(176) = f(147)
            g(177) = f(150)
            g(178) = f(152)
            g(179) = f(153)
            g(180) = f(157)
            g(181) = f(160)
            g(182) = f(162)
            g(183) = f(163)
            g(184) = f(166)
            g(185) = f(168)
            g(186) = f(169)
            g(187) = f(171)
            g(188) = f(172)
            g(189) = f(173)
            g(190) = f(177)
            g(191) = f(180)
            g(192) = f(182)
            g(193) = f(183)
            g(194) = f(186)
            g(195) = f(188)
            g(196) = f(189)
            g(197) = f(191)
            g(198) = f(192)
            g(199) = f(193)
            g(200) = f(196)
            g(201) = f(198)
            g(202) = f(199)
            g(203) = f(201)
            g(204) = f(202)
            g(205) = f(203)
            g(206) = f(205)
            g(207) = f(206)
            g(208) = f(207)
            g(209) = f(208)
          endif
        endif
      endif

      end
+dk laseig
      subroutine laseig(fm, reeig, aieig, am)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Return eigenvalues and eigenvectors of a 4x4 matrix.               *
* Input:                                                               *
*   FM(6,6)   (real)    Matrix to be transformed.                      *
* Output:                                                              *
*   REEIG(6)  (real)    Real parts of eigenvalues.                     *
*   AIEIG(6)  (real)    Imaginary parts of eigenvalues.                *
*   AM(6,6)   (real)    Transforming matrix, contains eigenvectors.    *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ihi,ilo,info,ipind,iqind,j,k,mdim,nn
      double precision aieig,aival,am,big,c,d,dx,dy,fm,pb,reeig,reval,s,
     +tm
      dimension         fm(6,6), reeig(6), aieig(6), am(6,6)
+ca message

      parameter         (ilo = 1, ihi = 4, mdim = 6, nn = 4)
      dimension         d(6), reval(6), aival(6), tm(6,6)
      integer           kpnt(6)

*---- Compute eigenvalues and vectors.
      call m66cpy(fm, tm)
      call m66one(am)
      call orthes(mdim, nn, ilo, ihi, tm, d)
      call ortran(mdim,  nn, ilo, ihi, tm, d, am)
      call hqr2(mdim, nn, ilo, ihi, tm, reval, aival, am, info)
      if (info .ne. 0) then
        write (msg, 910) ((fm(i,k), k = 1, 6), i = 1, 6)
  910   format('Unable to find eigenvalues for matrix:'/
     +         (6f12.6))
        call aafail('LADEIG', 7, msg)
        go to 999
      endif

*---- Normalize the eigenvectors.
      do 30 k = 1, 5, 2
        pb = 0.0
        do 10 ipind = 2, 6, 2
          iqind = ipind - 1
          pb = pb + am(iqind,k) * am(ipind,k+1)
     +            - am(ipind,k) * am(iqind,k+1)
   10   continue
        s = sqrt(abs(pb))
        if (pb .lt. 0.0) then
          aival(k) = - aival(k)
          aival(k+1) = - aival(k+1)
        endif
        do 20 i = 1, 6
          am(i,k)   = am(i,k) / s
          am(i,k+1) = am(i,k+1) * (s / pb)
   20   continue
   30 continue

*---- Sort these eigenvectors.
      call m66cpy(am, tm)

*---- Find the eigenvectors with the largest vertical component.
      big = 0.0
      kpnt(3) = 1
      do 40 i = 1, 3, 2
        c = tm(3,i)**2 + tm(3,i+1)**2 + tm(4,i)**2 + tm(4,i+1)**2
        if (c .gt. big) then
          big = c
          kpnt(3) = i
        endif
  40  continue

*---- Find the remaining vector.
      do 50 i = 1, 3, 2
        if (i .ne. kpnt(3)) kpnt(1) = i
   50 continue

*---- Reorder vectors.
      do 70 i = 1, 3, 2
        k = kpnt(i)
        reeig(i) = reval(k)
        aieig(i) = aival(k)
        reeig(i+1) = reval(k+1)
        aieig(i+1) = aival(k+1)
        do 60 j = 1, 6
          am(j,i) = tm(j,k)
          am(j,i+1) = tm(j,k+1)
   60   continue
   70 continue
      reeig(5) = 1.0
      aieig(5) = 0.0
      reeig(6) = 1.0
      aieig(6) = 0.0

*---- Rephase the result.
      call m66one(tm)
      dx = sqrt(am(1,1)**2 + am(1,2)**2)
      tm(1,1) = am(1,1) / dx
      tm(2,1) = am(1,2) / dx
      tm(1,2) = - tm(2,1)
      tm(2,2) = tm(1,1)
      dy = sqrt(am(3,3)**2 + am(3,4)**2)
      tm(3,3) = am(3,3) / dy
      tm(4,3) = am(3,4) / dy
      tm(3,4) = - tm(4,3)
      tm(4,4) = tm(3,3)
      call m66mpy(am, tm, am)

  999 end
+dk laspuc
      subroutine laspuc(nord, fp, fm, gp, gm, tp, tm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Purify the chromatic F3 part of a static Lie-algebraic map.        *
* Source:     MARYLIE, version 3.0 (routine SCPUR3).                   *
* Input:                                                               *
*   NORD      (integer) Order of the map F (at most 4).                *
*   FP, FM    (map)     Original map to be purified (unchanged).       *
* Output:                                                              *
*   GP, GM    (map)     Purified map.                                  *
*   TP, TM    (map)     Purifying map, i. e. G = T*F*T**(-1).          *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision fm,fp,gm,gp,tm,tp
      dimension         fp(*), fm(6,6)
      dimension         gp(*), gm(6,6), tp(*), tm(6,6)

      if (nord .ge. 3) then
        call laspur(nord, fp, fm, gp, gm, tp, tm, 31, 42)
      endif

      end
+dk laspug
      subroutine laspug(nord, fp, fm, gp, gm, tp, tm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Purify the geometric F3 part of a static Lie-algebraic map.        *
* Source:     MARYLIE, version 3.0 (routine SGPUR3).                   *
* Input:                                                               *
*   NORD      (integer) Order of the map F (at most 4).                *
*   FP, FM    (map)     Original map to be purified (unchanged).       *
* Output:                                                              *
*   GP, GM    (map)     Purified map.                                  *
*   TP, TM    (map)     Purifying map, i. e. G = T*F*T**(-1).          *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision fm,fp,gm,gp,tm,tp
      dimension         fp(*), fm(6,6)
      dimension         gp(*), gm(6,6), tp(*), tm(6,6)

      if (nord .ge. 3) then
        call laspur(nord, fp, fm, gp, gm, tp, tm, 43, 62)
      endif

      end
+dk laspur
      subroutine laspur(nord, fp, fm, gp, gm, tp, tm, min, max)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Generic purifying routine for the static resonance case.           *
* Source:     MARYLIE, version 3.0 (routine GSPUR).                    *
* Input:                                                               *
*   NORD      (integer) Order of the map F (at most 4).                *
*   FP, FM    (map)     Original map to be purified (unchanged).       *
*   MIN, MAX  (integer) Index range to be purified.                    *
* Output:                                                              *
*   GP, GM    (map)     Purified map.                                  *
*   TP, TM    (map)     Purifying map, i. e. G = T*F*T**(-1).          *
*----------------------------------------------------------------------*
+ca aparam
      integer i,isave,it1p,it2p,k,k1,k2,max,min,n,nord,nx,ny
      double precision ax,ay,bx,by,cth,det,detmin,fm,fp,gm,gp,sth,tm,tp
      dimension         fp(*), fm(6,6), gp(*), gm(6,6), tp(*), tm(6,6)
+ca memdum
+ca message
+ca wstack

      parameter         (detmin = 1.0d-12)
      dimension         ax(-4:4), bx(-4:4), ay(-4:4), by(-4:4)
      integer           isrexp(0:2,209)

      data (isrexp(i,1),   i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,2),   i = 0, 2) / 1, 1, 0 /
      data (isrexp(i,3),   i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,4),   i = 0, 2) / 1, 0, 1 /
      data (isrexp(i,5),   i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,6),   i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,7),   i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,8),   i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,9),   i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,10),  i = 0, 2) / 1, 1, 0 /
      data (isrexp(i,11),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,12),  i = 0, 2) / 1, 0, 1 /
      data (isrexp(i,13),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,14),  i = 0, 2) / 1, 2, 0 /
      data (isrexp(i,15),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,16),  i = 0, 2) / 1, 0, 2 /
      data (isrexp(i,17),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,18),  i = 0, 2) / 1, 1, 1 /
      data (isrexp(i,19),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,20),  i = 0, 2) / 1, 1, -1 /
      data (isrexp(i,21),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,22),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,23),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,24),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,25),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,26),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,27),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,28),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,29),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,30),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,31),  i = 0, 2) / 1, 1, 0 /
      data (isrexp(i,32),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,33),  i = 0, 2) / 1, 0, 1 /
      data (isrexp(i,34),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,35),  i = 0, 2) / 1, 2, 0 /
      data (isrexp(i,36),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,37),  i = 0, 2) / 1, 0, 2 /
      data (isrexp(i,38),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,39),  i = 0, 2) / 1, 1, 1 /
      data (isrexp(i,40),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,41),  i = 0, 2) / 1, 1, -1 /
      data (isrexp(i,42),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,43),  i = 0, 2) / 1, 1, 0 /
      data (isrexp(i,44),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,45),  i = 0, 2) / 1, 0, 1 /
      data (isrexp(i,46),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,47),  i = 0, 2) / 1, 1, 0 /
      data (isrexp(i,48),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,49),  i = 0, 2) / 1, 0, 1 /
      data (isrexp(i,50),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,51),  i = 0, 2) / 1, 3, 0 /
      data (isrexp(i,52),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,53),  i = 0, 2) / 1, 0, 3 /
      data (isrexp(i,54),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,55),  i = 0, 2) / 1, 2, 1 /
      data (isrexp(i,56),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,57),  i = 0, 2) / 1, 1, 2 /
      data (isrexp(i,58),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,59),  i = 0, 2) / 1, 2, -1 /
      data (isrexp(i,60),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,61),  i = 0, 2) / 1, -1, 2 /
      data (isrexp(i,62),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,63),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,64),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,65),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,66),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,67),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,68),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,69),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,70),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,71),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,72),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,73),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,74),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,75),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,76),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,77),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,78),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,79),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,80),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,81),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,82),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,83),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,84),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,85),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,86),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,87),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,88),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,89),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,90),  i = 0, 2) / 1, 1, 0 /
      data (isrexp(i,91),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,92),  i = 0, 2) / 1, 0, 1 /
      data (isrexp(i,93),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,94),  i = 0, 2) / 1, 2, 0 /
      data (isrexp(i,95),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,96),  i = 0, 2) / 1, 0, 2 /
      data (isrexp(i,97),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,98),  i = 0, 2) / 1, 1, 1 /
      data (isrexp(i,99),  i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,100), i = 0, 2) / 1, 1, -1 /
      data (isrexp(i,101), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,102), i = 0, 2) / 1, 1, 0 /
      data (isrexp(i,103), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,104), i = 0, 2) / 1, 0, 1 /
      data (isrexp(i,105), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,106), i = 0, 2) / 1, 1, 0 /
      data (isrexp(i,107), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,108), i = 0, 2) / 1, 0, 1 /
      data (isrexp(i,109), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,110), i = 0, 2) / 1, 3, 0 /
      data (isrexp(i,111), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,112), i = 0, 2) / 1, 0, 3 /
      data (isrexp(i,113), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,114), i = 0, 2) / 1, 2, 1 /
      data (isrexp(i,115), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,116), i = 0, 2) / 1, 1, 2 /
      data (isrexp(i,117), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,118), i = 0, 2) / 1, 2, -1 /
      data (isrexp(i,119), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,120), i = 0, 2) / 1, -1, 2 /
      data (isrexp(i,121), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,122), i = 0, 2) / 1, 2, 0 /
      data (isrexp(i,123), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,124), i = 0, 2) / 1, 0, 2 /
      data (isrexp(i,125), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,126), i = 0, 2) / 1, 2, 0 /
      data (isrexp(i,127), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,128), i = 0, 2) / 1, 0, 2 /
      data (isrexp(i,129), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,130), i = 0, 2) / 1, 1, 1 /
      data (isrexp(i,131), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,132), i = 0, 2) / 1, 1, 1 /
      data (isrexp(i,133), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,134), i = 0, 2) / 1, 1, -1 /
      data (isrexp(i,135), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,136), i = 0, 2) / 1, -1, 1 /
      data (isrexp(i,137), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,138), i = 0, 2) / 1, 4, 0 /
      data (isrexp(i,139), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,140), i = 0, 2) / 1, 0, 4 /
      data (isrexp(i,141), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,142), i = 0, 2) / 1, 3, 1 /
      data (isrexp(i,143), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,144), i = 0, 2) / 1, 1, 3 /
      data (isrexp(i,145), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,146), i = 0, 2) / 1, 3, -1 /
      data (isrexp(i,147), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,148), i = 0, 2) / 1, -1, 3 /
      data (isrexp(i,149), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,150), i = 0, 2) / 1, 2, 2 /
      data (isrexp(i,151), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,152), i = 0, 2) / 1, 2, -2 /
      data (isrexp(i,153), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,154), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,155), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,156), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,157), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,158), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,159), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,160), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,161), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,162), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,163), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,164), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,165), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,166), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,167), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,168), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,169), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,170), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,171), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,172), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,173), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,174), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,175), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,176), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,177), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,178), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,179), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,180), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,181), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,182), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,183), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,184), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,185), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,186), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,187), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,188), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,189), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,190), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,191), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,192), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,193), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,194), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,195), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,196), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,197), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,198), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,199), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,200), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,201), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,202), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,203), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,204), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,205), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,206), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,207), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,208), i = 0, 2) / 0, 0, 0 /
      data (isrexp(i,209), i = 0, 2) / 0, 0, 0 /

*---- Allocate working space.
      isave = iwork
      it1p  = iwork
      it2p  = it1p + 209
      iwork = it2p + 209
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Set up multiple angle arrays.
      ax(0) = 1.0
      bx(0) = 0.0
      ay(0) = 1.0
      by(0) = 0.0
      ax(1) = fm(1,1)
      bx(1) = fm(1,2)
      ay(1) = fm(3,3)
      by(1) = fm(3,4)

      do 10 n = 2, 4
        ax(n) = ax(1) * ax(n-1) - bx(1) * bx(n-1)
        bx(n) = bx(1) * ax(n-1) + ax(1) * bx(n-1)
   10 continue

      do 20 n = 2, 4
        ay(n) = ay(1) * ay(n-1) - by(1) * by(n-1)
        by(n) = by(1) * ay(n-1) + ay(1) * by(n-1)
   20 continue

      do 30 n = 1, 4
        ax(-n) =   ax(n)
        bx(-n) = - bx(n)
        ay(-n) =   ay(n)
        by(-n) = - by(n)
   30 continue

*---- Resonance decompose map.
      call lasc2r(nord, fp, dq(it1p+1))

*---- Set up map to remove offensive terms of index MIN->MAX.
      call pa6clr(dq(it2p+1), -nord)
      do 100 k = min, max
        if (isrexp(0,k) .ne. 0) then

*---- Compute cth = cos(theta) and sth=sin(theta) for
*     THETA = SREXP(1,K)*WX + SREXP(2,K)*WY
          nx = isrexp(1,k)
          ny = isrexp(2,k)
          cth = ax(nx) * ay(ny) - bx(nx) * by(ny)
          sth = bx(nx) * ay(ny) + ax(nx) * by(ny)

*---- Carry out rest of calculation.
          det = 2.0 * (1.0 - cth)
          k1 = k
          k2 = k + 1
          if (abs(det) .gt. detmin) then
            dq(it2p+k1) =
     +        ((1.0 - cth) * dq(it1p+k1) + sth * dq(it1p+k2)) / det
            dq(it2p+k2) =
     +        ((1.0 - cth) * dq(it1p+k2) - sth * dq(it1p+k1)) / det
          else
            write (msg, 910) k1, k2, det
  910       format('DET(',i3,',',i3,') = ',f16.8,' not removed.')
            call aawarn('LADPUR', 1, msg)
          endif
        endif
  100 continue

*---- Transform map to Cartesian basis; the result is the map T.
      call lmone(nord, tp, tm)
      call lasr2c(nord, dq(it2p+1), tp)

*---- Remove offensive terms (MIN->MAX).
      call lmsand(nord, tp, tm, fp, fm, gp, gm)

*---- Drop working storage.
      iwork = isave

      end
+dk laspu2
      subroutine laspu2(nord, fp, fm, gp, gm, tp, tm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Purify the F2 (matrix) part of a static Lie-algebraic map.         *
*   Assumes that dispersion is already removed.                        *
* Source:     MARYLIE, version 3.0 (routine SPUR2).                    *
* Input:                                                               *
*   NORD      (integer) Order of the map F (at most 4).                *
*   FP, FM    (map)     Original map to be purified (unchanged).       *
* Output:                                                              *
*   GP, GM    (map)     Purified map.                                  *
*   TP, TM    (map)     Purifying map, i. e. G = T*F*T**(-1).          *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,nord
      double precision aieig,diff,fm,fp,gm,gp,reeig,tm,tol,tp
      dimension         fp(*), fm(6,6)
      dimension         gp(*), gm(6,6), tp(*), tm(6,6)
+ca message
+ca status

      parameter         (tol = 1.0d-8)
      dimension         reeig(6), aieig(6)

*---- Find the map A2.
      call laseig(fm, reeig, aieig, tm)
      if (error) go to 999

*---- Go to Floquet variables.
      call pa6clr(tp, -nord)
      call lmsand(nord, tp, tm, fp, fm, gp, gm)

*---- If eigenvalues are off unit circle, print warning message.
      do 20 i = 1, 4
        if (abs(reeig(i)**2 + aieig(i)**2 - 1.0) .gt. tol) then
          write (msg, 910)
          do 10 j = 1, 6
            diff = sqrt(reeig(j)**2 + aieig(j)**2) - 1.0
            write (msg(j+2), 920) reeig(j), aieig(j), diff
   10     continue
          call aawarn('LASPU2', 8, msg)
          go to 999
        endif
   20 continue

  910 format('Eigenvalues not on unit circle:'/
     +       6x,'Real',12x,'Imaginary',5x,'Error')
  920 format(2f16.8,1p,e18.6)

  999 end
+dk laspu4
      subroutine laspu4(nord, fp, fm, gp, gm, tp, tm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Purify the F4 part of a static Lie-algebraic map.                  *
* Source:     MARYLIE, version 3.0 (routine SPUR4).                    *
* Input:                                                               *
*   NORD      (integer) Order of the map F (at most 4).                *
*   FP, FM    (map)     Original map to be purified (unchanged).       *
* Output:                                                              *
*   GP, GM    (map)     Purified map.                                  *
*   TP, TM    (map)     Purifying map, i. e. G = T*F*T**(-1).          *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision fm,fp,gm,gp,tm,tp
      dimension         fp(*), fm(6,6), gp(*), gm(6,6), tp(*), tm(6,6)

      if (nord .ge. 4) then
        call laspur(nord, fp, fm, gp, gm, tp, tm, 90, 153)
      endif

      end
+dk lasr2c
      subroutine lasr2c(nord, g, f)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Transform from a static resonance basis to a Cartesian basis.      *
* Source:     MARYLIE, version 3.0 (routine SRTOC).                    *
* Input:                                                               *
*   NORD      (integer) Order of the map G (at most 4).                *
*   G(*)      Static resonance basis coefficients.                     *
* Output:                                                              *
*   F(*)      Cartesian basis coefficients.                            *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision f,g
      dimension         f(*), g(*)

      f(1) = g(2)
      f(2) = g(3)
      f(3) = g(4)
      f(4) = g(5)
      f(5) = g(6)
      f(6) = g(1)
      if (nord .ge. 2) then
        f(7) = g(14)+g(7)
        f(8) = 2.0*g(15)
        f(9) = g(20)+g(18)
        f(10) = -g(21)+g(19)
        f(11) = g(22)
        f(12) = g(10)
        f(13) = -g(14)+g(7)
        f(14) = g(21)+g(19)
        f(15) = g(20)-g(18)
        f(16) = g(23)
        f(17) = g(11)
        f(18) = g(16)+g(8)
        f(19) = 2.0*g(17)
        f(20) = g(24)
        f(21) = g(12)
        f(22) = -g(16)+g(8)
        f(23) = g(25)
        f(24) = g(13)
        f(25) = g(26)
        f(26) = g(27)
        f(27) = g(9)
        if (nord .ge. 3) then
          f(28) = g(51)+g(43)
          f(29) = 3.0*g(52)+g(44)
          f(30) = g(59)+g(55)+g(49)
          f(31) = -g(60)+g(56)+g(50)
          f(32) = g(63)
          f(33) = g(35)+g(28)
          f(34) = -3.0*g(51)+g(43)
          f(35) = 2.0*(g(60)+g(56))
          f(36) = 2.0*(g(59)-g(55))
          f(37) = g(64)
          f(38) = 2.0*g(36)
          f(39) = g(61)+g(57)+g(47)
          f(40) = 2.0*(g(62)+g(58))
          f(41) = g(65)
          f(42) = g(41)+g(39)
          f(43) = -g(61)-g(57)+g(47)
          f(44) = g(66)
          f(45) = -g(42)+g(40)
          f(46) = g(67)
          f(47) = g(68)
          f(48) = g(31)
          f(49) = -g(52)+g(44)
          f(50) = -g(59)-g(55)+g(49)
          f(51) = g(60)-g(56)+g(50)
          f(52) = g(69)
          f(53) = -g(35)+g(28)
          f(54) = -g(62)+g(58)+g(48)
          f(55) = 2.0*(g(61)-g(57))
          f(56) = g(70)
          f(57) = g(42)+g(40)
          f(58) = g(62)-g(58)+g(48)
          f(59) = g(71)
          f(60) = g(41)-g(39)
          f(61) = g(72)
          f(62) = g(73)
          f(63) = g(32)
          f(64) = g(53)+g(45)
          f(65) = 3.0*g(54)+g(46)
          f(66) = g(74)
          f(67) = g(37)+g(29)
          f(68) = -3.0*g(53)+g(45)
          f(69) = g(75)
          f(70) = 2.0*g(38)
          f(71) = g(76)
          f(72) = g(77)
          f(73) = g(33)
          f(74) = -g(54)+g(46)
          f(75) = g(78)
          f(76) = -g(37)+g(29)
          f(77) = g(79)
          f(78) = g(80)
          f(79) = g(34)
          f(80) = g(81)
          f(81) = g(82)
          f(82) = g(83)
          f(83) = g(30)
          if (nord .ge. 4) then
            f(84) = g(138)+g(122)+g(87)
            f(85) = 2.0*g(123)+4.0*g(139)
            f(86) = g(146)+g(142)+g(134)+g(130)
            f(87) = -g(147)+g(143)-g(135)+g(131)
            f(88) = g(154)
            f(89) = g(110)+g(102)
            f(90) = 2.0*g(87)-6.0*g(138)
            f(91) = 3.0*(g(147)+g(143))+g(135)+g(131)
            f(92) = 3.0*(g(146)-g(142))+g(134)-g(130)
            f(93) = g(155)
            f(94) = 3.0*g(111)+g(103)
            f(95) = g(152)+g(150)+g(128)+g(126)+g(89)
            f(96) = 2.0*(-g(153)+g(151)+g(129))
            f(97) = g(156)
            f(98) = g(118)+g(114)+g(108)
            f(99) = -g(152)-g(150)-g(128)+g(126)+g(89)
            f(100) = g(157)
            f(101) = -g(119)+g(115)+g(109)
            f(102) = g(158)
            f(103) = g(159)
            f(104) = g(94)+g(84)
            f(105) = 2.0*g(123)-4.0*g(139)
            f(106) = -3.0*(g(146)+g(142))+g(134)+g(130)
            f(107) = 3.0*(g(147)-g(143))-g(135)+g(131)
            f(108) = g(160)
            f(109) = -3.0*g(110)+g(102)
            f(110) = 2.0*(g(153)+g(151)+g(127))
            f(111) = 4.0*(g(152)-g(150))
            f(112) = g(161)
            f(113) = 2.0*(g(119)+g(115))
            f(114) = 2.0*(-g(153)-g(151)+g(127))
            f(115) = g(162)
            f(116) = 2.0*(g(118)-g(114))
            f(117) = g(163)
            f(118) = g(164)
            f(119) = 2.0*g(95)
            f(120) = g(148)+g(144)+g(136)+g(132)
            f(121) = 3.0*(g(149)+g(145))+g(137)+g(133)
            f(122) = g(165)
            f(123) = g(120)+g(116)+g(106)
            f(124) = -3.0*(g(148)+g(144))+g(136)+g(132)
            f(125) = g(166)
            f(126) = 2.0*(g(121)+g(117))
            f(127) = g(167)
            f(128) = g(168)
            f(129) = g(100)+g(98)
            f(130) = -g(149)-g(145)+g(137)+g(133)
            f(131) = g(169)
            f(132) = -g(120)-g(116)+g(106)
            f(133) = g(170)
            f(134) = g(171)
            f(135) = -g(101)+g(99)
            f(136) = g(172)
            f(137) = g(173)
            f(138) = g(174)
            f(139) = g(90)
            f(140) = g(138)-g(122)+g(87)
            f(141) = -g(147)-g(143)+g(135)+g(131)
            f(142) = -g(146)+g(142)+g(134)-g(130)
            f(143) = g(175)
            f(144) = -g(111)+g(103)
            f(145) = -g(152)-g(150)+g(128)-g(126)+g(89)
            f(146) = 2.0*(g(153)-g(151)+g(129))
            f(147) = g(176)
            f(148) = -g(118)-g(114)+g(108)
            f(149) = g(152)+g(150)-g(128)-g(126)+g(89)
            f(150) = g(177)
            f(151) = g(119)-g(115)+g(109)
            f(152) = g(178)
            f(153) = g(179)
            f(154) = -g(94)+g(84)
            f(155) = -g(149)+g(145)-g(137)+g(133)
            f(156) = 3.0*(g(148)-g(144))+g(136)-g(132)
            f(157) = g(180)
            f(158) = -g(121)+g(117)+g(107)
            f(159) = 3.0*(g(149)-g(145))-g(137)+g(133)
            f(160) = g(181)
            f(161) = 2.0*(g(120)-g(116))
            f(162) = g(182)
            f(163) = g(183)
            f(164) = g(101)+g(99)
            f(165) = -g(148)+g(144)+g(136)-g(132)
            f(166) = g(184)
            f(167) = g(121)-g(117)+g(107)
            f(168) = g(185)
            f(169) = g(186)
            f(170) = g(100)-g(98)
            f(171) = g(187)
            f(172) = g(188)
            f(173) = g(189)
            f(174) = g(91)
            f(175) = g(140)+g(124)+g(88)
            f(176) = 2.0*g(125)+4.0*g(141)
            f(177) = g(190)
            f(178) = g(112)+g(104)
            f(179) = 2.0*g(88)-6.0*g(140)
            f(180) = g(191)
            f(181) = 3.0*g(113)+g(105)
            f(182) = g(192)
            f(183) = g(193)
            f(184) = g(96)+g(85)
            f(185) = 2.0*g(125)-4.0*g(141)
            f(186) = g(194)
            f(187) = -3.0*g(112)+g(104)
            f(188) = g(195)
            f(189) = g(196)
            f(190) = 2.0*g(97)
            f(191) = g(197)
            f(192) = g(198)
            f(193) = g(199)
            f(194) = g(92)
            f(195) = g(140)-g(124)+g(88)
            f(196) = g(200)
            f(197) = -g(113)+g(105)
            f(198) = g(201)
            f(199) = g(202)
            f(200) = -g(96)+g(85)
            f(201) = g(203)
            f(202) = g(204)
            f(203) = g(205)
            f(204) = g(93)
            f(205) = g(206)
            f(206) = g(207)
            f(207) = g(208)
            f(208) = g(209)
            f(209) = g(86)
          endif
        endif
      endif

      end
+dk lastat
      subroutine lastat(deltap, flag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Analysis of static maps; STATIC command execution.                 *
* Attributes:                                                          *
*   DELTAP    (real)    Average relative energy error.                 *
*   MAP       FLAG(1)   Print total transfer map.                      *
*   ORBIT     FLAG(2)   Print transfer map w.r.t. closed orbit.        *
*   FIXED     FLAG(3)   Print map about fixed point.                   *
*   T         FLAG(4)   Print transformation to fixed point script T.  *
*   A         FLAG(5)   Print normalizing map script A.                *
*   N         FLAG(6)   Print normal form map script N.                *
*   RESONANCE FLAG(7)   Print resonance excitation terms.              *
*   EXPONENT  FLAG(8)   Print normal form exponent.                    *
*   HAMILTON  FLAG(9)   Print pseudo-Hamiltonian.                      *
*   BETATRON  FLAG(10)  Print betatron factor.                         *
*   NONLINEAR FLAG(11)  Print nonlinear factor of the map.             *
*   CONJUGATE FLAG(12)  Print conjugate to betatron factor.            *
*   INVARIANT FLAG(13)  Print linear invariants.                       *
*   LONG      FLAG(14)  Long output.                                   *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,mord,nline
      double precision alfx,alfy,betx,bety,dddpx,dddpy,dddx,dddy,ddpx,
     +ddpy,ddx,ddy,deltap,dpx,dpy,dx,dy,epxh,epxv,epyh,epyv,exh,exv,eyh,
     +eyv,gamx,gamy,tenp6,twopi,wt,wx,wy,zero
      logical           flag(*)
+ca beam
+ca lamaps
+ca largo
+ca optic0
+ca range
+ca refer
+ca status
+ca zunit
      character*(*)     title

+ca pi
      parameter         (twopi = 2.0 * pi, zero  = 0.0, mord = 4)
      parameter         (tenp6 = 1.0d6)
      parameter         (title = 'Static analysis.')

*---- Check line definition.
      call lnchck('LASTAT', error)
      if (error) return
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)
*---- SYMM is not allowed.
      if (symm) then
        call aafail('LASTAT', 1,
     +    '"SYMM" cannot be set for "STATIC" command.')
        return
      endif

*---- Initialize polynomial package.
      call painit(6)

*---- Print page header.
      if (flag(15)) then
        call prhead('STATIC', title, deltap, 4, nline, 1)
      endif

*---- Fix up environment.
      call aapdrp
      call enfix
      call enfreq(deltap)

*---- Compute one-turn map to order 4.
      call laturn(lcseq, deltas, flag(14), mord, fp, fm)

*---- Output for "MAP" or "ORBIT".
      if (flag(1) .or. flag(2)) then
        write (iqpr2, 910) 'Transfer map about closed orbit'
        call lmprnt(iqpr2, mord, fp, fm)
      endif

*---- Transform top fixed point and print its location.
      call lmfixp(fp, fm, gp, gm, tp, tm)
      dx    = tm(1,6)
      dpx   = tm(2,6)
      dy    = tm(3,6)
      dpy   = tm(4,6)
      ddx   = - tp(63)
      ddpx  =   tp(48)
      ddy   = - tp(79)
      ddpy  =   tp(73)
      dddx  = - tp(174)
      dddpx =   tp(139)
      dddy  = - tp(204)
      dddpy =   tp(194)

*---- Output for "FIXED".
      if (flag(3)) then
        write (iqpr2, 910) 'Transfer map about fixed point'
        call lmprnt(iqpr2, mord, gp, gm)
      endif

*---- Output for "T".
      if (flag(4)) then
        write (iqpr2, 910) 'Transformation script T to fixed point'
        call lmprnt(iqpr2, mord, tp, tm)
      endif

*---- Remove other linear terms.
      call laspu2(mord, gp, gm, gp, gm, pp, pm)
      if (error) return
      call lmcat(mord, pp, pm, tp, tm, tp, tm)

*---- Tunes and momentum compaction.
      wx = atan2(gm(1,2),gm(1,1))
      q1 = nsup * wx / twopi
      if (q1 .lt. 0.0) q1 = q1 + nsup
      wy = atan2(gm(3,4),gm(3,3))
      q2 = nsup * wy / twopi
      if (q2 .lt. 0.0) q2 = q2 + nsup
      wt = gm(5,6)

*---- Remove offending chromatic terms in F3 part of map.
      call laspuc(mord, gp, gm, gp, gm, hp, hm)
      call lmcat(mord, hp, hm, tp, tm, tp, tm)

*---- Compute chromaticities.
      call lasc2r(mord, gp, hp)
      xi1 = - nsup * hp(28) / pi
      xi2 = - nsup * hp(29) / pi
      xin1 = - (2.0 * nsup / pi) * hp(84)
      xin2 = - (2.0 * nsup / pi) * hp(85)

*---- Remove offending geometric terms in F3 part of map.
      call laspug(mord, gp, gm, gp, gm, hp, hm)
      call lmcat(mord, hp, hm, tp, tm, tp, tm)

*---- Dependence of tune on betatron amplitude.
      call lasc2r(mord, gp, hp)
      dq1de1 = - (2.0 * (nsup / pi)) * hp(87)
      dq2de2 = - (2.0 * (nsup / pi)) * hp(88)
      dq1de2 = - (nsup / pi) * hp(89)

*---- Short output ends here.
      if (.not. flag(14)) go to 800

*---- Remove offending terms in F4 part of map.
      call laspu4(mord, gp, gm, gp, gm, hp, hm)
      call lmcat(mord, hp, hm, tp, tm, tp, tm)

*---- Output for "A".
      if (flag(5)) then
        write (iqpr2, 910) 'Normalizing map script A'
        call lmprnt(iqpr2, mord, tp, tm)
      endif

*---- Output for "N".
      if (flag(6)) then
        write (iqpr2, 910) 'Normal form map script N'
        call lmprnt(iqpr2, mord, gp, gm)
      endif

*---- Output for "RESONANCE".
      call lasc2r(mord, gp, hp)
      if (flag(7)) then
        write (iqpr2, 910)
     +    'Generating coefficients in static resonance base'
        call lmsprt(iqpr2, mord, hp)
      endif

*---- Output for "EXPONENT".
      call pa6clr(gp, -2)
      gp(7)  = - wx / 2.0
      gp(13) = - wx / 2.0
      gp(18) = - wy / 2.0
      gp(22) = - wy / 2.0
      gp(27) = - wt / 2.0
      if (flag(8)) then
        write (iqpr2, 910) 'Exponent for normal form'
        call pa6prt(gp, mord, iqpr2)
      endif

*---- Output for "HAMILTON"; Pseudo Hamiltonian for normal form.
      if (flag(9)) then
        call lminv(mord, tp, tm, tp, tm)
        call lafxfm(mord, tp, tm, gp, hp)
        write (iqpr2, 910) 'Pseudo Hamiltonian'
        call pa6prt(hp, mord, iqpr2)
      endif

*==== Second pass --- Twiss parameters and envelopes.
      call lmfixp(fp, fm, gp, gm, tp, tm)

*---- Output for "BETATRON"; extract the betatron factor of the map.
      call labeta(mord, gp, gm, bp, bm)
      if (flag(10)) then
        write (iqpr2, 910) 'Betatron factor of transfer map'
        call lmprnt(iqpr2, mord, bp, bm)
      endif

*---- Compute B for specific value of delta.
      call lachrm(mord, bp, bm, a1m, a2m)
      write (iqpr2, 910) 'On-energy Twiss matrix'
      call m66prt(bm, iqpr2)
      write (iqpr2, 910) 'First derivative w.r.t. energy error'
      write (iqpr2, '(1X,6E16.8)') ((a1m(i,j), j = 1, 6), i = 1, 6)
      write (iqpr2, 910) 'Second derivative w.r.t. energy error'
      write (iqpr2, '(1X,6E16.8)') ((a2m(i,j), j = 1, 6), i = 1, 6)

*---- Output for "NONLINEAR"; non-linear factor about fixed point.
      if (flag(11)) then
        call lminv(mord, bp, bm, hp, hm)
        call lmcat(mord, hp, hm, gp, gm, hp, hm)
        write (iqpr2, 910) 'Non-linear factor about fixed point'
        call lmprnt(iqpr2, mord, hp, hm)
      endif

*---- Transforming (conjugating) map AB for the betatron factor.
      call lmsand(mord, pp, pm, bp, bm, gp, gm)

*---- Remove offending chromatic terms in F3 part of map.
      call laspuc(mord, gp, gm, gp, gm, hp, hm)
      call lmcat(mord, hp, hm, pp, pm, tp, tm)

*---- Remove offending terms in F4 part of map.
      call laspu4(mord, gp, gm, gp, gm, hp, hm)
      call lmcat(mord, hp, hm, tp, tm, tp, tm)

*---- output for "CONJUGATE".
      if (flag(12)) then
        write (iqpr2, 910) 'Conjugate factor for betatron map'
        call lmprnt(iqpr2, mord, tp, tm)
      endif

*---- Eigenvectors and their dependence on DELTA.
      call lachrm(mord, tp, tm, a1m, a2m)
      write (iqpr2, 910) 'On energy eigenvectors'
      write (iqpr2, '(1X,6E16.8)') ((tm(i,j), j = 1, 6), i = 1, 6)
      write (iqpr2, 910) 'First derivatives'
      write (iqpr2, '(1X,6E16.8)') ((a1m(i,j), j = 1, 6), i = 1, 6)
      write (iqpr2, 910) 'Second derivatives'
      write (iqpr2, '(1X,6E16.8)') ((a2m(i,j), j = 1, 6), i = 1, 6)

*---- Compute envelopes.
      exh  = sqrt(ex * (tm(1,1)**2 + tm(1,2)**2))
      exv  = sqrt(ex * (tm(1,3)**2 + tm(1,4)**2))
      epxh = sqrt(ex * (tm(2,1)**2 + tm(2,2)**2))
      epxv = sqrt(ex * (tm(2,3)**2 + tm(2,4)**2))
      eyh  = sqrt(ey * (tm(3,1)**2 + tm(3,2)**2))
      eyv  = sqrt(ey * (tm(3,3)**2 + tm(3,4)**2))
      epyh = sqrt(ey * (tm(4,1)**2 + tm(4,2)**2))
      epyv = sqrt(ey * (tm(4,3)**2 + tm(4,4)**2))

*---- Invariant for mode 1.
      call lminv(mord, tp, tm, tp, tm)
      call pa6clr(gp, 2)
      gp(7) = 1.0
      gp(13) = 1.0
      call pa6xfm(gp, 2, tm, hp)
      alfx = hp(8) / 2.0
      betx = hp(13)
      gamx = hp(7)

*---- Output for "INVARIANT".
      if (flag(13)) then
        write (iqpr2, 910) 'Invariant polynomial for mode 1'
        call pa6prt(hp, 2, iqpr2)
      endif

*---- Invariant for mode 2.
      call pa6clr(gp, 2)
      gp(18) = 1.0
      gp(22) = 1.0
      call pa6xfm(gp, 2, tm, hp)
      alfy = hp(19) / 2.0
      bety = hp(22)
      gamy = hp(18)

*---- Output for "INVARIANT".
      if (flag(13)) then
        write (iqpr2, 910) 'Invariant polynomial for mode 2'
        call pa6prt(hp, 2, iqpr2)
      endif

*---- Print closed orbit position and its derivatives.
      write (iqpr2, 920) (orbit0(j), j = 1, 4), dx, dpx, dy, dpy,
     +                   ddx, ddpx, ddy, ddpy, dddx, dddpx, dddy, dddpy

*---- Print tunes.
  800 continue
      if (flag(15)) then
        write (iqpr2, 930) deltas, q1, q2, xi1, xi2, xin1, xin2

*---- Print Twiss parameters and envelopes (long output only).
        if (flag(14)) then
          write (iqpr2, 940) betx, bety, alfx, alfy, gamx, gamy,
     +                       tenp6 * ex, tenp6 * ey,
     +                       exh, exv, epxh, epxv, eyh, eyv, epyh, epyv
        endif

*---- Print normalized anharmonicites.
        write (iqpr2, 950) dq1de1, dq1de2, dq2de2
      endif

  910 format(' '/' ',a,':'/' ')
  920 format(' '/' Fixed point position:'/
     +       ' Closed orbit position',t51,4f16.6/
     +       ' First derivative w.r.t. energy',t51,4e16.6/
     +       ' Second derivative w.r.t. energy',t51,4e16.6/
     +       ' Third derivative w.r.t. energy',t51,4e16.6)
  930 format(' '/' Delta(p)/p:',f16.8,
     +       t45,'M o d e   1',t75,'M o d e   2'/
     +       ' Fractional tunes:',t31,'Q1      =',f16.8,
     +       t61,'Q2      =',  f16.8/
     +       ' First order chromaticity:',t31,'Q1''     =',f16.8,
     +       t61,'Q2''     =', f16.8/
     +       ' Second order chromaticity:',t31,'Q1''''    =',f16.8,
     +       t61,'Q2''''    =',f16.8)
  940 format(t31,'Beta_1  =',e16.8,' m',t61,'Beta_2  =',e16.8,' m'/
     +       t31,'Alpha_1 =',e16.8,' m',t61,'Alpha_2 =',e16.8,' m'/
     +       t31,'Gamma_1 =',e16.8,' m',t61,'Gamma_2 =',e16.8,' m'/
     +  ' Emittances:',t40,e16.8,' pi*mmm*mrad',t70,e16.8,'pi*mm*mrad'/
     +  ' Horizontal extent:',    t40,e16.8,' m  ',t70,e16.8,' m'/
     +  ' Horizontal divergence:',t40,e16.8,' rad',t70,e16.8,' rad'/
     +  ' Vertical extent:',      t40,e16.8,' m  ',t70,e16.8,' m'/
     +  ' Vertical divergence:',  t40,e16.8,' rad',t70,e16.8,' rad')
  950 format(' Normalized anharmonicities:',t31,'dQ1/dE1 =',e16.8/
     +       t31,'dQ1/dE2 =',e16.8,t61,'dQ2/dE2 =',e16.8)

      end
+dk latrns
      subroutine latrns(nord, pbh, ndim, zi, zf)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track through Lie-algebraic map with the "non-symplectic" method.  *
* Input:                                                               *
*   NORD      (integer) Order of the map.                              *
*   PBH(NDIM,6)         Poisson brackets as required.                  *
*   ZI(6)     (real)    Input phase space vector.                      *
* Output:                                                              *
*   ZF(6)     (real)    Final phase space vector.                      *
*----------------------------------------------------------------------*
+ca aparam
      integer i,isave,ivect,j,jord,ndim,nord
      double precision pbh,zf,zi
      dimension         pbh(ndim,6), zi(6), zf(6)
+ca memdum
+ca pa6lnk
+ca wstack

*---- Allocate working space.
      isave = iwork
      ivect = iwork
      iwork = ivect + itop6(nord)
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Compute basis monomials.
      do 10 i = 1, 6
        dq(ivect+i) = zi(i)
   10 continue
      do 30 jord = 2, nord-1
        do 20 i = ibot6(jord), itop6(jord)
          dq(ivect+i) = dq(ivect+iq(lind61+i))*dq(ivect+iq(lind62+i))
   20   continue
   30 continue

*---- Compute transformation.
      do 90 j = 1, 6
        zf(j) = 0.0
        do 80 i = 1, itop6(nord-1)
          zf(j) = zf(j) + dq(ivect+i) * pbh(i,j)
   80   continue
   90 continue

*---- Drop working storage.
      iwork = isave

      end
+dk laturn
      subroutine laturn(lseq, deltap, show, nord, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Fetch Lie algebraic map for one turn, if available, otherwise      *
*   search for closed orbit and accumulate map.                        *
* Input:                                                               *
*   NORD      (integer) Order of the map.                              *
* Output:                                                              *
*   FP, FM    (map)     Map w.r.t. the closed orbit.                   *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iflag,isize,lmap,lzfind,nord
      double precision deltap,fm,fp
      integer           lseq(1)
      logical           show
      logical           eflag
      dimension         fp(*), fm(6,6)
+ca memdum
+ca seqgroup
+ca optic0
+ca pa6lnk
+ca refer
+ca stflag
+ca option
+ca coesti

*---- Search for precomputed map with same DELTAP and flags.
*     Warning: LMAP is local link. Be careful with Zebra calls.
      iflag = 0
      do 10 i = 1, maxdof
        if (doflag(i)) then
          iflag = 2 * iflag + 1
        else
          iflag = 2 * iflag
        endif
   10 continue
      isize = itop6(nord)
      lmap = lzfind(0, lq(lcseq-mslie), nord, 2)
   20 if (lmap .ne. 0) then
        if (abs(q(lmap+1)-real(deltap)) .lt. 1.0e-6  .and.
     +      iq(lmap+2) .eq. iflag) then
          call ucopy(q(lmap+3), orbit0, 6*mwflt)
          if (optflg(20))  call ucopy(orbit0, coest, 6*mwflt)
          call ucopy(q(lmap+6*mwflt+3), fm, 36*mwflt)
          call ucopy(q(lmap+42*mwflt+3), fp, isize*mwflt)
          return
        endif
        lmap = lq(lmap)
        go to 20
      endif

*---- Accumulate transfer map and save it for later use.
      call lmclor(lcseq, deltap, show, nord, eflag, fp, fm)
      call mzbook(2, lmap, lcseq, -mslie, 'LMAP', 0, 0,
     +            (42 + isize) * mwflt + 3, 2, -1)
      q(lmap+1) = deltap
      iq(lmap+2) = 16 * (36 + isize) + mreal
      call ucopy(orbit0, q(lmap+3), 6*mwflt)
      if (optflg(20))  call ucopy(orbit0, coest, 6*mwflt)
      call ucopy(fm, q(lmap+6*mwflt+3), 36*mwflt)
      call ucopy(fp, q(lmap+42*mwflt+3), isize*mwflt)

      end
+dk lazzzz
+dk lmaaaa
+dk lmarb
      subroutine lmarb(nord, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lie-algebraic map for arbitrary element.                           *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
* Output:                                                              *
*   FP, FM    (map)     Element map.                                   *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision fm,fp
      dimension         fp(*), fm(6,6)

*---- Set up identity map.
      call lmone(nord, fp, fm)

      end
+dk lmbend
      subroutine lmbend(nord, el, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lie-algebraic map for a bending magnet.                            *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
* Output:                                                              *
*   EL        (real)    Bend length.                                   *
*   FP, FM    (map)     Bend map.                                      *
* Local link:                                                          *
*   LMAP                Transfer map for bend.                         *
*----------------------------------------------------------------------*
* Modified: 11-JAN-1999, T. Raubenheimer (SLAC)                        *
*   Included FINTX attribute in RBEND, SBEND, and GBEND (NOTE: FINTX   *
*   is assumed to have same value as FINT if it is not set or is       *
*   negative as is the default in the dictionary file)                 *
* Modified: 25-MAR-1999, M. Woodley (SLAC)                             *
*   Fix pointer to FINTX parameter for SBEND and RBEND                 *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,ifm,ifp,igm,igp,ilink,isave,isp,itop,lmap,nd,nord
      double precision an,corr,dh,e1x,e1y,e2x,e2y,el,field,fint,fm,fp,h,
     +h1,h2,hgap,one,sk1,sk2,sk3,sks,tilt
      dimension         fp(*), fm(6,6)
      double precision an2
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca mapelm
+ca option
+ca pa6lnk
+ca refer
+ca tmcomm
+ca wstack
      double precision fintx
      logical bvflag

      parameter         (one = 1.0d0)
      dimension         field(2,0:3)

      bvflag = .false.
*---- Allocate working space.
      isave = iwork
      ifm   = iwork
      igm   = ifm + 36
      ifp   = igm + 36
      igp   = ifp + 209
      iwork = igp + 209
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Test for presence of bend.
      call ucopy(q(lcelm+melen), el, mwflt)
      if (el .eq. 0.0) then
        call lmone(nord, fp, fm)

*---- Can we use precomputed map?
      else
        ilink = iq(lcelm+mbat) + mbelie
        lmap = lq(lcelm-ilink)
        if (lmap .ne. 0  .and.  lcfld .eq. 0) then
          itop = itop6(min(nord,4))
          call ucopy(q(lmap+1), fm, 36 * mwflt)
          call ucopy(q(lmap+36*mwflt+1), fp, mwflt * itop)

*---- Fetch bend data.
        else
          isp = iq(lcelm+mbsp)

*---- RBEND or SBEND.
          if (isp .ne. 26) then
            call ucopy(q(lcelm+meangb), an, mwflt)
            call ucopy(q(lcelm+mek1b), sk1, mwflt)
            call ucopy(q(lcelm+mee1b), e1x, mwflt)
            call ucopy(q(lcelm+mee2b), e2x, mwflt)
            call ucopy(q(lcelm+metltb), tilt, mwflt)
            call ucopy(q(lcelm+mek2b), sk2, mwflt)
            call ucopy(q(lcelm+meh1b), h1, mwflt)
            call ucopy(q(lcelm+meh2b), h2, mwflt)
            call ucopy(q(lcelm+megapb), hgap, mwflt)
            call ucopy(q(lcelm+meintb), fint, mwflt)
            call ucopy(q(lcelm+meintbx+3*mcsiz), bvflag, 1)
            call ucopy(q(lcelm+meintbx), fintx, mwflt)
            call ucopy(q(lcelm+mek3b), sk3, mwflt)
            sks = 0.0

*---- GBEND.
          else
            call ucopy(q(lcelm+meangg), an, mwflt)
            call ucopy(q(lcelm+mek1g), sk1, mwflt)
            call ucopy(q(lcelm+mee1g), e1x, mwflt)
            call ucopy(q(lcelm+mee2g), e2x, mwflt)
            call ucopy(q(lcelm+metltg), tilt, mwflt)
            call ucopy(q(lcelm+meksg), sks, mwflt)
            call ucopy(q(lcelm+meh1g), h1, mwflt)
            call ucopy(q(lcelm+meh2g), h2, mwflt)
            call ucopy(q(lcelm+megapg), hgap, mwflt)
            call ucopy(q(lcelm+meintg), fint, mwflt)
            call ucopy(q(lcelm+meintgx), fintx, mwflt)
            call ucopy(q(lcelm+meintgx+3*mcsiz), bvflag, 1)
            sk2 = 0.0
            sk3 = 0.0
          endif

*--- HG000915 use bv flag to possibly invert angle
        if (bvflag) an = beambv * an
          if (isp .eq. 2) then
*--- HG001026: arc length to rectangular bend
            an2 = an / 2.d0
            if (an2 .ne. 0.d0 .and. rbarc)  el = el * an2 / sin(an2)
            e1x = e1x + an2
            e2x = e2x + an2
          endif
          h = an / el
          corr = (h + h) * hgap * fint
          e1y = e1x - corr * (1.0 + sin(e1x)**2) / cos(e1x)
*---- Tor: use FINTX if set
          if (fintx .gt. 0) then
            corr = (h + h) * hgap * fintx
            else
            corr = (h + h) * hgap * fint
          endif
          e2y = e2x - corr * (1.0 + sin(e2x)**2) / cos(e2x)

*---- Fetch field errors, if any.
          if (lcfld .ne. 0) then
            nd = min(8*mwflt,iq(lcfld-1))
            call uzero(field, 1, 8*mwflt)
            call ucopy(q(lcfld+1), field, nd)
*--- HG000915 use bv flag to possibly invert angle
            if (bvflag) field(1,0) = beambv * field(1,0)
            dh = (- h * deltas + field(1,0) / el) / (one + deltas)
            sk1 = (sk1 + field(1,1)/el) / (one + deltas)
            sks = (sks + field(1,1)/el) / (one + deltas)
            sk2 = (sk2 + field(1,2)/el) / (one + deltas) * cohelp
            sk3 = (sk3 + field(1,3)/el) / (one + deltas)
          else
            dh = - h * deltas / (one + deltas)
            sk1 = sk1 / (one + deltas)
            sks = sks / (one + deltas)
            sk2 = sk2 / (one + deltas) * cohelp
            sk3 = sk3 / (one + deltas)
          endif
*--- apply inversion and scaling
          sk1 = sk1 * elmfact(1)
          sks = sks * elmfact(1)
          sk2 = sk2 * elmfact(2)

*---- Body of dipole.
          if (isp .ne. 26) then
            call lmsect(4,el,h,dh,sk1,sk2,sk3,dq(ifp+1),dq(ifm+1))
          else
            call tmgsec(.false.,el,h,dh,sk1,sks,ek,dq(ifm+1),te)
            call uzero(dq(ifm+1), 1, 210*mwflt)
            dq(ifp+1) =   ek(2)
            dq(ifp+2) = - ek(1)
            dq(ifp+3) =   ek(4)
            dq(ifp+4) = - ek(3)
            dq(ifp+5) =   ek(6)
            dq(ifp+6) = - ek(5)
          endif

*---- Fringe fields.
          call lmfrg1(4, h, e1x, e1y, sk1, h1, dq(igp+1), dq(igm+1))
          call lmcat(4, dq(igp+1), dq(igm+1), dq(ifp+1), dq(ifm+1),
     +               dq(ifp+1), dq(ifm+1))
          call lmfrg2(4, h, e2x, e2y, sk1, h2, dq(igp+1), dq(igm+1))
          call lmcat(4, dq(ifp+1), dq(ifm+1), dq(igp+1), dq(igm+1),
     +               dq(ifp+1), dq(ifm+1))
          call lmtilt(4, tilt, dq(ifp+1), dq(ifm+1))
          call lmcopy(min(nord,4), dq(ifp+1), dq(ifm+1), fp, fm)

*---- Store map for later re-use.
          if (lcfld .eq. 0) then
            nd = mwflt * (36 + 209)
            call mzbook(2, lmap, lcelm, -ilink, 'TMAP', 0, 0, nd,
     +                  mreal,0)
            call ucopy(dq(ifm+1), q(lmap+1), 36 * mwflt)
            call ucopy(dq(ifp+1), q(lmap+36*mwflt+1), 209 * mwflt)
          endif
        endif

*---- Clear terms of higher orders.
        do 10 i = 210, itop6(nord)
          fp(i) = 0.0
   10   continue
      endif

*---- Drop working storage.
      iwork = isave

      end
+dk lmcanx
      subroutine lmcanx(nord, gp, df, ndim)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Establish standard rep of transfer map for ray traces.             *
* Input:                                                               *
*   NORD      (integer) Order of the map.                              *
*   GP(*)     (poly)    Lie-algebraic representation of non-linearity. *
* Output:                                                              *
*   DF(*,6)   (poly)    Derivatives of generating function.            *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iaux,ifp,iqind,isave,itrm,jord,jqind,kqind,ndim,nord
      double precision by2,by24,by6,df,gp,three
      dimension         gp(*), df(ndim,6)
+ca memdum
+ca pa6lnk
+ca wstack

      parameter         (three = 3.0d0)
      parameter         (by2   = 1.0d0 / 2.0d0)
      parameter         (by6   = 1.0d0 / 6.0d0)
      parameter         (by24  = 1.0d0 / 24.0d0)

*---- Allocate working space.
      isave = iwork
      iaux  = iwork
      ifp   = iaux + itop6(min(nord,4))
      itrm  = ifp  + itop6(nord)
      iwork = itrm + itop6(nord)
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Orders 1 and 2 (identity transformation).
      do 10 i = 1, 27
        dq(ifp+i) = 0.0
   10 continue
      dq(ifp+8)  = 1.0
      dq(ifp+19) = 1.0
      dq(ifp+26) = 1.0

*---- Copy generator terms.
      do 20 i = 28, itop6(nord)
        dq(ifp+i) = - gp(i)
   20 continue

*---- Order 4 terms.
      if (nord .ge. 4) then

*---- Derivatives of array GP: DF(*,i) = dGP/dZi.
        do 30 i = 1, 6
        do 30 jord = 3, nord-1
          call pa6dif(gp, i, jord, df(1,i))
   30   continue
        call pa6clr(dq(itrm+1), 4)
        do 190 iqind = 1, 5, 2
          call pa6prd(df(1,iqind), 2, df(1,iqind+1), 2, dq(itrm+1))
  190   continue
        call pa6sum(by2, dq(itrm+1), 4, dq(ifp+1))
      endif

*---- Order 5 terms.
      if(nord .ge. 5) then

*---- Terms g4 x g3.
        do 210 iqind = 1, 5, 2
          call pa6prd(df(1,iqind), 3, df(1,iqind+1), 2, dq(ifp+1))
  210   continue

*---- Terms g3 x g3 x g3.
        call pa6clr(dq(itrm+1), 5)
        do 290 iqind = 1, 5, 2

*---- Simple sum over g3 x t4.
          call pa6dif(dq(itrm+1), iqind+1, 4, dq(iaux+1))
          call pa6prd(df(1,iqind), 2, dq(iaux+1), 3, dq(itrm+1))

*---- Double sum over g3 x g3 x g3.
          call pa6clr(dq(iaux+1), 3)
          do 280 jqind = 1, 5, 2
            call pa6dif(df(1,iqind), jqind, 2, dq(iaux+1))
            call pa6prd(dq(iaux+1), 1, df(1,jqind+1), 2, dq(iaux+1))
  280     continue
          call pa6prd(dq(iaux+1), 3, df(1,iqind+1), 2, dq(itrm+1))
  290   continue

*---- Add in t(5) term.
        call pa6sum(- by6, dq(itrm+1), 5, dq(ifp+1))
      endif

*---- Order 6 terms.
      if (nord .ge. 6) then

*---- Term g5 x g3.
        do 310 iqind = 1, 5, 2
          call pa6prd(df(1,iqind), 4, df(1,iqind+1), 2, dq(ifp+1))
  310   continue

*---- Terms g4 x g4.
        call pa6clr(dq(itrm+1), 6)
        do 320 iqind = 1, 5, 2
          call pa6prd(df(1,iqind), 3, df(1,iqind+1), 3, dq(itrm+1))
  320   continue
        call pa6sum(by2, dq(itrm+1), 6, dq(ifp+1))

*---- Terms g4 x g3 x g3.
        call pa6clr(dq(itrm+1), 6)
        do 340 iqind = 1, 5, 2

*---- Simple sum over g4 x t4.
          call pa6dif(dq(itrm+1), iqind+1, 4, dq(iaux+1))
          call pa6prd(df(1,iqind), 3, dq(iaux+1), 3, dq(itrm+1))

*---- Double sum over g4 x g3 x g3.
          call pa6clr(dq(iaux+1), 4)
          do 330 jqind = 1, 5, 2
            call pa6dif(df(1,iqind), jqind, 3, dq(iaux+1))
            call pa6prd(dq(iaux+1), 2, df(1,jqind+1), 2, dq(iaux+1))
  330     continue
          call pa6prd(dq(iaux+1), 4, df(1,iqind+1), 2, dq(itrm+1))
  340   continue

*---- Add in u(6) term.
        call pa6sum(- by2, dq(itrm+1), 6, dq(ifp+1))

*---- Terms g3 x g3 x g3 x g3.
        call pa6clr(dq(itrm+1), 6)
        do 390 iqind = 1, 5, 2

*---- Simple sum over g3 x t5.
          call pa6dif(dq(itrm+1), iqind+1, 5, dq(iaux+1))
          call pa6prd(df(1,iqind), 2, dq(iaux+1), 4, dq(itrm+1))

*---- Double sum over g3 x g3 x t4.
          call pa6clr(dq(iaux+1), 4)
          do 380 jqind = 1, 5, 2
            call pa6dif(df(1,iqind), jqind, 2, dq(iaux+1))

*---- Triple sum over g3 x g3 x g3 x g3.
            call pa6clr(dq(iaux+1), 2)
            do 370 kqind = 1, 5, 2
              call pa6sum(dq(iaux+kqind), df(1,kqind+1), 2, dq(iaux+1))
  370       continue
            call pa6prd(dq(iaux+1), 2, df(1,jqind+1), 2, dq(iaux+1))

*---- Finish double sum (including factor 3).
            call pa6scl(three, dq(iaux+1), 1, dq(iaux+1))
            call pa6dif(dq(itrm+1), jqind+1, 4, dq(iaux+1))
            call pa6prd(dq(iaux+1), 1, dq(iaux+1), 3, dq(iaux+1))
  380     continue
          call pa6prd(dq(iaux+1), 4, df(1,iqind+1), 2, dq(itrm+1))
  390   continue

*---- Add in t6 term.
        call pa6sum(by24, dq(itrm+1), 6, dq(ifp+1))
      endif

*---- Compute the derivatives of the generating function F
*     (standard representation of the canonical transformation).
      do 400 i = 1, 6
        call pa6dif(dq(ifp+1), i, -nord, df(1,i))
  400 continue

*---- Drop working storage.
      iwork = isave

      end
+dk lmcat
      subroutine lmcat(nord, fp, fm, gp, gm, hp, hm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Concatenate two Lie-algebraic maps.                                *
* Source:     MARYLIE, version 5.1 (routine CONCAT).                   *
* Author:     Liam Healy.                                              *
* Input:                                                               *
*   FP, FM    (map)     First map (in beam order).                     *
*   GP, GM    (map)     Second map (in beam order).                    *
* Output:                                                              *
*   HP, HM    (map)     Concatenated map.                              *
*----------------------------------------------------------------------*
+ca aparam
      integer if1m,if1p,if3g3,ifxfm,ig3f,ig3f3,iginv,iresm,iresp,isave,
     +itemp,jord,nord
      double precision fm,four,fp,gm,gp,hm,hp,one,three,two
      dimension         fp(*), fm(6,6), gp(*), gm(6,6), hp(*), hm(6,6)
+ca memdum
+ca pa6lnk
+ca wstack

      parameter         (one    = 1.0d0)
      parameter         (two    = 2.0d0)
      parameter         (three  = 3.0d0)
      parameter         (four   = 4.0d0)

*---- Allocate working space.
      isave = iwork
      if1m  = iwork
      iginv = if1m
      iresm = if1m  + 36
      if1p  = iresm + 36
      ig3f  = if1p
      ifxfm = if1p  + itop6(nord)
      itemp = ifxfm + itop6(nord)
      if3g3 = itemp + itop6(nord)
      ig3f3 = if3g3 + itop6(nord)
      iresp = ig3f3 + itop6(nord)
      iwork = iresp + itop6(nord)
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Move G1 to the left across the F's.
      call lmg1mv(nord, fp, fm, gp, dq(if1p+1), dq(if1m+1))
      call pa6cpy(dq(if1p+1), 1, dq(iresp+1))

*---- Compute DQ(IRESM+1) = GM * F1M.
      call m66mpy(gm, dq(if1m+1), dq(iresm+1))
      call pa6clr(dq(iresp+1), 2)

*---- Nonlinear map?
      if (nord .ge. 3) then

*---- Inverse of GM.
        call m66inv(gm, dq(iginv+1))

*---- Compute transformed arrays and sum of FXFM and G.
        do 10 jord = 3, nord
          call pa6xfm(dq(if1p+1), jord, dq(iginv+1), dq(ifxfm+1))
          call pa6add(dq(ifxfm+1), gp, jord, dq(iresp+1))
   10   continue
        if (nord .ge. 4) then
          call lmexpo(dq(ifxfm+1), 3, gp, 3, dq(if3g3+1), nord)
          call pa6sum(one/two, dq(if3g3+1), 4, dq(iresp+1))
          if (nord .ge. 5) then
            call lmexpo(gp, 3, dq(ifxfm+1), 3, dq(ig3f3+1), nord)
            call pa6brk(gp, 3, dq(ifxfm+1), 4, dq(ig3f+1))
            call pa6sum(- one, dq(ig3f+1), 5, dq(iresp+1))
            call pa6sum(- one/three, dq(if3g3+1), 5, dq(iresp+1))
            call pa6sum(two/three, dq(ig3f3+1), 5, dq(iresp+1))
            if (nord .ge. 6) then
              call pa6brk(gp, 3, dq(ifxfm+1), 5, dq(ig3f+1))
              call pa6sum(- one, dq(ig3f+1), 6, dq(iresp+1))
              call pa6brk(gp, 3, dq(ig3f+1), 5, dq(itemp+1))
              call pa6sum(one/two, dq(itemp+1), 6, dq(iresp+1))
              call pa6brk(dq(ifxfm+1), 4, gp, 4, dq(itemp+1))
              call pa6sum(one/two, dq(itemp+1), 6, dq(iresp+1))
              call pa6add(dq(ifxfm+1), gp, 4, dq(itemp+1))
              call pa6brk(dq(itemp+1),4, dq(if3g3+1),4, dq(itemp+1))
              call pa6sum(- one/four, dq(itemp+1), 6, dq(iresp+1))
              call pa6sum(one/four, dq(if3g3+1), 6, dq(iresp+1))
              call pa6sum(- three/four, dq(ig3f3+1), 6, dq(iresp+1))
              call pa6brk(dq(ifxfm+1),3, dq(ig3f3+1),5, dq(itemp+1))
              call pa6sum(- one/four, dq(itemp+1), 6, dq(iresp+1))
            endif
          endif
        endif
      endif

*---- Copy result and drop working storage.
      call lmcopy(nord, dq(iresp+1), dq(iresm+1), hp, hm)
      iwork = isave

      end
+dk lmclor
      subroutine lmclor(lseq, deltap, show, nord, eflag, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find closed orbit for a beam line sequence using Lie algebra.      *
* Input:                                                               *
*   LSEQ(1)   (pointer) Beam line sequence bank.                       *
*   DELTAP    (real)    Relative energy error.                         *
*   SHOW      (logical) Print flag.                                    *
*   NORD      (integer) Desired map order.                             *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
*   FP(*), FM(6,6)      Map about closed orbit.                        *
* Important common data:                                               *
*   ORBIT0(6) /OPTIC0/  Initial conditions for closed orbit, returned. *
*----------------------------------------------------------------------*
+ca aparam
      integer i,irank,itmax,itra,j,nord
      double precision cogood,costep,deltap,dmat,err,fm,fp,guess,one,
     +small,smat,toler,two,zero
      integer           lseq(1)
      logical           show, eflag
      dimension         fp(*), fm(6,6)
+ca memdum
+ca message
+ca beam
+ca option
+ca coesti
+ca optic0
+ca optic1
+ca pa6lnk
+ca range
+ca tmcomm
+ca wstack
+ca zunit

      dimension         dmat(6,7), smat(4,5)
      logical           m66sta
      parameter         (itmax = 20)
      parameter         (zero = 0.0d0, one = 1.0d0, toler = 1.d-6)
      parameter         (two = 2.0d0, small = 0.01d0)

*---- Retrieve beam line description.
      call utbeam(lseq, irg1, irg2, symm, nsup, linnam, rngnam)
*---- Clear closed orbit displacement.
      cohelp = one
      costep = one
      cogood = zero

*---- Initialize guess.
      call ucopy(coest, orbit0, 6*mwflt)

*---- Store delta(p)/p for the static case.
   10 continue
      if (show) write (iqlog, 910) linnam, nord, deltap
  910 format(' '/' Searching for closed orbit for line: ',a,
     +       '   order =',i2,'.'/
     +       t11,'Delta(p)/p =',f12.6/
     +       ' Iteration',5x,'x',11x,'px',10x,'y',11x,'py',10x,'t',11x,
     +       'pt',9x,'error')

*---- Iteration loop.
      do 190 itra = 1, itmax
        call lalump(nord, lseq, fp, fm)
        err = zero

*---- Static case (constant p).
        if (m66sta(fm)) then
          do 120 i = 1, 4
            do 110 j = 1, 4
              smat(i,j) = fm(i,j)
  110       continue
            smat(i,i) = smat(i,i) - one
            smat(i,5) = orbit(i) - orbit0(i)
            err = max(abs(smat(i,5)), err)
  120     continue
          call solver(smat, 4, 1, irank)
          do 130 i = 1, 4
            orbit0(i) = orbit0(i) - smat(i,5)
  130     continue

*---- Dynamic case (variable p).
        else
          do 170 i = 1, 6
            do 160 j = 1, 6
              dmat(i,j) = fm(i,j)
  160       continue
            dmat(i,i) = dmat(i,i) - one
            dmat(i,7) = orbit(i) - orbit0(i)
            err = max(abs(dmat(i,7)), err)
  170     continue

          call solver(dmat, 6, 1, irank)
          do 180 i = 1, 6
            orbit0(i) = orbit0(i) - dmat(i,7)
  180     continue
        endif

*---- Message and convergence test.
        if (show) write (iqlog, 920) itra, orbit0, err
  920   format(' ',i9,6f12.6,1p,e16.6)
        if (err .lt. toler) go to 830
  190 continue

*---- No convergence.
      if (show) write (msg(1), 930) itmax
  930 format('Closed orbit did not converge in ',i5,' iterations.')
      costep = costep / two
      go to 850

*---- Converged with current factor.
  830 continue
      if (cohelp .ge. one) go to 890
      if (costep .le. small) go to 880
      if (show) write (msg(1), 950) cohelp
  950 format('Succeeded to find closed orbit for sextupoles reduced to',
     +       2p,f6.2,' percent.')
      call ucopy(orbit0, guess, 6*mwflt)
      cogood = cohelp
      if (itra .eq. 1) then
        costep = costep * two
      else if (itra .gt. 3) then
        costep = costep / two
      endif
      cohelp = min(cogood + costep, one)
      if (show) then
        write (msg(2), 960) cohelp
  960   format('Continuing with sextupoles increased to',
     +       2p,f6.2,' percent.')
        call aainfo('LMCLOR', 2, msg)
      endif
      go to 10

*---- Test for possible restart.
  850 continue
      if (costep .le. small) go to 880
      costep = costep / two
      cohelp = min(cogood + costep, one)
      if (show) then
        write (msg(2), 970) cohelp
  970   format('Restarting with sextupoles reduced to',
     +         2p,f6.2,' percent.')
        call aainfo('LMCLOR', 2, msg)
      endif
      go to 10

*---- Exit with best orbit so far.
  880 continue
      if (show) then
        msg(1) =
     +    'Unable to find closed orbit for full sextupole settings.'
        write (msg(2), 980) cogood
  980   format('The best orbit found had the sextupoles reduced to',
     +         2p,f7.2,' percent.')
        call aafail('LMCLOR', 2, msg)
      endif
      call ucopy(guess, orbit0, 6*mwflt)
      eflag = .true.

*---- Restore closed orbit help factor.
  890 cohelp = one
      if (optflg(20))  call ucopy(orbit0, coest, 6*mwflt)

      end
+dk lmcopy
      subroutine lmcopy(nord, rp, rm, tp, tm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Copy a Lie-algebraic map.                                          *
* Source:     MARYLIE, version 3.0 (routine MAPMAP).                   *
* Input:                                                               *
*   NORD      (integer) Order of the map.                              *
*   RP, RM    (map)     Origin map.                                    *
* Output:                                                              *
*   TP, TM    (map)     Destination map.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision rm,rp,tm,tp
      dimension         rp(*), rm(6,6), tp(*), tm(6,6)

      call m66cpy(rm, tm)
      call pa6cpy(rp, -nord, tp)

      end
+dk lmcorr
      subroutine lmcorr(nord, el, dpx, dpy, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lie-algebraic map for a closed orbit corrector.                    *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   EL        (real)    Corrector length.                              *
*   DPX       (real)    Horizontal kick.                               *
*   DPY       (real)    Vertical kick.                                 *
* Output:                                                              *
*   FP, FM    (map)     Element map.                                   *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision bil4,dppx,dppy,dpt,dpx,dpy,el,el2,fm,fp,one
      dimension         fp(*), fm(6,6)
+ca beam
+ca stflag
+ca physicpm

      parameter         (one = 1.0d0)

*---- Set up identity map.
      call lmone(nord, fp, fm)

*---- Kicks.
      dppx = dpx / (one + deltas)
      dppy = dpy / (one + deltas)
      el2 = el / 2.0
      bil4 = el2 / (2.0 * betas)
      fp(1) =   dppx
      fp(2) = - el2 * dppx
      fp(3) =   dppy
      fp(4) = - el2 * dppy
      fp(6) =   bil4 * (dppx**2 + dppy**2) - el*dtbyds

*---- Radiation loss.
      if (dorad .and. el .ne. 0.0) then
        dpt = - (2.0 * arad * charge * gammas**3) * (dppx**2 + dppy**2)
     +  / (3.0 * el)
        fp(1) = dppx - dpt * dppx / (2.0 * betas)
        fp(3) = dppy - dpt * dppy / (2.0 * betas)
        fp(5) = dpt
      endif

*---- First-order terms (matrix).
      fm(1,2) =   el
      fm(1,6) = fp(2) / betas
      fm(5,2) = - fm(1,6)
      fm(3,4) =   el
      fm(3,6) = fp(4) / betas
      fm(5,4) = - fm(3,6)
      fm(5,6) = el / (betas*gammas)**2

*---- F3 polynomial.
      if (nord .ge. 3) then
        fp(53) = el / (2.0 * betas)
        fp(76) = el / (2.0 * betas)
        fp(83) = fm(5,6) / (2.0 * betas)
      endif

*---- F4 polynomial.
      if (nord .ge. 4) then
        fp(140) = - el / 8.0
        fp(149) = - el / 4.0
        fp(195) = - el / 8.0
        fp(154) = el * (1.0 - 3.0 / betas**2) / 4.0
        fp(200) = el * (1.0 - 3.0 / betas**2) / 4.0
        fp(209) = fm(5,6) * (1.0 - 5.0 / betas**2) / 8.0
      endif

      end
+dk lmdprt
      subroutine lmdprt(iunit, nord, fp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print the polynomials of a dynamic resonance basis.                *
* Source:     MARYLIE, version 3.0 (routine PDRMAP).                   *
* Input:                                                               *
*   IUNIT     (integer) Logical output unit.                           *
*   NORD      (integer) Order of the map.                              *
*   FP(*)     (poly)    Coefficients in resonance basis.               *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iunit,j,jl,jord,nl,nord
      double precision fp,tol
      dimension         fp(*)
+ca pa6lnk

      parameter         (tol = 1.0d-8)
      integer           il(209)
      character*8       dln(209)

      data (dln(i), i = 1, 25)
     +   / 'R100000', 'I100000', 'R001000', 'I001000', 'R000010',
     +     'I000010', 'R110000', 'R001100', 'R000011', 'R000020',
     +     'I000020', 'R100010', 'I100010', 'R100001', 'I100001',
     +     'R001010', 'I001010', 'R001001', 'I001001', 'R200000',
     +     'I200000', 'R002000', 'I002000', 'R101000', 'I101000' /
      data (dln(i), i = 26, 50)
     +   / 'R100100', 'I100100', 'R110010', 'I110010', 'R001110',
     +     'I001110', 'R000030', 'I000030', 'R000021', 'I000021',
     +     'R100011', 'I100011', 'R001011', 'I001011', 'R100020',
     +     'I100020', 'R100002', 'I100002', 'R001020', 'I001020',
     +     'R001002', 'I001002', 'R200010', 'I200010', 'R200001' /
      data (dln(i), i = 51, 75)
     +   / 'I200001', 'R002010', 'I002010', 'R002001', 'I002001',
     +     'R101010', 'I101010', 'R101001', 'I101001', 'R100110',
     +     'I100110', 'R100101', 'I100101', 'R210000', 'I210000',
     +     'R002100', 'I002100', 'R101100', 'I101100', 'R111000',
     +     'I111000', 'R300000', 'I300000', 'R003000', 'I003000' /
      data (dln(i), i = 76, 100)
     +   / 'R201000', 'I201000', 'R102000', 'I102000', 'R200100',
     +     'I200100', 'R100200', 'I100200', 'R220000', 'R002200',
     +     'R000022', 'R111100', 'R110011', 'R001111', 'R110020',
     +     'I110020', 'R001120', 'I001120', 'R000040', 'I000040',
     +     'R000031', 'I000031', 'R100030', 'I100030', 'R100003' /
      data (dln(i), i = 101, 125)
     +   / 'I100003', 'R001030', 'I001030', 'R001003', 'I001003',
     +     'R100021', 'I100021', 'R100012', 'I100012', 'R001021',
     +     'I001021', 'R001012', 'I001012', 'R200011', 'I200011',
     +     'R002011', 'I002011', 'R200020', 'I200020', 'R200002',
     +     'I200002', 'R002020', 'I002020', 'R002002', 'I002002' /
      data (dln(i), i = 126, 150)
     +   / 'R101011', 'I101011', 'R100111', 'I100111', 'R101020',
     +     'I101020', 'R101002', 'I101002', 'R100120', 'I100120',
     +     'R100102', 'I100102', 'R210010', 'I210010', 'R210001',
     +     'I210001', 'R002110', 'I002110', 'R002101', 'I002101',
     +     'R101110', 'I101110', 'R101101', 'I101101', 'R111010' /
      data (dln(i), i = 151, 175)
     +   / 'I111010', 'R111001', 'I111001', 'R300010', 'I300010',
     +     'R300001', 'I300001', 'R003010', 'I003010', 'R003001',
     +     'I003001', 'R201010', 'I201010', 'R201001', 'I201001',
     +     'R102010', 'I102010', 'R102001', 'I102001', 'R200110',
     +     'I200110', 'R200101', 'I200101', 'R100201', 'I100201' /
      data (dln(i), i = 176, 200)
     +   / 'R100210', 'I100210', 'R310000', 'I310000', 'R003100',
     +     'I003100', 'R201100', 'I201100', 'R112000', 'I112000',
     +     'R211000', 'I211000', 'R102100', 'I102100', 'R210100',
     +     'I210100', 'R101200', 'I101200', 'R400000', 'I400000',
     +     'R004000', 'I004000', 'R301000', 'I301000', 'R103000' /
      data (dln(i), i = 201, 209)
     +   / 'I103000', 'R300100', 'I300100', 'R100300', 'I100300',
     +     'R202000', 'I202000', 'R200200', 'I200200' /

      do 90 jord = 1, nord
        nl = 0
        do 70 j = ibot6(jord), itop6(jord)
          if (abs(fp(j)) .gt. tol) then
            nl = nl + 1
            il(nl) = j
          endif
   70   continue
        if (nl .gt. 0) then
          write (iunit, 910) jord
          write (iunit, 920) (dln(il(jl)), fp(il(jl)), jl = 1, nl)
        endif
   90 continue

  910 format(' Terms of order ',i1,':')
  920 format(4(' ',a7,' = ',1pe14.6:,5x))

      end
+dk lmdrf
      subroutine lmdrf(nord, el, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lie-algebraic map for a drift space.                               *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   EL        (real)    Drift length.                                  *
* Output:                                                              *
*   FP, FM    (map)     Drift map.                                     *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision el,fm,fp
      dimension         fp(*), fm(6,6)
+ca beam

*---- Linear terms.
      call lmone(nord, fp, fm)
      fm(1,2) = el
      fm(3,4) = el
      fm(5,6) = el / (betas*gammas)**2
      fp(6) = - el*dtbyds

*---- Third order terms.
      if (nord .ge. 3) then
        fp(53) = el / (2.0 * betas)
        fp(76) = el / (2.0 * betas)
        fp(83) = fm(5,6) / (2.0 * betas)
      endif

*---- Fourth order terms.
      if (nord .ge. 4) then
        fp(140) = - el / 8.0
        fp(149) = - el / 4.0
        fp(195) = - el / 8.0
        fp(154) = el * (1.0 - 3.0 / betas**2) / 4.0
        fp(200) = el * (1.0 - 3.0 / betas**2) / 4.0
        fp(209) = fm(5,6) * (1.0 - 5.0 / betas**2) / 8.0
      endif

      end
+dk lmdsp1
      subroutine lmdsp1(ipos, nord, d, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lie-algebraic map for a misalignment at entrance.                  *
* Input:                                                               *
*   IPOS      (integer) Position in beam line (not used).              *
*   NORD      (integer) Order desired.                                 *
*   D(6)      (real)    Components of misalignemt.                     *
* Output:                                                              *
*   FP, FM    (map)     Map representing displacement.                 *
*----------------------------------------------------------------------*
+ca aparam
      integer ipos,nord
      double precision d,fm,fp,half,phi,psi,s2,the,two,w
      dimension         d(6), fp(*), fm(6,6)
+ca memdum
+ca beam
+ca pa6lnk

      dimension         w(3,3)
      parameter         (two = 2.0d0, half = 0.5d0)

*---- Build rotation matrix and compute additional drift length.
      the = d(5)
      phi = d(4)
      psi = d(6)
      call sumtrx(the, phi, psi, w)
      s2 = (w(1,3) * d(1) + w(2,3) * d(2) + w(3,3) * d(3)) / w(3,3)

*---- F1 terms (kicks).
      call lmone(nord, fp, fm)
      fp(1) = - w(1,3) / w(3,3)
      fp(2) = d(1) + fp(1) * s2
      fp(3) = - w(2,3) / w(3,3)
      fp(4) = d(2) + fp(3) * s2
      fp(5) = 0.0
      fp(6) = d(3) / betas

*---- F2 terms (transfer matrix).
      fm(2,2) = w(1,1)
      fm(2,4) = w(2,1)
      fm(2,6) = w(3,1) / betas
      fm(4,2) = w(1,2)
      fm(4,4) = w(2,2)
      fm(4,6) = w(3,2) / betas

      fm(1,1) =   w(2,2) / w(3,3)
      fm(1,2) = fm(1,1) * s2
      fm(1,3) = - w(1,2) / w(3,3)
      fm(1,4) = fm(1,3) * s2
      fm(3,1) = - w(2,1) / w(3,3)
      fm(3,2) = fm(3,1) * s2
      fm(3,3) =   w(1,1) / w(3,3)
      fm(3,4) = fm(3,3) * s2
      fm(5,1) = w(1,3) / (w(3,3) * betas)
      fm(5,2) = fm(5,1) * s2
      fm(5,3) = w(2,3) / (w(3,3) * betas)
      fm(5,4) = fm(5,3) * s2
      fm(5,6) = - s2 / (betas * gammas)**2

*---- F3  and F4 terms are ignored.

      end
+dk lmdsp2
      subroutine lmdsp2(ipos, nord, d, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lie-algebraic map for a misalignment at exit.                      *
* Input:                                                               *
*   IPOS      (integer) Position in beam line.                         *
*   NORD      (integer) Order desired.                                 *
*   D(6)      (real)    Components of misalignment.                    *
* Output:                                                              *
*   FP, FM    (map)     Map representing displacement.                 *
*----------------------------------------------------------------------*
+ca aparam
      integer ipos,nord
      double precision arc,d,el,fm,fp,half,phi,psi,r,s2,the,two,ve,w,we
      dimension         d(6), fp(*), fm(6,6)
+ca memdum
+ca bankhead
+ca prcgroup
+ca beam
+ca pa6lnk
+ca refer
+ca wstack

      dimension         r(3), ve(3), w(3,3), we(3,3)
      parameter         (two = 2.0d0, half = 0.5d0)

*---- Rotation w.r.t. entrance system.
      the = d(5)
      phi = d(4)
      psi = d(6)
      call sumtrx(the, phi, psi, w)

*---- Translation from entrance to exit w.r.t. entrance system.
      if (iq(lcelm+mbpr) .eq. mplin) then
        call suline(ipos, el, arc, ve, we)
      else
        call suelem(el, arc, ve, we)
      endif
      r(1) = d(1)+w(1,1)*ve(1)+w(1,2)*ve(2)+w(1,3)*ve(3)-ve(1)
      r(2) = d(2)+w(2,1)*ve(1)+w(2,2)*ve(2)+w(2,3)*ve(3)-ve(2)
      r(3) = d(3)+w(3,1)*ve(1)+w(3,2)*ve(2)+w(3,3)*ve(3)-ve(3)

*---- Convert all references to exit.
      call sutran(w, r, we)

*---- Build additional drift.
      s2 = - (w(1,3) * r(1) + w(2,3) * r(2) + w(3,3) * r(3)) / w(3,3)

*---- Rotation:
      call lmone(nord, fp(1), fm)

*---- F1 terms (kicks).
      fp(1) = - w(3,1)
      fp(2) = - (w(2,2) * r(1) - w(1,2) * r(2)) / w(3,3)
      fp(3) = - w(3,2)
      fp(4) = - (w(1,1) * r(2) - w(2,1) * r(1)) / w(3,3)
      fp(5) = 0.0
      fp(6) = s2 / betas

*---- F2 terms (transfer matrix).
      fm(1,1) = w(1,1)
      fm(3,1) = w(2,1)
      fm(5,1) = w(3,1) / betas
      fm(1,3) = w(1,2)
      fm(3,3) = w(2,2)
      fm(5,3) = w(3,2) / betas

      fm(2,2) =   w(2,2) / w(3,3)
      fm(1,2) = fm(2,2) * s2
      fm(4,2) = - w(1,2) / w(3,3)
      fm(3,2) = fm(4,2) * s2
      fm(2,4) = - w(2,1) / w(3,3)
      fm(1,4) = fm(2,4) * s2
      fm(4,4) =   w(1,1) / w(3,3)
      fm(3,4) = fm(4,4) * s2
      fm(2,6) = w(1,3) / (w(3,3) * betas)
      fm(1,6) = fm(2,6) * s2
      fm(4,6) = w(2,3) / (w(3,3) * betas)
      fm(3,6) = fm(4,6) * s2
      fm(5,6) = - s2 / (betas * gammas)**2

*---- F3 and F4 terms are ignored.

      end
+dk lmelem
      subroutine lmelem(iturn, nord, isup, ipos, suml,
     +                  track, number, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track through an element by Lie-algebraic method.                  *
* Input:                                                               *
*   ITURN     (integer) Turn number.                                   *
*   NORD      (integer) Order desired for tracking.                    *
*   ISUP      (integer) Superperiod number.                            *
*   IPOS      (integer) Position counter.                              *
* Input/output:                                                        *
*   SUML      (real)    Accumulated length.                            *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   NUMBER(*) (integer) Number of current track                        *
*   KTRACK    (integer) number of surviving tracks.                    *
*----------------------------------------------------------------------*
* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Added LCAVITY element at ISP 27 ... calls routine LMLCAV           *
*----------------------------------------------------------------------*
+ca aparam
      integer ifm,ifp,iord,ipos,isave,isp,isup,iturn,nd,ne,nord,ktrack
      double precision efield,el,field,one,parvec,rff,rfl,rfv,sk1,sk2,
     +sk3,sks,suml,tilt,track,xcm,xkick,ycm,ykick
      dimension         track(6,*)
      integer           number(*)
      integer i,j
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca pa6lnk
+ca refer
+ca wstack

      parameter         (nd = 8 * mwflt, one = 1.0d0)
      dimension         field(2,0:3)
      dimension parvec(mbbparam)
      logical bvflag

      bvflag = .false.
*---- Initialize.
      isp = iq(lcelm+mbsp)
      el = 0.0
      iord = nord
      if (isp .eq. 23) iord = iq(lcelm+mbat+2*mcsiz+mcval)

*---- Allocate working space.
      isave = iwork
      ifm   = iwork
      ifp   = ifm + 36
      iwork = ifp + itop6(iord)
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Field error data.
      call uzero(field, 1, nd)
      if (lcfld .ne. 0) then
        ne = min(iq(lcfld-1), nd)
        call ucopy(q(lcfld+1), field, ne)
      endif

*---- Switch on element type.
      go to ( 10,  20,  30,  40,  50,  60,  70,  80,  90, 100,
     +       110, 120, 130, 140, 150, 160, 170, 180, 190, 200,
     +       210, 220, 230, 240, 250, 260, 270, 280, 290, 300,
     +       310, 310, 310, 310, 310, 310, 310, 310, 310, 310), isp

*---- Drift space, treated by TRANSPORT method for speed.
   10 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ttdrf(el, track, ktrack)
      go to 500

*---- All Bending magnets, RBEND, SBEND, GBEND.
   20 continue
   30 continue
  260 continue
        call lmbend(iord, el, dq(ifp+1), dq(ifm+1))
        call lmtrak(iord, dq(ifp+1), dq(ifm+1), track, ktrack)
      go to 500

*---- Arbitrary map.
   40 continue
        call lmarb(iord, dq(ifp+1), dq(ifm+1))
        call lmtrak(iord, dq(ifp+1), dq(ifm+1), track, ktrack)
      go to 500

*---- Quadrupole.
   50 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mek1q), sk1, mwflt)
        sk1 = (sk1 + field(1,1)) / (one + deltas)
*--- apply inversion and scaling
        sk1 = sk1 * elkfact(5)
        call ucopy(q(lcelm+metltq), tilt, mwflt)
        call lmquad(iord, el, sk1, tilt, dq(ifp+1), dq(ifm+1))
        call lmtrak(iord, dq(ifp+1), dq(ifm+1), track, ktrack)
      go to 500

*---- Sextupole.
   60 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mek2s), sk2, mwflt)
        sk2 = (sk2 + field(1,2)) / (one + deltas)
*--- apply inversion and scaling
        sk2 = sk2 * elkfact(6)
        call ucopy(q(lcelm+metlts), tilt, mwflt)
        call lmsext(iord, el, sk2, tilt, dq(ifp+1), dq(ifm+1))
        call lmtrak(iord, dq(ifp+1), dq(ifm+1), track, ktrack)
      go to 500

*---- Octupole.
   70 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mek3o), sk3, mwflt)
        sk3 = (sk3 + field(1,3)) / (one + deltas)
*--- apply inversion and scaling
        sk3 = sk3 * elkfact(7)
        call ucopy(q(lcelm+metlto), tilt, mwflt)
        call lmoct(iord, el, sk3, tilt, dq(ifp+1), dq(ifm+1))
        call lmtrak(iord, dq(ifp+1), dq(ifm+1), track, ktrack)
      go to 500

*---- Multipole, treated by TRANSPORT method for speed.
   80 continue
        call ttmult(track, ktrack)
      go to 500

*---- Solenoid.
   90 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mekss), sks, mwflt)
        sks = sks / (one + deltas)
*--- apply inversion and scaling
        sks = sks * elkfact(9)
        call lmsol(iord, el, sks, dq(ifp+1), dq(ifm+1))
        call lmtrak(iord, dq(ifp+1), dq(ifm+1), track, ktrack)
      go to 500

*---- RF cavity.
  100 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mevltc), rfv, mwflt)
        call ucopy(q(lcelm+melagc), rfl, mwflt)
        call ucopy(q(lcelm+mefrqc), rff, mwflt)
        call lmrf(iord, el, rfv, rfl, rff, dq(ifp+1), dq(ifm+1))
        call lmtrak(iord, dq(ifp+1), dq(ifm+1), track, ktrack)
      go to 500

*---- Electrostatic separator.
  110 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+meflde), efield, mwflt)
        call ucopy(q(lcelm+metlte), tilt, mwflt)
        call lmsep(iord, el, efield, tilt, dq(ifp+1), dq(ifm+1))
        call lmtrak(iord, dq(ifp+1), dq(ifm+1), track, ktrack)
      go to 500

*---- Rotation around s-axis.
  120 continue
        call ttsrot(track, ktrack)
      go to 500

*---- Rotation around y-axis.
  130 continue
        call ttyrot(track, ktrack)
      go to 500

*---- Correctors.
  140 continue
  150 continue
  160 continue
        call ucopy(q(lcelm+melen), el, mwflt)

*---- Original setting.
        if (isp .eq. 14) then
          call ucopy(q(lcelm+mekick), xkick, mwflt)
          call ucopy(q(lcelm+mekick+mcsiz), bvflag, 1)
          ykick = 0.0
        else if (isp .eq. 16) then
          xkick = 0.0
          call ucopy(q(lcelm+mekick), ykick, mwflt)
          call ucopy(q(lcelm+mekick+mcsiz), bvflag, 1)
        else
          call ucopy(q(lcelm+mekick), xkick, mwflt)
          call ucopy(q(lcelm+mekick+mcsiz), ykick, mwflt)
          call ucopy(q(lcelm+mekick+2*mcsiz), bvflag, 1)
        endif

*---- Correction from C.O. correction algorithm.
        if (lccom .ne. 0) then
          call ucopy(q(lccom+1), xcm, 2*mwflt)
        else
          xcm = 0.0
          ycm = 0.0
        endif

*---- Apply sum of original setting, correction, and field error.
        xcm = xcm + xkick + field(1,0)
        ycm = ycm + ykick + field(2,0)
*--- HG000915 use bv flag to possibly invert angle
        if (bvflag) then
          xcm = beambv * xcm
          ycm = beambv * ycm
        endif
        call lmcorr(iord, el, xcm, ycm, dq(ifp+1), dq(ifm+1))
        call lmtrak(iord, dq(ifp+1), dq(ifm+1), track, ktrack)
      go to 500

*---- Monitor, "HMONITOR", "VMONITOR", "MONITOR".
  170 continue
  180 continue
  190 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ttdrf(el, track, ktrack)
      go to 500

*---- Elliptic collimator.
  200 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call trkill
     +    (1, iturn, isup, ipos, suml, el, track, number, ktrack)
      go to 500

*---- Rectangular collimator.
  210 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call trkill
     +    (2, iturn, isup, ipos, suml, el, track, number, ktrack)
      go to 500

*---- Beam-beam.
  220 continue
        if (parnum .ne. 0.0) then
          call ucopy(q(lcelm+mesigx), parvec(1), mwflt)
          if (parvec(1) .eq. 0.d0) parvec(1) = 1.d0
          call ucopy(q(lcelm+mesigy), parvec(2), mwflt)
          if (parvec(2) .eq. 0.d0) parvec(2) = 1.d0
          call ucopy(q(lcelm+mexma), parvec(3), mwflt)
          call ucopy(q(lcelm+meyma), parvec(4), mwflt)
          parvec(5) = arad
          call ucopy(q(lcelm+mechg), parvec(6), mwflt)
          parvec(6) = parvec(6) * charge * parnum
          parvec(7) = gammas
          parvec(8) = ex
          parvec(9) = ey
          j = mechg
          do i = 1, 17
            j = j + mcsiz
            call ucopy(q(lcelm+j), parvec(i+9), mwflt)
          enddo
          if (parvec(23) .eq. 0.d0) then
*--- standard 4D
            call ttbb(parvec, track, ktrack)
          else
*--- Hirata 6D (no Lie map yet)
*            call beamint(parvec, track, ktrack)
          endif
        endif
      go to 500

*---- Lump.
  230 continue
        call lmmap(iord, el, dq(ifp+1), dq(ifm+1))
        call lmtrak(iord, dq(ifp+1), dq(ifm+1), track, ktrack)
      go to 500

*---- Beam instrument.
  240 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ttdrf(el, track, ktrack)
      go to 500

*---- Marker.
  250 continue
      go to 500
*---- LCAV cavity.
  270 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mevltc), rfv, mwflt)
        call ucopy(q(lcelm+melagc), rfl, mwflt)
        call ucopy(q(lcelm+mefrqc), rff, mwflt)
        call lmlcav(iord, el, rfv, rfl, rff, dq(ifp+1), dq(ifm+1))
        call lmtrak(iord, dq(ifp+1), dq(ifm+1), track, ktrack)
      go to 500
  280 continue
  290 continue
  300 continue
      go to 500

*---- User-defined elements.
  310 continue
        call lmuser(iord, isp, el, dq(ifp+1), dq(ifm+1))
        call lmtrak(iord, dq(ifp+1), dq(ifm+1), track, ktrack)
      go to 500
  500 continue
      suml = suml + el

*---- Drop working storage.
      iwork = isave

      end
+dk lmexpo
      subroutine lmexpo(op, iopord, arg, iarord, out, imxord)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Apply the exponential of a Lie operator to an argument.            *
*   The series is truncated at a given order.                          *
*   A second-order operator is not allowed.                            *
* Source:     MARYLIE, version 5.1 (routine EXPOP).                    *
* Algorithm:  Liam Healy.                                              *
* Input:                                                               *
*   OP(*)     (poly)    The homogeneous polynomial for the operator.   *
*   IOPORD    (integer) The order of OP.                               *
*   ARG(*)    (poly)    The polynomial to be operated upon.            *
*   IARORD    (integer) The order of ARG:                              *
*                       IARORD > 0: Only order IARORD.                 *
*                       IARORD < 0: Orders from 1 to - IARORD.         *
*   IMXORD    (integer) The order at which to truncate the series.     *
* Output:                                                              *
*   OUT(*)    (poly)    The result of OUT = exp(:OP:) ARG.             *
*----------------------------------------------------------------------*
+ca aparam
      integer iacc,iarmax,iarmin,iarord,imxord,iopord,iornew,iorold,
     +isave,jord,jpower
      double precision arg,factor,op,out
      dimension         out(*), op(*), arg(*)
+ca memdum
+ca pa6lnk
+ca wstack

*---- Allocate working space.
      isave = iwork
      iacc  = iwork
      iwork = iacc + itop6(imxord)
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Set limits for argument orders.
      if (iarord .lt. 0) then
        iarmin = 1
        iarmax = - iarord
      else
        iarmin = iarord
        iarmax = iarord
      endif

*---- Clear result array.
      call pa6clr(out, -imxord)

*---- Identity operator for all orders in ARG.
      call pa6cpy(arg, iarord, out)

*---- For all orders in ARG do...
      do 90 jord = iarmin, iarmax

*---- Copy current order of ARG to working array.
        call pa6cpy(arg, jord, dq(iacc+1))
        iorold = jord
        factor = 1.0

*---- Accumulate powers of Lie operators.
        do 80 jpower = 1, imxord
          iornew = iopord + iorold - 2
          if (iornew .le. 0  .or.  iornew .gt. imxord) go to 90
          call pa6brk(op, iopord, dq(iacc+1), iorold, dq(iacc+1))
          factor = factor / jpower
          call pa6sum(factor, dq(iacc+1), iornew, out)
          iorold = iornew
   80   continue
   90 continue

*---- Drop working storage.
      iwork = isave

      end
+dk lmfixp
      subroutine lmfixp(fp, fm, ap, am, tp, tm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find the fixed point of a map.                                     *
* Source:     MARYLIE, version 3.0 (routine FXPT).                     *
* Author:     Alex Dragt, October 1985.                                *
* Input:                                                               *
*   FP, FM    (map)     Initial map (unchanged by subroutine).         *
* Output:                                                              *
*   AP, AM    (map)     Map about fixed point.                         *
*   TP, TM    (map)     Transformation to the fixed point.             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,irank,isave,ittp,j,nord
      double precision am,ap,bmat,fm,fp,tm,tmpm,tp,ttm
      dimension         fp(*), fm(6,6), ap(*), am(6,6), tp(*), tm(6,6)
+ca memdum
+ca wstack

      parameter         (nord = 4)

      dimension         bmat(4,5), tmpm(6,6), ttm(6,6)

*---- Allocate working space.
      isave = iwork
      ittp  = iwork
      iwork = ittp + 209
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Compute AN1.
*     Set up BMAT = 4x4 block of (FM - I), and BVEC = FM(I,6).
      do 20 i = 1, 4
        do 10 j = 1, 4
          bmat(i,j) = fm(i,j)
   10   continue
        bmat(i,i) = bmat(i,i) - 1.0
        bmat(i,5) = fm(i,6)
   20 continue

*---- Compute ALPHV.
      call solver(bmat, 4, 1, irank)

*---- Compute T1.
      call lmone(nord, tp, tm)
      do 30 i = 1, 4
        tm(i,6) = - bmat(i,5)
   30 continue
      tm(5,1) =   bmat(2,5)
      tm(5,2) = - bmat(1,5)
      tm(5,3) =   bmat(4,5)
      tm(5,4) = - bmat(3,5)

*---- Store T1.
      call lmcopy(nord, tp, tm, dq(ittp+1), ttm)

*---- Compute T1*M*T1INV where M is initial map.
      call lmsand(nord, tp, tm, fp, fm, ap, am)

*---- Compute AN2.
*     Set up BMAT.
      call m66inv(am, tmpm)
      do 50 i = 1, 4
        do 40 j = 1, 4
          bmat(i,j) = tmpm(j,i)
   40   continue
        bmat(i,i) = bmat(i,i) - 1.0
   50 continue

*---- Set up BVEC.
      bmat(1,5) = - ap(48)
      bmat(2,5) = - ap(63)
      bmat(3,5) = - ap(73)
      bmat(4,5) = - ap(79)

*---- Compute ALPHV.
      call solver(bmat, 4, 1, irank)

*---- Compute T2.
      call lmone(nord, tp, tm)
      tp(48) = bmat(1,5)
      tp(63) = bmat(2,5)
      tp(73) = bmat(3,5)
      tp(79) = bmat(4,5)

*---- Compute and store T2*T1
      call lmcat(nord, tp, tm, dq(ittp+1), ttm, dq(ittp+1), ttm)

*---- Compute T2*AN1*T2INV.
      call lmsand(nord, tp, tm, ap, am, ap, am)

*---- Compute AN3.
*     Set up BMAT.
      do 70 i = 1, 4
        do 60 j = 1, 4
          bmat(i,j) = tmpm(j,i)
   60   continue
        bmat(i,i) = bmat(i,i) - 1.0
   70 continue

*---- Set up BVEC.
      bmat(1,5) = - ap(139)
      bmat(2,5) = - ap(174)
      bmat(3,5) = - ap(194)
      bmat(4,5) = - ap(204)

*---- Compute ALPHV.
      call solver(bmat, 4, 1, irank)

*---- Compute T3.
      call lmone(nord, tp, tm)
      tp(139) = bmat(1,5)
      tp(174) = bmat(2,5)
      tp(194) = bmat(3,5)
      tp(204) = bmat(4,5)

*---- Compute and store T3*T2*T1.
      call lmcat(nord, tp, tm, dq(ittp+1), ttm, dq(ittp+1), ttm)

*---- Compute T3*AN2*T3INV.
      call lmsand(nord, tp, tm, ap, am, ap, am)

*---- Store T3*T2*T1 in T.
      call lmcopy(nord, dq(ittp+1), ttm, tp, tm)

*---- Drop working storage.
      iwork = isave

      end
+dk lmfrg1
      subroutine lmfrg1(nord, h, e1x, e1y, sk1, h1, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*    Lie algebraic map for fringe field at entrance.                   *
* Input:                                                               *
*                                                                      *
*   NORD      (integer) Order desired.                                 *
* Output:                                                              *
*   FP, FM    (map)     Element map.                                   *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision e1x,e1y,fm,fp,h,h1,secx,sk1,ss,tanx,tany
      dimension         fp(*), fm(6,6)

*---- Linear terms.
      call lmone(nord, fp, fm)
      tanx = tan(e1x)
      tany = tan(e1y)
      secx = 1.0 / cos(e1x)
      fm(2,1) = + h * tanx
      fm(4,3) = - h * tany

*---- Third-order terms.
      if (nord .ge. 3) then
        ss = h * h1 * secx**3 + 2.0 * sk1 * tanx
        fp(28) = (ss - 2.0 * h**2 * tanx**3) / 6.0
        fp(29) = + h * tanx**2 / 2.0
        fp(39) = (h**2 * tanx * (secx**2 - tany**2) - ss) / 2.0
        fp(40) = - h * tanx * tany
        fp(54) = - h * secx**2 / 2.0
      endif

*---- Fourth order not yet available.

      end
+dk lmfrg2
      subroutine lmfrg2(nord, h, e2x, e2y, sk1, h2, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*    Lie algebraic map for fringe field at exit.                       *
* Input:                                                               *
*                                                                      *
*   NORD      (integer) Order desired.                                 *
* Output:                                                              *
*   FP, FM    (map)     Element map.                                   *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision e2x,e2y,fm,fp,h,h2,secx,sk1,ss,tanx,tany
      dimension         fp(*), fm(6,6)

*---- Linear terms.
      call lmone(nord, fp, fm)
      tanx = tan(e2x)
      tany = tan(e2y)
      secx = 1.0 / cos(e2x)
      fm(2,1) = + h * tanx
      fm(4,3) = - h * tany

*---- Third-order terms.
      if (nord .ge. 3) then
        ss = h * h2 * secx**3 + 2.0 * sk1 * tanx
        fp(28) = (ss + h**2 * tanx**3) / 6.0
        fp(29) = - h * tanx**2 / 2.0
        fp(39) = (h**2 * tanx * tany**2 - ss) / 2.0
        fp(40) = + h * tanx * tany
        fp(54) = + h * secx**2 / 2.0
      endif

*---- Fourth order not yet avaliable.

      end
+dk lmg1mv
      subroutine lmg1mv(nord, fp, fm, gp, hp, hm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Move the exponential of a first order polynomial to the left:      *
*         exp(:F1:)exp(:F2:)exp(:F3:)exp(:F4:)exp(:G1:)                *
*       = exp(:H1:)exp(:H2:)exp(:H3:)exp(:H4:).                        *
* Source:     MARYLIE, version 5.1 (routine G1MOVE).                   *
* Author:     Liam Healy.                                              *
* Input:                                                               *
*   NORD      (integer) The order of the maps involved.                *
*   FP, FM    (map)     The map F.                                     *
*   GP        (poly)    The polynomials representing the map G.        *
* Output:                                                              *
*   HP, HM    (map)     The map H defined above.                       *
*----------------------------------------------------------------------*
+ca aparam
      integer ifj,ifk,ipb2,ipb3,ipb4,isave,itm,j,k,nord
      double precision by12,by2,by24,by6,by8,fm,fp,gneg,gp,gt,hm,hp,one
      dimension         fp(*), fm(6,6), gp(*), hp(*), hm(6,6)
+ca memdum
+ca pa6lnk
+ca wstack

      parameter         (one = 1.0d0)
      parameter         (by2 = 1.0d0 / 2.0d0)
      parameter         (by6 = 1.0d0 / 6.0d0)
      parameter         (by8 = 1.0d0 / 8.0d0)
      parameter         (by12 = 1.0d0 / 12.0d0)
      parameter         (by24 = 1.0d0 / 24.0d0)

      dimension         gneg(6), gt(6)
      logical           eflag

*---- If there is no G1, copy "F" map and return.
      do 10 j = 1, 6
        if (gp(j) .ne. 0.0) go to 100
   10 continue
      call pa6cpy(fp, - nord, hp)
      call m66cpy(fm, hm)
      return

*---- Linear map?
  100 continue
      if (nord .le. 2) then
        call pa6xfm(gp, 1, fm, gt)
        call pa6add(fp, gt, 1, hp)
        call pa6clr(hp, 2)
        call m66cpy(fm, hm)
        return
      endif

*---- Allocate working space.
      isave = iwork
      itm   = iwork
      ifj   = itm  + 36
      ifk   = ifj  + itop6(nord)
      ipb2  = ifk  + itop6(nord)
      ipb3  = ipb2 + itop6(nord)
      ipb4  = ipb3 + itop6(nord)
      iwork = ipb4 + itop6(nord)
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Clear result array and add G1.
      call pa6clr(hp, -nord)
      call pa6add(hp, gp, 1, hp)

*---- Find GNEG = - G1.
      call pa6scl(- one, gp, 1, gneg)

*---- Switch to suppress higher orders, if not wanted.
*     Note: NORD .LE. 2 will not come here.
      go to (200, 200, 200, 130, 120, 110), nord

*---- Terms arising from F6.
  110 continue
        call lmexpo(gneg, 1, fp, 6, dq(ifj+1), 6)
        call pa6add(hp, dq(ifj+1), - 6, hp)

*---- Terms arising from F5.
  120 continue
        call lmexpo(gneg, 1, fp, 5, dq(ifj+1), 5)
        call pa6add(hp, dq(ifj+1), - 5, hp)

*---- Terms arising from F4.
  130 continue
        call lmexpo(gneg, 1, fp, 4, dq(ifj+1), 4)
        call pa6add(hp, dq(ifj+1), - 4, hp)
        if (nord .ge. 6) then
          do 140 k = 1, 3
          do 140 j = k+1, 4
            call pa6brk(dq(ifj+1), j, dq(ifj+1), k, dq(ipb2+1))
            call pa6sum(by2, dq(ipb2+1), j+k-2, hp)
  140     continue
        endif
  200 continue

*---- Move H1 across F3.
      call pa6scl(- one, hp, 1, gneg)
      call lmexpo(gneg, 1, fp, 3, dq(ifj+1), 3)

*---- Factorize F(J), result is F(K).
      call pa6cpy(dq(ifj+1), - 3, dq(ifk+1))
      if (nord .ge. 4) then
        call pa6clr(dq(ifk+1), 4)
        call pa6brk(dq(ifj+1), 2, dq(ifj+1), 1, dq(ipb2+1))
        call pa6brk(dq(ifj+1), 3, dq(ifj+1), 1, dq(ipb2+1))
        call pa6brk(dq(ifj+1), 3, dq(ifj+1), 2, dq(ipb2+1))
        call pa6sum(by2, dq(ipb2+1), - 3, dq(ifk+1))
        if (nord .ge. 5) then
          call pa6clr(dq(ifk+1), 5)
          call pa6brk(dq(ifj+1), 2, dq(ipb2+1), 3, dq(ipb3+1))
          call pa6sum(- by6, dq(ipb3+1), 3, dq(ifk+1))
          call pa6brk(dq(ifj+1), 3, dq(ipb2+1), 3, dq(ipb3+1))
          call pa6sum(- by12, dq(ipb3+1), 4, dq(ifk+1))
          if (nord .ge. 6) then
            call pa6brk(dq(ifj+1), 2, dq(ipb3+1), 3, dq(ipb4+1))
            call pa6sum(by24, dq(ipb4+1), 3, dq(ifk+1))
            call pa6brk(dq(ifj+1), 3, dq(ipb3+1), 3, dq(ipb4+1))
            call pa6sum(by24, dq(ipb4+1), 4, dq(ifk+1))
            call pa6brk(dq(ifj+1), 3, dq(ipb3+1), 4, dq(ipb4+1))
            call pa6sum(by24, dq(ipb4+1), 5, dq(ifk+1))
          endif
          call pa6brk(dq(ifj+1), 1, dq(ipb2+1), 2, dq(ipb3+1))
          call pa6sum(- by6, dq(ipb3+1), 1, dq(ifk+1))
          call pa6brk(dq(ifj+1), 2, dq(ipb2+1), 2, dq(ipb3+1))
          call pa6sum(- by12, dq(ipb3+1), 2, dq(ifk+1))
          call pa6brk(dq(ifj+1), 3, dq(ipb2+1), 2, dq(ipb3+1))
          call pa6sum(by6, dq(ipb3+1), 3, dq(ifk+1))
          if (nord .ge. 6) then
            call pa6brk(dq(ifj+1), 2, dq(ipb3+1), 1, dq(ipb4+1))
            call pa6brk(dq(ifj+1), 3, dq(ipb3+1), 1, dq(ipb4+1))
            call pa6sum(- by24, dq(ipb4+1), - 2, dq(ifk+1))
            call pa6brk(dq(ifj+1), 3, dq(ipb3+1), 2, dq(ipb4+1))
            call pa6sum(by24, dq(ipb4+1), 3, dq(ifk+1))
            call pa6brk(dq(ifj+1), 2, dq(ipb3+1), 3, dq(ipb4+1))
            call pa6sum(- by8, dq(ipb4+1), 3, dq(ifk+1))
            call pa6brk(dq(ifj+1), 3, dq(ipb3+1), 3, dq(ipb4+1))
            call pa6sum(- by24, dq(ipb4+1), 4, dq(ifk+1))
          endif
          call pa6brk(dq(ifj+1), 2, dq(ipb2+1), 1, dq(ipb3+1))
          call pa6brk(dq(ifj+1), 3, dq(ipb2+1), 1, dq(ipb3+1))
          call pa6sum(by6, dq(ipb3+1), - 2, dq(ifk+1))
          if (nord .ge. 6) then
            call pa6brk(dq(ifj+1), 2, dq(ipb3+1), 1, dq(ipb4+1))
            call pa6brk(dq(ifj+1), 3, dq(ipb3+1), 1, dq(ipb4+1))
            call pa6sum(by24, dq(ipb4+1), - 2, dq(ifk+1))
            call pa6brk(dq(ifj+1), 1, dq(ipb3+1), 2, dq(ipb4+1))
            call pa6sum(- by8, dq(ipb4+1), 1, dq(ifk+1))
            call pa6brk(dq(ifj+1), 2, dq(ipb3+1), 2, dq(ipb4+1))
            call pa6sum(- by24, dq(ipb4+1), 2, dq(ifk+1))
            call pa6brk(dq(ifj+1), 3, dq(ipb3+1), 2, dq(ipb4+1))
            call pa6sum(by24, dq(ipb4+1), 3, dq(ifk+1))
          endif
        endif
      endif

*---- Concatenate DQ(IFK+1) with H = F4...F6.
      if (nord .ge. 5) then
        call pa6brk(dq(ifk+1), 2, hp, 2, dq(ipb2+1))
        call pa6sum(by2, dq(ipb2+1), 2, hp)
        call pa6brk(dq(ifk+1), 3, hp, 2, dq(ipb2+1))
        call pa6sum(one, dq(ipb2+1), 3, hp)
        call pa6brk(dq(ifk+1), 3, hp, 3, dq(ipb2+1))
        call pa6sum(by2, dq(ipb2+1), 4, hp)
        if (nord .ge. 6) then
          call pa6brk(dq(ifk+1), 2, dq(ipb2+1), 2, dq(ipb3+1))
          call pa6sum(by12, dq(ipb3+1), 2, hp)
          call pa6brk(dq(ifk+1), 3, dq(ipb2+1), 4, dq(ipb3+1))
          call pa6sum(- by6, dq(ipb3+1), 5, hp)
        endif
      endif
      call pa6add(hp, dq(ifk+1), - min(nord,5), hp)

*---- Move H1 across F2 and combine with F1.
      call pa6xfm(hp, 1, fm, gt)
      call pa6add(fp, gt, 1, hp)

*---- Calculate the matrix part of the factored exponential.
      call m66mak(hp, hm)
      call m66exp(hm, dq(itm+1), eflag)
      call m66mpy(dq(itm+1), fm, hm)

*---- Drop working storage.
      iwork = isave

      end
+dk lminv
      subroutine lminv(nord, gp, gm, hp, hm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Invert Lie-algebraic map.                                          *
* Source:     MARYLIE, version 3.0 (routine INV).                      *
* Author:     Liam Healy, April 1985.                                  *
* Input:                                                               *
*   NORD      (integer) Order of the map.                              *
*   GP, GM    (map)     Map to be inverted.                            *
* Output:                                                              *
*   HP, HM    (map)     Map resulting from inversion.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision gm,gp,hm,hp,one
      dimension         gp(*), gm(6,6), hp(*), hm(6,6)

      parameter         (one = 1.0d0)

*---- Reverse the factorization.
      call lmrevf(gp, gm, nord, hp, hm)

*---- Invert the matrix.
      call m66inv(hm, hm)

*---- Invert polynomials.
      call pa6scl(-one, hp, -nord, hp)

      end
+dk lmlcav
      subroutine lmlcav(nord, el, rfv, rfl, rff, fp, fm)
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lie-algebraic map for a travelling wave RF cavity.                 *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   EL        (real)    Cavity length.                                 *
*   RFV       (real)    Cavity voltage.                                *
*   RFL       (real)    Cavity phase lag.                              *
*   RFF       (real)    Cavity frequency.                              *
* Output:                                                              *
*   FP, FM    (map)     Cavity map.                                    *
*----------------------------------------------------------------------*
* Created:  28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Routine copied and modified from LMRF ... non-operational          *
*----------------------------------------------------------------------*
      implicit none
      integer nord
      double precision el, rfv, rfl, rff
      double precision fp(*), fm(6,6)
+ca message

*---- Issue an error message
      msg(1) = 'Cannot use LM routines (LIE) with LCAVITY'
      call aafail ('lmlcav', 1, msg)

      end
+dk lmmap
      subroutine lmmap(nord, el, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*    Return Lie algebraic map for an element.                          *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
* Output:                                                              *
*   EL        (real)    Element length.                                *
*   FP, FM    (map)     Element map.                                   *
* Local links:                                                         *
*   LMAP                Transfer map for a lump.                       *
*   LSEQ                Beam lines sequence for a lump.                *
*----------------------------------------------------------------------*
* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Added LCAVITY element at ISP 27 ... calls routine LMLCAV           *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ileng,iord,isp,lmap,nd,ne,nord
      double precision efield,el,field,fm,fp,one,phi,psi,rff,rfl,rfv,
     +sk1,sk2,sk3,sks,tilt,xcm,xkick,ycm,ykick,zero
      dimension         fp(*), fm(6,6)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca message
+ca beam
+ca pa6lnk
+ca refer

      parameter         (nd = 8 * mwflt)
      parameter         (zero = 0.0d0, one = 1.0d0)

      character*(mcnam) elmnam
      dimension         field(2,0:3)
      logical bvflag

      bvflag = .false.
*---- Field error data.
 1000 continue
      call uzero(field, 1, nd)
      if (lcfld .ne. 0) then
        ne = min(iq(lcfld-1),nd)
        call ucopy(q(lcfld+1), field, ne)
      endif

*---- Switch for element type.
      el = 0.0
      isp = iq(lcelm+mbsp)
      go to ( 10,  20,  30,  40,  50,  60,  70,  80,  90, 100,
     +       110, 120, 130, 140, 150, 160, 170, 180, 190, 200,
     +       210, 220, 230, 240, 250, 260, 270, 280, 290, 300,
     +       310, 310, 310, 310, 310, 310, 310, 310, 310, 310), isp

*---- Drift space.
   10 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call lmdrf(6, el, fp, fm)
      go to 500

*---- All bending magnets RBEND, SBEND, GBEND.
   20 continue
   30 continue
  260 continue
        call lmbend(6, el, fp, fm)
      go to 500

*---- Arbitrary matrix.
   40 continue
        call lmarb(6, fp, fm)
      go to 500

*---- Quadrupole.
   50 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mek1q), sk1, mwflt)
        sk1 = (sk1 + field(1,1)/el) / (one + deltas)
*--- apply inversion and scaling
        sk1 = sk1 * elkfact(5)
        call ucopy(q(lcelm+metltq), tilt, mwflt)
        call lmquad(6, el, sk1, tilt, fp, fm)
      go to 500

*---- Sextupole.
   60 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mek2s), sk2, mwflt)
        sk2 = (sk2 + field(1,2)/el) / (one + deltas)
*--- apply inversion and scaling
        sk2 = sk2 * elkfact(6)
        call ucopy(q(lcelm+metlts), tilt, mwflt)
        call lmsext(6, el, sk2, tilt, fp, fm)
      go to 500

*---- Octupole.
   70 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mek3o), sk3, mwflt)
        sk3 = (sk3 + field(1,3)/el) / (one + deltas)
*--- apply inversion and scaling
        sk3 = sk3 * elkfact(7)
        call ucopy(q(lcelm+metlto), tilt, mwflt)
        call lmoct(6, el, sk3, tilt, fp, fm)
      go to 500

*---- Multipole.
   80 continue
        call lmmult(3, fp, fm)
      go to 500

*---- Solenoid.
   90 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mekss), sks, mwflt)
        sks = sks / (one + deltas)
*--- apply inversion and scaling
        sks = sks * elkfact(9)
        call lmsol(6, el, sks, fp, fm)
      go to 500

*---- RF Cavity.
  100 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mevltc), rfv, mwflt)
        call ucopy(q(lcelm+melagc), rfl, mwflt)
        call ucopy(q(lcelm+mefrqc), rff, mwflt)
        call lmrf(6, el, rfv, rfl, rff, fp, fm)
      go to 500

*---- Electrostatic separator.
  110 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+meflde), efield, mwflt)
        call ucopy(q(lcelm+metlte), tilt, mwflt)
        call lmsep(6, el, efield, tilt, fp, fm)
      go to 500

*---- S-Rotation.
  120 continue
        call ucopy(q(lcelm+meangr), psi, mwflt)
        call lmsrot(6, psi, fp, fm)
      go to 500

*---- Y-Rotation.
  130 continue
        call ucopy(q(lcelm+meangr), phi, mwflt)
        call lmyrot(6, phi, fp, fm)
      go to 500

*---- Correctors.
  140 continue
  150 continue
  160 continue
        call ucopy(q(lcelm+melen), el, mwflt)

*---- Original setting.
        if (isp .eq. 14) then
          call ucopy(q(lcelm+mekick), xkick, mwflt)
          call ucopy(q(lcelm+mekick+mcsiz), bvflag, 1)
          ykick = 0.0
        else if (isp .eq. 16) then
          xkick = 0.0
          call ucopy(q(lcelm+mekick), ykick, mwflt)
          call ucopy(q(lcelm+mekick+mcsiz), bvflag, 1)
        else
          call ucopy(q(lcelm+mekick), xkick, mwflt)
          call ucopy(q(lcelm+mekick+mcsiz), ykick, mwflt)
          call ucopy(q(lcelm+mekick+2*mcsiz), bvflag, 1)
        endif

*---- Correction from C.O. correction algorithm.
        if (lccom .ne. 0) then
          call ucopy(q(lccom+1), xcm, 2*mwflt)
        else
          xcm = 0.0
          ycm = 0.0
        endif

*---- Apply sum of original setting, correction, and field error.
        xcm = xcm + xkick + field(1,0)
        ycm = ycm + ykick + field(2,0)
*--- HG000915 use bv flag to possibly invert angle
        if (bvflag) then
          xcm = beambv * xcm
          ycm = beambv * ycm
        endif
        call lmcorr(6, el, xcm, ycm, fp, fm)
      go to 500

*---- Monitors.
  170 continue
  180 continue
  190 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call lmdrf(6, el, fp, fm)
      go to 500

*---- Apertures.
  200 continue
  210 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call lmdrf(6, el, fp, fm)
      go to 500

*---- Beam-Beam: not allowed.
  220 continue
        call diname(ldbnk, iq(lcelm+mbnam), elmnam)
        call utleng(elmnam, ileng)
        msg(1) = 'Lie-algebraic map for beam-beam element is not known,'
        msg(2) = 'identity used for "' // elmnam(1:ileng) // '".'
        call aawarn('LMMAP', 2, msg)
        call lmone(6, fp, fm)
      go to 500

*---- Lump.
  230 continue
        iord = 4
        call utgint(lcelm, 3, 3, iord)
        iord = min(iord, 6)
        lmap = lq(lcelm-iq(lcelm+mbat)-mbelie)
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lmap+1), fm, 36*mwflt)
        call ucopy(q(lmap+36*mwflt+1), fp, itop6(iord)*mwflt)
        do 235 i = ibot6(iord+1), itop6(nord)
          fp(i) = 0.0
 235    continue
      go to 500

*---- Beam instrument.
  240 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call lmdrf(6, el, fp, fm)
      go to 500

*---- Marker.
  250 continue
        call lmone(6, fp, fm)
      go to 500

*---- LCAV Cavity.
  270 continue
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mevltc), rfv, mwflt)
        call ucopy(q(lcelm+melagc), rfl, mwflt)
        call ucopy(q(lcelm+mefrqc), rff, mwflt)
        call lmlcav(6, el, rfv, rfl, rff, fp, fm)
      go to 500
  280 continue
  290 continue
  300 continue
        call lmone(6, fp, fm)
      go to 500

*---- User-defined elements.
  310 continue
        call lmuser(6, isp, el, fp, fm)

*---- End of element calculation; check for LUMP.
  500 continue

      end
+dk lmmask
      subroutine lmmask(nord, wipe, gp, gm, hp, hm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Wipe out monomial coefficients as specified by WIPE.               *
* Source:     MARYLIE, version 3.0 (routine MASK).                     *
* Input:                                                               *
*   NORD      (integer) Order of the map.                              *
*   WIPE(*)   (logical) .TRUE. for orders to be wiped out.             *
*   GP, GM    (map)     Map to be wiped.                               *
* Output:                                                              *
*   HP, HM    (map)     Result of wiping out.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer jord,nord
      double precision gm,gp,hm,hp
      logical           wipe(*)
      dimension         gp(*), gm(6,6), hp(*), hm(6,6)

*---- Matrix is always kept.
      call m66cpy(gm, hm)

*---- WIPE(JORD) refers to G(JORD).
      do 90 jord = 1, nord
        if (wipe(jord)) then
          call pa6clr(hp, jord)
        else
          call pa6cpy(gp, jord, hp)
        endif
   90 continue

      end
+dk lmmult
      subroutine lmmult(nord, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lie-algebraic map for a thin multipole.                            *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
* Output:                                                              *
*   FP, FM    (map)     Element map.                                   *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,iord,nd,ne,nord
      double precision ang,data,dbi,dbr,dipi,dipr,dpt,dpx,dpy,elrad,
     +field,fm,fp,one,val
      dimension         fp(*), fm(6,6)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer
+ca stflag
+ca tmcomm
+ca physicpm
      parameter         (nd = 8 * mwflt, one = 1.0d0)

      integer bvpos, nord_l
      parameter         (bvpos = 24)
      logical bvflag
      dimension         data(2,0:3), field(2,0:3)

      bvflag = .false.
*--- copy to avoid overflows
      nord_l = max(nord,3)
*---- Multipole length for radiation.
      call ucopy(q(lcelm+melen), elrad, mwflt)

*---- Multipole components.
      call uzero(data, 1, nd)
      call utgflt(lcelm, 3, 10, data)
      call utglog(lcelm, bvpos, bvpos, bvflag)

*---- Field error data.
      call uzero(field, 1, nd)
      if (lcfld .ne. 0) then
        ne = min(iq(lcfld-1), nd)
        call ucopy(q(lcfld+1), field, ne)
      endif

*--- apply inversion and scaling
      do i = 1, 3
        do j = 1, 2
          data(j,i) = data(j,i) * elmfact(i)
          field(j,i) = field(j,i) * elmfact(i)
        enddo
      enddo

*---- Dipole error.
      dbr = field(1,0) / (one + deltas)
      dbi = field(2,0) / (one + deltas)

*---- Nominal dipole strength.
      ang =  data(2,0)
      dipr = data(1,0) * cos(ang) / (one + deltas)
      dipi = data(1,0) * sin(ang) / (one + deltas)

*--- HG000915 use bv flag to possibly invert angle
        if (bvflag) then
          dipr = beambv * dipr
          dipi = beambv * dipi
        endif

*---- Other components and errors.
      do 10 iord = 1, 3
        val =   data(1,iord)
        ang =   data(2,iord) * float(iord+1)
        field(1,iord) = (val*cos(ang) + field(1,iord)) / (one + deltas)
        field(2,iord) = (val*sin(ang) + field(2,iord)) / (one + deltas)
   10 continue

*---- Reduce sextupoles for closed orbit search.
      field(1,2) = field(1,2) * cohelp
      field(2,2) = field(2,2) * cohelp

*---- Set up identity map.
      call lmone(2*nord_l, fp, fm)

*---- Matrix.
*     Quadrupole part.
      fm(2,1) = - field(1,1)
      fm(2,3) = + field(2,1)
      fm(4,1) = + field(2,1)
      fm(4,3) = + field(1,1)

*---- Dispersion due to total dipole.
      fm(2,6) = + dipr / betas
      fm(4,6) = - dipi / betas
      fm(5,1) = - fm(2,6)
      fm(5,3) = - fm(4,6)

*---- Kick due to dipole error and dispersion.
      fp(1) = - field(1,0) + deltas * dipr
      fp(3) = + field(2,0) - deltas * dipi

*---- Radiation loss in dipole (length used for radiation only).
      if (dorad .and. elrad .ne. 0.0) then
        dpx = field(1,0) + dipr
        dpy = field(2,0) + dipi
        dpt = - (2.0 * arad * charge * gammas**3)
     +      * (dipr**2 + dipi**2) / (3.0 * elrad)
        fp(1) = fp(1) + 0.5 * dpt * fm(2,6)
        fp(3) = fp(3) + 0.5 * dpt * fm(4,6)
        fp(5) = dpt
      endif

*---- F3 Polynomial.
      if (2*nord .ge. 3) then

*---- Sextupole part.
        fp(28) = - field(1,2) / 6.0
        fp(30) = + field(2,2) / 2.0
        fp(39) = + field(1,2) / 2.0
        fp(64) = - field(2,2) / 6.0
      endif

*---- F4 Polynomial (octupole).
      if (2*nord .ge. 4) then
        fp(84)  = - field(1,3) / 24.0
        fp(86)  = + field(2,3) /  6.0
        fp(95)  = + field(1,3) /  4.0
        fp(120) = - field(2,3) /  6.0
        fp(175) = - field(1,3) / 24.0
      endif

      end
+dk lmnewt
      subroutine lmnewt(nord, df, ndim, zi, zf)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Apply a canonical transformation, defined by the derivatives of    *
*   its generating function, to a phase space vector.                  *
*     DF contains the derivatives of F w.r.t. the six variables,       *
*     and the polynomial order of F is NORD.                           *
* Source:     MARYLIE, version 5.1 (routine NEWT).                     *
* Authors:    Liam Healy and Philippo Neri.                            *
* Input:                                                               *
*   NORD      (integer) Order of the generating function F.            *
*   DF(NDIM,6)(poly)    The six derivatives of F.                      *
*   ZI(6)     (real)    Input phase space vector.                      *
* Output:                                                              *
*   ZF(6)     (real)    Final phase space vector.                      *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ipind,iqind,irank,itra,j,jord,n,ndim,nord
      double precision df,pvec,qvec,rdf,rjac,rmat,root,square,vect,zf,
     +zi
      dimension         df(ndim,6), zi(6), zf(6)
+ca memdum
+ca pa3lnk
+ca pa6lnk

      dimension         pvec(0:55), qvec(0:55)
      dimension         rdf(0:55,3), rjac(0:35,3,3)
      dimension         rmat(3,4), vect(461)
      equivalence       (pvec(0), qvec(0), vect(1))

*---- Initialize.
      do 10 i = 1, 6
        zf(i) = zi(i)
   10 continue

*---- Basis monomials in Q.
      qvec(0) = 1.0
      qvec(1) = zi(1)
      qvec(2) = zi(3)
      qvec(3) = zi(5)
      do 30 jord = 2, nord-1
        do 20 i = ibot3(jord), itop3(jord)
          qvec(i) = qvec(iq(lind31+i)) * qvec(iq(lind32+i))
   20   continue
   30 continue

*---- Coefficients of RDF (reduced DF), function of P only.
      do 190 i = 1, 3

*---- Clear the table.
        do 110 j = 0, itop3(nord-1)
          rdf(j,i) = 0.0
  110   continue

*---- Add up the monomial coefficients.
*     (Note: This loop contains vector dependencies).
        do 130 j = 1, itop6(nord-1)
          rdf(iq(larrp+j),i) = rdf(iq(larrp+j),i) +
     +      qvec(iq(larrq+j))*df(j,2*i-1)
  130   continue

*---- Coefficients of the Jacobian (all orders through NORD-2).
        do 180 j = 1, 3
          call pa3dif(rdf(1,i), j, 1-nord, rjac(1,i,j))
  180   continue
  190 continue

*---- Loop to apply contraction mapping.
      do 390 itra = 1, 12

*---- Basis monomials in P.
        pvec(0) = 1.0
        pvec(1) = zf(2)
        pvec(2) = zf(4)
        pvec(3) = zf(6)
        do 220 jord = 2, nord-1
          do 210 i = ibot3(jord), itop3(jord)
            pvec(i) = pvec(iq(lind31+i)) * pvec(iq(lind32+i))
  210     continue
  220   continue

*---- Error vector.
        do 290 i = 1, 3
          rmat(i,4) = rdf(0,i) - zi(2*i)
          do 260 n = 1, itop3(nord-1)
            rmat(i,4) = rmat(i,4) + rdf(n,i) * pvec(n)
  260     continue

*---- Jacobian matrix.
          do 280 j = 1, 3
            rmat(i,j) = rdf(i,j)
            do 270 n = 1, itop3(nord-2)
              rmat(i,j) = rmat(i,j) + rjac(n,i,j) * pvec(n)
  270       continue
  280     continue
  290   continue
        call solver(rmat, 3, 1, irank)
        if(irank .lt. 3) then
          call aawarn('LMNEWT', 1,
     +    'Problems with matrix inversion for tracking.')
          return
        endif
        square = rmat(1,4)**2 + rmat(2,4)**2 + rmat(3,4)**2
        root = sqrt(square)
        do 330 i = 1, 3
          zf(2*i) = zf(2*i) - rmat(i,4)
  330   continue
        if(root .lt. 1.0e-12) go to 400
  390 continue
      call aawarn('LMNEWT', 1, 'Newton search did not converge.')

*---- Compute new position coordinates.
  400 continue

*---- Basis monomials in Q and P.
      do 410 i = 1, 6
        vect(i) = zf(i)
  410 continue
      do 430 jord = 2, nord-1
        do 420 i = ibot6(jord), itop6(jord)
          vect(i) = vect(iq(lind61+i)) * vect(iq(lind62+i))
  420   continue
  430 continue

*---- Values of the new position coordinates.
      do 490 iqind = 1, 5, 2
        ipind = iqind + 1
        do 480 j = 7, itop6(nord-1)
          zf(iqind) = zf(iqind) + df(j,ipind) * vect(j)
  480   continue
  490 continue

      end
+dk lmoct
      subroutine lmoct(nord, el, sk3, tilt, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*    Lie algebraic map for an octupole.                                *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   EL        (real)    Octupole length.                               *
*   SK3       (real)    Octupole strength.                             *
*   TILT      (real)    Octupole tilt.                                 *
* Output:                                                              *
*   FP, FM    (map)     Octupole map.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision el,fact,fm,fp,sk3,tilt
      dimension         fp(*), fm(6,6)
+ca beam

*---- Linear terms.
      call lmone(nord, fp, fm)
      fm(1,2) = el
      fm(3,4) = el
      fm(5,6) = el/(betas*gammas)**2
      fp(6) = - el*dtbyds

*---- Third order terms.
      if (nord .ge. 3) then
        fp(53) = el / (2.0 * betas)
        fp(76) = el / (2.0 * betas)
        fp(83) = fm(5,6) / (2.0 * betas)
      endif

*---- Fourth order terms.
      if (nord .ge. 4) then
        fact = sk3 * el
        fp( 84) = - fact / 24.0
        fp( 95) =   fact /  4.0
        fp(175) = - fact / 24.0
        fact = fact * el
        fp( 85) =   fact / 12.0
        fp( 96) = - fact /  4.0
        fp(110) = - fact /  4.0
        fp(176) =   fact / 12.0
        fact = fact * el
        fp( 90) = - fact / 12.0
        fp( 99) =   fact / 12.0
        fp(111) =   fact /  3.0
        fp(145) =   fact / 12.0
        fp(179) = - fact / 12.0
        fact = fact * el
        fp(105) =   fact / 24.0
        fp(114) = - fact /  8.0
        fp(146) = - fact /  8.0
        fp(185) =   fact / 24.0
        fact = fact * el
        fp(140) = - fact / 120.0 - el / 8.0
        fp(149) =   fact /  20.0 - el / 4.0
        fp(195) = - fact / 120.0 - el / 8.0
        fp(154) = el * (1.0 - 3.0 / betas**2) / 4.0
        fp(200) = el * (1.0 - 3.0 / betas**2) / 4.0
        fp(209) = fm(5,6) * (1.0 - 5.0 / betas**2) / 8.0
      endif

*---- Transform for rotation.
      if (tilt .ne. 0.) call lmtilt(nord, tilt, fp, fm)

      end
+dk lmone
      subroutine lmone(nord, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*    Set up identity map.                                              *
* Source:     MARYLIE, version 3.0 (routine IDENT).                    *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
* Output:                                                              *
*   FP, FM    (map)     Identity map.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision fm,fp
      dimension         fp(*), fm(6,6)

      call m66one(fm)
      call pa6clr(fp, -nord)

      end
+dk lmprnt
      subroutine lmprnt(iunit, nord, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print complete representation of a Lie-algebraic map.              *
* Input:                                                               *
*   IUNIT     (integer) Logical output unit.                           *
*   NORD      (integer) Order of the map.                              *
*   FP, FM    (map)     The map to be printed.                         *
*----------------------------------------------------------------------*
+ca aparam
      integer iunit,nord
      double precision fm,fp
      dimension         fp(*), fm(6,6)

*---- Linear terms contained in FM.
      write (iunit, 910)
      call m66prt(fm, iunit)

*---- Polynomials F1 through F(NORD).
      call pa6prt(fp, nord, iunit)

  910 format(' Matrix of map:')

      end
+dk lmquad
      subroutine lmquad(nord, el, sk1, tilt, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*    Lie algebraic map for a quadrupole.                               *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   EL        (real)    Quadrupole length.                             *
*   SK1       (real)    Quadrupole strenth.                            *
*   TILT      (real)    Quadrupole tilt.                               *
* Output:                                                              *
*   FP, FM    (map)     Quadrupole map.                                *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision c2x,c2y,cx,cy,ekx,ekxl,ekxl2,el,fm,fp,s2x,s2y,
     +sk1,sx,sy,tilt
      dimension         fp(*), fm(6,6)
+ca beam

*---- Linear terms.
      call lmone(nord, fp, fm)
      ekx = sqrt(abs(sk1))
      ekxl = ekx * el
      if (abs(ekxl) .lt. 1.0e-3) then
        ekxl2 = sk1 * el**2
        cx = (1.0 - ekxl2 / 2.0)
        sx = (1.0 - ekxl2 / 6.0) * el
        cy = (1.0 + ekxl2 / 2.0)
        sy = (1.0 + ekxl2 / 6.0) * el
      else if (sk1 .gt. 0.0) then
        cx = cos(ekxl)
        sx = sin(ekxl) / ekx
        cy = cosh(ekxl)
        sy = sinh(ekxl) / ekx
      else
        cx = cosh(ekxl)
        sx = sinh(ekxl) / ekx
        cy = cos(ekxl)
        sy = sin(ekxl) / ekx
      endif
      fm(1,1) = + cx
      fm(1,2) = + sx
      fm(2,1) = - sx * sk1
      fm(2,2) = + cx
      fm(3,3) = + cy
      fm(3,4) = + sy
      fm(4,3) = + sy * sk1
      fm(4,4) = + cy
      fm(5,6) = el/(betas*gammas)**2
      fp(6) = - el*dtbyds

*---- Third order terms.
      if (nord .ge. 3) then
        s2x = cx * sx
        s2y = cy * sy
        fp(33) = sk1 * (el - s2x) / (4.0 * betas)
        fp(38) = sk1 * sx**2 / (2.0 * betas)
        fp(53) = (el + s2x) / (4.0 * betas)
        fp(67) = - sk1 * (el - s2y) / (4.0 * betas)
        fp(70) = - sk1 * sy**2 / (2.0 * betas)
        fp(76) = (el + s2y) / (4.0 * betas)
        fp(83) = fm(5,6) / (2.0 * betas)
      endif

*---- Fourth order terms.
      if (nord .ge. 4) then
        c2x = 2.0*cx**2 - 1.0
        c2y = 2.0*cy**2 - 1.0
        fp( 84) = sk1**2 * (s2x * (4.0 - c2x) - 3.0*el) / 64.0
        fp( 85) = - sk1**3 * sx**4 / 8.0
        fp( 90) = (3.0 / 32.0) * sk1 * (c2x*s2x - el)
        fp( 95) = sk1**2 * (2.0*el - s2x * (2.0 - c2y) -
     +    s2y * (2.0 - c2x)) / 32.0
        fp( 96) = sk1 * (c2y * (2.0 - c2x) - 1.0 -
     +    4.0*sk1*s2x*s2y) / 32.0
        fp( 99) = sk1 * (s2x * (2.0 + c2y) - s2y * (2.0 - c2x) -
     +    2.0*el) / 32.0
        fp(104) = sk1 * ((el - s2x) + (3.0 * s2x + el * (c2x - 4.0)) /
     +  (2.0 * betas**2)) / 8.0
        fp(105) = (cx**4 - 1.0) / 8.0
        fp(110) = sk1 * (1.0 - c2x * (2.0 - c2y) -
     +    4.0*sk1*s2x*s2y) / 32.0
        fp(111) = sk1 * (s2x*c2y - c2x*s2y) / 8.0
        fp(114) = (c2x * (2.0 + c2y) - 4.0*sk1*s2x*s2y - 3.0) / 32.0
        fp(119) = - sk1 * (el*s2x + (2.0 - betas**2) * sx**2) / (4.0 *
     +  betas**2)
        fp(140) = - (s2x * (4.0 + c2x) + 3.0*el) / 64.0
        fp(145) = sk1 * (2.0*el - s2y * (2.0 + c2x) +
     +    s2x * (2.0-c2y)) / 32.0
        fp(146) = (c2y * (2.0 + c2x) + 4.0*sk1*s2x*s2y - 3.0) / 32.0
        fp(149) = - (2.0*el + s2x * (2.0 + c2y) +
     +    s2y * (2.0 + c2x)) / 32.0
        fp(154) = ((el + s2x) - (5.0 * s2x + el * (6.0 + c2x)) / (2.0 *
     +  betas**2)) / 8.0
        fp(175) = sk1**2 * (s2y * (4.0 - c2y) - 3.0*el) / 64.0
        fp(176) = + sk1**3 * sy**4 / 8.0
        fp(179) = (3.0 / 32.0) * sk1 * (el - c2y*s2y)
        fp(184) = - sk1 * ((el - s2y) + (3.0 * s2y + el * (c2y - 4.0)) /
     +  (2.0 * betas**2)) / 8.0
        fp(185) = (cy**4 - 1.0) / 8.0
        fp(190) = sk1 * (el*s2y + (2.0 - betas**2) * sy**2) / (4.0 *
     +  betas**2)
        fp(195) = - (s2y * (4.0 + c2y) + 3.0*el) / 64.0
        fp(200) = ((el + s2y) - (5.0 * s2y + el * (6.0 + c2y)) / (2.0 *
     +  betas**2)) / 8.0
        fp(209) = fm(5,6) * (1.0 - 5.0 / betas**2) / 8.0
      endif

*---- Transform for rotation.
      if (tilt .ne. 0.) call lmtilt(nord, tilt, fp, fm)

      end
+dk lmrefl
      subroutine lmrefl(gp, gm, nord, hp, hm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Reflect a map, i.e. run through its elements in backward order.    *
* Source:     MARYLIE, version 3.0 (routine REV).                      *
* Author:     Alex Dragt, September 1985.                              *
* Input:                                                               *
*   GP, GM    (map)     Map to be reflected.                           *
*   NORD      (integer) Order of the map.                              *
* Output:                                                              *
*   HP, HM    (map)     The reflected map.                             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,itest,j,nord
      double precision d,gm,gp,hm,hp
      dimension         gp(*), gm(6,6), hp(*), hm(6,6)
+ca memdum
+ca pa6lnk

*---- Define the reversing matrix D:
      dimension         d(6)
      data d            / +1.d0, -1.d0, +1.d0, -1.d0, -1.d0, +1.d0 /

*---- Compute inverse map.
      call lminv(nord, gp, gm, hp, hm)

*---- Reverse matrix portion of map.
      do 10 i = 1, 6
      do 10 j = 1, 6
        hm(i,j) = d(i) * hm(i,j) * d(j)
   10 continue

*---- Reverse polynomial portion of map.
      do 20 i = 1, itop6(nord)
        itest = iq(lexp6(2)+i) + iq(lexp6(4)+i) + iq(lexp6(5)+i)
        if(mod(itest,2) .eq. 0) then
          hp(i) = - hp(i)
        endif
   20 continue

      end
+dk lmrevf
      subroutine lmrevf(gp, gm, nord, hp, hm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Reverse the order of factorization.                                *
* Source:     MARYLIE, version 3.0 (routine REVF).                     *
* Author:     Liam Healy, April 1985.                                  *
* Input:                                                               *
*   GP, GM    (map)     Map in standard order:                         *
*                       exp(:g2:)exp(:g3:)exp(:g4).                    *
*   NORD      (integer) Order of the map.                              *
* Output:                                                              *
*   HP, HM    (map)     Map with reverse factorization:                *
*                       exp(:h4:)exp(:h3:)exp(:h2:).                   *
*----------------------------------------------------------------------*
+ca aparam
      integer isave,itemp,jord,nord
      double precision gm,gp,hm,hp
      dimension         gp(*), gm(6,6), hp(*), hm(6,6)
+ca memdum
+ca pa6lnk
+ca wstack

*---- Allocate working space.
      isave = iwork
      itemp = iwork
      iwork = itemp + itop6(nord)
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Copy matrix.
      call m66cpy(gm, hm)
      call pa6clr(hp, -2)

*---- Transform higher terms.
      do 10 jord = 3, nord
        call pa6xfm(gp, jord, hm, dq(itemp+1))
        call pa6cpy(dq(itemp+1), jord, hp)
   10 continue

*---- Drop working storage.
      iwork = isave

      end
+dk lmrf
      subroutine lmrf(nord, el, rfv, rfl, rff, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lie-algebraic map for a RF cavity.                                 *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   EL        (real)    Cavity length.                                 *
*   RFV       (real)    Cavity voltage.                                *
*   RFL       (real)    Cavity phase lag.                              *
*   RFF       (real)    Cavity frequency.                              *
* Output:                                                              *
*   FP, FM    (map)     Cavity map.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer idm,idp,isave,nord
      double precision el,fm,fp,omega,one,phirf,rff,rfl,rfv,ten3m,ten6p,
     +twopi,vrf
      dimension         fp(*), fm(6,6)
+ca memdum
+ca beam
+ca pa6lnk
+ca wstack
+ca physicpm
      parameter         (one = 1.0d0, ten3m = 1.0d-3, ten6p = 1.0d+6)
+ca pi
      parameter         (twopi = 2.0d0 * pi)

*---- Extract data for element.
      isave = iwork
      omega = rff * ten6p * twopi / clight
      vrf   = rfv * ten3m / (pc * (one + deltas))
      phirf = rfl * twopi

*---- Transfer map for cavity as a thin lens.
      call lmone(nord, fp, fm)
      fp(5) = vrf * sin(phirf)
      fm(6,5) = - vrf * cos(phirf) * omega
*      IF (NORD .GE. 3) FP(80) = - VRF * SIN(PHIRF) * OMEGA**2 / 6.0
*      IF (NORD .GE. 4) FP(205) = VRF * COS(PHIRF) * OMEGA**3 / 24.0

*---- If length is non-zero, sandwich between two drifts.
*     Assign temporary storage.
      if (el .ne. 0.0) then
        idm   = iwork
        idp   = idm + 36
        iwork = idp + itop6(nord)
        if (iwork .gt. nwork) then
          call mzwork(0, dq(1), dq(iwork+1), 2)
          nwork = iwork
        endif

*---- Transfer map for drift of half length.
        call lmdrf(nord, el / 2.0, dq(idp+1), dq(idm+1))

*---- Concatenate the three parts.
        call lmcat(nord, dq(idp+1), dq(idm+1), fp, fm, fp, fm)
        call lmcat(nord, fp, fm, dq(idp+1), dq(idm+1), fp, fm)
      endif

*---- Release working storage.
      iwork = isave

      end
+dk lmsand
      subroutine lmsand(nord, t1p, t1m, t2p, t2m, t3p, t3m)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Sandwich a Lie-algebraic map: T3=T1*T2*(T1 inverse)                *
* Source:     MARYLIE, version 3.0 (routine SNDWCH).                   *
* Author:     Liam Healy.                                              *
* Input:                                                               *
*   NORD      (integer) Order of the maps.                             *
*   T1P, T1M  (map)     Transforming map.                              *
*   T2P, T2M  (map)     Map to be transformed.                         *
* Output:                                                              *
*   T3P, T3M  (map)     Result of the sandwich.                        *
*----------------------------------------------------------------------*
+ca aparam
      integer isave,it4m,it4p,nord
      double precision t1m,t1p,t2m,t2p,t3m,t3p
      dimension         t1p(*), t1m(6,6), t2p(*), t2m(6,6)
      dimension         t3p(*), t3m(6,6)
+ca memdum
+ca pa6lnk
+ca wstack

*---- Allocate working space.
      isave = iwork
      it4m  = iwork
      it4p  = it4m + 36
      iwork = it4p + itop6(nord)
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Perform calculation.
      call lminv(nord, t1p, t1m, dq(it4p+1), dq(it4m+1))
      call lmcat(nord, t1p, t1m, t2p, t2m, t3p, t3m)
      call lmcat(nord, t3p, t3m, dq(it4p+1), dq(it4m+1), t3p, t3m)

*---- Drop working storage.
      iwork = isave

      end
+dk lmsect
      subroutine lmsect(nord, el, h, dh, sk1, sk2, sk3, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lie-algebraic map for sector dipole.                               *
*   Excitation error DH is treated in a linear approximation.          *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   EL        (real)    Dipole length.                                 *
*   H         (real)    Curvature of reference orbit.                  *
*   DH        (real)    Curvature error (excitation error of K0).      *
*   SK1       (real)    Quadrupole strength.                           *
*   SK2       (real)    Sextupole strength.                            *
*   SK3       (real)    Octupole strength.                             *
* Output:                                                              *
*   FP, FM    (map)     Element map.                                   *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision bi,bi2,c1,c2,c3,c4,cg0,cg1,cg2,ch0,ch1,ch2,cm,cp,
     +cx,cy,cyy,dd,dh,dif,dm,dp,dpt,dx,dyy,el,fm,fminus,fp,fplus,fx,fyy,
     +gx,h,hx,s1,s2,s3,s4,sk1,sk2,sk3,sm,sp,sum,sx,sy,syy,xk,xkl,xklsq,
     +xksq,xs6,y0,y1,y2,yk,ykl,yklsq,yksq,ys2,yyklsq,yyksq,zc,zd,zf,zs
      dimension         fp(*), fm(6,6)
+ca beam
+ca stflag
+ca physicpm
      parameter         (c1  =   1.0d0,
     +                   c2  =   1.0d0 /      2.0d0,
     +                   c3  =   1.0d0 /     24.0d0,
     +                   c4  =   1.0d0 /    720.0d0)
      parameter         (s1  =   1.0d0,
     +                   s2  =   1.0d0 /      6.0d0,
     +                   s3  =   1.0d0 /    120.0d0,
     +                   s4  =   1.0d0 /   5040.0d0)
      parameter         (cg0 =   1.0d0 /     20.0d0,
     +                   cg1 =   5.0d0 /    840.0d0,
     +                   cg2 =  21.0d0 /  60480.0d0)
      parameter         (ch0 =   1.0d0 /     56.0d0,
     +                   ch1 =  14.0d0 /   4032.0d0,
     +                   ch2 = 147.0d0 / 443520.0d0)

*---- Horizontal focusing functions.
      xksq = h**2 + sk1
      xk  = sqrt(abs(xksq))
      xkl = xk * el
      xklsq = xksq * el**2
      if (abs(xklsq) .lt. 1.0e-2) then
        cx = (c1 - xklsq * (c2 - xklsq * c3))
        sx = (s1 - xklsq * (s2 - xklsq * s3)) * el
        dx = (c2 - xklsq * (c3 - xklsq * c4)) * el**2
        fx = (s2 - xklsq * (s3 - xklsq * s4)) * el**3
        gx = (cg0 - xklsq * (cg1 - xklsq * cg2)) * el**5
        hx = (ch0 - xklsq * (ch1 - xklsq * ch2)) * el**7
      else
        if (xklsq .gt. 0.0) then
          cx = cos(xkl)
          sx = sin(xkl) / xk
        else
          cx = cosh(xkl)
          sx = sinh(xkl) / xk
        endif
        dx = (1.0 - cx) / xksq
        fx = (el  - sx) / xksq
        gx = (3.0*el - sx*(4.0-cx)) / (2.0*xksq**2)
        hx = (15.0*el - sx*(22.0-9.0*cx+2.0*cx**2)) / (6.0*xksq**3)
      endif

*---- Vertical focusing functions.
      yksq = - sk1
      yk  = sqrt(abs(yksq))
      ykl = yk * el
      yklsq = yksq * el**2
      if (abs(yklsq) .lt. 1.0e-2) then
        cy = (c1 - yklsq * (c2 - yklsq * c3))
        sy = (s1 - yklsq * (s2 - yklsq * s3)) * el
      else if (yklsq .gt. 0.0) then
        cy = cos(ykl)
        sy = sin(ykl) / yk
      else
        cy = cosh(ykl)
        sy = sinh(ykl) / yk
      endif

*---- Fill in matrix.
      call lmone(nord, fp, fm)
      fm(1,1) = + cx
      fm(1,2) = + sx
      fm(1,6) = dx * h / betas
      fm(2,1) = - sx * xksq
      fm(2,2) = + cx
      fm(2,6) = sx * h / betas
      fm(3,3) = + cy
      fm(3,4) = + sy
      fm(4,3) = - sy * yksq
      fm(4,4) = + cy
      fm(5,1) = - fm(2,6)
      fm(5,2) = - fm(1,6)
      fm(5,6) = - fx*(h/betas)**2 + el/(betas*gammas)**2

*---- Excitation error.
      fp(1) = - dh * sx
      fp(2) = - dh * dx
      fp(6) = - dh * fx * h / betas - el*dtbyds

*---- Radiation loss.
*     Loss for ideal orbit is assumed.
      if (dorad) then
        dpt = - (2.0 * arad * charge * gammas**3) * el * h**2 / 3.0
        fp(1) = fp(1) + 0.5 * dpt * fm(2,6)
        fp(2) = fp(2) - 0.5 * dpt * fm(1,6)
        fp(5) = dpt
        fp(6) = fp(6) - 0.5 * dpt * fm(5,6)
      endif

*---- Third order, pure horizontal terms.
      if (nord .ge. 3) then
        xs6 = (sk2 + 2.0*h*sk1) / 6.0
        bi = 1.0 / betas
        bi2 = bi**2
        fp(28) = - xs6*sx*(2.0 + cx**2)/3.0 - h*xksq**2*sx**3/6.0
        fp(29) = + xs6*dx*(1.0 + cx + cx**2) - h*xksq*sx**2*cx/2.0
        fp(34) = - xs6*sx**3 - h*sx*cx**2/2.0
        fp(49) = + xs6*dx**2*(2.0 + cx)/3.0 + h*(dx + sx**2*cx)/6.0
        fp(33) = bi*(- h*xs6*(xksq*gx + cx*sx*dx) + h**2*xksq*sx**3/2.0
     +               + sk1*(el - cx*sx)/4.0)
        fp(38) = bi*(h*xs6*dx**2*(1.0 + 2.0*cx) + h**2*sx**2*cx
     +             + sk1*sx**2/2.0)
        fp(53) = bi*(- h*xs6*(sx*dx**2 + gx)
     +         - h**2*(fx + sx*dx*(1.0+2.0*cx))/4.0 + (el + sx*cx)/4.0)
        fp(48) = h*bi2*(- h*xs6*(sx*dx**2 - gx - gx) - h**2*sx**3/2.0 -
     +  sk1*(fx + sx*dx)/2.0 - sx / (2.0*gammas**2))
        fp(63) = h*bi2*(h*xs6*dx**3 + h**2*sx**2*dx/2.0 - sx**2/2.0 +
     +  dx / (2.0*gammas**2))
        fp(83) = h**2*bi**3*(- h*xs6*hx - h**2*(sx*dx**2 + gx)/6.0 +
     +  (fx + sx*dx)/4.0 - fx / (2.0*gammas**2)) + el / (2.0*betas**3
     +  *gammas**2)

*---- Third order, coupling terms.
        yyksq = 4.0 * yksq
        call tmfoc(el, yyksq, cyy, syy, dyy, fyy)
        yyklsq = yyksq * el**2
        if (max(abs(yyklsq),abs(xklsq)) .le. 1.0e-2) then
          y0 = 1.0
          y1 = xklsq + yyklsq
          y2 = xklsq**2 + xklsq*yyklsq + yyklsq**2
          zc = (y0 - (y1 - y2 / 30.0) / 12.0) * el**2 /   2.0
          zs = (y0 - (y1 - y2 / 42.0) / 20.0) * el**3 /   6.0
          zd = (y0 - (y1 - y2 / 56.0) / 30.0) * el**4 /  24.0
          zf = (y0 - (y1 - y2 / 72.0) / 42.0) * el**5 / 120.0
        else if (xksq .le. 0.0 .or. yksq .le. 0.0) then
          dd = xksq - yyksq
          zc = (cyy - cx) / dd
          zs = (syy - sx) / dd
          zd = (dyy - dx) / dd
          zf = (fyy - fx) / dd
        else
          sum = (xk/2.0 + yk) ** 2
          dif = (xk/2.0 - yk) ** 2
          call tmfoc(el, sum, cp, sp, dp, fplus)
          call tmfoc(el, dif, cm, sm, dm, fminus)
          zc = sp * sm / 2.0
          zs = (sp*cm - cp*sm) / (4.0*xk*yk)
          if (xksq .gt. yyksq) then
            zd = (dyy - zc) / xksq
            zf = (fyy - zs) / xksq
          else
            zd = (dx - zc) / yyksq
            zf = (fx - zs) / yyksq
          endif
        endif
        ys2 = (sk2 + h*sk1) / 2.0
        fp(39) = + sk1*sk2*(xksq*sx*zd + cx*zs) + ys2*sx
        fp(40) = - sk2*(xksq*sx*zs + cx*zc)
        fp(43) = + sk2*(xksq*sx*zd + cx*zs) - h*sx/2.0
        fp(54) = + sk1*sk2*(cx*zd - sx*zs) - ys2*dx
        fp(55) = - sk2*(cx*zs - sx*zc)
        fp(58) = + sk2*(cx*zd - sx*zs) + h*dx/2.0
        fp(67) = (h*sk2*sk1*(zf + dx*zs - sx*zd) + h*ys2*fx - sk1*(el -
     +  sy*cy)/4.0) / betas
        fp(70) = (- h*sk2*(zd + dx*zc - sx*zs) - sk1*sy**2/2.0) / betas
        fp(76) = (h*sk2*(zf + dx*zs - sx*zd) - h**2*fx/2.0 + (el + sy
     +  *cy)/4.0) / betas
      endif

*---- Fourth order not yet available.
      end
+dk lmsep
      subroutine lmsep(nord, el, efield, tilt, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lie-algebraic map for an electrostatic separator.                  *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   EL        (real)    Separator length.                              *
*   EFIELD    (real)    Separator field.                               *
*   TILT      (real)    Separator tilt.                                *
* Output:                                                              *
*   FP, FM    (map)     Separator map.                                 *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision by120,by2,by24,by6,ch,cy,dy,efield,ekick,ekl,el,
     +eps,f444,f446,f466,f666,fact,fm,fp,one,sh,sy,ten3m,three,tilt
      dimension         fp(*), fm(6,6)
+ca beam

      parameter         (one     = 1.d0)
      parameter         (by2     = 1.d0/2.d0)
      parameter         (by6     = 1.d0/6.d0)
      parameter         (by24    = 1.d0/24.d0)
      parameter         (by120   = 1.d0/120.d0)
      parameter         (three   = 3.0d0)
      parameter         (eps     = 1.d-4)
      parameter         (ten3m   = 1.d-3)

*---- Prepare linear transformation parameters.
*     DY = (COSH(K*L) - 1) / K.
      ekick  = efield * ten3m * charge / (pc * (one + deltas))
      ekl = ekick * el
      if (abs(ekl) .gt. eps) then
        ch = cosh(ekl)
        cy = ch
        sh = sinh(ekl)
        sy = sh / ekick
        dy = (ch - one) / ekick**2
      else
        ch = (one + by2  * ekl**2)
        cy = ch
        sy = (one + by6  * ekl**2) * el
        sh = sy * ekick
        dy = (by2 + by24 * ekl**2) * el**2
      endif

*---- Kicks.
      call lmone(nord, fp, fm)
      fp(3) = sy * (ekick / betas)
      fp(4) = - dy * (ekick / betas)
      fp(6) = - el * dtbyds

*---- Transfer matrix.
      fm(1,2) = el
      fm(3,3) = ch - ekl * sh / betas**2
      fm(3,4) = sy
      fm(3,6) = (dy - el * sy / betas**2) * ekick
      fm(4,3) = (sh - ekl * ch / betas**2) * ekick
      fm(4,4) = ch
      fm(4,6) = (sh - ekl * ch / betas**2)
      fm(5,3) = - fm(4,6)
      fm(5,4) = - dy * ekick
      fm(5,6) = - (sy - el * cy / betas**2)

*---- Third order.
      if (nord .ge. 3) then
        fp(50) = + ekl * ch / (2.0 * betas)
        fp(51) = - el * sh / (2.0 * betas)
        fp(53) = + el * ch / (2.0 * betas)

        fact = el * (ekl**2 / betas**2 + three / gammas**2) / betas**3
        f444 = fact * sh**3 + fm(3,3) * (three * el * ch * sh / betas)
        f446 = fact * sh**2 * ch + el * (fm(3,3) * (ch**2 + sh**2) + fm
     +  (4,6) * (ch*sh)) / betas
        f466 = fact * sh * ch**2 + el * (fm(4,6) * (ch**2 + sh**2) + fm
     +  (3,3) * (ch*sh)) / betas
        f666 = fact * ch**3 + fm(4,6) * (three * el * ch * sh / betas)

        fp(74) = - f444 * by6
        fp(68) = + f446 * by2 * ekick
        fp(76) = + f446 * by2
        fp(65) = - f466 * by2 * ekick**2
        fp(70) = - f466 * ekick
        fp(79) = - f466 * by2
        fp(64) = + f666 * by6 * ekick**3
        fp(67) = + f666 * by2 * ekick**2
        fp(73) = + f666 * by2 * ekick
        fp(83) = + f666 * by6
      endif

*---- $$$ Fourth order not available $$$

*---- Transform for rotation.
      if (tilt .ne. 0.0) call lmtilt(3, tilt, fp, fm)

      end
+dk lmsext
      subroutine lmsext(nord, el, sk2, tilt, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lie algebraic map for a sextupole.                                 *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   EL        (real)    Sextupole length.                              *
*   SK2       (real)    Sextupole strength.                            *
*   TILT      (real)    Sextupole tilt.                                *
* Output:                                                              *
*   FP, FM    (map)     Sextupole map.                                 *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision el,fact,fm,fp,sext,sk2,tilt
      dimension         fp(*), fm(6,6)
+ca beam
+ca tmcomm

*---- Linear terms.
      call lmone(nord, fp, fm)
      fm(1,2) = el
      fm(3,4) = el
      fm(5,6) = el/(betas*gammas)**2
      fp(6) = - el*dtbyds

*---- Third order terms.
      if (nord .ge. 3) then
        sext = sk2 * cohelp
        fact = sext * el
        fp(28) = - fact / 6.0
        fp(39) = + fact / 2.0
        fact = fact * el
        fp(29) = + fact / 4.0
        fp(40) = - fact / 2.0
        fp(54) = - fact / 4.0
        fact = fact * el
        fp(34) = - fact / 6.0
        fp(43) = + fact / 6.0
        fp(55) = + fact / 3.0
        fact = fact * el
        fp(49) = + fact / 24.0
        fp(58) = - fact / 8.0
        fp(53) = el / (2.0 * betas)
        fp(76) = el / (2.0 * betas)
        fp(83) = fm(5,6) / (2.0 * betas)
      endif

*---- Fourth order terms.
      if (nord .ge. 4) then
        fact = sext * sext * el * el * el
        fp( 84) = + fact / 48.0
        fp( 95) = + fact / 24.0
        fp(175) = + fact / 48.0
        fact = fact * el
        fp( 85) = - fact / 24.0
        fp( 96) = - fact / 24.0
        fp(110) = - fact / 24.0
        fp(176) = - fact / 24.0
        fact = fact * el
        fp( 90) = + fact / 32.0
        fp( 99) = + fact / 480.0
        fp(111) = + fact * (7.0 / 120.0)
        fp(145) = + fact / 480.0
        fp(179) = + fact / 32.0
        fact = fact * el
        fp(105) = - fact / 96.0
        fp(114) = - fact / 96.0
        fp(146) = - fact / 96.0
        fp(185) = - fact / 96.0
        fact = fact * el
        fp(140) = + fact / 672.0 - el / 8.0
        fp(149) = + fact / 336.0 - el / 4.0
        fp(195) = + fact / 672.0 - el / 8.0
        fact = sext * el * el * el / betas
        fp(109) = + fact / 12.0
        fp(132) = - fact / 12.0
        fp(161) = - fact / 6.0
        fact = fact * el
        fp(144) = - fact / 24.0
        fp(167) = + fact / 8.0
        fp(154) = el * (1.0 - 3.0 / betas**2) / 4.0
        fp(200) = el * (1.0 - 3.0 / betas**2) / 4.0
        fp(209) = fm(5,6) * (1.0 - 5.0 / betas**2) / 8.0
      endif

*---- Transform for rotation.
      if (tilt .ne. 0.) call lmtilt(nord, tilt, fp, fm)

      end
+dk lmsol
      subroutine lmsol(nord, el, sks, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lie-algebraic map for a solenoid.                                  *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   EL        (real)    Solenoid length.                               *
*   SKS       (real)    Solenoid strength.                             *
* Output:                                                              *
*   FP, FM    (map)     Element map.                                   *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision co,el,fact,fm,fp,si,sibk,sik,sk,skl,sks
      dimension         fp(*), fm(6,6)
+ca beam

*---- Set up C's and S's.
      call lmone(nord, fp, fm)
      sk = sks / 2.0
      skl = el * sk
      co = cos(skl)
      si = sin(skl)
      if (abs(skl) .lt. 1.0d-8) then
        sibk = (1 - skl**2 / 6.0) * el
      else
        sibk = si / sk
      endif

*---- Linear terms.
      sik = si * sk
      fm(1,1) = co * co
      fm(1,2) = co * sibk
      fm(1,3) = co * si
      fm(1,4) = si * sibk
      fm(2,1) = - co * sik
      fm(2,2) = co * co
      fm(2,3) = - si * sik
      fm(2,4) = co * si
      fm(3,1) = - co * si
      fm(3,2) = - si * sibk
      fm(3,3) = co * co
      fm(3,4) = co * sibk
      fm(4,1) = si * sik
      fm(4,2) = - co * si
      fm(4,3) = - co * sik
      fm(4,4) = co * co
      fm(5,6) = el/(betas*gammas)**2
      fp(6) = - el*dtbyds

*---- Third order terms.
      if (nord .ge. 3) then
        fp(53) = el / (2.0 * betas)
        fp(76) = el / (2.0 * betas)
        fp(83) = fm(5,6) / (2.0 * betas)
        fp(57) = 2.0 * fp(53) * sk
        fp(45) = - fp(57)
        fp(33) = fp(53) * sk**2
        fp(67) = fp(33)
      endif

*---- Fourth order terms.
      if (nord .ge. 4) then
        fp(140) = - el / 8.0
        fp(149) = - el / 4.0
        fp(195) = - el / 8.0
        fp(154) = - el * (1.0 - 3.0 / betas**2) / 4.0
        fp(200) = - el * (1.0 - 3.0 / betas**2) / 4.0
        fp(209) = - fm(5,6) * (5.0 - 1.0 / betas**2) / 8.0
        fact = el * sk
        fp(107) = + fact / 2.0
        fp(130) = + fact / 2.0
        fp(141) = - fact / 2.0
        fp(159) = - fact / 2.0
        fp(135) = + fact * (1.0 - 3.0 / betas**2) / 2.0
        fp(164) = - fact * (1.0 - 3.0 / betas**2) / 2.0
        fact = fact * sk
        fp(111) = + fact
        fp( 90) = - fact / 4.0
        fp(179) = - fact / 4.0
        fp( 99) = - (fact * 3.0) / 4.0
        fp(145) = - (fact * 3.0) / 4.0
        fp(104) = - fact * (1.0 - 3.0 / betas**2) / 4.0
        fp(184) = - fact * (1.0 - 3.0 / betas**2) / 4.0
        fact = fact * sk
        fp( 87) = + fact / 2.0
        fp( 91) = - fact / 2.0
        fp(121) = + fact / 2.0
        fp(155) = - fact / 2.0
        fact = fact * sk
        fp( 84) = - fact / 8.0
        fp( 95) = - fact / 4.0
        fp(175) = - fact / 8.0
      endif

      end
+dk lmsprt
      subroutine lmsprt(iunit, nord, fp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print the polynomials of a map in the static resonance basis.      *
* Source:     MARYLIE, version 3.0 (routine PSRMAP).                   *
* Input:                                                               *
*   IUNIT     (integer) Logical output unit.                           *
*   NORD      (integer) Order of the map.                              *
*   FP(*)     (poly)    Static resonance basis coefficients.           *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iunit,j,jl,jord,nl,nord
      double precision fp,tol
      dimension         fp(*)
+ca pa6lnk

      parameter         (tol = 1.0d-8)
      integer           il(209)
      character*6       sln(209)

      data (sln(i), i = 1, 25)
     +   / 'R00001', 'R10000', 'I10000', 'R00100', 'I00100',
     +     '000010', 'R11000', 'R00110', 'R00002', 'R10001',
     +     'I10001', 'R00101', 'I00101', 'R20000', 'I20000',
     +     'R00200', 'I00200', 'R10100', 'I10100', 'R10010',
     +     'I10010', '100010', '010010', '001010', '000110' /
      data (sln(i), i = 26, 50)
     +   / '000020', '000011', 'R11001', 'R00111', 'R00003',
     +     'R10002', 'I10002', 'R00102', 'I00102', 'R20001',
     +     'I20001', 'R00201', 'I00201', 'R10101', 'I10101',
     +     'R10011', 'I10011', 'R21000', 'I21000', 'R00210',
     +     'I00210', 'R10110', 'I10110', 'R11100', 'I11100' /
      data (sln(i), i = 51, 75)
     +   / 'R30000', 'I30000', 'R00300', 'I00300', 'R20100',
     +     'I20100', 'R10200', 'I10200', 'R20010', 'I20010',
     +     'R01200', 'I01200', '200010', '110010', '101010',
     +     '100110', '100020', '100011', '020010', '011010',
     +     '010110', '010020', '010011', '002010', '001110' /
      data (sln(i), i = 76, 100)
     +   / '001020', '001011', '000210', '000120', '000111',
     +     '000030', '000021', '000012', 'R11002', 'R00112',
     +     'R00004', 'R22000', 'R00220', 'R11110', 'R10003',
     +     'I10003', 'R00103', 'I00103', 'R20002', 'I20002',
     +     'R00202', 'I00202', 'R10102', 'I10102', 'R10012' /
      data (sln(i), i = 101, 125)
     +   / 'I10012', 'R21001', 'I21001', 'R00211', 'I00211',
     +     'R10111', 'I10111', 'R11101', 'I11101', 'R30001',
     +     'I30001', 'R00301', 'I00301', 'R20101', 'I20101',
     +     'R10201', 'I10201', 'R20011', 'I20011', 'R01201',
     +     'I01201', 'R31000', 'I31000', 'R00310', 'I00310' /
      data (sln(i), i = 126, 150)
     +   / 'R20110', 'I20110', 'R11200', 'I11200', 'R21100',
     +     'I21100', 'R10210', 'I10210', 'R21010', 'I21010',
     +     'R01210', 'I01210', 'R40000', 'I40000', 'R00400',
     +     'I00400', 'R30100', 'I30100', 'R10300', 'I10300',
     +     'R30010', 'I30010', 'R01300', 'I01300', 'R20200' /
      data (sln(i), i = 151, 175)
     +   / 'I20200', 'R20020', 'I20020', '300010', '210010',
     +     '201010', '200110', '200020', '200011', '120010',
     +     '111010', '110110', '110020', '110011', '102010',
     +     '101110', '101020', '101011', '100210', '100120',
     +     '100111', '100030', '100021', '100012', '030010' /
      data (sln(i), i = 176, 200)
     +   / '021010', '020110', '020020', '020011', '012010',
     +     '011110', '011020', '011011', '010210', '010120',
     +     '010111', '010030', '010021', '010012', '003010',
     +     '002110', '002020', '002011', '001210', '001120',
     +     '001111', '001030', '001021', '001012', '000310' /
      data (sln(i), i = 201, 209)
     +   / '000220', '000211', '000130', '000121', '000112',
     +     '000040', '000031', '000022', '000013' /

      do 90 jord = 1, nord
        nl = 0
        do 70 j = ibot6(jord), itop6(jord)
          if (abs(fp(j)) .gt. tol) then
            nl = nl + 1
            il(nl) = j
          endif
   70   continue
        if (nl .gt. 0) then
          write (iunit, 910) jord
          write (iunit, 920) (sln(il(jl)), fp(il(jl)), jl = 1, nl)
        endif
   90 continue

  910 format(' Terms of order ',i1,':')
  920 format(4(' ',a6,'  = ',1pe14.6:,5x))

      end
+dk lmsrot
      subroutine lmsrot(nord, psi, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lie-algebraic map for a rotation around s-axis.                    *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   PSI       (real)    Rotation angle.                                *
* Output:                                                              *
*   FP, FM    (map)     Rotation map.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision cospsi,fm,fp,psi,sinpsi
      dimension         fp(*), fm(6,6)

*---- S-Rotation is linear, thus F3 = F4 = 0.
      call lmone(nord, fp, fm)

*---- F2 terms (F matrix).
      cospsi = cos(psi)
      sinpsi = sin(psi)
      fm(1,1) =   cospsi
      fm(1,3) =   sinpsi
      fm(3,1) = - sinpsi
      fm(3,3) =   cospsi
      fm(2,2) =   cospsi
      fm(2,4) =   sinpsi
      fm(4,2) = - sinpsi
      fm(4,4) =   cospsi

      end
+dk lmtilt
      subroutine lmtilt(nord, tilt, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*    Modify map for elements rotated by TILT.                          *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   TILT      (real)    Tilt angle.                                    *
* Input/output:                                                        *
*   FP, FM    (map)     Element map to be rotated.                     *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iftp,isave,j,nord
      double precision c,f1mj,f2mj,fm,fmi1,fmi2,fp,ftm,s,tilt
      dimension         fp(*), fm(6,6)
+ca memdum
+ca pa6lnk
+ca wstack

      dimension         ftm(6,6)

      isave = iwork

*---- Linear terms.
      c = cos(tilt)
      s = sin(tilt)
      do 10 i = 1, 6
        fmi1 = fm(i,1)
        fm(i,1) = fmi1 * c - fm(i,3) * s
        fm(i,3) = fmi1 * s + fm(i,3) * c
        fmi2 = fm(i,2)
        fm(i,2) = fmi2 * c - fm(i,4) * s
        fm(i,4) = fmi2 * s + fm(i,4) * c
   10 continue
      do 20 j = 1, 6
        f1mj = fm(1,j)
        fm(1,j) = c * f1mj - s * fm(3,j)
        fm(3,j) = s * f1mj + c * fm(3,j)
        f2mj = fm(2,j)
        fm(2,j) = c * f2mj - s * fm(4,j)
        fm(4,j) = s * f2mj + c * fm(4,j)
   20 continue

*---- Third order terms.
      if (nord .ge. 3) then

*---- Allocate working space.
        iftp  = iwork
        iwork = iftp + itop6(min(nord,4))
        if (iwork .gt. nwork) then
          call mzwork(0, dq(1), dq(iwork+1), 2)
          nwork = iwork
        endif
        call m66one(ftm)
        ftm(1,1) = c
        ftm(1,3) = s
        ftm(3,1) = -s
        ftm(3,3) = c
        ftm(2,2) = c
        ftm(2,4) = s
        ftm(4,2) = -s
        ftm(4,4) = c
        call pa6xfm(fp, 3, ftm, dq(iftp+1))
        call pa6cpy(dq(iftp+1), 3, fp)

*---- Fourth order terms.
        if (nord .ge. 4) then
          call pa6xfm(fp, 4, ftm, dq(iftp+1))
          call pa6cpy(dq(iftp+1), 4, fp)
        endif
      endif

*---- Drop working storage.
      iwork = isave

      end
+dk lmtrak
      subroutine lmtrak(nord, fp, fm, track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track particles through a Lie-algebraic map.                       *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   FP, FM    (map)     Element map.                                   *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) number of surviving tracks.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer idf,isave,itrack,ndim,nord,ktrack
      double precision fm,fp,track,zi,zt
      dimension         fp(*), fm(6,6), track(6,ktrack)
+ca memdum
+ca pa6lnk
+ca wstack

      dimension         zi(6), zt(6)

*---- Allocate working space.
      isave = iwork
      idf   = iwork
      ndim  = itop6(nord-1)
      iwork = idf + 6 * ndim
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Set up derivaties of generating function.
      call lmcanx(nord, fp, dq(idf+1), ndim)

*---- Loop for particles.
      do 90 itrack = 1, ktrack

*---- Linear part of the map (displacement and transfer matrix).
        zt(1) = track(1,itrack) - fp(2)
        zt(2) = track(2,itrack) + fp(1)
        zt(3) = track(3,itrack) - fp(4)
        zt(4) = track(4,itrack) + fp(3)
        zt(5) = track(5,itrack) - fp(6)
        zt(6) = track(6,itrack) + fp(5)

*---- Find new momenta by Newton search.
        if (nord .gt. 2) then
          call m66byv(fm, zt, zi)
          call lmnewt(nord, dq(idf+1), ndim, zi, track(1,itrack))
        else
          call m66byv(fm, zt, track(1,itrack))
        endif
   90 continue

*---- Drop working storage.
      iwork = isave

      end
+dk lmuser
      subroutine lmuser(nord, isp, el, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*    User-defined map.                                                 *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   ISP       (integer) Subprocess code.                               *
* Output:                                                              *
*   FP, FM    (map)     Element map.                                   *
*----------------------------------------------------------------------*
+ca aparam
      integer isp,nord
      double precision el,fm,fp
      dimension         fp(*), fm(6,6)

*---- Set up identity map.
      call lmone(nord, fp, fm)

      end
+dk lmyrot
      subroutine lmyrot(nord, phi, fp, fm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lie-algebraic map for a rotation around the Y-axis.                *
*   Treated in a purely linear way.                                    *
* Input:                                                               *
*   NORD      (integer) Order desired.                                 *
*   PHI       (real)    Rotation angle.                                *
* Output:                                                              *
*   FP, FM    (map)     Rotation map.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer nord
      double precision cosphi,fm,fp,phi,sinphi,tanphi
      dimension         fp(*), fm(6,6)
+ca beam

*---- F1 term.
      call lmone(nord, fp, fm)
      cosphi = cos(phi)
      sinphi = sin(phi)
      tanphi = sinphi / cosphi
      fp(1) = - tanphi

*---- F2 terms (F matrix).
      fm(1,1) = 1.0 / cosphi
      fm(2,2) = cosphi
      fm(2,6) = - sinphi / betas
      fm(5,1) = tanphi / betas

      end
+dk lmzzzz
+dk lnaaaa
+dk lnbeam
      subroutine lnbeam(label, if1, if2)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode beam line definition.                                       *
* Input:                                                               *
*   LABEL    (char)     Label for new definition (required).           *
*   IF1      (integer)  First character of formals list (optional).    *
*   IF2      (integer)  Last character of formals list.                *
*----------------------------------------------------------------------*
+ca aparam
      integer if1,if2
      character*(mcnam) label
+ca refer
+ca status
+ca stbuff

*---- Build LINE bank and link it to LINE keyword.
      call lnmake(lccmd, lckey)

*---- Decode formals list.
      if (if1 .ne. 0) then
        call dcform(lccmd, if1, if2, error)
      endif

*---- Skip separator.
      if (token(jtok) .eq. ','  .or.  token(jtok) .eq. '=') then
        jtok = jtok + 1
      endif

*---- Decode beam line list.
      call dclist(lccmd, error)

*---- If error detected, drop line bank.
      if (error) then
        call aadrop(lccmd)

*---- If all OK, link line bank to directory.
      else
        call didefi(ldbnk, label, lccmd)
      endif

      end
+dk lnchck
      subroutine lnchck(comand, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Check existence of a beam line sequence.                           *
* Input:                                                               *
*   LCSEQ     /REFER/   Current beam line sequence.                    *
*   COMAND    (char)    Command name.                                  *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
+ca refer
      character*(*)     comand
      logical           eflag

*---- Give warning message, no beam line has been USE'd.
      eflag = .false.
      if (lcseq .eq. 0) then
        call aafail(comand, 1, 'USE command missing.')
        eflag = .true.
      endif

      end
+dk lndrop
      subroutine lndrop(lseq)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Drop a beam line expansion and delete anonymous drifts.            *
* Input:                                                               *
*   LSEQ(1)  (pointer)  Pointer to expansion to be dropped.            *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,ipos
      integer           lseq(1)
+ca memdum
+ca bankhead
+ca prcgroup
+ca seqgroup
+ca refer

      character*(mcnam) label

      if (lseq(1) .eq. 0) go to 9999

*---- Delete anonymous drifts.
      lsdir = lq(lseq(1)-msdir)
      do 90 ipos = 1, iq(lsdir-1)
        idir = iq(lsdir+ipos)
        lcelm = lq(ldbnk(3)-idir)
        if (lcelm .ne. 0) then

*---- See if element is anonymous drift.
          if (iq(lcelm+mbpr).eq.mpelm .and. iq(lcelm+mbsp).eq.1) then
            call diname(ldbnk, idir, label)
            if (label(1:1) .eq. '[') then
              lq(ldbnk(3)-idir) = 0

*---- Use AADROP to drop drift, if its length is an expression.
              if (lq(lcelm-2) .ne. 0) then
                call aadrop(lcelm)

*---- For constant length, MZDROP is much faster.
              else
                call mzdrop(0, lcelm, '.')
              endif
            endif
          endif
        endif
   90 continue

*---- Erase expansion.
      call mzdrop(0, lseq, '.')
      lseq(1) = 0

 9999 end
+dk lndump
      subroutine lndump(lline, label)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Dump a line definition.                                            *
* Input:                                                               *
*   LLINE(1)  (pointer) Pointer to line module.                        *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ilist,j,jform,lform,nform,nlist
      integer           lline(*)
      character*(mcnam) label
+ca memdum
+ca bankhead
+ca lingroup
+ca zunit

      character*(mcnam) frmnam(10)

*---- Print header information.
      write (iqlog, 910) label,
     +  iq(lline(1)+mbln), iq(lline(1)+mbpr), iq(lline(1)+mbsp)

*---- Formal arguments.
      lform = lq(lline(1)-1)
      if (lform .ne. 0) then
        nform = iq(lform-1)
        write (iqlog, 920)
        i = 0
        do 10 jform = 1, nform, mwnam
          i = i + 1
          call uhtoc(q(lform+jform), mcwrd, frmnam(i), mcnam)
          if (i .eq. 10) then
            write (iqlog, 930) (frmnam(j), j = 1, 10)
            i = 0
          endif
   10   continue
        if (i .ne. 0) then
          write (iqlog, 930) (frmnam(j), j = 1, i)
        endif
      endif

*---- List data.
      nlist = iq(lline(1)-1) - 1
      write (iqlog, 940) iq(lline(1)+mlhd)
      do 20 ilist = mlfree, nlist, mlsiz
        write (iqlog, 950) ilist, (iq(lline(1)+ilist+j), j = 1, mlsiz)
   20 continue
      write (iqlog, 960)

  910 format(' '/' LNDUMP.  Command name:     ',a/
     +       t11,'Definition line:  ',i8/
     +       t11,'Process code:     ',i8/
     +       t11,'Subprocess code:  ',i8)
  920 format(' '/t11,'Formal arguments:')
  930 format(t11,10(a,' '))
  940 format(' '/t11,'Beam line list (header at',i8,'):'/
     +       t11,'Position      Type  Previous      Next    Repeat',
     +       ' Reference   Actuals')
  950 format(t11,i8,6i10)
  960 format(' ')

      end
+dk lnebgn
      subroutine lnebgn
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initialize editing of a beam line sequence, SEQEDIT command.       *
* Attributes:                                                          *
*   SEQUENCE (name)    Name of sequence to be edited.                  *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca prcgroup
+ca message
+ca lnlink
+ca range
+ca refer
      integer idir,ilen,ileng

      character*(mcnam) seqnam

*---- Retrieve sequence name.
      seqnam = ' '
      call utgnam(lccmd, 1, 1, seqnam)
      if (seqnam .eq. ' ') then
        call aafail('LNEBGN', 1, 'Sequence name missing.')
      else

*---- Look up name and check if sequence.
        call utleng(seqnam, ilen)
        call difind(ldbnk, seqnam(1:ilen), idir, llnesq)

*---- Have we found name?
        call utleng(seqnam, ileng)
        if (llnesq .eq. 0) then
          msg(1) = 'Sequence "' // seqnam(1:ileng) // '" not found.'
          call aafail('LNEBGN', 1, msg)

*---- Is it a valid sequence?
        else if (iq(llnesq+mbpr).ne.mplin.or.iq(llnesq+mbsp).ne.2) then
          msg(1) = '"' // seqnam(1:ileng) // '" is not a sequence.'
          call aafail('LNEBGN', 1, msg)
          llnesq = 0

*---- Optional drop of main beam line.
        else if (lcseq .ne. 0) then
          call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)
          if (linnam .eq. seqnam) then
            call aawarn('LNEBGN', 1,
     +        'Sequence name occurs in main beam line; USE deleted.')
            call mzdrop(0, lcseq, '.')
            lcseq = 0
          endif
        endif
      endif

      end
+dk lnecyc
      subroutine lnecyc
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Cyclic exchange of elements in sequence, CYCLE command.            *
* Attributes:                                                          *
*   START    (name)    Name of element for new start (marker).         *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca prcgroup
+ca express
+ca exstak
+ca message
+ca lnlink
+ca refer
      integer idir,ielem,ilast,ilen,incr,jdata,jelem,kdata,kelem,kfinal,
     +ndata,nelem
      double precision zero

      parameter         (zero = 0.0d0)

      character*(mcnam) elmnam

*---- Retrieve data for sequence to be edited.
      llnedr = lq(llnesq-1)
      llneat = llnesq
      nelem  = iq(llnedr+1)

*---- Check that last element is marker.
      idir  = iq(llnedr+nelem)
      lcelm = lq(ldbnk(3)-idir)
      if (iq(lcelm+mbpr) .ne. mpelm  .or. iq(lcelm+mbsp) .ne. 25) then
        call aafail('LNECYC', 1,
     +    'Last element in sequence should be a marker.')
        go to 9999
      endif

*---- Retrieve START position.
      elmnam = ' '
      call utgnam(lccmd, 1, 1, elmnam)
      if (elmnam .eq. ' ') then
        call rdfail('LNECYC', 1, 'Need START name for CYCLE.')
        go to 9999
      endif

*---- Look up element name in directory.
      call utleng(elmnam, ilen)
      call difind(ldbnk, elmnam(1:ilen), idir, lcelm)
      if (lcelm .eq. 0) then
        call rdfail('LNECYC', 1, 'Element "' // elmnam(1:ilen) //
     +              '" is not defined."')
        go to 9999
      endif

*---- Search for START position in sequence.
      do 10 ielem = 2, nelem
        if (iq(llnedr+ielem) .eq. idir) go to 20
   10 continue
      call rdfail('LNECYC', 1, 'Element "' // elmnam(1:ilen) //
     +            '" not found in sequence.')
      go to 9999

*---- Avoid cycling to previous starting position.
   20 if (ielem .eq. 2) then
        call aawarn('LNECYC', 1,
     +    'START position is already origin of sequence.')
        go to 9999
      endif

*---- Start position must be a marker.
      lcelm = lq(ldbnk(3)-idir)
      if (iq(lcelm+mbpr) .ne. mpelm  .or. iq(lcelm+mbsp) .ne. 25) then
        call aafail('LNECYC', 1,
     +    'START position for CYCLE should be a marker.')
        go to 9999
      endif

*---- Make sure there is enough space for interchange.
      ilast = nelem + ielem - 2
      if (ilast .ge. iq(llnedr-1)) then
        incr = ilast - iq(llnedr-1) + 1
        call mzpush(0, llnedr, 0, incr, '.')
        call mzpush(0, llneat, incr, incr * mwflt, '.')
        llnesq = llneat
      endif

*---- Move elements preceding START to end, adding total length.
      jdata = mbat + mcsiz + 2
      ndata = mbat + mcsiz + 2 + (nelem - 2) * mwflt
      kelem = nelem
      kdata = ndata
      do 30 jelem = 2, ielem - 1
        kelem = kelem + 1
        kdata = kdata + mwflt
        iq(llnedr+kelem) = iq(llnedr+jelem)
        level = 0
        nxopr = 0
        call excopy(llneat, jelem, jdata)
        call excopy(llneat, nelem, ndata)
        call exbin(1)
        call exmake(llneat, kelem, kdata, rsval(1), isval(1) + 1)
        jdata = jdata + mwflt
   30 continue
      kfinal = kelem

*---- Move START element, keep its original position.
      kelem = 2
      kdata = mbat + mcsiz + 2
      iq(llnedr+kelem) = iq(llnedr+ielem)
      call ucopy(q(llneat+jdata), q(llneat+kdata), mwflt)
      lcexp = lq(llneat-2)
      if (lcexp .ne. 0) call aadrop(lcexp)
      lcexp = lq(llneat-ielem)
      call zshunt(0, lcexp, llneat, -2, 0)

*---- Move all elements to position, subtracting START position.
*     Skip element NELEM (end marker stays in place).
      do 40 jelem = ielem + 1, kfinal
        jdata = jdata + mwflt
        if (jelem .ne. nelem) then
          kelem = kelem + 1
          kdata = kdata + mwflt
          iq(llnedr+kelem) = iq(llnedr+jelem)
          level = 0
          nxopr = 0
          call excopy(llneat, jelem, jdata)
          call excopy(llneat, 2, mbat+mcsiz+2)
          call exbin(2)
          call exmake(llneat, kelem, kdata, rsval(1), isval(1) + 1)
        endif
   40 continue

*---- Set START element's position to zero.
      lcexp = lq(llneat-2)
      if (lcexp .ne. 0) call aadrop(lcexp)
      call ucopy(zero, q(llneat+mbat+mcsiz+2), mwflt)

*---- Mark as modified.
      call aamark('LNECYC', llneat)
      call aainfo('LNECYC', 1,
     +  'Cyclic interchange completed, end marker stays in place.')

 9999 end
+dk lnedit
      subroutine lnedit(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Switch routine (subprocess code) for sequence editor.              *
* Input:                                                               *
*   IPR       (integer) Process code.                                  *
*   ISP       (integer) Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca message
+ca lnlink
+ca option
+ca status
      integer ipr,isp

*==== Sequence editor commands.
*     ISP = 1, SEQEDIT.
      if (isp .eq. 1) then
        if (imodul .ne. 0) then
          msg(1) =
     +    'Cannot initiate editor while previous process not complete,'
          msg(2) = 'Enter proper ENDxxxx command first.'
          call aafail('LNEDIT', 2, msg)
        else
          call lnebgn
          if (.not. error) imodul = ipr
        endif

*---- Check valid use.
      else if (imodul .ne. ipr) then
        msg(1) =
     +  'Cannot run editor subcommand outside sequence editor,'
        msg(2) = 'SEQEDIT command required first.'
        call aafail('LNEDIT', 2, msg)

*---- ISP = 2, INSTALL.
      else if (isp .eq. 2) then
        call lneins

*---- ISP = 3, MOVE.
      else if (isp .eq. 3) then
        call lnemov

*---- ISP = 4, REMOVE.
      else if (isp .eq. 4) then
        call lnerem

*---- ISP = 5, ENDEDIT.
      else if (isp .eq. 5) then
        llnesq = 0
        imodul = 0
      endif

      end
+dk lneins
      subroutine lneins
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Insert element(s) in a beam line sequence, INSERT command.         *
*   Last element must be marker.                                       *
* Attributes:                                                          *
*   ELEMENT  (name)    Name of element to be added.                    *
*   CLASS    (name)    Class name (like SEQUENCE definition).          *
*   AT       (real)    Position for new element.                       *
*   FROM     (name)    If given, AT is relative to this element,       *
*                      otherwise AT is absolute position.              *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca markbits
+ca prcgroup
+ca message
+ca lnlink
+ca exlink
+ca express
+ca exstak
+ca option
+ca refer
+ca status
+ca stbuff
+ca datatype
      integer ibias,icat,idata,idir,ielem,iexpr,ilen,iln,ipr,isp,jdata,
     +jdir,jelem,kdata,kelem,leng,melem,ncat,nd,nelem,ni,nkat,nl
      double precision pos,posi,posj

      character*(mcnam) clsnam, elmnam, frmnam, label
      integer           itype(4)
      logical           copy, found, select

*---- Retrieve data for sequence to be edited.
      llneat = llnesq
      llnedr = lq(llneat-1)
      llnefl = lq(llnedr-1)

*---- Retrieve data flags.
      call utgtyp(lccmd, itype)

*---- Retrieve name of element to be inserted.
      elmnam = ' '
      call utgnam(lccmd, 1, 1, elmnam)
      if (elmnam .eq. ' ') then
        call rdfail('LNEINS', 1, 'Need element name.')
        error = .true.
      endif

*---- Retrieve class of element to be inserted.
      clsnam = elmnam
      call utgnam(lccmd, 2, 2, clsnam)

*---- Look up class name.
      call utleng(clsnam, leng)
      call difind(ldbnk, clsnam(1:leng), idir, lccls)
      if (lccls .eq. 0  .or.  iq(lccls+mbpr) .ne. mpelm) then
        msg(1) = 'Element "' // clsnam(1:leng) // '" is unknown.'
        call rdfail('LNEINS', 1, msg)
        go to 9999
      endif

*---- Retriev "FROM" name.
      select = .false.
      if (itype(4) .ne. 0) then
        frmnam = ' '
        call utgnam(lccmd, 4, 4, frmnam)

*---- "SELECTED" --> install, element, at=ds, from=selected
        if (frmnam .eq. 'SELECTED') then
          select = .true.

*---- Look up "FROM" element name in directory.
        else
          call utleng(frmnam, ilen)
          call difind(ldbnk, frmnam(1:ilen), jdir, lcelm)
          if (jdir .eq. 0  .or.  iq(lcelm+mbpr) .ne. mpelm) then
            msg(1) = 'Element "' // frmnam(1:ilen) // '" is unknown.'
            call aafail('LNEINS', 1, msg)
            error = .true.
          endif
        endif
      endif

*---- Set flag for allowable copy.
      if (elmnam .ne. clsnam) then
        call direfe(ldbnk, elmnam, idir)

*---- Already defined --> redefinition not allowed.
        if (lq(ldbnk(3)-idir) .ne. 0) then
          lcelm = lccls
          copy = .false.
*---- Not yet defined --> new element.
        else
          lckey = lq(lccls+1)
          call kwget(lckey, iln, ipr, isp, nkat)
          call aabook(lcelm, elmnam, ipr, isp, lckey, 1)
          lq(ldbnk(3)-idir) = lccls
          copy = .true.
        endif
      else
        lcelm = lccls
        copy = .false.
      endif

*---- Test for additional attributes.
      if (token(jtok) .eq. ',') then

*---- Attributes are allowed.
        if (copy) then

*---- Copy default attributes from class.
          ncat = iq(lccls+mbat)
          do 10 icat = 1, ncat
            call aacopy(lccls, icat, lcelm)
  10      continue

*---- Link to class name.
          call sbit1(iq(lccls), mxcls)
          lq(lcelm-ncat-mbecls) = lccls

*---- Decode additional attributes.
          lcdef = lq(lckey-2)
          call aaattr(lcdef, lcelm, nkat, error)
          if (error) call aadrop(lcelm)

*---- DEFINE dump option.
          lq(ldbnk(3)-idir) = lcelm
          iq(lcelm+mbnam) = idir
          if (ideffl .eq. 1  .or.  ideffl .eq. 3) then
            call aadump(lcelm)
          endif
          if (ideffl .eq. 2  .or.  ideffl .eq. 3) then
            call dzshow('element', 0, lcelm, 'V', 0, 0, 0, 0)
          endif

*---- Duplicate name, change of attributes is not allowed.
        else
          call utleng(elmnam, leng)
          msg(1) = 'Name "' // elmnam(1:leng) // '" is not unique.'
          call rdfail('LNEINS', 1, msg)
          error = .true.
        endif

*---- Mark source bank as a synonym.
      else
        call sbit1(iq(lccls), mxals)
      endif

*---- Pass 1: Count elements which will be inserted.
      if (error) go to 9999
      nelem = iq(llnedr+1)
      melem = 0
      do 20 ielem = 2, nelem
        if (select) then
          found = iq(llnefl+ielem) .ne. 0
        else
          found = iq(llnedr+ielem) .eq. jdir
        endif
        if (found) melem = melem + 1
   20 continue

*---- If there are any installations, make sure there is enough space.
      if (melem .eq. 0) then
        call aainfo('LNEINS', 1, 'No element inserted.')
        go to 9999
      endif

*---- Copy keyword to local storage.
      lckey = lq(llnesq+1)
      call kwget(lckey, iln, ipr, isp, nkat)

*---- Lift banks for modified sequence.
*     New sequence bank LLNTMP(1): positions and expressions links.
      call diname(ldbnk, iq(llnesq+mbnam), label)
      call aabook(llntmp(1), label, ipr, isp, lckey, 1)
      call ucopy(q(llnesq+mbat+1), q(llntmp(1)+mbat+1), mcsiz)
      nl = nelem + melem - 1
      nd = mwflt * (nelem + melem) + 1
      call mzpush(0, llntmp(1), nl, nd, 'I')
      ni = nelem + melem
*     New sequence bank LLNTMP(2): directory indices.
      call mzbook(2,llntmp(2),llntmp(1),-1,'SDIR',1,1,ni,2,0)
*     New sequence bank LLNTMP(5): selection flags.
      if (llnefl .ne. 0)
     +  call mzbook(2,llntmp(3),llntmp(2),-1,'SFLG',0,0,ni,2,0)
      iq(llnedr+1) = nelem + melem

*---- Book banks for insertions.
      nl = melem
      nd = mwflt * melem
*     Temporary bank LLNTMP(1); inserted positions and expression links.
      call mzbook(2,llntmp(4),llntmp(4),1,'SEQU',nl,nl,nd,2,0)

*---- Pass 2: Fill banks for insertions.
      idata = mbat + mcsiz + 2
      jelem = 1
      jdata = 1
      do 30 ielem = 2, nelem
        if (select) then
          found = iq(llnefl+ielem) .ne. 0
        else
          found = iq(llnedr+ielem) .eq. jdir
        endif

*---- Determine position for insertion.
        if (found) then
          level = 0
          nxopr = 0
          if (itype(4) .ne. 0) then
            call excopy(llneat, ielem, idata)
            call excopy(lccmd, 3, mbat + 2*mcsiz + mcval)
            call exbin(1)
          else
            call excopy(lccmd, 3, mbat + 2*mcsiz + mcval)
          endif
          pos   = rsval(1)
          iexpr = isval(1) + 1
          call exmake(llntmp(4), jelem, jdata, pos, iexpr)

*---- Go to next position.
          jelem = jelem + 1
          jdata = jdata + mwflt
        endif

*---- Go to next original position.
        idata = idata + mwflt
   30 continue

*---- Pass 3: Merge the install banks with the original banks.
*     Original position is I.
      ielem = 2
      idata = mbat + mcsiz + 2
      call ucopy(q(llneat+idata), posi, mwflt)
*     Inserted position is J.
      jelem = 1
      jdata = 1
      call ucopy(q(llntmp(4)+jdata), posj, mwflt)
*     Merged position is K.
      kelem = 2
      kdata = mbat + mcsiz + 2

*---- As long as there are positions in either structure do...
   50 if (ielem .le. nelem  .or.  jelem .le. melem) then

*---- Original position comes first.
        if (jelem .gt. melem  .or.
     +      ielem .le. nelem .and. posi .le. posj) then
*     Position.
          call ucopy(posi, q(llntmp(1)+kdata), mwflt)
          lcexp = lq(llneat-ielem)
*     Directory index.
          iq(llntmp(2)+kelem) = iq(llnedr+ielem)
*     Selection flag.
          if (llnefl .ne. 0) iq(llntmp(3)+kelem) = iq(llnefl+ielem)
*     Go to next original position.
          ielem = ielem + 1
          idata = idata + mwflt
          call ucopy(q(llneat+idata), posi, mwflt)

*---- Inserted position comes first.
        else
*     Position.
          call ucopy(posj, q(llntmp(1)+kdata), mwflt)
          lcexp = lq(llntmp(4)-jelem)
*     Directory index.
          iq(llntmp(2)+kelem) = idir
*     Inserted position cannot be selected at this time.
          if (llnefl .ne. 0) iq(llntmp(3)+kelem) = 0
*     Go to next inserted position.
          jelem = jelem + 1
          jdata = jdata + mwflt
          call ucopy(q(llntmp(4)+jdata), posj, mwflt)
        endif

*---- Move expression, if any.
        if (lcexp .ne. 0) then
          call zshunt(0, lcexp, llntmp(1), -kelem, 0)
          ibias = mxsiz * iq(lcexp-3) + mxval
          iq(lcexp+ibias) = kdata
        endif

*---- Go to next merged position.
        kelem = kelem + 1
        kdata = kdata + mwflt
        go to 50
      endif

*---- Mark as modified.
      call aamark('LNEINS', llneat)
      write (msg, 910) melem
  910 format(i5,' element(s) inserted.')
      call aainfo('LNEINS', 1, msg)

*---- Remove old sequence and insert banks.
*     Keep directory index.
      idir = iq(llnesq+mbnam)
*     Drop old sequence.
      call aadrop(llnesq)
*     Drop insertions bank.
      call mzdrop(0, llntmp(4), ' ')
*     Store sequence size.
      iq(llntmp(2)+1) = nelem + melem
*     Link to directory.
      iq(llntmp(1)+mbnam) = idir
      lq(ldbnk(3)-idir) = llntmp(1)
*     Current SEQEDIT sequence.
      llnesq = llntmp(1)

 9999 end
+dk lnemov
      subroutine lnemov
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Move element in a beam line sequence, MOVE command.                *
* Attributes:                                                          *
*   ELEMENT  (name)    Name of element to be moved.
*
*   BY       (real)    If given, BY is displacement relative to the    *
*                      original position, otherwise use TO/FROM.       *
*   TO       (real)    Position for new element.                       *
*   FROM     (name)    If given, TO is relative to this element,       *
*                      otherwise TO is absolute position.              *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca prcgroup
+ca message
+ca express
+ca exstak
+ca lnlink
+ca refer
+ca status
+ca datatype
      integer idata,idir,ielem,iexpr,ilen,jbias,jdata,jdir,jelem,kdata,
     +kdir,kelem,melem,nelem
      double precision oldpos,pos,refrr

      character*(mcnam) elmnam, frmnam
      logical           found, select
      integer           itype(4)

*---- Retrieve data flags and bank pointers.
      call utgtyp(lccmd, itype)
      llneat = llnesq
      llnedr = lq(llneat-1)
      llnefl = lq(llnedr-1)

*---- Retrieve element name
      elmnam = ' '
      call utgnam(lccmd, 1, 1, elmnam)
      select = .false.
      if (elmnam .eq. ' ') then
        call aafail('LNEMOV', 1, 'Need element name or "SELECTED".')
        go to 9999

*---- "SELECTED" --> remove all selected elements
      else if (elmnam .eq. 'SELECTED') then

*---- Should have made a selection.
        if (llnefl .eq. 0) then
          call aafail('LNEMOV', 1, 'You have made no selection yet.')
          error = .true.
        else
          select = .true.
        endif

*---- Element name given --> find it in directory.
      else
        select = .false.
        call utleng(elmnam, ilen)
        call difind(ldbnk, elmnam(1:ilen), idir, lcelm)
        if (idir .eq. 0  .or.  iq(lcelm+mbpr) .ne. mpelm) then
          msg(1) = 'Element "' // elmnam(1:ilen) // '" is unknown.'
          call aafail('LNEMOV', 1, msg(1))
          error = .true.
        endif
      endif

*---- Check other attributes.
      if (select  .or.  itype(2) .ne. 0) then
        if (itype(3) .ne. 0  .or.  itype(4) .ne. 0) then
          call aafail('LNEMOV', 1, 'Inconsistent attributes given.')
          error = .true.
        endif
      endif

*---- Look up "FROM" element name in directory.
      call utgnam(lccmd, 4, 4, frmnam)
      if (itype(4) .ne. 0) then
        call utleng(frmnam, ilen)
        call difind(ldbnk, frmnam(1:ilen), kdir, lcelm)
        if (kdir .eq. 0  .or.  iq(lcelm+mbpr) .ne. mpelm) then
          msg(1) = 'Element "' // frmnam(1:ilen) // '" is unknown.'
          call aafail('LNEMOV', 1, msg)
          error = .true.
        endif
      endif

*---- Retrieve data for sequence to be edited.
      if (error) go to 9999
      nelem = iq(llnedr+1)
      melem = 0
      idata = mbat + mcsiz + 2

*---- Loop over sequence and move element(s).
      do 90 ielem = 2, nelem
        if (select) then
          found = iq(llnefl+ielem) .ne. 0
        else
          found = iq(llnedr+ielem) .eq. idir
        endif

*---- If found, move the element.
        if (found) then
          level = 0
          nxopr = 0
          if (itype(2) .ne. 0) then
            idata = mbat + mcsiz + (ielem - 2) * mwflt + 2
            call excopy(llneat, ielem, idata)
            call excopy(lccmd, 2, mbat + mcsiz + mcval)
            call exbin(1)

*---- "FROM" attribute.
          else

*---- Look up "FROM" element name in sequence.
            if (itype(4) .ne. 0) then
              do 10 kelem = 2, nelem
                if (iq(llnedr+kelem) .eq. kdir) go to 20
   10         continue
              msg(1) = 'Element "' // frmnam(1:ilen) //
     +                 '" not in sequence.'
              call aafail('LNEMOV', 1, msg)
              go to 9999
   20         continue

*---- Define origin of displacement.
              kdata = mbat + mcsiz + (kelem - 2) * mwflt + 2
              call excopy(llneat, kelem, kdata)
              call excopy(lccmd, 3, mbat + 2*mcsiz + mcval)
              call exbin(1)
            else
              call excopy(lccmd, 3, mbat + 2*mcsiz + mcval)
            endif
          endif
          pos   = rsval(1)
          iexpr = isval(1) + 1

*---- Save old position in temporary.
          jdir = iq(llnedr+ielem)
          idata = mbat + mcsiz + (ielem - 2) * mwflt + 2
          call ucopy(q(llneat+idata), oldpos, mwflt)

*---- Remove old position expression, if any.
          lcexp = lq(llneat-ielem)
          if (lcexp .ne. 0) call aadrop(lcexp)

*---- New position is lower than old one.
          jelem = ielem
          jdata = idata
          if (pos .lt. oldpos) then

*---- Move positions up to make room in the proper place.
   50       if (jelem .le. 2) go to 80
              call ucopy(q(llneat+jdata-mwflt), refrr, mwflt)
              if (refrr .lt. pos) go to 80
              call ucopy(refrr, iq(llneat+jdata), mwflt)
              iq(llnedr+jelem) = iq(llnedr+jelem-1)
              lcexp = lq(llneat-jelem+1)
              if (lcexp .ne. 0) then
                call zshunt(0, lcexp, llneat, -jelem, 0)
                jbias = mxsiz * iq(lcexp-3) + mxval
                iq(lcexp+jbias) = jdata
              endif
              jelem = jelem - 1
              jdata = jdata - mwflt
            go to 50

*---- New position is higher than old one.
          else

*---- Move positions down to make room in the proper place
   60       if (jelem .ge. nelem) go to 80
              call ucopy(q(llneat+jdata+mwflt), refrr, mwflt)
              if (refrr .gt. pos) go to 80
              call ucopy(refrr, iq(llneat+jdata), mwflt)
              iq(llnedr+jelem) = iq(llnedr+jelem+1)
              lcexp = lq(llneat-jelem-1)
              if (lcexp .ne. 0) then
                call zshunt(0, lcexp, llneat, -jelem, 0)
                jbias = mxsiz * iq(lcexp-3) + mxval
                iq(lcexp+jbias) = jdata
              endif
              jelem = jelem + 1
              jdata = jdata + mwflt
            go to 60
          endif

*---- Store new reference to the slot created.
   80     iq(llnedr+jelem) = jdir
          call exmake(llneat, jelem, jdata, pos, iexpr)
          melem = melem + 1
        endif
   90 continue

*---- Mark, if modified.
      if (melem .gt. 0) then
        call aamark('LNEMOV', llneat)
        write (msg, 910) melem
  910   format(i5,' element(s) moved.')
        call aainfo('LNEMOV', 1, msg)
      else
        call aawarn('LNEMOV', 1, 'No element moved.')
      endif

 9999 end
+dk lnepos
      subroutine lnepos(lrng, lseq, iend, ipos, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find place in sequence.                                            *
* Input:                                                               *
*   LRNG(1)   (pointer) Range reference bank.                          *
*   LSEQ(1)   (pointer) Sequence directory bank.                       *
*   IEND      (integer) 0: Begin of range, 3: End of range.            *
* Output:                                                              *
*   IPOS      (integer) Bias of position.                              *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer icode,idir,iend,ileng,index,iocc,ipos,jdir
      integer           lrng(*), lseq(*)
      logical           eflag
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca message
+ca lnlink
+ca status
+ca refer

      character*(mcnam) elmnam

      icode = iq(lrng(1)+iend+1)
      index = iq(lrng(1)+iend+3)

*---- Start of sequence.
      if (icode .eq. 1) then
        ipos = 2

*---- End of sequence.
      else if (icode .eq. 2) then
        ipos = iq(lsdir+1) -1

*---- Codes #F, #L, #iii not allowed
      else if (icode .le. 5) then
        call aawarn('LNEPOS', 1,
     +              'Codes #F, #L, or #n not defined in SEQEDIT.')

*---- Named position: Find occurrence of name in sequence.
      else
        idir = iq(lrng(1)+iend+2)
        iocc = 0
        do 90 ipos = 2, iq(llnedr+1) - 1
          jdir = iq(llnedr+ipos)

*---- Try the present object itself.
          if (jdir .eq. idir) then
            iocc = iocc + 1
            if (iocc .ge. index) go to 9999

*---- Try all classes which may contain the present element.
          else if (iq(lcelm+mbpr) .eq. mpelm) then
            lccls = lq(ldbnk(3)-jdir)
   20       if (lccls .ne. 0) then
              jdir = iq(lccls+mbnam)
              if (jdir .eq. idir) then
                iocc = iocc + 1
                if (iocc .ge. index) go to 9999
              endif
              lccls = lq(lccls-iq(lccls+mbat)-mbecls)
              go to 20
            endif
          endif
   90   continue

*---- Name not found.
        call diname(ldbnk, idir, elmnam)
        call utleng(elmnam, ileng)
        if (index .eq. 0) then
          write (msg, 920) elmnam(1:ileng)
  920     format('Element "',a,'" not found in sequence.')
        else
          write (msg, 930) elmnam(1:ileng), index
  930     format('Element "',a,'[',i6,']" not found in sequence.')
        endif
        call aafail('LNEPOS', 1, msg)
        eflag = .true.
      endif

 9999 end
+dk lneref
      subroutine lneref
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Invert order of elements in sequence, REFLECT command.             *
*   Last element must be marker.                                       *
* No attributes.                                                       *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca express
+ca exstak
+ca prcgroup
+ca lnlink
+ca refer
      integer idata,idir,ielem,iexpr,irefer,ix,jdata,jelem,ndata,nelem,
     +nx1,nx2
      double precision rival

      character*(mcnam) refdic(3), refnam

      data refdic       / 'ENTRY', 'CENTRE', 'EXIT' /

*---- Retrieve data for sequence to be edited.
      llnedr = lq(llnesq-1)
      llneat = llnesq
      nelem  = iq(llnedr+1)

*---- Check that last element is marker.
      idir  = iq(llnedr+nelem)
      lcelm = lq(ldbnk(3)-idir)
      if (iq(lcelm+mbpr) .ne. mpelm  .or. iq(lcelm+mbsp) .ne. 25) then
        call aafail('LNEREF', 1,
     +    'Last element in sequence should be a marker.')

*---- Reflect by interchanging from both ends.
      else
        idata = mbat + mcsiz + 2
        ielem = 2
        ndata = mbat + mcsiz + 2 + (nelem - 2) * mwflt
        jdata = ndata - mwflt
        jelem = nelem - 1

*---- Test for termination.
  100   if (ielem .lt. jelem) then

*---- Exchange elemens at positions I and J.
          idir = iq(llnedr+ielem)
          iq(llnedr+ielem) = iq(llnedr+jelem)
          iq(llnedr+jelem) = idir

*---- Build expressions for new positions (total length - position).
          level = 0
          nxopr = 0
          call excopy(llneat, nelem, ndata)
          call excopy(llneat, ielem, idata)
          call exbin(2)
          nx1 = nxopr
          call excopy(llneat, nelem, ndata)
          call excopy(llneat, jelem, jdata)
          call exbin(2)
          nx2 = nxopr

*---- Store new positions.
          nxopr = nx1
          call exmake(llneat, jelem, jdata, rsval(1), isval(1)+1)
          nxopr = nx2 - nx1
          do 10 ix = 1, nxopr
            ixopr(ix)  = ixopr(ix+nx1)
            ixsub1(ix) = ixsub1(ix+nx1)
            ixsub2(ix) = ixsub2(ix+nx1)
            ixsub3(ix) = ixsub3(ix+nx1)
            axbank(ix) = axbank(ix+nx1)
            axattr(ix) = axattr(ix+nx1)
            rxval(ix)  = rxval(ix+nx1)
   10     continue
          call exmake(llneat, ielem, idata, rsval(2), isval(2)+1)

*---- Next pair.
          ielem = ielem + 1
          idata = idata + mwflt
          jelem = jelem - 1
          jdata = jdata - mwflt
          go to 100
        endif

*---- Handle middle element, if any.
        if (ielem .eq. jelem) then
          level = 0
          nxopr = 0
          call excopy(llneat, nelem, ndata)
          call excopy(llneat, ielem, idata)
          call exbin(2)
          rival = rsval(1)
          iexpr = isval(1)
          call exmake(llneat, ielem, idata, rival, iexpr)
        endif

*---- Change reference according to REFER.
        call utgnam(llneat, 1, 1, refnam)
        call utlook(refnam, refdic, 3, irefer)
        if (irefer .ne. 0) call utpnam(llneat, 1, 1, refdic(4-irefer))

*---- Mark as modified.
        call aamark('LNEREF', llneat)
        call aainfo('LNEREF', 1,
     +    'Sequence has been reflected, end marker stays in place.')
      endif

 9999 end
+dk lnerem
      subroutine lnerem
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Remove an element from a beam line sequence, REMOVE command.       *
* Attributes:                                                          *
*   CLASS    (name)    Name of class to be removed.                    *
*   PATTERN  (string)  Pattern for names to be removed.                *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca prcgroup
+ca message
+ca lnlink
+ca refer
+ca status
      integer ibias,idata,idir,ielem,ilen,jdata,jelem,nelem

      character*(mcnam) elmnam
      logical           found, select

*---- Retrieve bank pointers and element name
      llneat = llnesq
      llnedr = lq(llneat-1)
      llnefl = lq(llnedr-1)
      elmnam = ' '
      call utgnam(lccmd, 1, 1, elmnam)
      if (elmnam .eq. ' ') then
        call aafail('LNEREM', 1, 'Need element name or "SELECTED".')
        go to 9999

*---- "SELECTED" --> remove all selected elements
      else if (elmnam .eq. 'SELECTED') then

*---- Should have made a selection.
        if (llnefl .eq. 0) then
          call aafail('LNEREM', 1, 'You have made no selection yet.')
          error = .true.
        else
          select = .true.
        endif

*---- Element name given --> find it in directory.
      else
        select = .false.
        call utleng(elmnam, ilen)
        call difind(ldbnk, elmnam(1:ilen), idir, lcelm)
        if (idir .eq. 0  .or.  iq(lcelm+mbpr) .ne. mpelm) then
          msg(1) = 'Element "' // elmnam(1:ilen) // '" is unknown.'
          call aafail('LNEREM', 1, msg(1))
          error = .true.
        endif
      endif

*---- Retrieve data for sequence to be edited.
      if (error) go to 9999
      llneat = llnesq
      llnedr = lq(llneat-1)
      llnefl = lq(llnedr-1)
      nelem = iq(llnedr+1)
      jelem = 1
      idata = mbat + mcsiz + 2
      jdata = idata

*---- Loop over sequence to remove.
      do 90 ielem = 2, nelem
       if (select) then
          found = iq(llnefl+ielem) .ne. 0
        else
          found = iq(llnedr+ielem) .eq. idir
        endif

*---- If found, drop expression.
        if (found) then
          lcexp = lq(llneat-ielem)
          if (lcexp .ne. 0) call aadrop(lcexp)

*---- Otherwise move down.
        else
          jelem = jelem + 1
          if (jelem .lt. ielem) then
            call ucopy(q(llneat+idata), q(llneat+jdata), mwflt)
            iq(llnedr+jelem) = iq(llnedr+ielem)
            lcexp = lq(llneat-ielem)
            if (lcexp .ne. 0) then
              call zshunt(0, lcexp, llneat, -jelem, 0)
              ibias = mxsiz * iq(lcexp-3) + mxval
              iq(lcexp+ibias) = jdata
            endif
            if (llnefl .ne. 0) iq(llnefl+jelem) = iq(llnefl+ielem)
          endif
          jdata = jdata + mwflt
        endif
        idata = idata + mwflt
   90 continue
      iq(llnedr+1) = jelem

*---- Mark, if modified.
      if (jelem .lt. nelem) then
        call aamark('LNEREM', llneat)
        write (msg, 910) nelem - jelem
  910   format(i5,' element(s) removed.')
        call aainfo('LNEREM', 1, msg)
      else
        call aawarn('LNEREM', 1, 'No element removed.')
      endif

 9999 end
+dk lnerep
      subroutine lnerep
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Remove an element from a beam line sequence, REMOVE command.       *
* Attributes:                                                          *
*   CLASS    (name)    Name of class to be removed.                    *
*   PATTERN  (string)  Pattern for names to be removed.                *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca lingroup
+ca prcgroup
+ca message
+ca lnlink
+ca refer
+ca status
      integer idir,ielem,ilen,jdir,jelem,kdir,mxals,nelem

      character*(mcnam) oldnam, newnam
      logical           found,  replst, select

*---- Retrieve bank pointers and element names.
      llneat = llnesq
      llnedr = lq(llneat-1)
      llnefl = lq(llnedr-1)
      idir = 0
      oldnam = ' '
      newnam = ' '
      call utgnam(lccmd, 1, 1, oldnam)
      call utgnam(lccmd, 2, 2, newnam)
      if (oldnam .eq. ' '  .or.  newnam .eq. ' ') then
        call aafail('LNEREP', 1, 'Need "ELEMENT" and "BY".')
        error = .true.
        go to 9999
      endif

*---- "SELECTED" --> remove all selected elements
      select = .false.
      if (oldnam .eq. 'SELECTED') then

*---- Should have made a selection.
        if (llnefl .eq. 0) then
          call aafail('LNEREM', 1, 'You have made no selection yet.')
          error = .true.
        else
          select = .true.
        endif

*---- Find old name in directory.
      else
        call utleng(oldnam, ilen)
        call difind(ldbnk, oldnam(1:ilen), idir, lcelm)
        if (idir .eq. 0  .or.  iq(lcelm+mbpr) .ne. mpelm) then
          msg(1) = 'Element "' // oldnam(1:ilen) // '" is unknown.'
          call aafail('LNEREP', 1, msg(1))
          go to 9999
        endif
      endif

*---- Look up new name in directory
      replst = .false.
      call utleng(newnam, ilen)
      call difind(ldbnk, newnam(1:ilen), kdir, lcelm)
*     Not found ?
      if (kdir .eq. 0) then
        msg(1) = 'Element "' // newnam(1:ilen) // '" is unknown.'
        call aafail('LNEREP', 1, msg(1))
        error = .true.
      else
*     Replacement list ?
        if (iq(lcelm+mbpr).eq.mplin .and. iq(lcelm+mbsp).eq.3) then
          call lnxres
          llncal = lcelm
          replst = .true.
*     Should be element.
        else if (iq(lcelm+mbpr) .ne. mpelm) then
          msg(1) = 'Element "' // newnam(1:ilen) // '" is ivalid.'
          call aafail('LNEREP', 1, msg(1))
          error = .true.
        endif
      endif

*---- Retrieve data for sequence to be edited.
      if (error) go to 9999
      llneat = llnesq
      llnedr = lq(llneat-1)
      llnefl = lq(llnedr-1)
      nelem = iq(llnedr+1)
      jelem = 0

*---- Loop over sequence and replace.
      do 90 ielem = 2, nelem
        if (select) then
          found = iq(llnefl+ielem) .ne. 0
          iq(llnefl+ielem) = 0
        else
          found = iq(llnedr+ielem) .eq. idir
        endif

*---- Element must be replaced.
*     For replacement list, advance to next item
        if (found) then
          if (replst) then
            call lnxlst(1)
            kdir = iq(llncal+mlfree+mlsiz+mlref)
            lcelm = lq(ldbnk(3)-kdir)
          endif
          idir = iq(llnedr+ielem)
          jdir = iq(lq(ldbnk(3)-idir)+mbnam)

*---- Element is the class object (X, AT=...)$
*     Change reference to use Y.
          if (jdir .eq. idir) then
            iq(llnedr+ielem) = kdir

*---- Element is alias (X1: X, AT=...):
*     Change alias X1 to point to Y and mark Y as an alias.
          else
            lq(ldbnk(3)-idir) = lcelm
            call sbit1(iq(lcelm), mxals)
          endif
          jelem = jelem + 1
        endif
   90 continue

*---- Mark, if modified.
      if (jelem .gt. 0) then
        call aamark('LNEREP', llneat)
        write (msg, 910) jelem
  910   format(i5,' element(s) replaced.')
        call aainfo('LNEREP', 1, msg)
      else
        call aawarn('LNEREP', 1, 'No element replaced.')
      endif

 9999 end
+dk lnesel
      subroutine lnesel
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   SELECT command, set dump flags for sequence editor.                *
* Attributes, must be given in this order in the dictionary:           *
*   FLAG      (name)    Must be "SEQEDIT" when we come here.           *
*   RANGE     (range)   Range to limit selections.                     *
*   CLASS     (name)    Class of elements to be affected in RANGE.     *
*   PATTERN   (string)  Regular expression to limit choice.            *
*   FULL      (logical) If true, all dump flags are set.               *
*   CLEAR     (logical) If true, all dump flags are cleared first.     *
* (*) Dimensions may be changed in the command dictionary.             *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca message
+ca lnlink
+ca refer
+ca status
+ca datatype
      integer idir,ipos,ipos1,ipos2,j,l,mclass,mclear,mfull,mpatt,
     +mrange,ncount,nd

      integer           itype(6)
      logical           flag(2), found
      character*(mcnam) class, label
      character*(mcstr) patt

*---- Note that attribute "FLAG" has already been used.
      parameter         (mrange = 2, mclass = 3, mpatt  = 4)
      parameter         (mfull  = 5, mclear = 6)

*---- Get bank pointers.
      llneat = llnesq
      llnedr = lq(llneat-1)
      llnefl = lq(llnedr-1)
      if (llnefl .eq. 0) then
        nd = iq(llnedr-1)
        call mzbook(2, llnefl, llnedr, -1, 'SFLG', 0, 0, nd, 2, 0)
      endif

*---- Fetch logical flags.
      call utgtyp(lccmd, itype)
      flag(1) = .false.
      flag(2) = .false.
      call utglog(lccmd, mfull, mclear, flag)
      ipos1 = 2
      ipos2 = iq(llnedr+1) - 1

*---- FULL option sets select flags for full map.
      if (flag(1)) then
        do 10 ipos = ipos1, ipos2
          iq(llnefl+ipos) = 1
   10   continue

*---- CLEAR option: clears select flags for full map.
      else if (flag(2)) then
        call mzdrop(0, llnefl, ' ')
        do 20 j = mrange, mpatt
          if (itype(j) .ne. 0) then
            call aawarn('LNESEL', 1,
     +        'No selection can be made with "CLEAR" option.')
            return
          endif
   20   continue

*---- Now set select flags according to RANGE, CLASS and PATTERN.
      else
        class = ' '
        patt  = ' '
        call utgnam(lccmd, mclass, mclass, class)
        call utgstr(lccmd, mpatt,  mpatt,  patt)
        lcatt = lq(lccmd-mrange)

*---- Determine range to be considered.
        if (lcatt .ne. 0) then
          call lnepos(lcatt, llnedr, 0, ipos1, error)
          call lnepos(lcatt, llnedr, 3, ipos2, error)
          if (.not. error  .and.  ipos1 .gt. ipos2) then
            call aafail('UTGRNG', 1,
     +                  'Begin and end of range inverted.')
            error = .true.
          endif
        endif
        if (error) go to 9999

*---- Find class name.
        if (class .eq. ' ') then
          lccls = 0
        else
          call difind(ldbnk, class, idir, lccls)
          if (lccls .eq. 0) then
            call utleng(class, l)
            msg(1) = 'Unknown class name "' // class(1:l) // '".'
            call aafail('ENSRNG', 1, msg)
            error = .true.
          endif
        endif

*---- Build pattern.
        if (patt .eq. ' '  .or.  patt .eq. '.*') then
          lref1 = 0
        else
          call utpatt(patt, lref1)
        endif

*---- Loop for positions.
        if (error) go to 9999
        ncount = 0
        do 90 ipos = ipos1, ipos2
          idir = iq(llnedr+ipos)
          lcelm = lq(ldbnk(3)-idir)

*---- If CLASS != ' ', test for class membership.
          if (lccls .ne. 0) then
            found = .false.
            lref2 = lcelm
   30       if (lref2 .ne. 0  .and. .not. found) then
              if (lref2 .eq. lccls) then
                found = .true.
              endif
              if (iq(lref2+mbpr) .ne. mplin) then
                lref2 = lq(lref2-iq(lref2+mbat)-mbecls)
                go to 30
              endif
            endif

*---- Default for CLASS = ' ' is all classes.
          else
            found = .true.
          endif

*---- Test for pattern match (skip, if not found as a class member).
          if (found  .and.  lref1 .ne. 0) then
            call diname(ldbnk, idir, label)
            call utmtpt(lref1, label, found)
          endif

*---- If tests succeeded, perform action.
          if (found) then
            iq(llnefl+ipos) = 1
            ncount = ncount + 1
          endif
   90   continue

*---- Drop pattern.
        if (lref1 .ne. 0) call mzdrop(0, lref1, 'L')

*---- Test for empty range.
        if (.not. error  .and.  ncount .eq. 0) then
          call aawarn('ENSRNG', 1,
     +    'No elements found in range which fulfill the conditions.')
        else
          write(msg, 910) ncount
  910     format('You have selected ',i6,' elements in this range.')
          call aainfo('ENSRNG', 1, msg)
        endif
      endif

 9999 end
+dk lnform
      subroutine lnform(lline, label, lact, iahed)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Fill in actual arguments for a beam line.                          *
* Input:                                                               *
*   LLINE(1)  (pointer) Beam line bank.                                *
*   LABEL     (char)    Name of called beam line.                      *
*   LACT(1)   (pointer) Bank containing actual arguments.              *
*   IAHED     (integer) Header of actual argument list.                *
*----------------------------------------------------------------------*
+ca aparam
      integer iact,iahed,icell,iform1,iform2,ileng,jform
      integer           lline(*), lact(*)
      character*(mcnam) label
+ca memdum
+ca bankhead
+ca lingroup
+ca message

*---- Formal argument list.
      iform1 = iq(lline(1)+mlf1)
      iform2 = iq(lline(1)+mlf2)
      if (iform1 .eq. 0  .and.  lact(1) .eq. 0) go to 9999

*---- Redundant actual argument list.
      call utleng(label, ileng)
      msg(1)(33:80) = 'entering "' // label(1:ileng) // '".'
      if (iform1 .eq. 0) then
        msg(1)(1:32) = 'Redundant actual argument list,'
        call aafail('LNFORM', 1, msg)

*---- Missing actual argument list.
      else if (lact(1) .eq. 0) then
        msg(1)(1:32) = 'Missing actual argument list,'
        call aafail('LNFORM', 1, msg)

*---- Header of actual argument list.
      else
        iact = iahed

*---- Loop for formals.
        do 90 jform = iform1, iform2, 2*mlsiz
          icell = jform + mlsiz
          iact = iq(lact(1)+iact+mlnxt)

*---- Header of actual argument list reached before formal list ends.
          if (iq(lact(1)+iact+mltyp) .eq. 1) then
            msg(1)(1:32) = 'Too few actual arguments seen,'
            call aafail('LNFORM', 1, msg)
            go to 9999

*---- Copy actual argument to formal argument.
*     If a sublist replaces a formal argument, mark its header.
          else if (iq(lact(1)+iact+mltyp) .eq. 4) then
            iq(lline(1)+icell+mltyp) = 5
            iq(lact(1)+iq(lact(1)+iact+mlref)+mltyp) = 3
          else
            iq(lline(1)+icell+mltyp) = iq(lact(1)+iact+mltyp)
          endif
          iq(lline(1)+icell+mlrep) = iq(lact(1)+iact+mlrep)
          iq(lline(1)+icell+mlref) = iq(lact(1)+iact+mlref)
          iq(lline(1)+icell+mlact) = iq(lact(1)+iact+mlact)
   90   continue

*---- Header of actual argument list not reached at end of formal list.
        iact = iq(lact(1)+iact+mlnxt)
        if (iq(lact(1)+iact+mltyp) .eq. 1) go to 9999
        msg(1)(1:32) = 'Too many actual arguments seen,'
        call aafail('LNFORM', 1, msg)
      endif

 9999 end
+dk lninit
      subroutine lninit
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initialize line handler.                                           *
*----------------------------------------------------------------------*
+ca aparam
+ca lnlink
      integer ilnflg

      data ilnflg       / 0 /

      if (ilnflg .eq. 0) then
        call mzlink(0, '/LNLINK/', llnbnk, llnbnk, llnefl)
        ilnflg = 1
      endif

      end
+dk lnlist
      subroutine lnlist(label)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode replacement list definition.                                *
* Input:                                                               *
*   LABEL    (char)     Label for new definition (required).           *
*----------------------------------------------------------------------*
+ca aparam
      integer icell,ifree
      character*(mcnam) label
+ca memdum
+ca bankhead
+ca lingroup
+ca refer
+ca status
+ca stbuff

*---- Build LIST bank and link it to LIST keyword.
      call lnmake(lccmd, lckey)

*---- Build dummy list for replacement (looks like main list).
      ifree = mlfree
      icell = ifree + mlsiz
      iq(lccmd+ifree+mltyp) = 1
      iq(lccmd+ifree+mlprv) = icell
      iq(lccmd+ifree+mlnxt) = icell
      iq(lccmd+icell+mlprv) = ifree
      iq(lccmd+icell+mlnxt) = ifree
      iq(lccmd+mlhd) = icell + mlsiz

*---- Skip separator.
      if (token(jtok) .eq. ','  .or.  token(jtok) .eq. '=') then
        jtok = jtok + 1
      endif

*---- Decode replacement list.
      call dclist(lccmd, error)

*---- If error detected, drop list bank.
      if (error) then
        call aadrop(lccmd)

*---- If all OK, link list bank to directory.
      else
        call didefi(ldbnk, label, lccmd)
      endif

      end
+dk lnmain
      subroutine lnmain(label, if1, if2)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode beam line definitions.                                      *
* Input:                                                               *
*   LABEL    (char)     Label for new definition (required).           *
*   IF1      (integer)  First character of formals list (optional).    *
*   IF2      (integer)  Last character of formals list.                *
*----------------------------------------------------------------------*
+ca aparam
      integer if1,if2,iln,ipr,isp,nkat
      character*(mcnam) label
+ca memdum
+ca bankhead
+ca message
+ca lnlink
+ca option
+ca refer
+ca status

      ipr = iq(lckey+mbpr)
      isp = iq(lckey+mbsp)

*==== Line and sequence definition commands.
      if (isp .le. 10) then

*---- ISP = 1, Beam line definition.
        if (isp .eq. 1) then
          call lnbeam(label, if1, if2)

*---- ISP = 2, Sequence definition.
        else if (isp .eq. 2) then
          call lnseq(label)

*---- ISP = 3, Replacement list definition.
        else if (isp .eq. 3) then
          call lnlist(label)

*---- Other.
        else
          call userdf(ipr, isp)
        endif

*---- LINE dump option.
        if (.not. error) then
          if (ilinfl .eq. 1  .or.  ilinfl .eq. 3) then
           call lndump(lccmd, label)
          endif
          if (ilinfl .eq. 2  .or.  ilinfl .eq. 3) then
            call dzshow('line', 0, lccmd, 'V', 0, 0, 0, 0)
          endif
        endif

*==== Sequence editor commands; skip in scanning mode
      else if (.not. scan) then

*---- Copy keyword to local storage.
        call kwget(lckey, iln, ipr, isp, nkat)

*---- Build new command bank (no defaults).
        call aabook(lccmd, label, ipr, isp, lckey, 1)

*---- Decode attributes.
        if (isp .eq. 12) nkat = - nkat
        call aaattr(lq(lckey-2), lccmd, nkat, error)
        if (error) go to 9999

*---- Fill in variable references.
        call exfill
        if (.not. error) then

*---- Order and evaluate expressions.
          call exordr
          if (.not. error) then
            call exupdt
          endif
        endif

*---- ISP = 11, SEQEDIT.
        if (isp .eq. 11) then
          if (imodul .ne. 0) then
            msg(1) = 'Cannot initiate sequence editor while previous '
     +               // 'process is not complete,'
            msg(2) = 'Enter proper ENDxxxx command first.'
            call aafail('LNMAIN', 2, msg)
          else
            call lnebgn
            if (.not. error) imodul = ipr
          endif

*---- Check valid use of sequence editor subcommand.
        else if (imodul .ne. ipr) then
          msg(1) =
     +    'Cannot run editor subcommand outside sequence editor,'
          msg(2) = 'SEQEDIT command required first.'
          call aafail('LNEDIT', 2, msg)

*---- ISP = 12, INSTALL.
        else if (isp .eq. 12) then
          call lneins

*---- ISP = 13, MOVE.
        else if (isp .eq. 13) then
          call lnemov

*---- ISP = 14, REMOVE.
        else if (isp .eq. 14) then
          call lnerem

*---- ISP = 15, CYCLE.
        else if (isp .eq. 15) then
          call lnecyc

*---- ISP = 16, REFLECT.
        else if (isp .eq. 16) then
          call lneref

*---- ISP = 17, ENDEDIT.
        else if (isp .eq. 17) then

*---- Drop selection bank.
          llnefl = lq(lq(llnesq-1)-1)
          if (llnefl .ne. 0) call mzdrop(0, llnefl, ' ')
          llnesq = 0
          imodul = 0

*---- LINE dump option.
          if (.not. error) then
            if (ilinfl .eq. 1  .or.  ilinfl .eq. 3) then
             call lndump(lccmd, label)
            endif
            if (ilinfl .eq. 2  .or.  ilinfl .eq. 3) then
              call dzshow('seqedit', 0, lccmd, 'V', 0, 0, 0, 0)
            endif
          endif

*---- ISP = 18, REPLACE.
        else if (isp .eq. 18) then
          call lnerep

*---- Other.
        else
          call userdf(ipr, isp)
        endif
      endif

 9999 end
+dk lnmake
      subroutine lnmake(lline, lkey)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Build beam line or list bank.                                      *
*   Uses the pointers to current keyword and current command.          *
* Input:                                                               *
*   LKEY(1)  (pointer)  Keyword pointer.                               *
* Output:                                                              *
*   LLINE(1) (pointer)  Generated beam line list bank.                 *
*----------------------------------------------------------------------*
+ca aparam
      integer mli
      integer           lline(*), lkey(*)
+ca memdum
+ca bankhead
+ca lingroup
+ca markbits
+ca option
+ca stbuff
+ca zunit

      parameter         (mli = mlfree + 100 * mlsiz)

*---- Lift bank, link it to keyword, and mark it as modified.
      call mzbook(2, lline, lkey, -1, 'BLST', 3, 1, mli, 7, 0)
      call aamark('LNMAKE', lline)

*---- Store bank description.
      iq(lline(1)+mbfrm) = 16 * 5 + 2
      iq(lline(1)+mbnam) = 0
      iq(lline(1)+mbln) = lintok
      iq(lline(1)+mbpr) = iq(lkey(1)+mbpr)
      iq(lline(1)+mbsp) = iq(lkey(1)+mbsp)
      iq(lline(1)+mbat) = iq(lkey(1)+mbat)

*---- Rest of bank is integer.
      iq(lline(1)+mlfm) = 16 * 0 + 2
      iq(lline(1)+mlhd) = mlfree

      end
+dk lnmark
      subroutine lnmark(subr)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Mark maps for main beam line as obsolete.                          *
* Input:                                                               *
*   SUBR     (char*6)   Name of calling subroutine.                    *
*----------------------------------------------------------------------*
+ca aparam
      character*(6)     subr
+ca option
+ca status
+ca zunit

      if (.not. newmap) then
        newmap = .true.
        if (debug) then
          call aainfo(subr, 1,
     +    'Precomputed maps for main beam line marked as obsolete.')
        endif
      endif

      end
+dk lnpmod
      subroutine lnpmod(lmark)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Propagate modification flags for lumps.                            *
* Input:                                                               *
*   LLUMP(1) (pointer)  Pointer to lump to be marked.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer icall,idir,ielem,jbit,laacur,nelem
      integer           lmark(1)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca lingroup
+ca markbits
+ca prcgroup
+ca message
+ca lnlink
+ca option
+ca refer

      character*(mcnam) bnknam
      logical           fmark

*---- Initialize.
      icall = 1
      fmark = .false.
      laacur = lmark(1)
      llump = 0

*---- Begin procedure to mark lumps.
  100 continue
        call mzbook(2, llump, llump, 1, 'LSTK', 1, 0, 2, 2, 0)
        lq(llump-1) = laacur
        iq(llump+1) = icall

*---- Skip, if already marked.
        if (jbit(iq(laacur),mxknw) .eq. 0) go to 110
          fmark = jbit(iq(laacur),mxmod) .ne. 0
          go to 300

*---- Element: test modify flag.
  110   if (iq(laacur+mbpr) .ne. mpelm) go to 150
          if (iq(laacur+mbsp) .eq. 23) go to 120
            fmark = jbit(iq(laacur),mxmod) .ne. 0
            go to 300

*---- LUMP: Check list for members.
  120     continue
            call sbit1(iq(laacur), mxknw)
            laacur = lq(ldbnk(3)-iq(laacur+mbat+3*mcsiz+mcval))
            icall = 2
            if (laacur .ne. 0) go to 100

*---- Check list for actual arguments.
  130       laacur = lq(lq(llump-1)-4)
            icall = 3
            if (laacur .ne. 0) go to 100
          go to 250

*---- LINE, LIST, or SEQUENCE: Check members.
  150   if (iq(laacur+mbpr) .ne. mplin) go to 300

*---- LINE or LIST
          if (iq(laacur+mbsp) .eq. 2) go to 200
          call sbit1(iq(laacur), mxknw)
          iq(llump+2) = iq(laacur+mlhd)
  160     if (iq(llump+2) .ge. iq(laacur-1)) go to 250
            if (iq(laacur+iq(llump+2)+mltyp) .lt. 6) go to 180
              laacur = lq(ldbnk(3)-iq(laacur+iq(llump+2)+mlref))
              icall = 4
              if (laacur .ne. 0) go to 100
  180       laacur = lq(llump-1)
            iq(llump+2) = iq(llump+2) + mlsiz
          go to 160

*---- SEQUENCE.
  200     call sbit1(iq(laacur), mxknw)
          llnedr = lq(laacur-1)
          nelem = iq(llnedr+1)
          ielem = 2
  210     if (ielem .gt. nelem) go to 250
            idir = iq(llnedr+ielem)
            laacur = lq(ldbnk(3)-idir)
            icall = 5
            if (laacur .ne. 0) go to 100
  220       ielem = ielem + 1
          go to 210

*---- Mark LUMP, LINE, LIST, or SEQUENCE as up to date.
  250     laacur = lq(llump-1)
          if (debug) then
            call diname(ldbnk, iq(laacur+mbnam), bnknam)
            msg(1) = 'Marking bank as up  to date: ' // bnknam
            call aainfo('LNPMOD', 1, msg)
          endif

*---- End of marking procedure.
  300   laacur = lq(llump-1)
        icall = iq(llump+1)
        call mzdrop(0, llump, '.')
        if (fmark) then
          call sbit1(iq(laacur), mxknw)
          call aamark('LNPMOD', laacur)
          if (llump .ne. 0) go to 300
        endif
      go to (9999, 130, 250, 180, 220), icall

 9999 end
+dk lnrefe
      subroutine lnrefe(lbank, ibias, lseq, lsup, isup)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Expand a beam line reference and return beam sequence bank.        *
*   Input is a normal data reference.                                  *
* Input:                                                               *
*   LBANK(1)  (pointer) Pointer to data bank containg reference.       *
*   IBIAS     (integer) Number of data group.                          *
*   LSUP(1)   (pointer) Supporting link (like for MZBOOK).             *
*   ISUP      (integer) Bias (like for MZBOOK).                        *
* Input/output:                                                        *
*   LSEQ(1)   (pointer) Generated sequence bank.                       *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,idata,idir,ienum,ileng,ipos,isup,itype,jbyt,nd
      integer           lbank(*), lseq(*), lsup(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca seqflag
+ca seqgroup
+ca message
+ca lnlink
+ca refer
+ca status
+ca datatype

      character*(mcnam) elmnam
      character*(mcrng) rngnam

*---- Book beam line sequence bank.
      llnbnk = lbank(1)
      llnsup = lsup(1)
      call mzbook(2, llnrsq, llnsup, isup, 'SEQ ', msref, mslnk,
     +            mss, 7, 0)

*---- Type of beam line reference.
      idata = mbat + mcsiz * (ibias - 1)
      itype = iq(llnbnk+idata+mctyp)
      idir = iq(llnbnk+idata+mcval)
      if (idir .eq. 0  .or.  itype/10 .ne. mtlin) then
        call rdfail('LNREFE', 1, 'Invalid line reference.')
      else
        call diname(ldbnk, idir, elmnam)
        call utleng(elmnam, ileng)
        llnrls = lq(ldbnk(3)-idir)
        msg(1) = 'Attempt to expand "' // elmnam(1:ileng)
     +  // '" --- not a beam line.'
        if (llnrls .eq. 0) then
          call rdfail('LNREFE', 1, msg)
        else if (iq(llnrls+mbpr) .ne. mplin  .or.
     +           iq(llnrls+mbsp) .eq. 3) then
          call rdfail('LNREFE', 1, msg)
        else if (itype .eq. 10*mtlin+1) then
          call lnxpnd(idir, 0, llnrsq)
        else if (itype .eq. 10*mtlin+2) then
          call lnxpnd(idir, lq(llnbnk-ibias), llnrsq)
        else if (itype .eq. 10*mtlin+3) then
          call lnxpnd(idir, 0, llnrsq)
        else
          call rdfail('LNREFE', 1, 'Invalid line reference.')
        endif
      endif

*---- In case of error, drop beam line sequence bank.
      if (error) then
        call lndrop(llnrsq)

*---- Default is full range, SYMM = .FALSE., SUPER = 1.
      else
        nd = iq(lq(llnrsq-msdir)-1)
        iq(llnrsq+msf1) = 16 * 4 + 2
        iq(llnrsq+msr1) = 1
        iq(llnrsq+msr2) = nd
        iq(llnrsq+msym) = 0
        iq(llnrsq+msup) = 1
        iq(llnrsq+msf2) = 16 * (mss - msbn) + 5
        rngnam = '#S/#E'
        call uctoh(elmnam, iq(llnrsq+msbn), mcwrd, mcnam)
        call uctoh(rngnam, iq(llnrsq+msrn), mcwrd, 40)

*---- Build element number bank.
        call mzbook(2, lsnum, llnrsq, -msnum, 'ENUM', 0, 0, nd, 2, 0)
        ienum = 0
        lsflg = lq(llnrsq-msflg)
        do 10 ipos = 1, nd
          if (jbyt(iq(lsflg+ipos),1,mcode) .eq. 1) ienum = ienum + 1
          iq(lsnum+ipos) = ienum
   10   continue
      endif
      lseq(1) = llnrsq

      end
+dk lnseq
      subroutine lnseq(label)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode a beam line sequence.                                       *
*   Magnets and their central positions are given as subcommands,      *
*   the drift spaces in between are generated by this routine.         *
* Input:                                                               *
*   LABEL     (char)    Name for generated sequence.                   *
*----------------------------------------------------------------------*
+ca aparam
      integer icat,idata,idir,ieval,iexpr,iln,ipr,isp,leng,mdi,mpi,ncat,
     +nelem,nkat
      double precision pos
      character*(mcnam) label
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca markbits
+ca prcgroup
+ca message
+ca lnlink
+ca option
+ca stbuff
+ca refer
+ca status

      character*(mcnam) atrnam, clsnam, elmnam, endseq
      logical           copy, eflag
+if doom
      logical force_copy
+ei
      parameter         (mdi = 500, mpi = mwflt * mdi)

      data endseq       / 'ENDSEQUENCE' /

*---- Lift bank, link it to keyword, and mark it as modified.
      call kwget(lckey, iln, ipr, isp, nkat)
      call aabook(llneat, label, ipr, isp, lckey, 1)

*---- Decode REFER attribute.
      if (token(jtok) .ne. ';') then
        call aaattr(lq(lckey-2), llneat, nkat, error)
        if (error) then
          call lndrop(llneat)
          go to 9999
        endif
      endif

*---- Push command bank to make room for MDI element positions.
      call mzpush(0, llneat, mdi, mpi + 1, 'I')
      iq(llneat+mbat+mcsiz+1) = 16 * mpi + mreal
      idata = mbat + mcsiz + 2

*---- Book bank for directory index table.
*     Link 1 is reserved for sequence flag bank.
      call mzbook(2, llnedr, llneat, -1, 'SDIR', 1, 1, mdi + 1, 2, 0)
      nelem = 1

*==== Read and decode next subcommand of sequence.
  100 continue
        call rdstat(eflag)
        if (eflag .or. token(1) .eq. ';') go to 100

*---- Decode element name.
        call rdword(elmnam, leng)
        if (leng .eq. 0) then
          call rdfail('LNSEQ', 1, 'Expected element name here.')
          go to 100
        endif

*---- If a colon is seen, decode class name.
        if (token(jtok) .eq. ':') then
          jtok = jtok + 1
          call rdword(clsnam, leng)
          if (leng .eq. 0) then
            call rdfail('LNSEQ', 1, 'Expected class name here.')
            go to 100
          endif

*---- Test for end of sequence.
        else if (token(jtok).eq.';' .and. elmnam.eq.endseq(1:leng)) then
          go to 200

*---- Otherwise element and class name are the same.
        else
          clsnam = elmnam
        endif

*---- Comma expected.
        if (token(jtok) .ne. ',') then
          call rdfail('LNSEQ', 1, 'Expected "," here.')
          go to 100
        endif
        jtok = jtok + 1

*---- Decode "AT" attribute.
        call rdword(atrnam, leng)
        if (atrnam .ne. 'AT') then
          call rdfail('LNSEQ', 1, 'Expected "AT" attribute here.')
          go to 100
        endif

*---- Equals sign expected.
        if (token(jtok) .ne. '=') then
          call rdfail('LNSEQ', 1, 'Expected "=" here.')
          go to 100
        endif
        jtok = jtok + 1

*---- Read position value, may be expression.
        ieval = 2
        call exread(ieval, pos, iexpr)
        if (eflag) go to 100
        nelem = nelem + 1
        if (nelem .gt. iq(llnedr-1)) then
          call mzpush(0, llnedr, 0,   mdi, 'I')
          call mzpush(0, llneat, mdi, mpi, 'I')
        endif
        call exmake(llneat, nelem, idata, pos, iexpr)
        idata = idata + mwflt

*---- Look up class name.
        call utleng(clsnam, leng)
        call difind(ldbnk, clsnam(1:leng), idir, lccls)
        if (lccls .eq. 0) then
          msg(1) = 'Unknown class name "' // clsnam(1:leng) // '".'
          call rdfail('LNSEQ', 1, msg)
          go to 100
        endif

*---- Must be beam element.
        if (iq(lccls+mbpr) .ne. mpelm) then
          msg(1) = 'Name "' // label(1:leng) // '" is not a class.'
          call rdfail('LNSEQ', 1, msg)
          go to 100
        endif

*---- Set flag for allowable copy - force copy if class = el. type
+if doom
        force_copy = elmnam .ne. clsnam
     +               .and. lccls .eq. lq(ldbnk(3)-idir)
+ei
        lcelm = lccls
        if (elmnam .ne. clsnam) then
          call direfe(ldbnk, elmnam, idir)
          if (lq(ldbnk(3)-idir) .ne. 0) then
            copy = .false.
          else
            lq(ldbnk(3)-idir) = lccls
            copy = .true.
          endif
        else
          copy = .false.
        endif

*---- Test for additional attributes.
        if (token(jtok) .eq. ',') then

*---- Attributes are allowed.
          if (copy) then

*---- Build new element.
            lckey = lq(lccls+1)
            call kwget(lckey, iln, ipr, isp, nkat)
            call aabook(lcelm, elmnam, ipr, isp, lckey, 1)

*---- Copy default attributes from class.
            ncat = iq(lccls+mbat)
            do 110 icat = 1, ncat
              call aacopy(lccls, icat, lcelm)
  110       continue

*---- Link to class name.
            call sbit1(iq(lccls), mxcls)
            lq(lcelm-ncat-mbecls) = lccls

*---- Decode additional attributes.
            lcdef = lq(lckey-2)
            call aaattr(lcdef, lcelm, nkat, eflag)
            if (eflag) then
              call aadrop(lcelm)
              go to 100
            endif

*---- DEFINE dump option.
            lq(ldbnk(3)-idir) = lcelm
            iq(lcelm+mbnam) = idir
            if (ideffl .eq. 1  .or.  ideffl .eq. 3) then
              call aadump(lcelm)
            endif
            if (ideffl .eq. 2  .or.  ideffl .eq. 3) then
              call dzshow('element', 0, lcelm, 'V', 0, 0, 0, 0)
            endif

*---- Duplicate name, change of attributes is not allowed.
          else
            call utleng(elmnam, leng)
            msg(1) = 'Name "' // elmnam(1:leng) // '" is not unique.'
            call rdfail('LNSEQ', 1, msg)
            go to 100
          endif
+if doom
        elseif (force_copy) then

*---- Build new element.
          lckey = lq(lccls+1)
          call kwget(lckey, iln, ipr, isp, nkat)
          call aabook(lcelm, elmnam, ipr, isp, lckey, 1)

*---- Copy default attributes from class.
          ncat = iq(lccls+mbat)
          do icat = 1, ncat
            call aacopy(lccls, icat, lcelm)
          enddo

*---- Link to class name.
          call sbit1(iq(lccls), mxcls)
          lq(lcelm-ncat-mbecls) = lccls

*---- Decode additional attributes.
          lcdef = lq(lckey-2)
          call aaattr(lcdef, lcelm, nkat, eflag)
          if (eflag) then
            call aadrop(lcelm)
            go to 100
          endif

*---- DEFINE dump option.
          lq(ldbnk(3)-idir) = lcelm
          iq(lcelm+mbnam) = idir
          if (ideffl .eq. 1  .or.  ideffl .eq. 3) then
            call aadump(lcelm)
          endif
          if (ideffl .eq. 2  .or.  ideffl .eq. 3) then
            call dzshow('element', 0, lcelm, 'V', 0, 0, 0, 0)
          endif
+ei
*---- Mark source bank as a synonym.
        else
          call sbit1(iq(lccls), mxals)
        endif

*---- Store directory index.
        iq(llnedr+nelem) = idir
      go to 100

*---- End of sequence.
  200 continue

*---- If all OK, define this sequence.
*     Do not drop excessive space; may be used in sequence editor.
      if (error) then
        call lndrop(llneat)
      else
        iq(llnedr+1) = nelem
        call didefi(ldbnk, label, llneat)

*---- DEFINE dump option.
        if (ideffl .eq. 1  .or.  ideffl .eq. 3) then
          call aadump(llneat)
        endif
        if (ideffl .eq. 2  .or.  ideffl .eq. 3) then
          call dzshow('sequence', 0, llneat, 'V', 0, 0, 0, 0)
        endif
      endif

 9999 end
+dk lnxlst
      subroutine lnxlst(idir)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Advance LIST "LLNCAL" to next member.                              *
* Input:                                                               *
*   IDIR      (integer) Code for direction of travel.                  *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca lingroup
+ca lnlink
      integer icur,idir,inext

*---- Is repeat count for current member exhausted?
      icur = iq(llncal+mlf1)
      iq(llncal+mlf2) = iq(llncal+mlf2) - 1
      if (iq(llncal+mlf2) .le. 0) then
        icur = iq(llncal+icur+mlnxt)

*---- If list header, test repeat count of list.
  100   if (iq(llncal+icur+mltyp) .le. 3) then
          if (iq(llncal+icur+mltyp) .ne. 1) then
            iq(llncal+icur+mlrep) = iq(llncal+icur+mlrep) - 1
            if (iq(llncal+icur+mlrep) .le. 0) then
              icur = iq(llncal+icur+mlref)
            endif
          endif
          icur = iq(llncal+icur+mlnxt)
          go to 100

*---- If call to sublist, move down one level.
        else if (iq(llncal+icur+mltyp) .le. 5) then
          inext = iq(llncal+icur+mlref)
          iq(llncal+inext+mlrep) = abs(iq(llncal+icur+mlrep))
          iq(llncal+inext+mlref) = icur
          icur = iq(llncal+inext+mlnxt)
          go to 100
        endif

*---- Otherwise store current member and repeat count.
        iq(llncal+mlf1) = icur
        iq(llncal+mlf2) = abs(iq(llncal+icur+mlrep))
      endif

*---- Fill in dummy line from list item.
      inext = mlfree + mlsiz
      iq(llncal+inext+mltyp) = iq(llncal+icur+mltyp)
      iq(llncal+inext+mlrep) = idir
      iq(llncal+inext+mlref) = iq(llncal+icur+mlref)
      iq(llncal+inext+mlact) = iq(llncal+icur+mlact)

      end
+dk lnxpnd
      subroutine lnxpnd(ibeam, lact, lseq)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Expand a beam line and build a beam sequence bank.                 *
*   Input is a beam line list and an actual argument list.             *
*   Directory index bank and flag bank is added to sequence.           *
* Input:                                                               *
*   IBEAM     (integer) Directory index for beam line to be expanded.  *
*   LACT(1)   (pointer) Bank containing actual arguments.              *
*   LSEQ(1)   (pointer) Beam line sequence bank.                       *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iact,ibeam,ibnk,icel,idir,idirep,ihed,ileng,ilst,irep,
     +iseq,itype,msi,nerror,nrefl,nseq
      integer           lact(*), lseq(*)
+ca memdum
+ca bankhead
+ca lingroup
+ca prcgroup
+ca seqflag
+ca seqgroup
+ca message
+ca lnlink
+ca refer

      character*(mcnam) label
      parameter         (msi = 500)

*---- Set up necessary links.
      llnhed = lq(ldbnk(3)-ibeam)
      llnxsq = lseq(1)
      llnact = lact(1)
      nrefl  = 0
      nerror = 0

*---- LIST is invalid for expansion.
      if (iq(llnhed+mbsp) .eq. 3) then
        call utleng(label, ileng)
        msg(1) = 'LIST "' // label(1:ileng) // '" cannot be expanded.'
        call aafail('LNXPND', 1, msg)
        nerror = 1

*---- Reset "LIST" commands to their first members.
      else
        call lnxres

*---- Lift banks for beam sequence.
        call mzbook(2, lsdir, llnxsq, -msdir, 'SDIR', 0, 0, msi, 2, 0)
        call mzbook(2, lsflg, llnxsq, -msflg, 'SFLG', 0, 0, msi, 2, 0)
        nseq = msi
        iseq = 0

*---- Clear occurrence counts.
        call utclrc

*==== Expand a LINE.
        if (iq(llnhed+mbsp) .eq. 1) then

*---- Call procedure "EXPAND_LINE".
          ihed = iq(llnhed+mlhd)
          idir = 0
          irep = 0
          icel = 0
          ilst = ibeam
          lq(llnhed-2) = llnact
          idirep = 1

*==== Procedure "EXPAND_LINE(ILST, IDIREP)".
*---- Replace formal arguments, if any.
          call diname(ldbnk, ibeam, label)
          if (iq(llnhed+mbsp) .eq. 1) then
            if (iq(llnhed+mlf1) .ne. 0  .or.  llnact .ne. 0) then
              iact = iq(llnact+mlhd)
              call lnform(llnhed, label, llnact, iact)
            endif
          endif

*---- Stack information to resume an outer line.
  100     continue
          iq(llnhed+ihed+mlrep) = idir * irep
          iq(llnhed+ihed+mlref) = icel
          iq(llnhed+ihed+mlact) = ilst

*---- Set up for tracking through this line.
          idir = sign(1,idirep)
          irep = abs(idirep)
          icel = ihed

*---- If named line, store entry position.
  110     if (iq(llnhed+icel+mltyp) .eq. 1) then
            call lnxput(2, ilst, iseq, nseq)
          endif

*---- Next line member.
  120     if (idir .lt. 0) icel = iq(llnhed+icel+mlprv)
          if (idir .gt. 0) icel = iq(llnhed+icel+mlnxt)
          itype = iq(llnhed+icel+mltyp)
          go to (500, 510, 510, 200, 300, 400, 400), itype

*---- Sublist or formal argument reference:
*     Sublist resides in current bank.
  200     continue
          idirep = iq(llnhed+icel+mlrep) * idir
          if (idirep .eq. 0) go to 120
          ihed = iq(llnhed+icel+mlref)
          go to 100

*---- Sublist replacing formal argument:
*     Sublist resides in calling bank.
  300     continue
          idirep = iq(llnhed+icel+mlrep) * idir
          if (idirep .eq. 0) go to 120
          llncal = lq(llnhed-2)
          lq(llncal-3) = llnhed
          ihed = iq(llnhed+icel+mlref)
          ilst = ibnk
          llnhed = llncal
          go to 100

*---- Enter element, named line or list.
*     <element> | <line> | <line>(<args>) | <list> | <sequence>.
  400     continue
          idirep = iq(llnhed+icel+mlrep) * idir
          if (idirep .eq. 0) go to 120
          ibnk = iq(llnhed+icel+mlref)
          iact = iq(llnhed+icel+mlact)
          llncal = lq(ldbnk(3)-ibnk)
          call diname(ldbnk, ibnk, label)
          call utleng(label, ileng)

*---- Undefined item.
          if (llncal .eq. 0) then
            msg(1) = 'Undefined name "' // label(1:ileng)
     +      // '" encountered in beam line.'
            call aafail('LNXPND', 1, msg)
            nerror = nerror + 1

*---- Store element position.
          else if (iq(llncal+mbpr) .eq. mpelm) then
            do 410 i = 1, abs(idirep)
              call lnxput(1, ibnk, iseq, nseq)
  410       continue

*---- Beam line or list.
          else if (iq(llncal+mbpr) .eq. mplin) then

*---- Beam line with or without arguments.
            if (iq(llncal+mbsp) .eq. 1) then

*---- Protect against recursive entry to line.
              ihed = iq(llncal+mlhd)
              if (iq(llncal+ihed+mlrep) .ne. 0) then
                msg(1) = 'LINE "' // label(1:ileng)
     +          // '" has a recursive definition.'
                call aafail('LNXPND', 1, msg)
                nerror = nerror + 1

*---- Expand named line; switch context.
*     Sublist resides in called bank, actual arguments in current bank.
              else
                if (itype .eq. 7  .or. iq(llncal+mlf1) .ne. 0) then
                  call lnform(llncal, label, llnhed, iact)
                endif
                lq(llncal-2) = llnhed
                llnhed = llncal
                ilst = ibnk
                go to 100
              endif

*---- Sequence: Cannot be recursive.
            else if (iq(llncal+mbsp) .eq. 2) then
              call lnxseq(llncal, iseq, nseq)

*---- Replacement list: Test for reflection.
            else if (iq(llncal+mbsp) .eq. 3) then
              if (idir .lt. 0) nrefl = nrefl + 1

*---- Advance to next member of LIST.
              call lnxlst(idir)

*---- Switch context:
*     Sublist resides in LIST bank.
              idirep = 1
              ihed = mlfree
              lq(llncal-2) = llnhed
              llnhed = llncal
              ilst = ibnk
              go to 100

*---- Invalid subprocess code.
            else
              msg(1) = 'Name "' // label(1:ileng)
     +        // '" is invalid in a beam line.'
              call aafail('LNXPND', 1, msg)
              nerror = nerror + 1
            endif

*---- Invalid process code.
          else
            msg(1) = 'Name "' // label(1:ileng)
     +      // '" is invalid in a beam line.'
            call aafail('LNXPND', 1, msg)
            nerror = nerror + 1
          endif
          go to 120

*---- List header reached: Store exit position.
  500     continue
          ilst = iq(llnhed+icel+mlact)
          call lnxput(3, ilst, iseq, nseq)

*---- Repetitions wanted?
  510     continue
          irep = irep - 1
          if (irep .gt. 0) go to 110

*---- End of line: Switch context to referring line.
          ihed = icel
          idirep = iq(llnhed+ihed+mlrep)
          icel = iq(llnhed+ihed+mlref)
          ilst = iq(llnhed+ihed+mlact)
          iq(llnhed+ihed+mlrep) = 0
          iq(llnhed+ihed+mlref) = 0
          iq(llnhed+ihed+mlact) = 0
          if (itype .eq. 1) then
            llnhed = lq(llnhed-2)
          else if (itype .eq. 3) then
            llnhed = lq(llnhed-3)
          endif

*---- Is there an outer line?
          idir = sign(1,idirep)
          irep = abs(idirep)
          if (icel .ne. 0) go to 120

*==== Expand a SEQUENCE.
        else if (iq(llnhed+mbsp) .eq. 2) then
          call lnxseq(llnhed, iseq, nseq)
        endif

*---- Release unused space.
        call mzpush(0, lsdir, 0, iseq - nseq, 'I')
        call mzpush(0, lsflg, 0, iseq - nseq, 'I')
      endif

*---- Terminating message.
      if (nerror .ne. 0) then
        call diname(ldbnk, ibeam, label)
        call utleng(label, ileng)
        write (msg, 910) label(1:ileng), nerror
  910   format('Beam line "',a,'" could not be expanded, ',
     +         i5,' error(s) detected.')
        call aafail('LNXPND', 1, msg)
      else if (nrefl .ne. 0) then
        call aawarn('LNXPND', 1,
     +  'Replacement lists cannot be reflected.')
      endif

 9999 end
+dk lnxput
      subroutine lnxput(icode, idir, iseq, nseq)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Store a position to the sequence banks during line expansion.      *
* Input:                                                               *
*   ICODE     (integer) Position code: 1=element, 2=entry, 3=exit.     *
*   IDIR      (integer) Directory index for item in this position.     *
* Input/output:                                                        *
*   ISEQ      (integer) Current position in expansion.                 *
*   NSEQ      (integer) length of expansion banks allocated so far.    *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca prcgroup
+ca bankhead
+ca seqflag
+ca refer
      integer icode,idir,iseq,jdir,msi,nseq

      parameter         (msi = 500)

*---- Make sure there is enough space in the sequence bank.
      iseq = iseq + 1
      if (iseq .gt. nseq) then
        call mzpush(0, lsdir, 0, msi, 'I')
        call mzpush(0, lsflg, 0, msi, 'I')
        nseq = nseq + msi
      endif

*---- Increment occurrence counts.
      if (icode .ne. 3) then
        iq(ldbnk(4)+idir) = iq(ldbnk(4)+idir) + 1
        lref2 = lq(ldbnk(3)-idir)
 10     if (lref2 .ne. 0) then
          jdir = iq(lref2+mbnam)
          if (jdir .ne. idir) iq(ldbnk(4)+jdir) = iq(ldbnk(4)+jdir) + 1
          if (iq(lref2+mbpr) .ne. mplin) then
            lref2 = lq(lref2-iq(lref2+mbat)-mbecls)
            go to 10
          endif
        endif
      endif

      iq(lsdir+iseq) = idir
      call sbyt(icode, iq(lsflg+iseq), 1, mcode)
      call sbyt(iq(ldbnk(4)+idir), iq(lsflg+iseq), mocc1, mocc2)

      end
+dk lnxres
      subroutine lnxres
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Reset all replacement lists to initial item.                       *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca lingroup
+ca lnlink
+ca refer
      integer ilst

      call difind(ldkey, 'LIST', ilst, llnxls)
      if (llnxls .ne. 0) then
        llncal = lq(llnxls-1)
   10   if (llncal .ne. 0) then
          iq(llncal+mlf1) = iq(llncal+mlhd)
          iq(llncal+mlf2) = 0
          llncal = lq(llncal)
          go to 10
        endif
      endif

      end
+dk lnxseq
      subroutine lnxseq(lbank, iseq, nseq)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Expand a beam line SEQUENCE.                                       *
* Input:                                                               *
*   LBANK(1)  (pointer) Pointer to SEQUENCE.                           *
* Input/output:                                                        *
*   ISEQ      (integer) Current position in expansion.                 *
*   NSEQ      (integer) length of expansion banks allocated so far.    *
*----------------------------------------------------------------------*
+ca aparam
      integer idata,idir,idrf,idrift,iexpr,ilast,ilen1,ilen2,ileng,iln,
     +ilst,ipos,ipr,iref,iseq,isp,jdir,ndrift,nkat,nseq,numlab
      double precision drflen,el,eps,half,pos1,pos2
      integer           lbank(1)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca lingroup
+ca seqflag
+ca seqgroup
+ca message
+ca exlink
+ca express
+ca exstak
+ca lnlink
+ca option
+ca refer
+ca status
+ca datatype

      parameter         (half = 0.5d0, eps = 0.6d-6)
      character*(mcnam) label, refnam, seqnam, refdic(3)
      character*(mcnam) elm1, elm2
      double precision l_fact, an
      data numlab       / 0 /
      data refdic       / 'ENTRY', 'EXIT', 'CENTRE' /

*---- Decode reference position.
      refnam = 'CENTRE'
      call utgnam(lbank, 1, 1, refnam)
      call utlook(refnam, refdic, 3, iref)
      if (iref .eq. 0) then
        call utleng(refnam, ileng)
        msg(1) = 'Unknown reference keyword "' // refnam(1:ileng)
     +  // '" --- "CENTRE" assumed.'
        call aawarn('LNXSEQ', 1, msg)
        iref = 3
      endif

*---- Position for begin of sequence.
      ilst = iq(lbank(1)+mbnam)
      call diname(ldbnk, ilst, seqnam)
      call lnxput(2, ilst, iseq, nseq)

*---- Find DRIFT keyword.
      call difind(ldkey, 'DRIFT', idrf, lckey)
      call kwget(lckey, iln, ipr, isp, nkat)

*---- Expand contents of sequence.
      ndrift = 0
      llnedr = lq(lbank(1)-1)
      llneat = lbank(1)
      ilast = iq(llnedr+1)
      idata = mbat + mcsiz + 2
      idir  = iq(llnedr+ilast)
      lcelm = lq(ldbnk(3)-idir)
      call diname(ldbnk, idir, elm1)
      pos1 = 0.0

*---- Get position difference.
      do 90 ipos = 2, ilast
        level = 0
        nxopr = 0
        call exload(seqnam, ' ', llneat, ipos, idata)
        pos2 = rsval(1)
        if (ipos .gt. 2) then
          call exload(seqnam, ' ', llneat, ipos - 1, idata - mwflt)
          call exbin(2)
        endif

*---- Cancel length of previous element.
        if (iref .ne. 2  .and.  iq(lcelm+mbsp) .ne. 8) then
          l_fact = 1.d0
          if (iq(lcelm+mbsp) .eq. 2) then
*--- HG001026: arc length to rectangular bend
            call ucopy(q(lcelm+meangb), an, mwflt)
            if (an .ne. 0.d0 .and. rbarc)
     +      l_fact = 0.5d0 * an / sin(0.5d0 * an)
          endif
          call exload(elm1, 'L', lcelm, 2, melen)
          if (iref .eq. 3) then
            call exfact(0.5d0 * l_fact)
          else
            call exfact(l_fact)
          endif
          call exbin(2)
        endif

*---- Cancel length of current element.
        idir = iq(llnedr+ipos)
        lcelm = lq(ldbnk(3)-idir)
        call diname(ldbnk, idir, elm2)
        if (iref .ne. 1  .and.  iq(lcelm+mbsp) .ne. 8) then
          l_fact = 1.d0
          if (iq(lcelm+mbsp) .eq. 2) then
*--- HG001026: arc length to rectangular bend
            call ucopy(q(lcelm+meangb), an, mwflt)
            if (an .ne. 0.d0 .and. rbarc)
     +      l_fact = 0.5d0 * an / sin(0.5d0 * an)
          endif
          call exload(elm2, 'L', lcelm, 2, melen)
          if (iref .eq. 3) then
            call exfact(0.5d0 * l_fact)
          else
            call exfact(l_fact)
          endif
          call exbin(2)
        endif

*---- Error, if drift length is negative.
        drflen = rsval(1)
        iexpr  = isval(1) + 1
        if (iexpr .eq. 1) then
          if (drflen .lt. -eps) then
            call utleng(elm1, ilen1)
            call utleng(elm2, ilen2)
            write (msg, 910) drflen, elm1(1:ilen1), pos1,
     +                         elm2(1:ilen2), pos2
  910       format('Negative drift length = ',f12.6,' detected.'/
     +             'preceding element: ',a,' at position ',f18.6/
     +             'following element: ',a,' at position ',f18.6)
            call aafail('LNXSEQ', 3, msg)
          endif
        endif

*---- Build drift space and store length.
        if (.not. error) then
          if (abs(drflen) .gt. eps  .or.  iexpr .gt. 1) then

*---- For constant length, try finding the same constant length.
            if (iexpr .eq. 1) then
              lccls = lq(lckey-1)
              do 70 idrift = 1, ndrift
                if (lq(lccls-2) .eq. 0) then
                  call ucopy(q(lccls+melen), el, mwflt)
                  if (100.0 * abs(el - drflen) .lt. eps) go to 80
                endif
                lccls = lq(lccls)
   70         continue
            endif

*---- Not found; define a new anonymous drift.
            ndrift = ndrift + 1
            call aabook(lccls, 'DRIF', ipr, isp, lckey, 1)
            call exmake(lccls, 2, mbat + mcsiz + mcval, drflen, iexpr)
            iq(lccls+mbat+mcsiz+mctyp) = 10 * mtflt + iexpr
            write (label, '(''['',I6.6,'']        '')') numlab
            numlab = numlab + 1
            call didefi(ldbnk, label, lccls)

*---- DEFINE dump option.
            if (ideffl .eq. 1  .or.  ideffl .eq. 3) then
              call aadump(lccls)
            endif
            if (ideffl .eq. 2  .or.  ideffl .eq. 3) then
              call dzshow('element', 0, lccls, 'V', 0, 0, 0, 0)
            endif

*---- Append drift space.
   80       continue
            jdir = iq(lccls+mbnam)
            call lnxput(1, jdir, iseq, nseq)
          endif

*---- Append current element.
          call lnxput(1, idir, iseq, nseq)
        endif
        elm1 = elm2
        pos1 = pos2
        idata = idata + mwflt
   90 continue

*---- Position for end of sequence.
      if (.not. error) call lnxput(3, ilst, iseq, nseq)

      end
+dk lnzzzz
+dk mtaaaa
+dk mtacon
      subroutine mtacon(ipos, kcon, nfun, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Add current constraint to position IPOS in beam line.              *
* Input:                                                               *
*   IPOS     (integer) Position where constraint is to be added.       *
*   KCON     (integer) Constraint type.                                *
*   NFUN     (integer) Number of constraint functions in this point.   *
* Output:                                                              *
*   EFLAG    (logical) Error flag.                                     *
*----------------------------------------------------------------------*
+ca aparam
      integer ipos,kcon,l,nfun
      logical           eflag
+ca memdum
+ca mtlink
+ca mtcflg
+ca minuit

*---- Warning: L is local link. Be careful with Zebra calls.
      call mzbook(2, l, lq(lsmat-imsequ), -ipos, 'CCM ', 1, 0, 1, 2, 0)
      lq(l-1) = lcon
      iq(l+1) = kcon
      ncon = ncon + nfun
      eflag = .false.

      end
+dk mtbtin
      subroutine mtbtin(iflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initial values for linear coupling parameters.                     *
* Output:                                                              *
*   IFLAG     (integer) Error flag.                                    *
* Important common data:                                               *
*   RT(6,6)   /MAPTRN/  One turn transfer matrix.                      *
*   TT(6,6,6) /MAPTRN/  Second order terms.                            *
*             /OPTIC0/  Initial values are stored here.                *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca seqgroup
+ca beam
+ca maptrn
+ca optic0
+ca status
+ca zunit
      integer iflag
      double precision a,arg,aux,d,den,det,dtr,eps,sinmu2

      parameter         (eps = 1.0d-10)
      dimension         aux(2,2), a(2,2), d(2,2)

*---- Initial dispersion.
      call twdisp(rt, rt(1,6), disp0)
      disp0(5) = 0.0
      disp0(6) = 1.0

*---- Matrix C + B(bar) and its determinant.
      aux(1,1) = rt(3,1) + rt(2,4)
      aux(1,2) = rt(3,2) - rt(1,4)
      aux(2,1) = rt(4,1) - rt(2,3)
      aux(2,2) = rt(4,2) + rt(1,3)
      det = aux(1,1) * aux(2,2) - aux(1,2) * aux(2,1)

*---- Coupling matrix.
      dtr = (rt(1,1) + rt(2,2) - rt(3,3) - rt(4,4)) / 2.0
      arg = det + dtr**2
      if (arg .ge. 0.0) then
        den = - (dtr + sign(sqrt(arg),dtr))
        if (abs(den) .lt. eps) then
          r0mat(1,1) = 0.0
          r0mat(1,2) = 0.0
          r0mat(2,1) = 0.0
          r0mat(2,2) = 0.0
        else
          r0mat(1,1) = aux(1,1) / den
          r0mat(1,2) = aux(1,2) / den
          r0mat(2,1) = aux(2,1) / den
          r0mat(2,2) = aux(2,2) / den
        endif

*---- Decouple: Find diagonal blocks.
        a(1,1) = rt(1,1) - rt(1,3)*r0mat(1,1) - rt(1,4)*r0mat(2,1)
        a(1,2) = rt(1,2) - rt(1,3)*r0mat(1,2) - rt(1,4)*r0mat(2,2)
        a(2,1) = rt(2,1) - rt(2,3)*r0mat(1,1) - rt(2,4)*r0mat(2,1)
        a(2,2) = rt(2,2) - rt(2,3)*r0mat(1,2) - rt(2,4)*r0mat(2,2)
        d(1,1) = rt(3,3) + r0mat(1,1)*rt(1,3) + r0mat(1,2)*rt(2,3)
        d(1,2) = rt(3,4) + r0mat(1,1)*rt(1,4) + r0mat(1,2)*rt(2,4)
        d(2,1) = rt(4,3) + r0mat(2,1)*rt(1,3) + r0mat(2,2)*rt(2,3)
        d(2,2) = rt(4,4) + r0mat(2,1)*rt(1,4) + r0mat(2,2)*rt(2,4)

*---- First mode.
        cosmux = (a(1,1) + a(2,2)) / 2.0
        stabx  = abs(cosmux) .lt. 1.0
        if (stabx) then
          sinmu2 = - a(1,2)*a(2,1) - 0.25*(a(1,1) - a(2,2))**2
          if (sinmu2 .lt. 0.0) sinmu2 = 0.0
          sinmux = sign(sqrt(sinmu2), a(1,2))
          betx0 = a(1,2) / sinmux
          alfx0 = (a(1,1) - a(2,2)) / (2.0 * sinmux)
        else
          betx0 = 0.0
          alfx0 = 0.0
        endif

*---- Second mode.
        cosmuy = (d(1,1) + d(2,2)) / 2.0
        staby  = abs(cosmuy) .lt. 1.0
        if (staby) then
          sinmu2 = - d(1,2)*d(2,1) - 0.25*(d(1,1) - d(2,2))**2
          if (sinmu2 .lt. 0.) sinmu2 = 0.0
          sinmuy = sign(sqrt(sinmu2), d(1,2))
          bety0 = d(1,2) / sinmuy
          alfy0 = (d(1,1) - d(2,2)) / (2.0 * sinmuy)
        else
          betx0 = 0.0
          alfy0 = 0.0
        endif

*---- Unstable due to coupling.
      else
        stabx = .false.
        staby = .false.
      endif
      iflag = 1
      if (stabx .and. staby) iflag = 0

*---- Initial phase angles.
      amux0 = 0.0
      amuy0 = 0.0

      end
+dk mtbttk
      subroutine mtbttk(plus)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track coupled lattice functions.                                   *
* Input:                                                               *
*   PLUS      (logical) True, to force positive phase advance.         *
*----------------------------------------------------------------------*
* Modified: 19-JUL-1999, T. Raubenheimer (SLAC)                        *
*   Added /SYNCH/ common and calculation of synchrotron integrals      *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j
      double precision a,adet,b,c,dt,tempa,tempb,twopi
      logical           plus
+ca mapelm
+ca optic1
+ca status
+ca synch
      double precision curlyh

      dimension         a(2,2), b(2,2), c(2,2), dt(6)

+ca pi
      parameter         (twopi = 2.0 * pi)
      double precision zero, one, two
      parameter         (zero  = 0.0d0, one = 1.0d0, two = 2.0d0)

*---- Synchrotron integrals before element.
      curlyh = disp(1)**2 * (one + alfx**2) / betx
     +       + two*disp(1)*disp(2)*alfx + disp(2)**2*betx
      synch_1 = synch_1 + disp(1) * rhoinv * blen/two
      synch_2 = synch_2 + rhoinv**2 * blen/two
      synch_3 = synch_3 + abs(rhoinv**3) * blen/two
      synch_5 = synch_5 + curlyh * abs(rhoinv**3) * blen/two

*---- Dispersion.
      do 20 i = 1, 6
        dt(i) = zero
        do 10 j = 1, 6
          dt(i) = dt(i) + re(i,j) * disp(j)
   10   continue
   20 continue
      call ucopy(dt, disp, 6*mwflt)

*---- Auxiliary matrices.
      a(1,1) = re(1,1) - (re(1,3) * rmat(1,1) + re(1,4) * rmat(2,1))
      a(1,2) = re(1,2) - (re(1,3) * rmat(1,2) + re(1,4) * rmat(2,2))
      a(2,1) = re(2,1) - (re(2,3) * rmat(1,1) + re(2,4) * rmat(2,1))
      a(2,2) = re(2,2) - (re(2,3) * rmat(1,2) + re(2,4) * rmat(2,2))
      b(1,1) = re(3,1) - (re(3,3) * rmat(1,1) + re(3,4) * rmat(2,1))
      b(1,2) = re(3,2) - (re(3,3) * rmat(1,2) + re(3,4) * rmat(2,2))
      b(2,1) = re(4,1) - (re(4,3) * rmat(1,1) + re(4,4) * rmat(2,1))
      b(2,2) = re(4,2) - (re(4,3) * rmat(1,2) + re(4,4) * rmat(2,2))
      c(1,1) = re(3,3) + (re(3,1) * rmat(2,2) - re(3,2) * rmat(2,1))
      c(1,2) = re(3,4) - (re(3,1) * rmat(1,2) - re(3,2) * rmat(1,1))
      c(2,1) = re(4,3) + (re(4,1) * rmat(2,2) - re(4,2) * rmat(2,1))
      c(2,2) = re(4,4) - (re(4,1) * rmat(1,2) - re(4,2) * rmat(1,1))

*---- Track R matrix.
      adet = a(1,1) * a(2,2) - a(1,2) * a(2,1)
      rmat(1,1) = - (b(1,1) * a(2,2) - b(1,2) * a(2,1)) / adet
      rmat(1,2) =   (b(1,1) * a(1,2) - b(1,2) * a(1,1)) / adet
      rmat(2,1) = - (b(2,1) * a(2,2) - b(2,2) * a(2,1)) / adet
      rmat(2,2) =   (b(2,1) * a(1,2) - b(2,2) * a(1,1)) / adet

*---- Mode 1.
      tempb = a(1,1) * betx - a(1,2) * alfx
      tempa = a(2,1) * betx - a(2,2) * alfx
      alfx = - (tempa * tempb + a(1,2) * a(2,2)) / (adet * betx)
      betx =   (tempb * tempb + a(1,2) * a(1,2)) / (adet * betx)
      amux = amux + atan2(a(1,2),tempb)

*---- Mode 2.
      tempb = c(1,1) * bety - c(1,2) * alfy
      tempa = c(2,1) * bety - c(2,2) * alfy
      alfy = - (tempa * tempb + c(1,2) * c(2,2)) / (adet * bety)
      bety =   (tempb * tempb + c(1,2) * c(1,2)) / (adet * bety)
      amuy = amuy + atan2(c(1,2),tempb)

*---- Synchrotron integrals after element.
      curlyh = disp(1)**2 * (one + alfx**2) / betx
     +       + two*disp(1)*disp(2)*alfx + disp(2)**2*betx
      synch_1 = synch_1 + disp(1) * rhoinv * blen/two
      synch_2 = synch_2 + rhoinv**2 * blen/two
      synch_3 = synch_3 + abs(rhoinv**3) * blen/two
      synch_5 = synch_5 + curlyh * abs(rhoinv**3) * blen/two

      end
+dk mtcell
      subroutine mtcell
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Main routine for cell matching.                                    *
* Attribute:                                                           *
*   DELTAP    (real)    Relative energy error.                         *
*----------------------------------------------------------------------*
+ca aparam
+ca beam
+ca mtcflg
+ca minuit
+ca range
+ca refer
+ca status
+ca zunit

      integer srange
      common / tmptmp/ srange(2,10)

      integer mdelta,morbit,i,msequ
      double precision deltap

      parameter         (mdelta = 1, msequ = 2, morbit = 4)

*---- Is main beam line set?
      call lnchck('MTCELL', error)
      if (.not. error) then

*---- Set up for matching.
        do i = 1, 2
          sequd(i) = ' '
        enddo
*---- Name of sequence(s).
        call utgnam(lccmd, msequ, msequ+1, sequd)
        if (sequd(2) .eq. ' ')  then
          mtdbfl = 1
        else
          mtdbfl = 2
        endif
        call mtinit
        imode = 1
        do i = 1, 2
          betnm(i) = ' '
        enddo

*---- Energy error.
        deltap = 0.0
        call utgflt(lccmd, mdelta, mdelta, deltap)
        florb = .false.
        call utglog(lccmd, morbit, morbit, florb)
        sequd(1) = sequnam
*---- Initial output.
        do i = 1, mtdbfl
          call get_active(sequd(i), 'MTCELL')
          call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)
          srange(1,i) = irg1
          srange(2,i) = irg2
          call prpage(iqpr2)
          write (iqpr2, 910) linnam, rngnam, deltap, symm
          call prline(iqpr2)
          call aainfo('MTCELL', 1, 'Begin cell matching mode.')
          call enfix
          call enfreq(deltap)
        enddo
      endif

  910 format(' Matching beam line "',a,'" as a cell',t84,'Range:',a/
     +       ' delta(p)/p = ',f12.6,t31,'symm = ',l1)

      end
+dk mtcond
      subroutine mtcond(fprt, nf, fvec, iflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Run through the matching conditions, compute (and print) values.   *
* Input:                                                               *
*   FPRT      (logical) Print flag.                                    *
*   NF        (integer) Number of matching functions.                  *
* Output:                                                              *
*   FVEC(NF)  (real)    Matching function values.                      *
*   IFLAG     (integer) Stability flag.                                *
*----------------------------------------------------------------------*
* Modified: 07-JAN-1999, T. Raubenheimer (SLAC)                        *
*   Changed MAXVAL = 26 -> MAXVAL = 27; added ENERGY_VAL and           *
*   CHROM_VAL ... the latter is necessary to get the printing and      *
*   constraint summation correct; added ENER to DICT list; added       *
*   printing for energy constraint                                     *
* Modified: 04-MAR-1999, T. Raubenheimer (SLAC)                        *
*   Changed MAXVAL = 27 -> MAXVAL = 28; added CIRC to DICT list        *
* Modified: 14-JUL-1999, T. Raubenheimer (SLAC)                        *
*   Changed MAXVAL = 28 -> MAXVAL = 34; added /SYNCH/ common block;    *
*   reset BLEN to zero in tracking loop                                *
* Modified: 12-AUG-1999, T. Raubenheimer (SLAC)                        *
*   Changed MAXVAL = 34 -> MAXVAL = 36; added I5I2 and I5I1            *
*   constraints                                                        *
*----------------------------------------------------------------------*
+ca aparam
      integer i,icode,icon,ienum,iepos,iflag,iocc,ipos,j,jbyt,jcon,k,
     +kcon,kflag,last,nf,nline
      double precision el,fsum,fvec,rsum,tsum,utwopi,x,zero
      logical           fprt
      dimension         fvec(nf)
+ca memdum
+ca seqflag
+ca message
+ca beam
+ca mtpara
+ca mapelm
+ca maptrn
+ca minuit
+ca mtccon
+ca mtcflg
+ca mtlink
+ca mtcmtx
+ca optic0
+ca optic1
+ca option
+ca range
+ca refer
+ca synch
+ca zunit

      integer srange
      common / tmptmp/ srange(2,10)

+ca pi
      parameter         (utwopi = 1.0d0 / (2.0d0 * pi), zero = 0.0d0)
      character*4       dict(maxval)
      character*(mcnam) elmnam*(mcnam), title*(*)
      logical           fmap, fsec
      parameter         (title = 'Matching summary.')
      data dict
     +   / 'BETX', 'ALFX', 'MUX ', 'BETY', 'ALFY', 'MUY ',
     +     'X   ', 'PX  ', 'Y   ', 'PY  ', 'T',    'PT',
     +     'DX  ', 'DPX ', 'DY  ', 'DPY ',
     +     'WX  ', 'PHIX', 'DMUX', 'WY  ', 'PHIY', 'DMUY',
     +     'DDX ', 'DDPX', 'DDY ', 'DDPY', 'ENER', 'CIRC',
     +     'I1  ', 'I2  ', 'I3  ', 'I4  ', 'I5  ', 'I5I2',
     +     'I5I1', 'DUMM'  /

*--- total penalty value
      fsum = 0.0
*--- constraint counter
      icon = 0
*---- Initialize global user constraints.
      call mtufun(.false., 1, icon, fvec, fsum)

*--- loop over sequences
      do imsequ = 1, mtdbfl
      lmtbet = lbeta0(imsequ)
      if (sequd(imsequ) .ne. ' ' .and. sequd(imsequ) .ne. sequnam)
     +call get_active(sequd(imsequ), 'MTCOND')
*---- Initialize lattice functions
      fsec = florb .or. fltmat .or. flchrm
      call mtpini(iflag)
      if (iflag .ne. 0) go to 9999
*---- Initialize transfer map.
      if (flrmat .or. fltmat) then
        call m66one(rt)
        if (fltmat) call uzero(tt, 1, 216*mwflt)
      endif

*---- Initialize.
      iepos = 0
      suml = 0.0

*---- Print page header.
      if (fprt) then
        call prhead('ENDMATCH', title, deltas, 0, nline, 1)
        if (florb) then
          write (iqpr2, 800) 'ACTUAL'
        else
          write (iqpr2, 800) 'IDEAL'
        endif
        call prline(iqpr2)
        write (iqpr2, 810)
        call prline(iqpr2)

*---- Print begin of beam line.
        elmnam = ' '
        write (iqpr2, 820) iepos, elmnam, 0, suml,
     +                     'begin matching range'
        cval(1) = betx
        cval(2) = alfx
        cval(3) = amux * utwopi
        cval(4) = bety
        cval(5) = alfy
        cval(6) = amuy * utwopi
        call ucopy(orbit, cval(7), 6*mwflt)
        call ucopy(disp, cval(13), 4*mwflt)
        ener1 = ener0
        if (ener1 .eq. zero .or. .not. ereset) ener1 = en0
        cval(energy_val) = ener1
        cval(energy_val+1) = suml
        cval(energy_val+2) = synch_1
        cval(energy_val+3) = synch_2
        cval(energy_val+4) = synch_3
        cval(energy_val+5) = synch_4
        cval(energy_val+6) = synch_5
        cval(energy_val+7) = synch_5/max(synch_2,1.d-8)
        cval(energy_val+8) = synch_5/max(synch_1,1.d-8)
        cval(energy_val+9) = 0
        if (flchrm) then
          last = chrom_val
          cval(17) = wx
          cval(18) = phix
          cval(19) = dmux * utwopi
          cval(20) = wy
          cval(21) = phiy
          cval(22) = dmuy * utwopi
          call ucopy(ddisp, cval(23), 4*mwflt)
        else
          last = maxlin
        endif

*---- Print orbit only if computed.
        do 10 jcon = 1, last
          if (florb  .or.  jcon .lt. 7  .or.  jcon .gt. 12) then
            write (iqpr2, 830) dict(jcon), cval(jcon)
          endif
   10   continue
        jcon = energy_val
        write (iqpr2, 830) dict(jcon), cval(jcon)
        write (iqpr2, 830) dict(jcon+1), cval(jcon+1)
        write (iqpr2, 830) dict(jcon+2), cval(jcon+2)
        write (iqpr2, 830) dict(jcon+3), cval(jcon+3)
        write (iqpr2, 830) dict(jcon+4), cval(jcon+4)
        write (iqpr2, 830) dict(jcon+5), cval(jcon+5)
        write (iqpr2, 830) dict(jcon+6), cval(jcon+6)
        write (iqpr2, 830) dict(jcon+7), cval(jcon+7)
        write (iqpr2, 830) dict(jcon+8), cval(jcon+8)
        write (iqpr2, 830) dict(jcon+9), cval(jcon+9)
      endif

*---- Tracking loop.
      irg1 = srange(1,imsequ)
      irg2 = srange(2,imsequ)
      do 100 ipos = irg1, irg2
        call utelem(lcseq, ipos, kflag, elmnam, iocc, ienum)
        icode = jbyt(kflag,1,mcode)

*---- Tor: set BLEN to zero ... it may get reset in TMMAP
        blen = zero

*---- Misalignment at entrance.
        if (icode .ne. 3  .and.  florb  .and.  lcali .ne. 0) then
          call tmali1(ipos, fsec, orbit, orbit, re, te)
          if (flchrm) then
            call twbttk(.true., .false.)
          else
            call mtbttk(.false.)
          endif
          if (flrmat .or. fltmat) then
            call tmcat(fltmat, re, te, rt, tt, rt, tt)
          endif
        endif

*---- Advance through element.
        if (icode .eq. 1) then
          call tmmap(fsec, florb, orbit, fmap, el, ek, re, te)
          if (fmap) then
            if (flchrm) then
              call twbttk(.true., .true.)
            else
              call mtbttk(.true.)
            endif
            suml = suml + el
            if (flrmat .or. fltmat) then
              call tmcat(fltmat, re, te, rt, tt, rt, tt)
            endif
          endif
        endif

*---- Misalignment at exit.
        if (icode .ne. 2  .and.  florb  .and.  lcali .ne. 0) then
          call tmali2(ipos, fsec, orbit, orbit, re, te)
          if (flchrm) then
            call twbttk(.true., .false.)
          else
            call mtbttk(.false.)
          endif
          if (flrmat .or. fltmat) then
            call tmcat(fltmat, re, te, rt, tt, rt, tt)
          endif
        endif

*---- Return (and print) user constraints for current position.
        if (icode .eq. 1) call mtufun(fprt, 2, icon, fvec, fsum)

*---- Test for constraints in this position.
        lptr = lq(lsmat-imsequ)
        if (lptr .ne. 0) lptr = lq(lptr-ipos)
   20   if (lptr .ne. 0) then
          lcon = lq(lptr-1)
          kcon = iq(lptr+1)

*---- Coupling constraint (beginning).
          if (kcon .eq. 2) then
            call ucopy(q(lcon+mconmn), cmin, maxval*mwflt)
            call ucopy(q(lcon+mconvl), cval, maxval*mwflt)
            call ucopy(q(lcon+mconwt), cwgt, maxval*mwflt)
            cmin(1) = betx
            cmin(2) = alfx
            cval(3) = amux * utwopi
            cmin(4) = bety
            cmin(5) = alfy
            cval(6) = amuy * utwopi
            call ucopy(orbit, cmin(7), 6*mwflt)
            call ucopy(disp, cmin(13), 4*mwflt)
            cval(energy_val) = ener1
            cval(energy_val+1) = suml
            cval(energy_val+2) = synch_1
            cval(energy_val+3) = synch_2
            cval(energy_val+4) = synch_3
            cval(energy_val+5) = synch_4
            cval(energy_val+6) = synch_5
            cval(energy_val+7) = synch_5/max(synch_2,1.d-8)
            cval(energy_val+8) = synch_5/max(synch_1,1.d-8)
            cval(energy_val+9) = 0
            if (flchrm) then
              last = chrom_val
              cval(17) = wx
              cval(18) = phix
              cval(19) = dmux * utwopi
              cval(20) = wy
              cval(21) = phiy
              cval(22) = dmuy * utwopi
              call ucopy(ddisp, cval(23), 4*mwflt)
            else
              last = maxlin
            endif
            call ucopy(cmin, q(lcon+mconmn), maxval*mwflt)
            call ucopy(cval, q(lcon+mconvl), maxval*mwflt)
            if (fprt) then
              write (iqpr2, 820) ienum, elmnam, iocc, suml,
     +                           'begin COUPLE range'
              do 30 jcon = 1, last
                if (cwgt(jcon) .ne. 0.) then
                  if (jcon .eq. 3  .or.  jcon .eq. 6) then
                    write (iqpr2, 840) dict(jcon),cwgt(jcon),zero
                  else
                    write (iqpr2, 840) dict(jcon),cwgt(jcon),cmin(jcon)
                  endif
                endif
   30         continue
              jcon = energy_val
              write (iqpr2, 830) dict(jcon), cval(jcon)
              write (iqpr2, 830) dict(jcon+1), cval(jcon+1)
              write (iqpr2, 830) dict(jcon+2), cval(jcon+2)
              write (iqpr2, 830) dict(jcon+3), cval(jcon+3)
              write (iqpr2, 830) dict(jcon+4), cval(jcon+4)
              write (iqpr2, 830) dict(jcon+5), cval(jcon+5)
              write (iqpr2, 830) dict(jcon+6), cval(jcon+6)
              write (iqpr2, 830) dict(jcon+7), cval(jcon+7)
              write (iqpr2, 830) dict(jcon+8), cval(jcon+8)
              write (iqpr2, 830) dict(jcon+9), cval(jcon+9)
            endif

*---- CONSTRAINT or end of COUPLE.
          else if (kcon .eq. 1  .or.  kcon .eq. 3) then
            call ucopy(q(lcon+mcontp), icc, maxval)
            call ucopy(q(lcon+mconmn), cmin, maxval*mwflt)
            call ucopy(q(lcon+mconmx), cmax, maxval*mwflt)
            call ucopy(q(lcon+mconvl), cval, maxval*mwflt)
            call ucopy(q(lcon+mconwt), cwgt, maxval*mwflt)
            cval(1) = betx
            cval(2) = alfx
            cval(4) = bety
            cval(5) = alfy
            call ucopy(orbit, cval(7), 6*mwflt)
            call ucopy(disp, cval(13), 4*mwflt)
            cval(energy_val) = ener1
            cval(energy_val+1) = suml
            cval(energy_val+2) = synch_1
            cval(energy_val+3) = synch_2
            cval(energy_val+4) = synch_3
            cval(energy_val+5) = synch_4
            cval(energy_val+6) = synch_5
            cval(energy_val+7) = synch_5/max(synch_2,1.d-8)
            cval(energy_val+8) = synch_5/max(synch_1,1.d-8)
            cval(energy_val+9) = 0
            if (flchrm) then
              last = chrom_val
              cval(17) = wx
              cval(18) = phix
              cval(19) = dmux * utwopi
              cval(20) = wy
              cval(21) = phiy
              cval(22) = dmuy * utwopi
              call ucopy(ddisp, cval(23), 4*mwflt)
            else
              last = maxlin
            endif
            if (kcon .eq. 1) then
              cval(3) = amux * utwopi
              cval(6) = amuy * utwopi
              if (fprt) write (iqpr2, 820) ienum, elmnam, iocc, suml,
     +                                     'CONSTRAINT'
            else
              cval(3) = amux * utwopi - cval(3)
              cval(6) = amuy * utwopi - cval(6)
              if (fprt) write (iqpr2, 820) ienum, elmnam, iocc, suml,
     +                                     'end   COUPLE range'
            endif

*---- Contribution to penalty function.
            do 90 jcon = 1, last
              if (icc(jcon) .ne. 0) then
                icon = icon + 1
                if (icc(jcon) .eq. 1) then
                  fvec(icon) = cwgt(jcon) * dim(cmin(jcon),cval(jcon))
                  if (fprt) write (iqpr2, 880) dict(jcon), cwgt(jcon),
     +              cval(jcon), cmin(jcon), fvec(icon)**2
                else if (icc(jcon) .eq. 2) then
                  fvec(icon) = cwgt(jcon) * dim(cval(jcon),cmax(jcon))
                  if (fprt) write (iqpr2, 890) dict(jcon), cwgt(jcon),
     +              cval(jcon), cmax(jcon), fvec(icon)**2
                else if (icc(jcon) .eq. 3) then
                  fvec(icon) = cwgt(jcon) * dim(cmin(jcon),cval(jcon))
     +               +  cwgt(jcon) * dim(cval(jcon),cmax(jcon))
                  if (fprt) write (iqpr2, 840) dict(jcon), cwgt(jcon),
     +              cval(jcon), cmin(jcon), cmax(jcon), fvec(icon)**2
                else if (icc(jcon) .eq. 4) then
                  fvec(icon) = cwgt(jcon) * (cval(jcon) - cmin(jcon))
                  if (fprt) write (iqpr2, 840) dict(jcon), cwgt(jcon),
     +              cval(jcon), cmin(jcon), cmin(jcon), fvec(icon)**2
                endif
                fsum = fsum + fvec(icon)**2
              endif
   90       continue

*---- Tor: added to sum energy and circ
            do 92 jcon = energy_val, energy_val+9
              if (icc(jcon) .ne. 0) then
                icon = icon + 1
                if (icc(jcon) .eq. 1) then
                  fvec(icon) = cwgt(jcon) * dim(cmin(jcon),cval(jcon))
                  if (fprt) write (iqpr2, 880) dict(jcon), cwgt(jcon),
     +                cval(jcon), cmin(jcon), fvec(icon)**2
                else if (icc(jcon) .eq. 2) then
                  fvec(icon) = cwgt(jcon) * dim(cval(jcon),cmax(jcon))
                  if (fprt) write (iqpr2, 890) dict(jcon), cwgt(jcon),
     +                cval(jcon), cmax(jcon), fvec(icon)**2
                else if (icc(jcon) .eq. 3) then
                  fvec(icon) = cwgt(jcon) * dim(cmin(jcon),cval(jcon))
     +                 +  cwgt(jcon) * dim(cval(jcon),cmax(jcon))
                  if (fprt) write (iqpr2, 840) dict(jcon), cwgt(jcon),
     +                cval(jcon), cmin(jcon), cmax(jcon), fvec(icon)**2
                else if (icc(jcon) .eq. 4) then
                  fvec(icon) = cwgt(jcon) * (cval(jcon) - cmin(jcon))
                  if (fprt) write (iqpr2, 840) dict(jcon), cwgt(jcon),
     +                cval(jcon), cmin(jcon), cmin(jcon), fvec(icon)**2
                endif
                fsum = fsum + fvec(icon)**2
              endif
   92       continue
*---- End of Tor

*---- RMATRIX or TMATRIX (beginning of range):
*     Save inverted accumulated map.
          else if (kcon .eq. 4) then
            call m66inv(rt, rtsav)
            call ucopy(rtsav, q(lcon+1), 36*mwflt)
            if (fprt) write (iqpr2, 820)
     +        ienum, elmnam, iocc, suml, 'begin RMATRIX range'
          else if (kcon .eq. 6) then
            call tminv(rt, tt, rtsav, ttsav)
            call ucopy(rtsav, q(lcon+1), 36*mwflt)
            call ucopy(ttsav, q(lcon+36*mwflt+1), 216*mwflt)
            if (fprt) write (iqpr2, 820)
     +        ienum, elmnam, iocc, suml, 'begin TMATRIX range'

*---- RMATRIX (end of range).
          else if (kcon .eq. 5) then
            call ucopy(q(lcon+1), rtsav, 36*mwflt)
            call m66mpy(rt, rtsav, rtsav)
            call ucopy(q(lcon+36*mwflt+1), rtdes, 36*mwflt)
            call ucopy(q(lcon+(36+36)*mwflt+1), rtwgt, 36*mwflt)
            rsum = 0.0
            do 70 k = 1, 36
              if (rtwgt(k) .ne. 0.0) then
                icon = icon + 1
                fvec(icon) = rtwgt(k) * (rtsav(k) - rtdes(k))
                rsum = rsum + fvec(icon)**2
              endif
   70       continue
            fsum = fsum + rsum
            if (fprt) then
              write (iqpr2, 820) ienum, elmnam, iocc, suml,
     +                           'end   RMATRIX range'
              do 75 i = 1, 6
                write (iqpr2, 850) (rtsav(k), k = i, 36, 6)
   75         continue
              write (iqpr2, 870) rsum
            endif

*---- TMATRIX (end of range).
          else if (kcon .eq. 7) then
            call ucopy(q(lcon+1), rtsav, 36*mwflt)
            call ucopy(q(lcon+36*mwflt+1), ttsav, 216*mwflt)
            call tmcat(.true., rt, tt, rtsav, ttsav, rtsav, ttsav)
            call ucopy(q(lcon+(36+216)*mwflt+1), rtdes, 216*mwflt)
            call ucopy(q(lcon+(36+216+216)*mwflt+1), rtwgt, 216*mwflt)
            tsum = 0.0
            do 80 k = 1, 216
              if (rtwgt(k) .ne. 0.0) then
                icon = icon + 1
                fvec(icon) = rtwgt(k) * (ttsav(k) - rtdes(k))
                tsum = tsum + fvec(icon)**2
              endif
   80       continue
            fsum = fsum + tsum
            if (fprt) then
              write (iqpr2, 820)
     +        ienum, elmnam, iocc, suml, 'end   TMATRIX range'
              do 85 i = 1, 6
                write (iqpr2, 860) i,
     +            ((ttsav(k), k = j, 216, 36), j = i, 36, 6)
   85         continue
              write (iqpr2, 870) tsum
            endif
          endif
          lptr = lq(lptr)
          go to 20
        endif
  100 continue

*---- Return (and print) global user constraints.
      call mtufun(fprt, 3, icon, fvec, fsum)
*---- End of beam line.
      if (fprt) then
        write (iqpr2, 820) ienum, elmnam, iocc, suml,
     +                     'end   matching range'
        cval(1) = betx
        cval(2) = alfx
        cval(3) = amux * utwopi
        cval(4) = bety
        cval(5) = alfy
        cval(6) = amuy * utwopi
        call ucopy(orbit, cval(7), 6*mwflt)
        call ucopy(disp, cval(13), 4*mwflt)
        cval(energy_val) = ener1
        cval(energy_val+1) = suml
        cval(energy_val+2) = synch_1
        cval(energy_val+3) = synch_2
        cval(energy_val+4) = synch_3
        cval(energy_val+5) = synch_4
        cval(energy_val+6) = synch_5
        cval(energy_val+7) = synch_5/max(synch_2,1.d-8)
        cval(energy_val+8) = synch_5/max(synch_1,1.d-8)
        cval(energy_val+9) = 0
        if (flchrm) then
          last = chrom_val
          cval(17) = wx
          cval(18) = phix
          cval(19) = dmux * utwopi
          cval(20) = wy
          cval(21) = phiy
          cval(22) = dmuy * utwopi
          call ucopy(ddisp, cval(23), 4*mwflt)
        else
          last = maxlin
        endif

*---- Print orbit only if computed.
        do 110 jcon = 1, last
          if (florb  .or.  jcon .lt. 7  .or.  jcon .gt. 12) then
            write (iqpr2, 830) dict(jcon), cval(jcon)
          endif
  110   continue
        jcon = energy_val
        write (iqpr2, 830) dict(jcon), cval(jcon)
        write (iqpr2, 830) dict(jcon+1), cval(jcon+1)
        write (iqpr2, 830) dict(jcon+2), cval(jcon+2)
        write (iqpr2, 830) dict(jcon+3), cval(jcon+3)
        write (iqpr2, 830) dict(jcon+4), cval(jcon+4)
        write (iqpr2, 830) dict(jcon+5), cval(jcon+5)
        write (iqpr2, 830) dict(jcon+6), cval(jcon+6)
        write (iqpr2, 830) dict(jcon+7), cval(jcon+7)
        write (iqpr2, 830) dict(jcon+8), cval(jcon+8)
        write (iqpr2, 830) dict(jcon+9), cval(jcon+9)
      endif
*--- end of loop over sequences
      enddo
*---- Final value of penalty function.
      if (fprt)  then
        fmin = fsum
        write (iqpr2, 900) fmin
        if (ilevel .ge. 0) then
          crout = 'ENDMATCH'
          cstat = 'final values'
          call mtprnt(nvar, x)
        endif
        write (msg, 910) fsum
        call aainfo('MTCOND', 1, msg)
      endif

  800 format(' Matched with respect to the ',a,' orbit.')
  810 format(' Pos.  element occ.     dist.  condition    quantity',
     +       '   weight',10x,'actual',10x,'minimum',9x,
     +       'maximum',9x,'penalty'/
     +       ' no.   name    no.       m     type',9x,'name',23x,
     +       3('value',11x),'contribution')
  820 format(' ',i5,' ',a8,i4,f10.3,2x,a)
  830 format(t45,a4,3x,16x,1p,e16.6)
  840 format(t45,a4,3x,1p,5e16.6)
  850 format(2x,6f16.6)
  860 format(1x,i1,6e16.6/(2x,6e16.6))
  870 format(t45,'Contribution of this constraint:',t116,1p,e16.6)
  880 format(t45,a4,3x,1p,3e16.6,16x,e16.6)
  890 format(t45,a4,3x,1p,2e16.6,16x,2e16.6)
  900 format(' '/t45,'Total penalty function:',t116,1p,e16.6)
  910 format('Last value of the penalty function:',1p,e14.6)

 9999 end
+dk mtcons
      subroutine mtcons
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   CONSTRAINT Command.                                                *
* Attributes:                                                          *
*   RANGE    (range)   Range to limit selections.                      *
*   CLASS    (name)    Class of elements to be affected in RANGE.      *
*   PATTERN  (string)  Regular expression to limit choice.             *
*   LINE     (line)    Match to this beam line.                        *
*   BETX     (real)    Horizontal beta.                                *
*   ALFX     (real)    Horizontal alpha.                               *
*   MUX      (real)    Horizontal phase.                               *
*   BETY     (real)    Vertical beta.                                  *
*   ALFY     (real)    Vertical alpha.                                 *
*   MUY      (real)    Vertical phase.                                 *
*   X        (real)    Horizontal orbit.                               *
*   PX       (real)    Horizontal orbit slope.                         *
*   Y        (real)    Vertical orbit.                                 *
*   PY       (real)    Vertical orbit slope.                           *
*   T        (real)    Longitudinal orbit.                             *
*   PT       (real)    Momentum error.                                 *
*   DX       (real)    Horizontal dispersion.                          *
*   DPX      (real)    Horizontal dispersion slope.                    *
*   DY       (real)    Vertical dispersion.                            *
*   DPY      (real)    Vertical dispersion slope.                      *
*   WX       (real)    Horizontal chromatic amplitude.                 *
*   PHIX     (real)    Horizontal chromatic phase.                     *
*   DMUX     (real)    Horizontal chromatic derivative of MUX.         *
*   WY       (real)    Vertical chromatic amplitude.                   *
*   PHIY     (real)    Vertical chromatic phase.                       *
*   DMUY     (real)    Vertical chromatic derivative of MUY.           *
*   DDX      (real)    Horizontal 2nd dispersion.                      *
*   DDPX     (real)    Horizontal 2nd dispersion slope.                *
*   DDY      (real)    Vertical 2nd dispersion.                        *
*   DDPY     (real)    Vertical 2nd dispersion slope.                  *
*   BETA0    (name)    Name of BETA0 bank defining constraints.        *
*   sequence (name)    Name of sequence for constraint                 *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca prcgroup
+ca strgroup
+ca message
+ca mtpara
+ca minuit
+ca mtccon
+ca mtcflg
+ca mtlink
+ca mtcwgt
+ca refer
+ca status
+ca datatype
      integer idata,idir,ileng,iline,jatt,jcon,mbeta,mclass,mcons,mline,
     +mpatt,mrange,nd,nfun,msequ,i,k

      parameter         (mrange = 1, mclass = 2, mpatt  = 3)
      parameter         (mline  = 4)
      parameter         (mcons  = 5, mbeta  = maxval + 5,
     +                   msequ = maxval + 6)

      external          mtacon
      character*(mcnam) betnam, class, seqnm
      character*(mcstr) patt
      logical           done, linflg, betflg, flwarn

*---- Lift constraint bank.
*     link 1 (structural): Sequence bank for LINE constraint,
*     link 2 (structural): Chain of expressions defining constraint values,
*     link 3 (reference):  BETA0 bank, if used.
      nd = 2 + maxval + 4 * maxval * mwflt
      call mzbook(2, lcon, lmcon, 1, 'CNST', 4, 2, nd, 7, 0)
      iq(lcon+mconf1) = 16 * maxval + 2
      iq(lcon+mconf2) = 16 * 4 * maxval * mwflt + mreal
      nfun = 0

*---- get sequence name
      seqnm = ' '
      call utgnam(lccmd, msequ, msequ, seqnm)
      if (seqnm .ne. ' ')  then
*---  keep sequence pointer
        k = 0
        do i = 1, 2
          if (seqnm .eq. sequd(i))  k = i
        enddo
        if (k .eq. 0)  then
          call utleng(seqnm, ileng)
          msg(1) = 'Constraint SEQUENCE "' // seqnm(1:ileng)
     +    // '" not in MATCH command - first sequence used.'
          call aawarn('MTCONS', 1, msg)
          imsequ = 1
        else
          imsequ = k
        endif
      else
        imsequ = 1
      endif
      if (sequd(imsequ) .ne. ' ' .and. sequd(imsequ) .ne. sequnam)
     +call get_active(sequd(imsequ), 'MTCONS')
*---- Link to BETA0 bank, if used.
      betnam = ' '
      call utgnam(lccmd, mbeta, mbeta, betnam)
      betflg = betnam .ne. ' '
      if (betflg) then
        call utleng(betnam, ileng)
        call difind(ldbnk, betnam(1:ileng), idir, lptr)
        if (idir .eq. 0) then
          msg(1) = 'Constraint BETA0 bank "' // betnam(1:ileng)
     +    // '" not found.'
          call aafail('MTCONS', 1, msg)
        else if (iq(lptr+mbpr).ne.mpenv .or. iq(lptr+mbsp).ne.2) then
          msg(1) = '"' // betnam(1:ileng) // '" is not a "BETA0" bank.'
          call aafail('MTCONS', 1, msg)
        else
          lq(lcon-3) = lptr
        endif
      endif

*---- Set up LINE constraint.
      iline = mbat + (mline - 1) * mcsiz
      linflg = mod(iq(lccmd+iline+mctyp),10) .ne. 0
      if (linflg) then
        if (betflg) then
          call aafail('MTCONS', 1,
     +    'Conflicting options BETA0 and LINE have been specified.')
        else
          call lnrefe(lccmd, mline, lmtseq, lcon, -1)
        endif
      endif
      if (error) go to 9999

*---- Copy remaining data.
      flwarn = .false.
      jatt = mcons
      idata = mbat
      do 90 jcon = 1, maxval

*---- Set up for unconstrained value.
        icc(jcon) = 0
        cmin(jcon) = 0.0
        cmax(jcon) = 0.0
        cwgt(jcon) = 0.0
        if (wgt(jcon) .ne. 0.0) then
          lcatt = lq(lccmd-jatt)

*---- BETA0 option. Cannot constrain phases.
          if (betflg  .and.  jcon .ne. 3  .and.  jcon .ne. 6) then
            if (florb  .or.  jcon .le. 6  .or.  jcon .gt. 12) then
              icc(jcon) = 4
              cwgt(jcon) = wgt(jcon)
              if (lq(lptr-jcon) .ne. 0) then
                call mzcopy(2, lq(lptr-jcon), 2, lcon, -2, 'Z')
                lcexp = lq(lcon-2)
                iq(lcexp+mxsiz*iq(lcexp-3)+mxval) =
     +            mconmn + (jcon - 1) * mwflt
                call exlkex
              else
                call ucopy(q(lptr+idata+mcval), cmin(jcon), mwflt)
              endif
            else
              icc(jcon) = 0
              cwgt(jcon) = 0.0
            endif

*---- LINE option. Cannot constrain phases.
          else if (linflg  .and.  jcon .ne. 3  .and.  jcon .ne. 6) then
            if (florb  .or.  jcon .le. 6  .or.  jcon .gt. 12) then
              icc(jcon) = 4
              cwgt(jcon) = wgt(jcon)
            else
              icc(jcon) = 0
              cwgt(jcon) = 0.0
            endif

*---- Other constraints.
          elseif (lcatt .ne. 0  .and.  iq(lcatt+2) .ne. 0) then

*---- For orbit constraints, set orbit flag.
            if (jcon .gt. 6  .and.  jcon .le. 12) florb = .true.

*---- Minimum value.
            if (lq(lcatt-1) .ne. 0) then
              call mzcopy(2, lq(lcatt-1), 2, lcon, -2, 'Z')
              lcexp = lq(lcon-2)
              iq(lcexp+mxsiz*iq(lcexp-3)+mxval) =
     +          mconmn + (jcon - 1) * mwflt
              call exlkex
            else
              call ucopy(q(lcatt+mcval+2), cmin(jcon), mwflt)
            endif

*---- Maximum value.
            if (lq(lcatt-2) .ne. 0) then
              call mzcopy(2, lq(lcatt-2), 2, lcon, -2, 'Z')
              lcexp = lq(lcon-2)
              iq(lcexp+mxsiz*iq(lcexp-3)+mxval) =
     +          mconmx+(jcon-1) * mwflt
              call exlkex
            else
              call ucopy(q(lcatt+mcsiz+mcval+2), cmax(jcon), mwflt)
            endif

*---- Constraint type and weight.
            cwgt(jcon) = wgt(jcon)
            icc(jcon) = iq(lcatt+2)
          endif

*---- Tor: check for linear constraints
*     (NOTE: this section moved here to check for BETA0 and LINES also)
          if (jcon .gt. maxlin .and. jcon .lt. energy_val) then
            flchrm = .true.
            flwarn = .true.
          endif

*---- Count constraints.
          if (icc(jcon) .ne. 0) then
            nfun = nfun + 1
            if (jcon .gt. maxlin) then
              flchrm = .true.
              flwarn = .true.
            endif
          endif
*---- Tor: if the weight is zero, but the function is being fit, issue
*     a warning message to remind the user
          lcatt = lq(lccmd-jatt)
          if (lcatt .ne. 0  .and.  iq(lcatt+2) .ne. 0 .and.
     +        wgt(jcon) .eq. 0.0) then
            msg(1) = 'You have chosen a constraint with weight = 0.'
            call aawarn('mtcons', 1, msg)
          endif
        endif
        jatt = jatt + 1
        idata = idata + mcsiz
   90 continue

*---- Warn user that no coupling can be present.
      if (flwarn) then
        msg(1) = 'You have selected a chromatic function for matching.'
        msg(2) = 'The match module will IGNORE any coupling.'
        call aawarn('MTCONS', 2, msg)
      endif

*---- Copy data to constraint bank.
      call ncopy(icc, iq(lcon+mcontp), maxval)
      call ucopy(cmin, q(lcon+mconmn), maxval*mwflt)
      call ucopy(cmax, q(lcon+mconmx), maxval*mwflt)
      call ucopy(cwgt, q(lcon+mconwt), maxval*mwflt)

*---- Call ENSRNG for setting constraints.
      class = ' '
      patt  = ' '
      call utgnam(lccmd, mclass, mclass, class)
      call utgstr(lccmd, mpatt,  mpatt,  patt)
      lcatt = lq(lccmd-mrange)
      call ensrng(lcatt, class, patt, mtacon, 1, nfun, done)

*---- Clean up.
      if (done  .and.  .not. error) then
        ifirst = 0
        icovar = 0
        flbeta = .true.
      else
        call lndrop(lq(lcon-1))
        call aadrop(lcon)
      endif

 9999 end
+dk mtcple
      subroutine mtcple
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   COUPLE Command.                                                    *
* Attributes:                                                          *
*   RANGE    (range)   Where to apply the constraint.                  *
*   MUX      (real)    Horizontal phase difference.                    *
*   MUY      (real)    Vertical phase difference.                      *
*----------------------------------------------------------------------*
* Modified: 07-JAN-1999, T. Raubenheimer (SLAC)                        *
*   Changed MAXVAL = 26 -> MAXVAL = 27; added ENERGY_VAL parameter to  *
*   check for linear constraints; added linear constrain checking      *
* Modified: 04-MAR-1999, T. Raubenheimer (SLAC)                        *
*   Changed MAXVAL = 27 -> MAXVAL = 28                                 *
* Modified: 14-JUL-1999, T. Raubenheimer (SLAC)                        *
*   Changed MAXVAL = 28 -> MAXVAL = 34                                 *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca mtpara
+ca message
+ca minuit
+ca mtccon
+ca mtcflg
+ca mtlink
+ca mtcwgt
+ca refer
+ca status
+ca zunit
+ca datatype
      integer idata,ipos1,ipos2,jatt,jcon,nd,nfun
      logical flwarn

*---- Valid range required.
      idata = mbat
      if (iq(lccmd+idata+mctyp) .ne. 10*mtrng + 1) then
        call aafail('MTCPLE', 1, 'COUPLE command requires a RANGE.')
        go to 9999
      endif
      lcatt = lq(lccmd-1)
      call utgrng(lcatt, lcseq, ipos1, ipos2, error)
      if (error) go to 9999

*---- Lift constraint bank.
*     NOTE. First link must always be zero (see MTPINI).
      nd = 2 + maxval + 4 * maxval * mwflt
      call mzbook(2, lcon, lmcon, 1, 'CPLE', 4, 2, nd, 7, 0)
      iq(lcon+mconf1) = 16 * maxval + 2
      iq(lcon+mconf2) = 16 * 4 * maxval * mwflt + mreal
      nfun = 0

*---- Fill in constraint types: Cannot constrain orbit.
      do 10 jcon = 1, maxval
        if (jcon .le. 6  .or.  jcon .ge. 11) then
          icc(jcon) = 4
          cwgt(jcon) = wgt(jcon)
        else
          icc(jcon) = 0
          cwgt(jcon) = 0.0
        endif
        cmin(jcon) = 0.0
        cmax(jcon) = 0.0
   10 continue

*---- Desired values for phase differences.
      do 20 jatt = 2, 3
        jcon = 3 * (jatt - 1)
        lcatt = lq(lccmd-jatt)
        if (lcatt .ne. 0) then

*---- Minimum value.
          lcexp = lq(lcatt-1)
          if (lcexp .ne. 0) then
            call mzcopy(2, lcexp, 2, lcon, -2, 'Z')
            lcexp = lq(lcon-2)
            iq(lcexp+mxsiz*iq(lcexp-3)+mxval) = mconmn + (jcon-1)*mwflt
            call exlkex
          else
            call ucopy(q(lcatt+mcval+2), cmin(jcon), mwflt)
          endif

*---- Maximum value.
          lcexp = lq(lcatt-2)
          if (lcexp .ne. 0) then
            call mzcopy(2, lcexp, 2, lcon, -2, 'Z')
            lcexp = lq(lcon-2)
            iq(lcexp+mxsiz*iq(lcexp-3)+mxval) = mconmx + (jcon-1)*mwflt
            call exlkex
          else
            call ucopy(q(lcatt+mcsiz+mcval+2), cmax(jcon), mwflt)
          endif

*---- Constraint type and weight.
          icc(jcon) = iq(lcatt+2)
          cwgt(jcon) = wgt(jcon)

*---- Not constrained.
        else
          icc(jcon) = 0
          cmin(jcon) = 0.0
          cmax(jcon) = 0.0
          cwgt(jcon) = 0.0
        endif
   20 continue

*---- Count constraints.
      flwarn = .false.
      do 30 jcon = 1, maxval
        if (cwgt(jcon) .eq. 0.0) then
          icc(jcon) = 0
        else
          nfun = nfun + 1
*---- Tor: check for linear constraints
          if (jcon .gt. maxlin .and. jcon .lt. energy_val) then
            flchrm = .true.
            flwarn = .true.
          endif
        endif
   30 continue

*---- Tor: warn user that no coupling can be present.
      if (flwarn) then
        msg(1) = 'You have selected a chromatic function for matching.'
        msg(2) = 'The match module will IGNORE any coupling.'
        call aawarn('MTCONS', 2, msg)
      endif

*---- Copy data to constraint bank.
      call ucopy(icc, iq(lcon+mcontp), maxval)
      call ucopy(cmin, iq(lcon+mconmn), maxval*mwflt)
      call ucopy(cmax, iq(lcon+mconmx), maxval*mwflt)
      call ucopy(cwgt, iq(lcon+mconwt), maxval*mwflt)

*---- Link constraint to proper places.
      imsequ = 1
      call mtacon(ipos1, 2, 0, error)
      call mtacon(ipos2, 3, nfun, error)
      ifirst = 0
      icovar = 0
      flbeta = .true.

 9999 end
+dk mtderi
      subroutine mtderi(fcn, nf, nx, x, grd, g2, fvec)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find first derivatives of penalty function.                        *
* Input:                                                               *
*   FCN       (subr)    Returns value of penalty function.             *
*   NF        (integer) Number of functions.                           *
*   NX        (integer) Number of parameters.                          *
*   X(NX)     (real)    Parameter values. On output, best estimate.    *
* Output:                                                              *
*   GRD(*)    (real)    Gradient of penalty function                   *
*                       w.r.t. internal parameter values.              *
*   G2(*)     (real)    Second derivatives of penalty function         *
*                       w.r.t. internal parameter values.              *
* Working array:                                                       *
*   FVEC(NF)  (real)    Function values.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer i,icycle,iflag,nf,nx
      double precision eps,f1,f2,fvec,g2,grd,half,one,two,vdot,x,xsave,
     +xstep
      external          fcn
      dimension         x(nx), grd(nx), g2(nx), fvec(nf)
+ca mchpar
+ca minuit

      parameter         (one = 1.0d0, half = 0.5d0, two = 2.0d0)

      eps = sqrt(epsmch)

      do 90 i = 1, nx
        xsave = x(i)
        xstep = eps * abs(xsave)
        if (xstep .eq. 0.0) xstep = eps
        do 50 icycle = 1, 10
          x(i) = xsave + xstep
          call fcn(nf, nx, x, fvec, iflag)
          nfcn = nfcn + 1
          if (iflag .eq. 0) then
            f2 = vdot(nf, fvec, fvec)
            x(i) = xsave - xstep
            call fcn(nf, nx, x, fvec, iflag)
            nfcn = nfcn + 1
            if (iflag .eq. 0) then
              f1 = vdot(nf, fvec, fvec)
              go to 60
            endif
          endif
          xstep = half * xstep
   50   continue
        f2 = fmin
        f1 = fmin
   60   continue
        grd(i) = (f2 - f1) / (two * xstep)
        g2(i) = (f2 - two * fmin + f1) / xstep**2
        if (g2(i) .eq. 0.0) g2(i) = one
        x(i) = xsave
   90 continue

      call mtputi(nx, x)

      end
+dk mtend
      subroutine mtend
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Final matching print-out, ENDMATCH command.                        *
* Attribute:                                                           *
*   INCREMENT    (string)  Save increments made in matching.           *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca matgroup
+ca message
+ca fllink
+ca minuit
+ca mtlink
+ca option
+ca refer
+ca status
+ca wstack
+ca zunit
      integer iflag,iref,iunit,jrow,ltemp,mcol,nrow
      double precision dval,vnew,vold,zero

      parameter         (mcol = 3)
      character*(mcnam) tabnam, cnam(mcol)
      character*(mcfil) filnam
      integer           icfrm(mcol)
      real              dt

      data cnam         / 'NAME', 'ATTRIBUTE', 'VALUE' /

*---- Get attribute.
      tabnam = ' '
      call utgnam(lccmd, 1, 1, tabnam)

*---- Assign working space (no need to keep previous working space).
      iwork = ncon
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Compute and print matching conditions.
      call mtcond(.true., ncon, dq(1), iflag)

*---- Drop links from sequence to constraint banks.
      if (lsmat .ne. 0) call mzdrop(0, lsmat, ' ')

*---- Drop initial values bank; may contain expressions.
      if (lmtbet .ne. 0) call aadrop(lmtbet)

*---- Drop constraints; may contain expanded lines and expressions.
  110 if (lmcon .ne. 0) then

*---- Drop line expansion for "LINE" constraint.
        if (lq(lmcon-1) .ne. 0) call lndrop(lq(lmcon-1))

*---- Drop expression chained to this constraint.
        lcexp = lq(lmcon-2)
  120   if (lcexp .ne. 0) then
          ltemp = lq(lcexp)
          call aadrop(lcexp)
          lcexp = ltemp
          go to 120
        endif

*---- Drop constraint.
        ltemp = lq(lmcon)
        call aadrop(lmcon)
        lmcon = ltemp
        go to 110
      endif

*---- Write increment file.
      if (tabnam .ne. ' ') then

*---- Build internal table.
        nrow  = 0
        lvar = lmvar
  130   if (lvar .ne. 0) then
          nrow  = nrow + 1
          lvar = lq(lvar)
          go to 130
        endif

        icfrm(1) = 5
        icfrm(2) = 5
        icfrm(3) = 3
        if (double) icfrm(3) = mreal
        call tbcrea(tabnam, 1, nrow, mcol, cnam, icfrm, 1, lfltab)
        call tbpdsc(lfltab, 'TYPE', 5, 0, zero, 'INCREMENTS')
        lvar = lmvar

        do 140 jrow = 1, nrow
          call tbset(lfltab, jrow, 3, lflbuf)
          call ucopy(q(lvar+mmbnam), q(lflbuf+1), mwnam)
          call ucopy(q(lvar+mmvnam), q(lflbuf+mwnam+1), mwnam)
          lref = lq(lvar-1)
          iref = iq(lvar+mmbias)
          call utgflt(lref, iref, iref, vnew)
          call ucopy(q(lvar+mmold), vold, mwflt)

          if (double) then
            dval = vnew - vold
            call ucopy(dval, q(lflbuf+2*mwnam+1), mwflt)
          else
            q(lflbuf+2*mwnam+1) = vnew - vold
          endif

          lvar = lq(lvar)
  140   continue

*---- Write table in TFS format.
        call tbclos(lfltab)
        filnam = tabnam
        call flopen(filnam, 'SWFD', 0, 0, iunit, error)
        if (.not. error) then
          call tbwtfs(tabnam, iunit)
          call flname(iunit, filnam)
          call flclos(iunit, error)
          if (.not. error) then
            msg(1) = 'Increments written on file: ' // filnam
            call aainfo('MTEND', 1, msg)
          endif
        endif
        call tbopen(tabnam, 0, lfltab)
        call tbdrop(lfltab)
      endif

*---- Drop variables.
      if (lmvar .ne. 0) call mzdrop(0, lmvar, 'L')

*---- Drop initial value line.
      if (lmtlin .ne. 0) call lndrop(lmtlin)

*---- Release working space.
      iwork = 0
      nwork = 0
      call mzwork(0, dq(1), dq(1), - 1)
      if (trace) then
        call timex(time2)
        dt = time2 - time1
        write (msg, 920) time2, dt
        call aainfo('MTEND', 1, msg)
      endif

  910 format('Last value of the penalty function:',1p,e14.6)
  920 format('End matching mode, time = ',f12.3,
     +       ', time for matching = ',f12.3,' seconds')

 9999 end
+dk mtfcn
      subroutine mtfcn(nf, nx, x, fval, iflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Compute matching functions.                                        *
* Input:                                                               *
*   NF        (integer) Number of functions to be computed.            *
*   NX        (integer) Number of input parameters.                    *
*   X(NX)     (real)    Input parameters.                              *
* Output:                                                              *
*   FVAL(NF)  (real)    Matching functions computed.                   *
*   IFLAG     (integer) Stability flag.                                *
*----------------------------------------------------------------------*
+ca aparam
      integer iflag,nf,nx
      double precision fval,x
      dimension         x(nx), fval(nf)

*---- Store parameter values in data structure.
      call mtputi(nx, x)

*---- Compute matching functions.
      call mtcond(.false., nf, fval, iflag)

 9999 end
+dk mtfix
      subroutine mtfix
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   FIX command.                                                       *
* Attribute:                                                           *
*   NAME     (name)    Variable to be fixed.                           *
*----------------------------------------------------------------------*
+ca aparam
+ca minuit
+ca mtlink
+ca refer
+ca wstack
      logical       skip

*---- Variable name required.
      call mtvfnd('FIX', skip)
      if (.not. skip) then

*---- Is parameter variable?
        if (lvar .eq. 0) then
          call rdwarn('MTFIX', 1,
     +    'Parameter is not variable --- FIX command ignored.')

*---- Remove parameter from variable list.
        else
          call mzdrop(0, lvar, '.')
          nvar = nvar - 1

*---- Mark working space as outdated.
          iwork = 0
          nwork = 0
          icovar = 0
        endif
      endif

      end
+dk mtgeti
      subroutine mtgeti(nx, x, dx)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Get internal parameter values from external ones.                  *
*   Also return steps sizes in terms of internal values.               *
*   This routine also marks all dependent elements for dropping maps.  *
* Input:                                                               *
*   X(NX)     (real)    Internal parameter values.                     *
*   DX(NX)    (real)    Internal step sizes.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,iref,ivar,nx
      double precision arg1,arg2,dx,eps,stplim,vval,x
      dimension         x(nx), dx(nx)
+ca memdum
+ca cmdgroup
+ca matgroup
+ca markbits
+ca ablink
+ca mtlink
+ca mtcvar
+ca refer

      parameter         (eps = 1.0d-10, stplim = 2.0d-1)

*---- Loop over variables.
      lvar = lmvar
      ivar = 0
   10 if (lvar .ne. 0) then
        lref = lq(lvar-1)
        iref = iq(lvar+mmbias)

*---- Fetch internal value.
        call utgflt(lref, iref, iref, vval)

*---- Mark bank as dependent.
        call aamark('MTGETI', lref)

*---- Convert to unlimited value
        call ucopy(q(lvar+mmdata), vstep, 3*mwflt)
        ivar = ivar + 1
        if (iq(lvar+2) .eq. 0) then
          x(ivar) = vval
          dx(ivar) = abs(vstep)
        else if (iq(lvar+2) .eq. 1) then
          arg1 = max(vval - vmin, eps)
          x(ivar) = sqrt(arg1)
          dx(ivar) = max(min(abs(vstep / arg1), stplim), eps) * x(ivar)
        else if (iq(lvar+2) .eq. 2) then
          arg2 = max(vmax - vval, eps)
          x(ivar) = sqrt(arg2)
          dx(ivar) = max(min(abs(vstep / arg2), stplim), eps) * x(ivar)
        else
          arg1 = max(vval - vmin, eps)
          arg2 = max(vmax - vval, eps)
          x(ivar) = asin((arg1 - arg2) / (arg1 + arg2))
          dx(ivar) = abs(vstep) / sqrt(arg1 * arg2)
          if (dx(ivar) .gt. stplim) dx(ivar) = stplim
          if (dx(ivar) .lt. eps) dx(ivar) = eps
        endif

*---- Next variable.
        lvar = lq(lvar)
        go to 10
      endif

*---- Propagate marks on dependent elements.
      call exupdt

*---- Propagate marks on dependent lumps.
      call difind(ldkey, 'LUMP', idir, laakey)
      laacur = lq(laakey-1)
   20 if (laacur .ne. 0) then
        call lnpmod(laacur)
        laacur = lq(laacur)
        go to 20
      endif

      end
+dk mtgwgt
      subroutine mtgwgt
      implicit none
*----------------------------------------------------------------------*
* Attributes:                                                          *
*   q1       (const.)   weight on tune of mode 1                       *
*   q2       (const.)   weight on tune of mode 2                       *
*   q1'      (const.)   weight on chromaticity of mode 1               *
*   q2'      (const.)   weight on chromaticity of mode 2               *
*   q1''     (const.)   weight on nonlinear chromaticity of mode 1     *
*   q2''     (const.)   weight on nonlinear chromaticity of mode 2     *
*   dq1de1   (const.)   weight on anharmonicity of mode 1              *
*   dq1de2   (const.)   weight on cross anharmonicity                  *
*   dq2de2   (const.)   weight on anharmonicity of mode 2              *
*   dtune    (const.)   weight on fast detuning.                       *
*   tunx     (const.)   weight on fast tune of mode x.                 *
*   tuny     (const.)   weight on fast tune of mode y.                 *
*   dynapfrac(const.)   weight on fractional dynamic aperture.         *
*   smear    (const.)   weight on smear.                               *
*   turns    (const.)   weight on number of survival turns.            *
*   lyapunov (const.)   weight on Lyapunov exponent                    *
*   xend     (const.)   weight on xend                                 *
*   pxend    (const.)   weight on pxend                                *
*   yend     (const.)   weight on yend                                 *
*   pyend    (const.)   weight on pyend                                *
*   tend     (const.)   weight on tend                                 *
*   ptend    (const.)   weight on ptend                                *
*   wxmin    (const.)   weight on wxmin                                *
*   wxmax    (const.)   weight on wxmax                                *
*   wymin    (const.)   weight on wymin                                *
*   wymax    (const.)   weight on wymax                                *
*   wxymin   (const.)   weight on wxymin                               *
*   wxymax   (const.)   weight on wxymax                               *
*   formula  (const.)   weight on user-defined formula                 *
*----------------------------------------------------------------------*
+ca aparam
+ca refer
+ca mtglob

*---- Copy data to local storage.
      call utgflt(lccmd, 1, 29, gpesi)

      end
+dk mthess
      subroutine mthess(fcn, nf, nx, covar, x, grd, g2, fvec, wa)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Build covariance matrix.                                           *
* Input:                                                               *
*   FCN       (subr)    Returns value of penalty function.             *
*   NF        (integer) Number of functions.                           *
*   NX        (integer) Number of parameters.                          *
*   X(NX)     (real)    Parameter values. On output, best estimate.    *
* Output:                                                              *
*   COVAR(NX,NX)        Covariance matrix.
*   GRD(NX)   (real)    Gradient of penalty function                   *
*                       w.r.t. internal parameter values.              *
*   G2(NX)    (real)    Second derivatives of penalty function         *
*                       w.r.t. internal parameter values.              *
* Working array:                                                       *
*   FVEC(NF)  (real)    Function values.                               *
*   WA(NX,2)  (real)    Working vectors.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer i,icycle,iflag,j,nf,nx
      double precision covar,eps,f1,f2,fij,fvec,g2,grd,half,one,two,
     +vdot,wa,x,xs1,xs2,xsave,xstep
      external          fcn
      dimension         covar(nx,nx), x(nx), grd(nx), g2(nx), wa(nx,2)
      dimension         fvec(nf)
      logical           eflag
+ca mchpar
+ca minuit

      parameter         (one = 1.0d0, half = 0.5d0, two = 2.0d0)

      eps = sqrt(epsmch)

      do 60 i = 1, nx
        xsave = x(i)
        xstep = eps * max(abs(xsave), one)
        do 30 icycle = 1, 10
          x(i) = xsave + xstep
          call fcn(nf, nx, x, fvec, iflag)
          nfcn = nfcn + 1
          if (iflag .eq. 0) then
            f2 = vdot(nf, fvec, fvec)
            x(i) = xsave - xstep
            call fcn(nf, nx, x, fvec, iflag)
            nfcn = nfcn + 1
            if (iflag .eq. 0) then
              f1 = vdot(nf, fvec, fvec)
              go to 40
            endif
          endif
          xstep = half * xstep
   30   continue
        f1 = fmin
        f2 = fmin
   40   continue
        grd(i) = (f2 - f1) / (two * xstep)
        g2(i) = (f2 - two * fmin + f1) / xstep**2
        if (g2(i) .eq. 0.0) g2(i) = one
        x(i) = xsave
        covar(i,i) = g2(i)
        wa(i,1) = f2
        wa(i,2) = xstep
   60 continue

*---- Off-diagonal elements.
      do 90 i = 1, nx - 1
        xs1 = x(i)
        x(i) = xs1 + wa(i,2)
        do 80 j = i + 1, nx
          xs2 = x(j)
          x(j) = xs2 + wa(j,2)
          call fcn(nf, nx, x, fvec, iflag)
          nfcn = nfcn + 1
          if (iflag .eq. 0) then
            fij = vdot(nf, fvec, fvec)
            covar(i,j) = (fij+fmin-wa(i,1)-wa(j,1)) / (wa(i,2)*wa(j,2))
            covar(j,i) = covar(i,j)
          else
            covar(i,j) = 0.0
            covar(j,i) = 0.0
          endif
          x(j) = xs2
   80   continue
        x(i) = xs1
   90 continue

*---- Restore original point.
      call mtputi(nx, x)

*---- Ensure positive definiteness and invert.
      call mtpsdf(covar, nx)
      call symsol(covar, nx, eflag)

      end
+dk mtinit
      subroutine mtinit
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initialize matching module.                                        *
*----------------------------------------------------------------------*
* Modified: 07-JAN-1999, T. Raubenheimer (SLAC)                        *
*   Changed MAXVAL = 26 -> MAXVAL = 27; added ENERGY weight = 1 to     *
*   initial values; set initial weights for 2nd order terms to zero    *
* Modified: 04-MAR-1999, T. Raubenheimer (SLAC)                        *
*   Changed MAXVAL = 27 -> MAXVAL = 28; added CIRC weight = 1 to       *
*   initial values                                                     *
* Modified: 25-MAR-1999, M. Woodley (SLAC)                             *
*   Set default weight = 0 for ENERGY and CIRC                         *
* Modified: 03-MAY-1999, M. Woodley (SLAC)                             *
*   Change size of IGFLAG array (in /MTIRGO/) from 30 to 31            *
* Modified: 14-JUL-1999, T. Raubenheimer (SLAC)                        *
*   Changed MAXVAL = 28 -> MAXVAL = 36; added /SYNCH/ common block     *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca seqgroup
+ca mtpara
+ca minuit
+ca mtcflg
+ca mtcwgt
+ca mtglob
+ca mtlink
+ca refer
+ca wstack
+ca synch
      integer imtflg,nl,i,locpt
      double precision piby2,worig

+ca pi
      parameter         (piby2 = pi / 2.0d0)
      dimension         worig(maxval)

*---- DATA WORIG        /  BETX,  ALFX,   MUX,  BETY,  ALFY,   MUY,
*                             X,    PX,     Y,    PY,     T,    PT,
*                            DX,   DPX,    DY,   DPY,
*                            WX,  PHIX,  DMUX,    WY,  PHIY,  DMUY,
*                           DDX,  DDPX,   DDY,  DDPY,
*                        ENERGY,  CIRC,    I1,    I2,    I3,    I4,
*                            I5,  I5I2,  I5I1,  DUMM  /

      data worig        /   1.0,  10.0,  10.0,   1.0,  10.0,  10.0,
     +                     10.0, 100.0,  10.0, 100.0,  10.0, 100.0,
     +                     10.0, 100.0,  10.0, 100.0,
     +                      0.0,   0.0,   0.0,   0.0,   0.0,   0.0,
     +                      0.0,   0.0,   0.0,   0.0,
     +                      0.0,   0.0,   0.0,   0.0,   0.0,   0.0,
     +                      0.0,   0.0,   0.0,   0.0  /
      data imtflg       / 0 /
      save              imtflg

*---- Initialize global matching weights.
      gpesi(1)  = 10.
      gpesi(2)  = 10.
      gpesi(3)  = 1.
      gpesi(4)  = 1.
      gpesi(5)  = .1
      gpesi(6)  = .1
      gpesi(7)  = .01
      gpesi(8)  = .01
      gpesi(9)  = .01
      gpesi(10) = 100.
      gpesi(11) = 10.
      gpesi(12) = 10.
      gpesi(13) = 10.
      gpesi(14) = 1.
      gpesi(15) = 0.1
      gpesi(16) = 1.
      gpesi(17) = 1.
      gpesi(18) = 1.
      gpesi(19) = 1.
      gpesi(20) = 1.
      gpesi(21) = 1.
      gpesi(22) = 1.
      gpesi(23) = 1.
      gpesi(24) = 1.
      gpesi(25) = 1.
      gpesi(26) = 1.
      gpesi(27) = 1.
      gpesi(28) = 1.
      gpesi(29) = 1.

*---- Initialize link area.
      if (imtflg .eq. 0) then
        call mzlink(0, '/MTLINK/', lsmat, lmtlin, lptr)
        imtflg = 1
      else
        lsmat = 0
        lmcon = 0
        lmvar = 0
        lmtlin = 0
        lmtbet = 0
        lbeta0(1) = 0
        lbeta0(2) = 0
        lcon  = 0
        lref  = 0
        lvar  = 0
        lptr  = 0
      endif

*---- Lift banks for linking constraints
      if (mtdbfl .eq. 0)  then
        nl = iq(lq(lcseq-msdir)-1)
      else
        nl = 0
        do i = 1, mtdbfl
          if (sequd(i) .ne. ' ') call get_active(sequd(i), 'MTINIT')
          nl = max(nl, iq(lq(lcseq-msdir)-1))
        enddo
      endif
      call mzbook(2, lsmat, lsmat, 1, 'SMAT', 2, 2, 0, 0, 0)
      do i = 1, 2
        call mzbook(2, locpt, lsmat, -i, 'MSUB', nl, nl, 0, 2, 0)
      enddo
*---- Matching flags.
      flbeta = .false.
      florb  = .false.
      flrmat = .false.
      fltmat = .false.
      flchrm = .false.

*---- Default matching weights.
      call ucopy(worig, wgt, maxval*mwflt)

*---- Matching counters and switches.
      ilevel = 1
      istrat = 1
      ncon = 0
      nvar = 0
      nfcn = 0
      nfcnmx = 0
      icall = 0
      icovar = 0
      ifirst = 0
      iwork = 0
      nwork = 0

*---- Clear counters for user constraints.
      nuglob = 0
      nuloc = 0

*---- Initial matching parameters.
      call timex(time1)
      fmin = 1.0d5
      tol = 1.0d-8
      up = 1.0
      edm = 1.0d5 * up

      end
+dk mtline
      subroutine mtline(fcn, nf, nx, x, dx, fvec, xsave, iflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Search for minimum along predicted direction.                      *
* Input:                                                               *
*   FCN       (subr)    Returns value of penalty function.             *
*   NF        (integer) Number of functions.                           *
*   NX        (integer) Number of parameters.                          *
*   X(NX)     (real)    Parameter values. On output, best estimate.    *
*   DX(NX)    (real)    Initial direction.                             *
*   FVEC(NF)  (real)    Function values.                               *
*   IFLAG     (integer) Error flag.                                    *
* Working array:                                                       *
*   XSAVE(NX) (real)    Save area for initial point.                   *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iflag,ipt,maxpt,nf,npts,nvmax,nx
      double precision alpha,c1,c2,den,dx,f3,fval,fvec,fvmin,half,one,
     +overal,ratio,s13,s21,s32,slam,slamax,slambg,slamin,sval,svmin,
     +tol8,tol9,two,undral,vdot,x,xsave
      external          fcn
      dimension         x(nx), dx(nx), fvec(nf), xsave(nx)
+ca minuit
+ca mchpar

      dimension         sval(3), fval(3)

      parameter         (alpha = 2.0d0, slambg = 5.0d0)
      parameter         (one = 1.0d0, two = 2.0d0, half = 0.5d0)
      parameter         (maxpt = 12)

*---- Initialize.
      overal = 1000.0
      undral = - 100.0
      sval(1) = 0.0
      fval(1) = fmin
      svmin = 0.0
      fvmin = fmin
      npts = 0

      slamin = 0.0
      do 10 i = 1, nx
        xsave(i) = x(i)
        if (dx(i) .ne. 0.0) then
          ratio = abs(x(i) / dx(i))
          if (slamin .eq. 0.0  .or.  ratio .lt. slamin) slamin = ratio
        endif
   10 continue
      if (slamin .eq. 0.0) slamin = epsmch
      slamin = slamin * epsmch
      slamax = slambg
      tol8 = 0.05d0

*---- Compute function for move by DX.
      slam = one
   20 continue
      sval(2) = slam
      do 30 i = 1, nx
        x(i) = xsave(i) + slam * dx(i)
   30 continue
      call fcn(nf, nx, x, fvec, iflag)
      nfcn = nfcn + 1
      npts = npts + 1

*---- If machine becomes unstable, cut step.
      if (iflag .ne. 0) then
        slam = half * slam
        if (slam .gt. slamin) go to 20
        go to 400
      endif
      fval(2) = vdot(nf, fvec, fvec)
      if (fval(2) .lt. fvmin) then
        svmin = sval(2)
        fvmin = fval(2)
      endif
      if (slam .lt. one) go to 400

*---- Compute function for move by 1/2 DX.
      slam = half * slam
      sval(3) = slam
      do 50 i = 1, nx
        x(i) = xsave(i) + slam * dx(i)
   50 continue
      call fcn(nf, nx, x, fvec, iflag)
      nfcn = nfcn + 1
      npts = npts + 1
      if (iflag .ne. 0) go to 400
      fval(3) = vdot(nf, fvec, fvec)
      if (fval(3) .lt. fvmin) then
        svmin = sval(3)
        fvmin = fval(3)
      endif

*---- Begin iteration.
  200 continue
        slamax = max(slamax, alpha * abs(svmin))

*---- Quadratic interpolation using three points.
        s21 = sval(2) - sval(1)
        s32 = sval(3) - sval(2)
        s13 = sval(1) - sval(3)
        den = s21 * s32 * s13
        c2 = (s32 * fval(1) + s13 * fval(2) + s21 * fval(3)) / den
        c1 = ((sval(3) + sval(2)) * s32 * fval(1) +
     +        (sval(1) + sval(3)) * s13 * fval(2) +
     +        (sval(2) + sval(1)) * s21 * fval(3)) / den
        if (c2 .ge. 0.0) then
          slam = svmin + sign(slamax, c1 - two * c2 * svmin)
        else
          slam = c1 / (two * c2)
          if (slam .gt. svmin + slamax) slam = svmin + slamax
          if (slam .le. svmin - slamax) slam = svmin - slamax
        endif
        if (slam .gt. 0.0) then
          if (slam .gt. overal) slam = overal
        else
          if (slam .lt. undral) slam = undral
        endif

*---- See if new point coincides with a previous one.
  300   continue
        tol9 = tol8 * max(one, slam)
        do 310 ipt = 1, 3
          if (abs(slam - sval(ipt)) .lt. tol9) go to 400
  310   continue

*---- Compute function for interpolated point.
        do 320 i = 1, nx
          x(i) = xsave(i) + slam * dx(i)
  320   continue
        call fcn(nf, nx, x, fvec, iflag)
        nfcn = nfcn + 1
        npts = npts + 1
        if (iflag .ne. 0) go to 400
        f3 = vdot(nf, fvec, fvec)

*---- Find worst point of previous three.
        nvmax = 1
        if (fval(2) .gt. fval(nvmax)) nvmax = 2
        if (fval(3) .gt. fval(nvmax)) nvmax = 3

*---- If no improvement, cut interval.
        if (f3 .ge. fval(nvmax)) then
          if (npts .ge. maxpt) go to 400
          if (slam .gt. svmin) overal = min(overal, slam - tol8)
          if (slam .le. svmin) undral = max(undral, slam + tol8)
          slam = half * (slam + svmin)
          go to 300
        endif

*---- Accept new point; replace previous worst point.
        sval(nvmax) = slam
        fval(nvmax) = f3
        if (f3 .lt. fvmin) then
          svmin = slam
          fvmin = f3
        else
          if (slam .gt. svmin) overal = min(overal, slam - tol8)
          if (slam .lt. svmin) undral = max(undral, slam + tol8)
        endif
      if (npts .lt. maxpt) go to 200

*---- Common exit point: Return best point and step used.
  400 continue
      fmin = fvmin
      do 410 i = 1, nx
        dx(i) = svmin * dx(i)
        x(i) = xsave(i) + dx(i)
  410 continue
      call mtputi(nx, x)

*---- Return Failure indication.
      iflag = 0
      if (svmin .eq. 0.0) iflag = 2

      end
+dk mtlmdf
      subroutine mtlmdf
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   LMDIF command.                                                     *
* Attributes:                                                          *
*   TOLERANCE (real)    Final tolerance for match.                     *
*   CALLS     (integer) Call limit to penalty function.                *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca minuit
+ca refer
+ca status
+ca wstack
      integer idiag,idx,ifjac,ifvec,ipvt,iqtf,iwa1,iwa2,iwa3,iwa4,ixvec,
     +ncalls

      external          mtfcn
      logical           skip

*---- Insert parameters.
      tol = 1.0d-8
      call utgflt(lccmd, 1, 1, tol)
      ncalls = 1000
      call utgint(lccmd, 2, 2, ncalls)

*---- Any constraints?
      skip = .false.
      if (ncon .eq. 0) then
        call aawarn('MTLMDF', 1, 'No constraints seen.')
        skip = .true.
      endif

*---- Any variable parameters?
      if (nvar .eq. 0) then
        call aawarn('MTLMDF', 1, 'No variables seen.')
        skip = .true.
      endif

*---- Too many variable parameters.
      if (nvar .gt. ncon) then
        call aawarn('MTLMDF', 1, 'LMDIF command cannot handle'
     +  // ' problems with more parameters than constraints.')
        skip = .true.
      endif
      if (skip .or. error .or. scan) go to 9999

*---- Allocate working space.
      ixvec  = iwork
      idx    = ixvec  + nvar
      ifvec  = idx    + nvar
      idiag  = ifvec  + ncon
      ifjac  = idiag  + nvar
      ipvt   = ifjac  + nvar * ncon
      iqtf   = ipvt   + nvar
      iwa1   = iqtf   + nvar
      iwa2   = iwa1   + nvar
      iwa3   = iwa2   + nvar
      iwa4   = iwa3   + nvar
      iwork  = iwa4   + ncon
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- CALL Minimization routine.
      nfcnmx = nfcnmx + ncalls
      call mtgeti(nvar, dq(ixvec+1), dq(idx+1))
      call lmdif(mtfcn, ncon, nvar, dq(ixvec+1), dq(ifvec+1),
     +           tol, dq(idiag+1), 1.0d0,
     +           dq(ifjac+1), ncon, dq(ipvt+1), dq(iqtf+1),
     +           dq(iwa1+1), dq(iwa2+1), dq(iwa3+1), dq(iwa4+1))

 9999 end
+dk mtmain
      subroutine mtmain(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Control routine for matching.                                      *
* Input:                                                               *
*   IPR       (integer) Process code.                                  *
*   ISP       (integer) Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca message
+ca minuit
+ca refer
+ca status
      integer ipr,isp

*---- Check valid use of command.
      if (isp .le. 2  .and.  imodul .ne. 0) then
        msg(1) =
     +  'Cannot initiate matching while previous process not complete,'
        msg(2) = 'Enter proper ENDxxxx command first.'
        call aafail('MTMAIN', 2, msg)
      else if (isp .gt. 2  .and.  imodul .ne. ipr) then
        msg(1) =
     +  'Cannot run match subcommand outside matching process,'
        msg(2) = 'CELL or MATCH command required first.'
        call aafail('MTMAIN', 2, msg)

*---- MATCH: Initiate insertion-matching process.
      else if (isp .eq. 1) then
        call mtmtch
        if (.not. error) then
          imodul = ipr
        endif

*---- CELL: Initiate cell-matching process.
      else if (isp .eq. 2) then
        call mtcell
        if (.not. error) then
          imodul = ipr
        endif

*---- ENDMATCH: End cell or insertion matching process.
      else if (isp .eq. 3) then
        call mtend
        imodul = 0

*---- MIGRAD: Gradient minimization.
      else if (isp .eq. 4) then
        call mtmigr

*---- SIMPLEX: Simplex minimization.
      else if (isp .eq. 5) then
        call mtsimp

*---- CONSTRAINT: Constraint.
      else if (isp .eq. 6) then
        call mtcons

*---- COUPLE: Sub-period constraint.
      else if (isp .eq. 7) then
        call mtcple

*---- FIX: Fix a variable parameter.
      else if (isp .eq. 8) then
        call mtfix

*---- LEVEL: Set print level.
      else if (isp .eq. 9) then
        call utgint(lccmd, 1, 1, ilevel)

*---- VARY: Variable parameter.
      else if (isp .eq. 10) then
        call mtvary

*---- WEIGHT: Set matching weights.
      else if (isp .eq. 11) then
        call mtweig

*---- LMDIF: Minimize by LMDIF method.
      else if (isp .eq. 12) then
        call mtlmdf

*---- RMATRIX: Match R matrix.
      else if (isp .eq. 13) then
        call mtrmat

*---- TMATRIX: Match T matrix.
      else if (isp .eq. 14) then
        call mttmat

*---- GLOBAL: User constraint.
      else if (isp .eq. 15) then
        call mtucon

*---- GWEIGHT: Global User weights.
      else if (isp .eq. 16) then
        call mtgwgt

*---- Unassigned subprocess codes.
      else
        call usercm(ipr, isp)
      endif

      end
+dk mtmigr
      subroutine mtmigr
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   MIGRAD command.                                                    *
* Attributes:                                                          *
*   TOLERANCE (real)    Final tolerance for match.                     *
*   CALLS     (integer) Call limit to penalty function.                *
*   STRATEGY  (integer) Strategy selection (see MINUIT manual).        *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca message
+ca minuit
+ca refer
+ca status
+ca wstack
      integer icov,idx,ifvec,iwa,ixvec,ncalls

      external          mtfcn
      logical           skip

*---- Insert parameters.
      tol = 1.0d-8
      call utgflt(lccmd, 1, 1, tol)
      ncalls = 1000
      call utgint(lccmd, 2, 2, ncalls)
      istrat = 1
      call utgint(lccmd, 3, 3, istrat)

*---- Any constraints?
      skip = .false.
      if (ncon .eq. 0) then
        call aawarn('MTMIGR', 1, 'No constraints seen.')
        skip = .true.
      endif

*---- Any variable parameters?
      if (nvar .eq. 0) then
        call aawarn('MTMIGR', 1, 'No variables seen.')
        skip = .true.
      endif
      if (skip .or. error .or. scan) go to 9999

*---- Too many variable parameters?
      if (nvar .gt. ncon) then
        msg(1) = 'More variables than constraints seen,'
        msg(2) = 'MIGRAD may not converge to optimal solution.'
        call aawarn('MTMIGR', 2, msg)
      endif

*---- Assign working space.
      ixvec = iwork
      idx   = ixvec + nvar
      ifvec = idx   + nvar
      icov  = ifvec + ncon
      iwa   = icov  + nvar * nvar
      iwork = iwa   + nvar * 7
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Call minimization routine.
      nfcnmx = nfcnmx + ncalls
      call mtgeti(nvar, dq(ixvec+1), dq(idx+1))
      call mtmig1(mtfcn, ncon, nvar, dq(ixvec+1), dq(idx+1),
     +            dq(ifvec+1), dq(icov+1), dq(iwa+1))

*---- Release working space.
      iwork = ixvec

 9999 end
+dk mtmig1
      subroutine mtmig1(fcn, nf, nx, x, dx, fvec, covar, wa)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Minimization by MIGRAD method by Davidon/Fletcher/Powell.          *
*   (Computer Journal 13, 317 (1970).                                  *
* Input:                                                               *
*   FCN       (subr)    Returns value of penalty function.             *
*   NF        (integer) Number of functions.                           *
*   NX        (integer) Number of parameters.                          *
*   X(NX)     (real)    Parameter values. On output, best estimate.    *
*   DX(NX)    (real)    Parameter errors. On output, error estimate.   *
* Output:                                                              *
*   FVEC(NF)  (real)    Vector of function values in best point.       *
* Working arrays:                                                      *
*   COVAR(NX,NX)        Covariance matrix.                             *
*   WA(NX,7)            Working vectors.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iflag,improv,iter,j,level,mflnu,mg2,mgrd,mgsave,mvg,
     +mxsave,nf,npsdf,nrstrt,nx
      double precision covar,d,delgam,dgi,dx,eps1,eps2,fvec,gdel,gssq,
     +gvg,half,sum,two,vdot,vgi,wa,x
      external          fcn
      logical           eflag
      dimension         x(nx), dx(nx), fvec(nf), covar(nx,nx), wa(nx,7)
+ca message
+ca mchpar
+ca minuit

      parameter         (two = 2.0d0, half = 0.5d0)
      parameter         (eps1 = 1.0d-3, eps2 = 1.0d-4)

      parameter         (mgrd = 1, mg2 = 2, mvg = 3)
      parameter         (mflnu = 5, mgsave = 6, mxsave = 7)

*---- Initialize penalty function.
      call fcn(nf, nx, x, fvec, iflag)
      nfcn = nfcn + 1
      if (iflag .ne. 0) then
        msg(1) = 'Matching stopped -- start point seems to be unstable,'
        msg(2) = '(Maybe a "LINE = ..." condition is unstable).'
        call aawarn('MTMIG1', 2, msg)
        cstat = 'unstable'
        go to 500
      endif
      fmin = vdot(nf, fvec, fvec)
      edm = fmin

*---- Start MIGRAD algorithm.
      crout = 'MIGRAD'
      cstat = 'start'
      nrstrt = 0
      npsdf = 0

*---- Come here to restart algorithm.
  100 continue
      if (istrat .eq. 2  .or.  istrat.gt.2 .and. icovar.lt.2) then
        call mthess(fcn, nf, nx, covar, x, wa(1,mgrd), wa(1,mg2), fvec,
     +              wa(1,mvg))
        npsdf = 0
      else
        call mtderi(fcn, nf, nx, x, wa(1,mgrd), wa(1,mg2), fvec)
        if (icovar .lt. 2) then
          do 120 i = 1, nx
            do 110 j = 1, nx
              covar(i,j) = 0.0
  110       continue
            if (wa(i,mg2) .eq. 0.0) wa(i,mg2) = 1.0
            covar(i,i) = 1.0 / wa(i,mg2)
  120     continue
        endif
      endif

*---- Initialize for first iteration.
      improv = 0
      edm = 0.0
      do 160 i = 1, nx
        sum = 0.0
        do 150 j = 1, nx
          sum = sum + covar(i,j) * wa(j,mgrd)
  150   continue
        edm = edm + sum * wa(i,mgrd)
  160 continue
      edm = min(half * edm, fmin)

*---- Print after initialization.
      if (ilevel .ge. 1) then
        call mtprnt(nx, x)
      endif
      iter = 0

*==== Start main iteration loop: Check for call limit.
  200 if (nfcn .lt. nfcnmx) then

*---- Find step size according to Newton's method.
        gdel = 0.0
        gssq = 0.0
        do 220 i = 1, nx
          sum = 0.0
          wa(i,mgsave) = wa(i,mgrd)
          gssq = gssq + wa(i,mgrd)**2
          do 210 j = 1, nx
            sum = sum + covar(i,j) * wa(j,mgrd)
  210     continue
          dx(i) = - sum
          gdel = gdel + dx(i) * wa(i,mgrd)
  220   continue

*---- First derivatives all zero?
        if (gssq .eq. 0.0) go to 400

*---- If GDEL .GE. 0 matrix is not positive definite.
        if (gdel .ge. 0.0) then
          cstat = 'not posdef'
          if (npsdf .eq. 0) then
            call symsol(covar, nx, eflag)
            call mtpsdf(covar, nx)
            call symsol(covar, nx, eflag)
            npsdf = 1
            go to 200
          else
            nrstrt = nrstrt + 1
            if (nrstrt .gt. istrat) go to 500
            go to 100
          endif
        endif

*---- Search for minimum along predicted line.
        call mtline(fcn, nf, nx, x, dx, fvec, wa(1,mxsave), iflag)

*---- No improvement found.
        if (iflag .ne. 0) then
          if (edm .lt. eps1 * tol) go to 400
          cstat = 'accuracy limit'
          if (edm .lt. two * epsmch * fmin) go to 500
          if (istrat .eq. 0  .and.  nrstrt .eq. 0) then
            istrat = 1
            nrstrt = 1
            cstat = 'restart'
            go to 100
          endif
          cstat = 'failed'
          go to 500
        endif

*---- Find gradient in new point.
        call mtderi(fcn, nf, nx, x, wa(1,mgrd), wa(1,mg2), fvec)
        npsdf = 0

*---- Estimated distance to minimum.
  300   continue
        edm = 0.0
        gvg = 0.0
        delgam = 0.0
        do 320 i = 1, nx
          vgi = 0.0
          sum = 0.0
          do 310 j = 1, nx
            vgi = vgi + covar(i,j) * (wa(j,mgrd) - wa(j,mgsave))
            sum = sum + covar(i,j) * wa(j,mgrd)
  310     continue
          wa(i,mvg) = vgi
          dgi = wa(i,mgrd) - wa(i,mgsave)
          gvg = gvg + vgi * dgi
          delgam = delgam + dx(i) * dgi
          edm = edm + sum * wa(i,mgrd)
  320   continue
        edm = min(half * edm, fmin)

*---- Test for convergence and print-out.
        if (edm .ge. 0.0  .and.  edm .lt. eps2 * tol) go to 400
        iter = iter + 1
        level = 3
        if (mod(iter,10) .eq. 0) level = 2
        if (ilevel .ge. level) then
          cstat = 'progress'
          call mtprnt(nx, x)
        endif

*---- Force positive definiteness.
        if (edm .lt. 0.0  .or. gvg .le. 0.0) then
          cstat = 'not posdef'
          icovar = 0
          if (npsdf .eq. 1) go to 500
          call symsol(covar, nx, eflag)
          call mtpsdf(covar, nx)
          call symsol(covar, nx, eflag)
          npsdf = 1
          go to 300
        endif

*---- Update covariance matrix.
        do 330 i = 1, nx
        do 330 j = 1, nx
          d = dx(i) * dx(j) / delgam - wa(i,mvg) * wa(j,mvg) / gvg
          covar(i,j) = covar(i,j) + d
  330   continue
        if (delgam .gt. gvg) then
          do 340 i = 1, nx
            wa(i,mflnu) = dx(i) / delgam - wa(i,mvg) / gvg
  340     continue
          do 350 i = 1, nx
          do 350 j = 1, nx
            d = gvg * wa(i,mflnu) * wa(j,mflnu)
            covar(i,j) = covar(i,j) + d + d
  350     continue
        endif
        improv = improv + 1
        if (improv .ge. nx) icovar = 3
        go to 200
      endif

*---- Call limit reached.
      cstat = 'call limit'
      icall = 1
      go to 500

*==== End of main iteration loop; Check covariance matrix.
  400 continue
      if (istrat .ge. 2  .or.  (istrat.eq.1 .and. icovar.lt.3)) then
        cstat = 'verify'
        call mthess(fcn, nf, nx, covar, x, wa(1,mgrd), wa(1,mg2), fvec,
     +              wa(1,mvg))
        npsdf = 0
        cstat = 'restart'
        if (edm .gt. eps1 * tol) go to 100
      endif
      cstat = 'converged'
      if (icovar .eq. 2) cstat = 'not posdef'
      if (icovar .lt. 2) cstat = 'uncertain'

*---- Common exit point; final print-out.
  500 continue
      call mtputi(nx, x)
      if (ilevel .ge. 1) call mtprnt(nx, x)

      end
+dk mtmtch
      subroutine mtmtch
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Main routine for insertion matching.                               *
* Attributes:                                                          *
*   BETX     (real)    Horizontal beta.                                *
*   ALFX     (real)    Horizontal alpha.                               *
*   MUX      (real)    Horizontal phase.                               *
*   BETY     (real)    Vertical beta.                                  *
*   ALFY     (real)    Vertical alpha.                                 *
*   MUY      (real)    Vertical phase.                                 *
*   X        (real)    Horizontal orbit.                               *
*   PX       (real)    Horizontal orbit slope.                         *
*   Y        (real)    Vertical orbit.                                 *
*   PY       (real)    Vertical orbit slope.                           *
*   T        (real)    Longitudinal orbit.                             *
*   PT       (real)    Momentum error.                                 *
*   DX       (real)    Horizontal dispersion.                          *
*   DPX      (real)    Horizontal dispersion slope.                    *
*   DY       (real)    Vertical dispersion.                            *
*   DPY      (real)    Vertical dispersion slope.                      *
*   WX       (real)    Horizontal chromatic amplitude.                 *
*   PHIX     (real)    Horizontal chromatic phase.                     *
*   DMUX     (real)    Horizontal chromatic derivative of MUX.         *
*   WY       (real)    Vertical chromatic amplitude.                   *
*   PHIY     (real)    Vertical chromatic phase.                       *
*   DMUY     (real)    Vertical chromatic derivative of MUY.           *
*   DDX      (real)    Horizontal 2nd dispersion.                      *
*   DDPX     (real)    Horizontal 2nd dispersion slope.                *
*   DDY      (real)    Vertical 2nd dispersion.                        *
*   DDPY     (real)    Vertical 2nd dispersion slope.                  *
*   ENER1     (real)                                                    *
*   CIRC     (real)                                                    *
*   I1       (real)                                                    *
*   I2       (real)                                                    *
*   I3       (real)                                                    *
*   I4       (real)                                                    *
*   I5       (real)                                                    *
*   I5I2     (real)                                                    *
*   I5I1     (real)                                                    *
*   DUMM     (real)                                                    *
*   sequence (2 names) match to these (1 or 2) sequences
*   BETA0    (name)    BETA0 module containing initial conditions.     *
*----------------------------------------------------------------------*
* Modified: 07-JAN-1999, T. Raubenheimer (SLAC)                        *
*   Added energy attribute; noted additional chromatic attributes in   *
*   header comments; changed MAXVAL = 26 -> MAXVAL = 27                *
* Modified: 04-MAR-1999, T. Raubenheimer (SLAC)                        *
*   Added CIRC attribute; changed MAXVAL = 27 -> MAXVAL = 28           *
* Modified: 14-JUL-1999, T. Raubenheimer (SLAC)                        *
*   Changed MAXVAL = 28 -> MAXVAL = 34; added /SYNCH/ common block     *
*   Changed MAXVAL = 34 -> MAXVAL = 36; T.R. ?                         *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca strgroup
+ca message
+ca beam
+ca mtpara
+ca minuit
+ca mtcflg
+ca mtlink
+ca range
+ca refer
+ca status
+ca zunit
+ca datatype

      integer srange
      common / tmptmp/ srange(2,10)

      double precision deltap
      integer ibeta,icat,idata,ikey,ileng,iline,ipr,isp,mbeta,mdelta,
     +mline,morbit,msequ
      parameter         (mline  = maxval + 1, msequ = maxval + 2,
     +                   mbeta  = maxval + 4,
     +                   mdelta = maxval + 6, morbit = maxval + 7)
      logical           linflg
      integer i

*---- Is main beam line set?
      call lnchck('MTMTCH', error)
      if (error) go to 9999

*---- Set up for insertion matching.
      do i = 1, 2
        sequd(i) = ' '
      enddo
*---- Name of sequence(s).
      call utgnam(lccmd, msequ, msequ+1, sequd)
      if (sequd(2) .eq. ' ')  then
        mtdbfl = 1
      else
        mtdbfl = 2
      endif
      call mtinit
      imode = 2
      do i = 1, 2
        betnm(i) = ' '
      enddo
*---- Name of BETA0 module(s).
      call utgnam(lccmd, mbeta, mbeta+1, betnm)
      iline = mbat + (mline - 1) * mcsiz
      linflg = mod(iq(lccmd+iline+mctyp),10) .ne. 0
      do i = 1, mtdbfl
        bdtflg(i) = betnm(i) .ne. ' '
*---- Check consistency.
        if (bdtflg(i)) then
          call utleng(betnm(i), ileng)
          call difind(ldbnk, betnm(i)(1:ileng), ibeta, ldummy(i))
          if (ldummy(i) .eq. 0) then
            msg(1) = 'Initial BETA0 bank "' // betnm(i)(1:ileng)
     +      // '" not found.'
            call aafail('MTMTCH', 1, msg)
          else if (iq(ldummy(i)+mbpr).ne.mpenv
     +    .or. iq(ldummy(i)+mbsp).ne.2) then
            msg(1) = '"' // betnm(i)(1:ileng)
     +               // '" is not a "BETA0" bank.'
            call aafail('MTMTCH', 1, msg)
          else if (linflg) then
            call aafail('MTMTCH', 1,
     +      'Conflicting options BETA0 and LINE have been specified.')
          endif
        else
          ldummy(i) = 0
        endif
      enddo
*---- Line attribute.
      if (error) go to 9999
      if (linflg) call lnrefe(lccmd, mline, lmtlin, lmtlin, 1)

*---- Energy error.
      deltap = 0.0
      call utgflt(lccmd, mdelta, mdelta, deltap)
      florb = .false.
      call utglog(lccmd, morbit, morbit, florb)

*---- Build temporary BETA0 bank to hold initial conditions.
      call difind(ldkey, 'BETA0', ikey, lckey)
      ipr = iq(lckey+mbpr)
      isp = iq(lckey+mbsp)
      do i = 1, mtdbfl
        call aabook(lbeta0(i), 'BETA', ipr, isp, lckey, 1)
*---- If BETA0 given, use it, but overwrite with data from command bank.
        if (ldummy(i) .ne. 0) then
          idata = mbat
          do icat = 1, maxval
            if (mod(iq(lccmd+idata+mctyp),10) .ne. 0) then
              if (icat .gt. 6  .and.  icat .le. 12) florb = .true.
              call aacopy(lccmd, icat, lbeta0(i))
            else
              call aacopy(ldummy(i), icat, lbeta0(i))
            endif
            idata = idata + mcsiz
          enddo
*---- Otherwise copy command bank.
        else
          do icat = 1, maxval
            call aacopy(lccmd, icat, lbeta0(i))
          enddo
        endif
      enddo
*---- Initial output.
      if (error) go to 9999
      do i = 1, mtdbfl
        if (sequd(i) .ne. ' ' .and. sequd(i) .ne. sequnam)
     +  call get_active(sequd(i), 'MTMTCH')
        call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)
        srange(1,i) = irg1
        srange(2,i) = irg2
        if (i .eq. 1) call prpage(iqpr2)
        call utleng(linnam, ileng)
        write (iqpr2, 910) linnam(1:ileng), rngnam, deltap
        call prline(iqpr2)
      enddo
      call aainfo('MTMTCH', 1, 'Begin insertion matching mode.')

*---- Make sure environment is set up.
      call enfix

  910 format(' Matching beam line "',a,'" as an insertion',t84,
     +       'Range:',a/' delta(p)/p = ',f12.6)

 9999 end
+dk mtpini
      subroutine mtpini(iflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initial conditions for penalty function computation.               *
* Output:                                                              *
*   IFLAG     (integer) Stability flag.                                *
*----------------------------------------------------------------------*
* Modified: 07-JAN-1999, T. Raubenheimer (SLAC)                        *
*   Changed MAXVAL = 26 -> MAXVAL = 27; added energy constraint to     *
*   CMIN; added energy constraint for lines; copied ENER0 data to ENER1 *
*   at end                                                             *
* Modified: 04-MAR-1999, T. Raubenheimer (SLAC)                        *
*   Changed MAXVAL = 27 -> MAXVAL = 28                                 *
* Modified: 14-JUL-1999, T. Raubenheimer (SLAC)                        *
*   Changed MAXVAL = 28 -> MAXVAL = 34; added /SYNCH/ common block;    *
*   zero all synchrotron integrals                                     *
* Modified: 09-SEP-1999, M. Woodley (SLAC)                             *
*   Enforce consistency between initial energy values in /BEAFLT/,     *
*   /OPTIC0/, and /OPTIC1/ common blocks                               *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca seqgroup
+ca beam
+ca mtpara
+ca minuit
+ca mtccon
+ca mtcflg
+ca mtlink
+ca optic0
+ca optic1
+ca option
+ca refer
+ca status
+ca stflag
+ca synch
      integer i,iflag
      double precision zero, one, twopi

+ca pi
      parameter         (zero = 0.d0, one = 1.d0, twopi  = 2.0d0 * pi)
      logical           eflag

*---- Set flags to use ideal orbit for calculation,
*     if ORBIT flag was not set.
      if (.not. florb) then
        do 5 i = 1, maxdof
          doflag(i) = .false.
    5   continue
      endif

*---- Fill in constraints.
      iflag = 1
      eflag = .false.
      lcon = lmcon
  100 if (lcon .ne. 0) then

*---- CONSTRAINT with LINE option?
*     link 1 of constraint bank is structural link to sequence bank.
        lmtseq = lq(lcon-1)
        if (lmtseq .ne. 0) then
          if (florb) then
            call tmclor(lmtseq, deltas, .false., error)
            if (error) go to 800
          else
            call tmrefe(lmtseq)
            call uzero(orbit0, 1, 6*mwflt)
          endif
          if (flchrm) then
            call tmscnd(lmtseq)
            call twbtin(lmtseq, .true., eflag)
            iflag = 0
            if (eflag) iflag = 1
          else
            call mtbtin(iflag)
          endif
          if (iflag .ne. 0) go to 9999
          call ucopy(q(lcon+mconmn), cmin, maxval*mwflt)
          cmin(1) = betx0
          cmin(2) = alfx0
          cmin(4) = bety0
          cmin(5) = alfy0
          call ucopy(orbit0, cmin(7), 6*mwflt)
          call ucopy(disp0, cmin(13), 4*mwflt)
          if (flchrm) then
            cmin(14) = wx0
            cmin(15) = phix0
            cmin(16) = dmux0 * twopi
            cmin(17) = wy0
            cmin(18) = phiy0
            cmin(19) = dmuy0 * twopi
            call ucopy(disp, cmin(23), 4*mwflt)
          endif
          cmin(27) = ener0
          cmin(28) = circ
          cmin(29) = zero
          cmin(30) = zero
          cmin(31) = zero
          cmin(32) = zero
          cmin(33) = zero
          cmin(34) = zero
          cmin(35) = zero
          cmin(36) = zero
          call ucopy(cmin, q(lcon+mconmn), maxval*mwflt)
        endif
        lcon = lq(lcon)
        go to 100
      endif

*---- Initial values for beam line.
      r0mat(1,1) = zero
      r0mat(1,2) = zero
      r0mat(2,1) = zero
      r0mat(2,2) = zero
*---- IMODE=1 -> CELL command; IMODE=2 -> MATCH command
      if (imode .eq. 2) then

*---- "LINE =..." initial condition.
        if (lmtlin .ne. 0) then
          if (florb) then
            call tmclor(lmtlin, deltas, .false., error)
            if (error) go to 800
          else
            call tmrefe(lmtlin)
            call uzero(orbit0, 1, 6*mwflt)
          endif
          if (flchrm) then
            call tmscnd(lmtlin)
            call twbtin(lmtlin, .true., eflag)
            iflag = 0
            if (eflag) iflag = 1
          else
            call mtbtin(iflag)
          endif
          if (iflag .ne. 0) go to 9999

*---- Otherwise set up defaults.
        else
          call uzero(betx0, 1, 36*mwflt)
          betx0 = one
          bety0 = one
          disp0(6) = one
        endif

*---- Overwrite with given values.
        call utgflt(lmtbet,  1,  6, betx0)
        amux0 = amux0 * twopi
        amuy0 = amuy0 * twopi
        call utgflt(lmtbet,  7, 12, orbit0)
        call utgflt(lmtbet, 13, 16, disp0)
        if (flchrm) then
          call utgflt(lmtbet, 17, 22, wx0)
          dmux0 = dmux0 * twopi
          dmuy0 = dmuy0 * twopi
          call utgflt(lmtbet, 23, 26, ddisp0)
        endif
        call utgflt(lmtbet, 27, 27, ener0)
        call utgflt(lmtbet, 28, 28, circ)
        iflag = 0
        if (betx0 .eq. zero  .or.  bety0 .eq. zero) iflag = 1
*---- Set up the initial energy value.
*     NOTE: if the initial energy value is not specified (either
*           explicitly by command attribute or implicitly via a
*           "BETA0="), reset the BEAM bank energy and use it; if the
*           initial energy value has been specified, set the BEAM bank
*           energy equal to it and recompute the relativistic
*           quantities
        if (ener0 .eq. zero) then
          call enget
          ener0 = en0
        else
          en0 = ener0
          pc = sqrt(en0**2 - amass**2)
          gamma = en0 / amass
          beta = pc / en0
        endif

*---- DELTAP command attribute doesn't seem to be used ... see MTMTCH
        deltas = zero
        gammas = gamma
        betas = beta
*---- Periodic initial conditions.
      else
        if (florb) then
          call tmclor(lcseq, deltas, .false., error)
          if (error) go to 800
        else
          call tmrefe(lcseq)
          call uzero(orbit0, 1, 6*mwflt)
        endif
        if (iq(lcseq+msym) .ne. 0) call tmmksm(.false.)
        if (flchrm) then
          call tmscnd(lcseq)
          call twbtin(lcseq, .true., eflag)
          iflag = 0
          if (eflag) iflag = 1
        else
          call mtbtin(iflag)
        endif
        if (iflag .ne. 0) go to 9999
      endif

*---- Copy to current values.
      call ucopy(betx0, betx, 18*mwflt)
      if (flchrm) call ucopy(wx0, wx, 12*mwflt)
      suml = circ
      ener1 = ener0
      if (ener1 .eq. zero .or. .not. ereset) ener1 = en0
*---- initialize synchrotron integrals to zero
      synch_1 = zero
      synch_2 = zero
      synch_3 = zero
      synch_4 = zero
      synch_5 = zero
      rmat(1,1) = r0mat(1,1)
      rmat(1,2) = r0mat(1,2)
      rmat(2,1) = r0mat(2,1)
      rmat(2,2) = r0mat(2,2)

*---- Failure to find closed orbit.
  800 error = .false.

 9999 end
+dk mtpmod
      subroutine mtpmod
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Delete precomputed maps for all elements marked as changed.        *
* Local links (only Zebra operations called are MZDROP):               *
*   LAACUR              Element.                                       *
*   LAAKEY              Keyword.                                       *
*   LMAP                Transfer map.                                  *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca markbits
+ca prcgroup
+ca seqgroup
+ca strgroup
+ca message
+ca ablink
+ca option
+ca refer
+ca status
      integer jbit,lmap

      character*(mcnam) bnknam

*---- Drop one-turn maps (always done).
      if (lcseq .ne. 0) then
        if (lq(lcseq-msmap) .ne. 0) then
          if (debug) then
            call aainfo('MTPMOD', 1,
     +      'Dropping TRANSPORT map for main beam line.')
          endif
          call mzdrop(0, lq(lcseq-msmap), 'L')
        endif
        if (lq(lcseq-mslie) .ne. 0) then
          if (debug) then
            call aainfo('MTPMOD', 1,
     +      'Dropping Lie algebraic map for main beam line.')
          endif
          call mzdrop(0, lq(lcseq-mslie), 'L')
        endif
      endif

*---- Parameters and elements: Loop over all keywords
      laakey = lq(lq(lroot-mrkey)-1)
   30 if (laakey .ne. 0) then

*---- Element keyword: Loop over daughters and drop maps for marked elements.
        if (iq(laakey+mbpr) .eq. mpelm) then
          laacur = lq(laakey-1)
   40     if (laacur .ne. 0) then
            if (debug) then
              if (iq(laacur+mbnam) .eq. 0) then
                bnknam = 'Unnamed'
              else
                call diname(ldbnk, iq(laacur+mbnam), bnknam)
                if (bnknam .eq. ' ') bnknam = 'Unnamed'
              endif
            endif
            if (jbit(iq(laacur),mxmod) .ne. 0) then
              lmap = lq(laacur-iq(laacur+mbat)-mbemap)
              if (lmap .ne. 0) then
                if (debug) then
                  msg(1) = 'Dropping TRANSPORT map for line: '
     +            // bnknam
                  call aainfo('MTPMOD', 1, msg)
                endif
                call mzdrop(0, lmap, '.')
              endif
              lmap = lq(laacur-iq(laacur+mbat)-mbelie)
              if (lmap .ne. 0) then
                if (debug) then
                  msg(1) = 'Dropping Lie algebraic map for line: '
     +            // bnknam
                  call aainfo('MTPMOD', 1, msg)
                endif
                call mzdrop(0, lmap, '.')
              endif
            endif
            laacur = lq(laacur)
            go to 40
          endif
        endif

*---- Next keyword.
        laakey = lq(laakey)
        go to 30
      endif

      end
+dk mtprnt
      subroutine mtprnt(nx, x)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print minimum information.                                         *
* Input:                                                               *
*   NX        (integer) Number of variables.                           *
*   X(NX)     (real)    Variable vector.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer jref,nx
      double precision vval,x
      dimension         x(nx)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca matgroup
+ca mtlink
+ca mtcvar
+ca minuit
+ca zunit

      character*(mcnam) bnknam, atrnam
      real              time

      call timex(time)
      write (iqpr2, 910) crout, time, nfcn, cstat, fmin, edm

      lvar = lmvar
   10 if (lvar .ne. 0) then
        lref = lq(lvar-1)
        jref = mbat + (iq(lvar+mmbias) - 1) * mcsiz
        call ucopy(q(lref+jref+mcval), vval, mwflt)
        call ucopy(q(lvar+mmdata), vstep, 3*mwflt)
        call uhtoc(q(lvar+mmbnam), mcwrd, bnknam, mcnam)
        call uhtoc(q(lvar+mmvnam), mcwrd, atrnam, mcnam)
        write (iqpr2, 920) bnknam, atrnam, vval, vstep, vmin, vmax
        lvar = lq(lvar)
        go to 10
      endif

  910 format(' '/' Command: ',a,t31,'Time: ',f12.3,t61,'Calls: ',i8,
     +       t91,'Status: ',a/' Penalty function: ',t35,1p,e14.6,
     +       t61,'Estimated distance to minimum: ',e14.6/
     +       ' '/' Element',t21,'attribute',t45,'value',t61,'step',
     +       t77,'lower',t93,'upper')
  920 format(' ',a,t21,a,t41,1p,4e16.6)

      end
+dk mtpsdf
      subroutine mtpsdf(covar, nx)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Force covariance matrix to be positive definite.                   *
* Updated:                                                             *
*   COVAR(*,*)        Covariance matrix.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ieigen,ip,nval,nx
      double precision add,covar,eps,one,pmax,pmin
      dimension  covar(nx,nx)
+ca memdum
+ca mchpar
+ca minuit
+ca wstack

      parameter         (one = 1.0d0, eps = 1.0d-3)

*---- Allocate working space.
      ip     = iwork
      ieigen = ip + nx * nx
      iwork  = ieigen + nx
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Copy matrix and find eigenvalues.
      call ucopy(covar, dq(ip+1), mwflt * nx * nx)
      call symeig(dq(ip+1), nx, nx, dq(ieigen+1), nval)

*---- Enforce positive definiteness.
      pmin = dq(ieigen+1)
      pmax = dq(ieigen+1)
      do 10 i = 1, nx
        if (dq(ieigen+i) .lt. pmin) pmin = dq(ieigen+i)
        if (dq(ieigen+i) .gt. pmax) pmax = dq(ieigen+i)
   10 continue
      pmax = max(abs(pmax), one)
      if (pmin .le. epsmch * pmax) then
        add = eps * pmax - pmin
        do 30 i = 1, nx
          covar(i,i) = covar(i,i) + add
   30   continue
        cstat = 'not posdef'
      endif

*---- Release working space.
      iwork = ip

      end
+dk mtputi
      subroutine mtputi(nx, x)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Set external parameter values from internal ones.                  *
* Input:                                                               *
*   X(NX)     (real)    Internal parameter values.                     *
*----------------------------------------------------------------------*
+ca aparam
      integer iref,ivar,nx
      double precision vval,x
      dimension         x(nx)
+ca memdum
+ca cmdgroup
+ca matgroup
+ca mtlink
+ca mtcvar

      lvar = lmvar
      ivar = 0
   10 if (lvar .ne. 0) then
        lref = lq(lvar-1)
        call ucopy(q(lvar+mmdata), vstep, 3*mwflt)
        ivar = ivar + 1
        if (iq(lvar+2) .eq. 0) then
          vval = x(ivar)
        else if (iq(lvar+2) .eq. 1) then
          vval = vmin + x(ivar)**2
        else if (iq(lvar+2) .eq. 2) then
          vval = vmax - x(ivar)**2
        else
          vval = ((vmin + vmax) + (vmax - vmin) * sin(x(ivar))) / 2.0
        endif
        lref = lq(lvar-1)
        iref = iq(lvar+mmbias)
        call utpflt(lref, iref, iref, vval)
        lvar = lq(lvar)
        go to 10
      endif

*---- Update dependent variables.
      call exupdt

*---- Drop precomputed maps which became obsolete.
      call mtpmod

      end
+dk mtrazz
      subroutine mtrazz(nvrr, fnew, pnew, fsim, psim, jh, jl)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Replace vertex in simplex whose function is highest.               *
*   Return indices of new best and worst points.                       *
* Input:                                                               *
*   NVAR      (integer) Number of parameters.                          *
*   FNEW      (real)    Function value for new vertex.                 *
*   PNEW(*)   (real)    Coordinates of new vertex.                     *
* Updated:                                                             *
*   FSIM(*)   (real)    Function values in (NVAR + 1) vertices.        *
*   PSIM(*,*) (real)    Coordinates of (NVAR + 1) vertices.            *
*   JH        (integer) Index of highest function value.               *
*   JL        (integer) Index of lowest function value.                *
*----------------------------------------------------------------------*
+ca aparam
      integer i,jh,jl,nvrr
      double precision fnew,fsim,pnew,psim
      dimension         pnew(nvrr), fsim(0:nvrr), psim(nvrr,0:nvrr)
+ca minuit

*---- Replace vertex with highest function value.
      do 10 i = 1, nvrr
        psim(i,jh) = pnew(i)
   10 continue
      fsim(jh) = fnew

*---- Find indices of lowest and highest function value.
      jl = 0
      jh = 0
      do 20 i = 1, nvrr
        if (fsim(i) .lt. fsim(jl)) jl = i
        if (fsim(i) .gt. fsim(jh)) jh = i
   20 continue

*---- Get best value and estimated distance to minimum.
      fmin = fsim(jl)
      edm = min(10.0 * (fsim(jh) - fmin), fmin)

      end
+dk mtrmat
      subroutine mtrmat
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Match R matrix; RMATRIX command.                                   *
* Attributes:                                                          *
*   RANGE    (range)   Where to apply the constraint.                  *
*   RM(6,6)  (real)    Desired values for matrix elements.             *
*   W(6,6)   (real)    Matching weights.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca mtcflg
+ca mtlink
+ca mtcmtx
+ca minuit
+ca refer
+ca status
+ca datatype
      integer idata,idest,ilink,ipos1,ipos2,irmat,irwgt,jcon,nd,nfun

*---- Valid range required.
      idata = mbat
      if (iq(lccmd+idata+mctyp) .ne. 10*mtrng + 1) then
        call aafail('MTRMAT', 1, 'RMATRIX command requires a RANGE.')
        go to 9999
      endif
      lcatt = lq(lccmd-1)
      call utgrng(lcatt, lcseq, ipos1, ipos2, error)
      if (error) go to 9999

*---- Lift constraint bank.
*     NOTE. First link must always be zero (see MTPINI).
      nd = 3 * 36 * mwflt
      call mzbook(2, lcon, lmcon, 1, 'RMAT', 4, 2, nd, mreal, 0)
      nfun = 0

*---- Fill in constraint data and copy expressions.
      ilink = 2
      irmat = mbat + mcsiz
      irwgt = irmat + 36 * mcsiz
      idest = 36 * mwflt + 1
      do 10 jcon = 1, 36
        if (mod(iq(lccmd+irmat+mctyp),10) .ne. 0) then
          lcexp = lq(lccmd-ilink)
          if (lcexp .ne. 0) then
            call mzcopy(2, lcexp, 2, lcon, -2, 'Z')
            lcexp = lq(lcon-2)
            iq(lcexp+mxsiz*iq(lcexp-3)+mxval) = idest
            call exlkex
          else
            call ucopy(q(lccmd+irmat+mcval), rtdes(jcon), mwflt)
          endif
          if (mod(iq(lccmd+irwgt+mctyp),10) .ne. 0) then
            call ucopy(q(lccmd+irwgt+mcval), rtwgt(jcon), mwflt)
          else
            rtwgt(jcon) = 1.0
          endif
          nfun = nfun + 1
        else
          rtdes(jcon) = 0.0
          rtwgt(jcon) = 0.0
        endif
        ilink = ilink + 1
        irmat = irmat + mcsiz
        irwgt = irwgt + mcsiz
        idest = idest + mwflt
   10 continue

*---- Copy data to constraint bank.
*     Leave space for inverted accumulated matrix.
      call ucopy(rtdes, q(lcon+36*mwflt+1), 36*mwflt)
      call ucopy(rtwgt, q(lcon+(36+36)*mwflt+1), 36*mwflt)

*---- Link constraint to proper places.
      imsequ = 1
      call mtacon(ipos1, 4, 0, error)
      call mtacon(ipos2, 5, nfun, error)
      ifirst = 0
      icovar = 0
      flrmat = .true.

 9999 end
+dk mtsimp
      subroutine mtsimp
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Control routine for simplex minimization; SIMPLEX command.         *
* Attributes:                                                          *
*   CALLS     (integer) Call limit for penalty function calls.         *
*   TOLERANCE (real)    Tolerance desired.                             *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca message
+ca minuit
+ca refer
+ca status
+ca wstack
      integer idx,ifsim,ifvec,ipsim,iwa,ixvec,ncalls

      external          mtfcn
      logical           skip

*---- Retrieve attributes.
      tol = 1.0d-6
      call utgflt(lccmd, 1, 1, tol)
      ncalls = 1000
      call utgint(lccmd, 2, 2, ncalls)

*---- Any constraints?
      skip = .false.
      if (ncon .eq. 0) then
        call aawarn('MTSIMP', 1, 'No constraints seen.')
        skip = .true.
      endif

*---- Any variable parameters?
      if (nvar .eq. 0) then
        call aawarn('MTSIMP', 1, 'No variables seen.')
        skip = .true.
      endif
      if (skip .or. error .or. scan) go to 9999

*---- Too many variable parameters?
      if (nvar .gt. ncon) then
        msg(1) = 'More variables than constraints seen,'
        msg(2) = 'SIMPLEX may not converge to optimal solution.'
        call aawarn('MTSIMP', 2, msg)
      endif

*---- Assign working space.
      ixvec = iwork
      idx   = ixvec + nvar
      ifvec = idx   + nvar
      ipsim = ifvec + ncon
      ifsim = ipsim + nvar * (nvar + 1)
      iwa   = ifsim + nvar + 1
      iwork = iwa   + nvar * 4
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Call minimization routine.
      nfcnmx = nfcnmx + ncalls
      call mtgeti(nvar, dq(ixvec+1), dq(idx+1))
      call mtsim1(mtfcn, ncon, nvar, dq(ixvec+1), dq(idx+1),
     +            dq(ifvec+1), dq(ipsim+1), dq(ifsim+1), dq(iwa+1))

*---- Release working space.
      iwork = ixvec

 9999 end
+dk mtsim1
      subroutine mtsim1(fcn, nf, nx, x, dx, fvec, psim, fsim, wa)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Minimization using the SIMPLEX method by Nelder and Mead.          *
*   (Computer Journal 7, 308 (1965).                                   *
* Input:                                                               *
*   FCN       (subr)    Returns value of function to be minimized.     *
*   NF        (integer) Number of functions.                           *
*   NX        (integer) Number of parameters.                          *
*   X(NX)     (real)    Parameter values. On output, best estimate.    *
*   DX(NX)    (real)    Parameter errors. On output, error estimate.   *
* Output:                                                              *
*   FVEC(NF)  (real)    Vector of function values in best point.       *
* Working arrays:                                                      *
*   PSIM(NX,0:NX)       Coordinates of simplex vertices.               *
*   FSIM(0:NX)          Function values in simplex vertices.           *
*   WA(NX,4)            Working vectors.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer i,idir,iflag,j,jh,jhold,jl,k,level,mbar,mrho,mstar,mstst,
     +ncycl,nf,nrstrt,ns,nx
      double precision alpha,beta,dx,eps,f,f1,f2,fbar,fbest,frho,
     +fsim,fstar,fstst,fvec,gamma,pb,pbest,pmax,pmin,psim,rho,rho1,rho2,
     +rhomax,rhomin,step,two,vdot,wa,x
      external          fcn
      dimension         x(nx), dx(nx), fvec(nf)
      dimension         psim(nx,0:nx), fsim(0:nx), wa(nx,4)
+ca message
+ca mchpar
+ca minuit

      parameter         (alpha  = 1.0d0)
      parameter         (beta   = 0.5d0)
      parameter         (gamma  = 2.0d0)
      parameter         (rhomin = 4.0d0, rhomax = 8.0d0)
      parameter         (rho1   = 1.0d0 + alpha)
      parameter         (rho2   = rho1 + alpha * gamma)
      parameter         (eps    = 1.0d-8)
      parameter         (two    = 2.0d0)

      parameter         (mbar = 1, mstar = 2, mstst = 3, mrho = 4)

*---- Initialize penalty function.
      crout = 'SIMPLEX'
      cstat = 'start'
      call fcn(nf, nx, x, fvec, iflag)
      nfcn = nfcn + 1
      if (iflag .ne. 0) then
        msg(1) = 'Matching stopped -- start point seems to be unstable,'
        msg(2) = '(Maybe a "LINE = ..." condition is unstable).'
        call aawarn('MTSIM1', 2, msg)
        cstat = 'unstable'
        go to 400
      endif
      fmin = vdot(nf, fvec, fvec)
      edm = fmin
      nrstrt = 0

*---- Choose the initial simplex using single-parameter searches.
*     Keep initial point in PBAR.
  100 continue
      if (ilevel .ge. 1) call mtprnt(nx, x)
      fbar = fmin
      do 180 i = 1, nx
        wa(i,mbar) = x(i)
        pbest = x(i)
        fbest = fmin
        step  = dx(i)

*---- Find proper initial direction and step.
        do 110 idir = 1, 12
          x(i) = pbest + step
          call fcn(nf, nx, x, fvec, iflag)
          nfcn = nfcn + 1
          if (iflag .eq. 0) then
            f = vdot(nf, fvec, fvec)
            if (f .le. fbest) go to 120
          endif
          if (mod(idir,2) .eq. 0) step = 0.1 * step
          step = - step
  110   continue
        go to 160

*---- Improvement found; attempt increasing steps.
  120   continue
        do 130 ns = 1, 3
          pbest = x(i)
          fbest = f
          step = step * 3.0
          x(i) = x(i) + step
          call fcn(nf, nx, x, fvec, iflag)
          nfcn = nfcn + 1
          if (iflag .ne. 0) go to 140
          f = vdot(nf, fvec, fvec)
          if (f .gt. fbest) go to 140
  130   continue
        go to 160

*---- Backtrack to best point.
  140   continue
        x(i) = pbest
        f = fbest

*---- Store local minimum in i'th direction.
  160   continue
        fsim(i) = f
        do 170 k = 1, nx
          psim(k,i) = x(k)
  170   continue
  180 continue

*---- Store initial point as 0'th vertex.
      jh = 0
      call mtrazz(nvar, fbar, wa(1,mbar), fsim, psim, jh, jl)

*---- Extract best point.
      do 190 i = 1, nx
        x(i) = psim(i,jl)
  190 continue

*---- Print-out after setting up simplex.
      if (ilevel .ge. 2) then
        cstat = 'progress'
        call mtprnt(nx, x)
      endif
      ncycl = 0

*==== Start main loop.
  200 continue
      if (edm .lt. tol) then
        cstat = 'converged'
      else if (nfcn .gt. nfcnmx) then
        cstat = 'call limit'
        icall = 1
      else

*---- Calculate PBAR and P*.
        do 220 i = 1, nx
          pb = psim(i,0)
          do 210 j = 1, nx
            pb = pb + psim(i,j)
  210     continue
          wa(i,mbar) = (pb - psim(i,jh)) / float(nx)
          wa(i,mstar) = wa(i,mbar) + alpha * (wa(i,mbar) - psim(i,jh))
  220   continue
        call fcn(nf, nx, wa(1,mstar), fvec, iflag)
        nfcn = nfcn + 1
        if (iflag .ne. 0) then
          fstar = two * fsim(jh)
        else
          fstar = vdot(nf, fvec, fvec)
        endif

*---- Point P* is better than point PSIM(*,JL).
        jhold = jh
        if (fstar .lt. fsim(jl)) then

*---- Try expanded point P**.
          do 230 i = 1, nx
            wa(i,mstst) = wa(i,mbar) + gamma * (wa(i,mstar)-wa(i,mbar))
  230     continue
          call fcn(nf, nx, wa(1,mstst), fvec, iflag)
          nfcn = nfcn + 1
          if (iflag .ne. 0) then
            fstst = two * fsim(jh)
            rho = 0.0
          else
            fstst = vdot(nf, fvec, fvec)

*---- Fit a parabola through FSIM(JH), F*, F**; minimum = RHO.
            f1 = (fstar - fsim(jh)) * rho2
            f2 = (fstst - fsim(jh)) * rho1
            rho = 0.5 * (rho2 * f1 - rho1 * f2) / (f1 - f2)
          endif

*---- Minimum inexistent ot too close to PBAR;
*     Use P** if it gives improvement; otherwise use P*.
          if (rho .lt. rhomin) then
            if (fstst .lt. fsim(jl)) then
              call mtrazz(nvar, fstst, wa(1,mstst), fsim, psim,
     +        jh, jl)
            else
              call mtrazz(nvar, fstar, wa(1,mstar), fsim, psim,
     +        jh, jl)
            endif

*---- Usable minimum found.
          else
            if (rho .gt. rhomax) rho = rhomax
            do 240 i = 1, nx
              wa(i,mrho) = psim(i,jh) + rho * (wa(i,mbar) - psim(i,jh))
  240       continue
            call fcn(nf, nx, wa(1,mrho), fvec, iflag)
            nfcn = nfcn + 1
            if (iflag .ne. 0) then
              frho = two * fsim(jh)
            else
              frho = vdot(nf, fvec, fvec)
            endif

*---- Select farthest point which gives decent improvement.
            if (frho .lt. fsim(jl) .and. frho .lt. fstst) then
              call mtrazz(nvar, frho, wa(1,mrho), fsim, psim, jh, jl)
            else if (fstst .lt. fsim(jl)) then
              call mtrazz(nvar, fstst, wa(1,mstst), fsim, psim,
     +        jh, jl)
            else
              call mtrazz(nvar, fstar, wa(1,mstar), fsim, psim,
     +        jh, jl)
            endif
          endif

*---- F* is higher than FSIM(JL).
        else
          if (fstar .lt. fsim(jh)) then
            call mtrazz(nvar, fstar, wa(1,mstar), fsim, psim, jh, jl)
          endif

*---- If F* is still highest value, try contraction,
*     giving point P** = PWRK(*,3).
          if (jhold .eq. jh) then
            do 250 i = 1, nx
              wa(i,mstst) = wa(i,mbar)
     +                    + beta * (psim(i,jh) - wa(i,mbar))
  250       continue
            call fcn(nf, nx, wa(1,mstst), fvec, iflag)
            nfcn = nfcn + 1
            if (iflag .ne. 0) then
              fstst = two * fsim(jh)
            else
              fstst = vdot(nf, fvec, fvec)
            endif

*---- Restart algorithm, if F** is higher; otherwise use it.
            if (fstst .gt. fsim(jh)) then
              cstat = 'failed'
              if (nrstrt .ne. 0) go to 300
              nrstrt = 1
              cstat = 'restart'
              do 260 j = 1, nx
                x(j) = psim(j,jl)
  260         continue
              go to 100
            endif
            call mtrazz(nvar, fstst, wa(1,mstst), fsim, psim, jh, jl)
          endif
        endif

*---- New minimum found.
        if (jl .eq. jhold) then
          nrstrt = 0
          ncycl = ncycl + 1
          level = 3
          if (mod(ncycl,10) .eq. 0) level = 2
          if (ilevel .ge. level) then
            cstat = 'progress'
            call mtprnt(nx, x)
          endif
        endif
        go to 200
      endif

*==== End main loop: Try central point of simplex.
  300 continue
      do 320 i = 1, nx
        pmin = psim(i,0)
        pmax = psim(i,0)
        pb = psim(i,0)
        do 310 j = 1, nx
          pb = pb + psim(i,j)
  310   continue
        wa(i,mbar) = (pb - psim(i,jh)) / float(nx)
        dx(i) = pmax - pmin
  320 continue
      call fcn(nf, nx, wa(1,mbar), fvec, iflag)
      nfcn = nfcn + 1
      if (iflag .eq. 0) then
        fbar = vdot(nf, fvec, fvec)
        if (fbar .lt. fsim(jl)) then
          call mtrazz(nvar, fbar, wa(1,mbar), fsim, psim, jh, jl)
        endif
      endif

*---- Recompute step sizes and extract best point.
      do 340 i = 1, nx
        pmin = psim(i,0)
        pmax = psim(i,0)
        do 330 j = 1, nx
          pmin = min(psim(i,j),pmin)
          pmax = max(psim(i,j),pmax)
  330   continue
        dx(i) = pmax - pmin
        x(i) = psim(i,jl)
  340 continue
      fmin = fsim(jl)
      call mtputi(nx, x)

*---- Check for necessity to restart after final change.
      if (nfcn + 3 * nx .lt. nfcnmx  .and.  nrstrt .eq. 0  .and.
     +    fmin .gt. 2.0 * (tol + epsmch)) then
        nrstrt = 1
        cstat = 'restart'
        go to 100
      endif

*---- Final print-out.
  400 continue
      if (ilevel .ge. 1) then
        call mtprnt(nx, x)
      endif

      end
+dk mttmat
      subroutine mttmat
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Match T matrix; TMATRIX command.                                   *
* Attributes:                                                          *
*   RANGE    (range)   Where to apply the constraint.                  *
*   TM(6,6,6)(real)    Desired values for matrix elements.             *
*   W(6,6,6) (real)    Matching weights.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca mtcflg
+ca mtlink
+ca mtcmtx
+ca minuit
+ca refer
+ca status
+ca datatype
      integer idata,idest,ilink,ipos1,ipos2,itmat,itwgt,jcon,nd,nfun

*---- Valid range required.
      idata = mbat
      if (iq(lccmd+idata+mctyp) .ne. 10*mtrng + 1) then
        call aafail('MTTMAT', 1, 'TMATRIX command requires a RANGE.')
        go to 9999
      endif
      lcatt = lq(lccmd-1)
      call utgrng(lcatt, lcseq, ipos1, ipos2, error)
      if (error) go to 9999

*---- Lift constraint bank.
*     NOTE. First link must always be zero (see MTPINI).
      nd = (36 + 3 * 216) * mwflt
      call mzbook(2, lcon, lmcon, 1, 'TMAT', 4, 2, nd, mreal, 0)
      nfun = 0

*---- Fill in constraint data and copy expressions.
      ilink = 2
      itmat = mbat + mcsiz
      itwgt = itmat + 216 * mcsiz
      idest = (36 + 216) * mwflt + 1
      do 10 jcon = 1, 216
        if (mod(iq(lccmd+itmat+mctyp),10) .ne. 0) then
          lcexp = lq(lccmd-ilink)
          if (lcexp .ne. 0) then
            call mzcopy(2, lcexp, 2, lcon, -2, 'Z')
            lcexp = lq(lcon-2)
            iq(lcexp+mxsiz*iq(lcexp-3)+mxval) = idest
            call exlkex
          else
            call ucopy(q(lccmd+itmat+mcval), rtdes(jcon), mwflt)
          endif
          if (mod(iq(lccmd+itwgt+mctyp),10) .ne. 0) then
            call ucopy(q(lccmd+itwgt+mcval), rtwgt(jcon), mwflt)
          else
            rtwgt(jcon) = 1.0
          endif
          nfun = nfun + 1
        else
          rtdes(jcon) = 0.0
          rtwgt(jcon) = 0.0
        endif
        ilink = ilink + 1
        itmat = itmat + mcsiz
        itwgt = itwgt + mcsiz
        idest = idest + mwflt
   10 continue

*---- Copy data to constraint bank.
*     Leave space for inverted accumulated map at beginning.
      call ucopy(rtdes, q(lcon+(36+216)*mwflt+1), 216*mwflt)
      call ucopy(rtwgt, q(lcon+(36+216+216)*mwflt+1), 216*mwflt)

*---- Link constraint to proper places.
      imsequ = 1
      call mtacon(ipos1, 6, 0, error)
      call mtacon(ipos2, 7, nfun, error)
      ifirst = 0
      icovar = 0
      fltmat = .true.

 9999 end
+dk mtucon
      subroutine mtucon
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Constraints on STATIC variables and dynamic aperture (in MTGLOB).  *
* Attributes:                                                          *
*   q1        (const.)   Desired tune of mode 1                        *
*   q2        (const.)   Desired tune of mode 2                        *
*   xi1       (const.)   Desired chromaticity of mode 1                *
*   xi2       (const.)   Desired chromaticity of mode 2                *
*   xin1      (const.)   Desired nonlinear chromaticity of mode 1      *
*   xin2      (const.)   Desired nonlinear chromaticity of mode 2      *
*   dq1de1    (const.)   Desired anharmonicity of mode 1               *
*   dq1de2    (const.)   Desired cross anharmonicity                   *
*   dq2de2    (const.)   Desired anharmonicity of mode 2               *
*   dtune     (const.)   Desired fast detuning over turns/2            *
*   tunx      (const.)   Desired fast tune of mode x                   *
*   tuny      (const.)   Desired fast tune of mode y                   *
*   dynapfrac (const.)   Desired fractional dynamic aperture           *
*   smear     (const.)   Desired smear                                 *
*   turns     (const.)   Desired number of turns (for survival)        *
*   lyapunov  (const.)   Desired Lyapunov exponent                     *
*   xend      (const.)   Desired xend                                  *
*   pxend     (const.)   Desired pxend                                 *
*   yend      (const.)   Desired yend                                  *
*   pyend     (const.)   Desired pyend                                 *
*   tend      (const.)   Desired tend                                  *
*   ptend     (const.)   Desired ptend                                 *
*   wxmin     (const.)   Desired wxmin                                 *
*   wxmax     (const.)   Desired wxmax                                 *
*   wymin     (const.)   Desired wymin                                 *
*   wymax     (const.)   Desired wymax                                 *
*   wxymin    (const.)   Desired wxymin                                *
*   wxymax    (const.)   Desired wxymax                                *
*   formula   (const.)   Desired value for user-defined formula        *
*   call      (name)     Subroutine to be called before formula        *
*   sequence  (name)     name of matched sequence                      *
*   fixpoint  (logical)  flag for fixed point search                   *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca expgroup
+ca prcgroup
+ca message
+ca minuit
+ca mtcflg
+ca mtglob
+ca mtlink
+ca refer
+ca status
+ca zunit
      integer i,k,idir,ileng

      character*(mcnam) newout, subnam, seqnm

*---- Set flag for quick call to LASTAT to compute only tunes
*     and chromaticities (unless nonlinear variables are needed).
      statflag   = .false.
      dynapflag  = .false.
      fixpointfl = .false.

      subnam = ' '
      call utgnam(lccmd, 30, 30, subnam)
*---- get sequence name
      seqnm = ' '
      call utgnam(lccmd, 31, 31, seqnm)
      if (seqnm .ne. ' ')  then
*---  keep sequence pointer
        k = 0
        do i = 1, 2
          if (seqnm .eq. sequd(i))  k = i
        enddo
        if (k .eq. 0)  then
          call utleng(seqnm, ileng)
          msg(1) = 'Global SEQUENCE "' // seqnm(1:ileng)
     +    // '" not in MATCH or CELL command - first sequence used.'
          call aawarn('MTUCON', 1, msg)
          imsequ = 1
        else
          imsequ = k
        endif
      else
        imsequ = 1
      endif
*---- Copy data to local storage.
      call uzero(gtarget(1,imsequ), 1, 29 * mwflt)
      call utgflt(lccmd, 1, 29, gtarget(1,imsequ))
      if (sequd(imsequ) .ne. ' ' .and. sequd(imsequ) .ne. sequnam)
     +call get_active(sequd(imsequ), 'MTUCON')
      call utgtyp(lccmd, igflag(1,imsequ))

*---- Count constraint.
      nuglob = 0
      do i = 1, 29
        if (igflag(i,imsequ) .ne. 0) then
          nuglob = nuglob + 1
          if (i .lt. 10) then
            statflag = .true.
          else if (i .lt. 29) then
            dynapflag = .true.
          endif
        endif
      enddo

      ncon = ncon + nuglob

*---- Initialise for CALL switch.
      iformula = 0
      lmtsub = 0
      if (subnam .ne. ' ') then
        call utleng(subnam, ileng)
        call difind(ldbnk, subnam(1:ileng), idir, lmtsub)
        if (lmtsub .eq. 0) then
          call aafail('AASUBR', 1,
     +      '"' // subnam(1:ileng) // '" is not a subroutine.')
        else if (iq(lmtsub+mbpr) .ne. mpsub  .or.
     +           iq(lmtsub+mbsp) .ne. 5) then
          call aafail('AASUBR', 1,
     +      '"' // subnam(1:ileng) // '" is not a subroutine.')
        else
          newout = 'CALL'
          call flopen(newout, 'SWFD', 0, 0, iformula, error)
        endif
      endif

*---- Set Fixpoint flag.
      if (igflag(32,imsequ) .ne. 0) fixpointfl = .true.

 9999 end
+dk mtufun
      subroutine mtufun(fprt, iflag, icon, fvec, fsum)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Deal with user constraints.                                        *
* Input:                                                               *
*   FPRT    (logical)   Print flag.                                    *
*   IFLAG   (integer)   Case flag:                                     *
*                       1: Initialize user constraints,                *
*                       2: Handle current position in machine,         *
*                       3: Return user constraint values.              *
* Input/output (updated for IFLAG = 3):                                *
*   ICON    (integer)   Counter for constraints.                       *
*   FVEC(*) (real)      Constraint values.                             *
*   FSUM    (real)      Sum of constraint squares.                     *
*----------------------------------------------------------------------*
+ca aparam
      integer i,icon,iflag,imodulold,iqlogold,iqpr2old,iqprntold,
     +lccmdold
      double precision formula,fsum,fvec,one,trturns,zero
      logical           fprt
      dimension         fvec(*)
+ca largo
+ca minuit
+ca mtcflg
+ca mtglob
+ca mtlink
+ca optic1
+ca refer
+ca range
+ca status
+ca trdynap
+ca zunit

      save i
      parameter         (zero = 0.0, one = 1.0)
      logical           flag(20)
      data flag         / 20 * .false. /

*---- IFLAG = 1: Initialize user constraints.
      if (nuglob .gt. 0) then
        if (iflag .eq. 1) then
          icon = nuglob
          fvec(1) = 0.0
          i = 1

*---- IFLAG = 2: Handle current position (sum up squares of DY).
*     Nothing to be done here.
        else if (iflag .eq. 2) then

*---- IFLAG = 3: Return (and print) global constraint functions.
        else if (iflag .eq. 3) then

*---- Constraints on STATIC results.
          if (statflag) then
            call lastat(zero, flag)
            if (igflag(1,imsequ) .ne. 0) then
              fvec(i) = gpesi(1) * (q1 - gtarget(1,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(2,imsequ) .ne. 0) then
              fvec(i) = gpesi(2) * (q2 - gtarget(2,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(3,imsequ) .ne. 0) then
              fvec(i) = gpesi(3) * (xi1 - gtarget(3,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(4,imsequ) .ne. 0) then
              fvec(i) = gpesi(4) * (xi2 - gtarget(4,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(5,imsequ) .ne. 0) then
              fvec(i) = gpesi(5) * (xin1 - gtarget(5,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(6,imsequ) .ne. 0) then
              fvec(i) = gpesi(6) * (xin2 - gtarget(6,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(7,imsequ) .ne. 0) then
              fvec(i) = gpesi(7) * (dq1de1 - gtarget(7,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(8,imsequ) .ne. 0) then
              fvec(i) = gpesi(8) * (dq1de2 - gtarget(8,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(9,imsequ) .ne. 0) then
              fvec(i) = gpesi(9) * (dq2de2 - gtarget(9,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
          endif

*---- Dynamic aperture constraints.
          if (dynapflag) then
            call trdynrun
            if (igflag(10,imsequ) .ne. 0) then
              fvec(i) = gpesi(10) * (dtune - gtarget(10,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(11,imsequ) .ne. 0) then
              fvec(i) = gpesi(11) * (tunx - gtarget(11,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(12,imsequ) .ne. 0) then
              fvec(i) = gpesi(12) * (tuny - gtarget(12,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(13,imsequ) .ne. 0) then
              fvec(i) = gpesi(13) * (dynapfrac - gtarget(13,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(14,imsequ) .ne. 0) then
              fvec(i) = gpesi(14) * (smear - gtarget(14,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(15,imsequ) .ne. 0) then
              trturns = ktrturns
              fvec(i) = gpesi(15) * (trturns - gtarget(15,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(16,imsequ) .ne. 0) then
              fvec(i) = gpesi(16) * (yapunov - gtarget(16,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif

*---- Fixpoint search.
            if (fixpointfl) then
              if (igflag(17,imsequ) .ne. 0) then
                fvec(i) = gpesi(17) * (zendyn(1) - zstart(1))
                fsum = fsum + fvec(i)**2
                i = i + 1
              endif
              if (igflag(18,imsequ) .ne. 0) then
                fvec(i) = gpesi(18) * (zendyn(2) - zstart(2))
                fsum = fsum + fvec(i)**2
                i = i + 1
              endif
              if (igflag(19,imsequ) .ne. 0) then
                fvec(i) = gpesi(19) * (zendyn(3) - zstart(3))
                fsum = fsum + fvec(i)**2
                i = i + 1
              endif
              if (igflag(20,imsequ) .ne. 0) then
                fvec(i) = gpesi(20) * (zendyn(4) - zstart(4))
                fsum = fsum + fvec(i)**2
                i = i + 1
              endif
              if (igflag(21,imsequ) .ne. 0) then
                fvec(i) = gpesi(21) * (zendyn(5) - zstart(5))
                fsum = fsum + fvec(i)**2
                i = i + 1
              endif
              if (igflag(22,imsequ) .ne. 0) then
                fvec(i) = gpesi(22) * (zendyn(6) - zstart(6))
                fsum = fsum + fvec(i)**2
                i = i + 1
              endif

*---- End point constraint.
            else
              if (igflag(17,imsequ) .ne. 0) then
                fvec(i) = gpesi(17) * (zendyn(1) - gtarget(17,imsequ))
                fsum = fsum + fvec(i)**2
                i = i + 1
              endif
              if (igflag(18,imsequ) .ne. 0) then
                fvec(i) = gpesi(18) * (zendyn(2) - gtarget(18,imsequ))
                fsum = fsum + fvec(i)**2
                i = i + 1
              endif
              if (igflag(19,imsequ) .ne. 0) then
                fvec(i) = gpesi(19) * (zendyn(3) - gtarget(19,imsequ))
                fsum = fsum + fvec(i)**2
                i = i + 1
              endif
              if (igflag(20,imsequ) .ne. 0) then
                fvec(i) = gpesi(20) * (zendyn(4) - gtarget(20,imsequ))
                fsum = fsum + fvec(i)**2
                i = i + 1
              endif
              if (igflag(21,imsequ) .ne. 0) then
                fvec(i) = gpesi(21) * (zendyn(5) - gtarget(21,imsequ))
                fsum = fsum + fvec(i)**2
                i = i + 1
              endif
              if (igflag(22,imsequ) .ne. 0) then
                fvec(i) = gpesi(22) * (zendyn(6) - gtarget(22,imsequ))
                fsum = fsum + fvec(i)**2
                i = i + 1
              endif
            endif

*---- Invariant constraints.
            if (igflag(23,imsequ) .ne. 0) then
              fvec(i) = gpesi(23) * (wxmin - gtarget(23,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(24,imsequ) .ne. 0) then
              fvec(i) = gpesi(24) * (wxmax - gtarget(24,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(25,imsequ) .ne. 0) then
              fvec(i) = gpesi(25) * (wymin - gtarget(25,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(26,imsequ) .ne. 0) then
              fvec(i) = gpesi(26) * (wymax - gtarget(26,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(27,imsequ) .ne. 0) then
              fvec(i) = gpesi(27) * (wxymin - gtarget(27,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
            if (igflag(28,imsequ) .ne. 0) then
              fvec(i) = gpesi(28) * (wxymax - gtarget(28,imsequ))
              fsum = fsum + fvec(i)**2
              i = i + 1
            endif
          endif

*---- FORMULA and/or subroutine CALL.
          if (igflag(29,imsequ) .ne. 0) then
            if (lmtsub .ne. 0) then
*---- Variables for matching module which must be saved.
              lccmdold  = lccmd
              imodulold = imodul
              iqlogold  = iqlog
              iqprntold = iqprnt
              iqpr2old  = iqpr2

*---- Set up environment for subroutine and reroute output.
              imodul = 0
              iqlog  = iformula
              iqprnt = iformula
              iqpr2  = iformula

*---- Execute the subroutine.
              lccmd = lmtsub
              call aaruns

*---- Restore saved variables.
              iqlog  = iqlogold
              iqprnt = iqprntold
              iqpr2  = iqpr2old
              lccmd  = lccmdold
              imodul = imodulold
            endif

*---- Update dependent variables.
            call exupdt
            call aagetp('FORMULA', formula)
            fvec(i) = gpesi(29) * (formula - gtarget(29,imsequ))
            fsum = fsum + fvec(i)**2
            i = i + 1
          endif

*---- Print user constraints.
          if (fprt) then
            i = 1
            if (igflag(1,imsequ) .ne. 0) then
              write (iqpr2, 910) 'Q1', gpesi(1), q1,
     +        gtarget(1,imsequ), gtarget(1,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(2,imsequ) .ne. 0) then
              write (iqpr2, 910) 'Q2', gpesi(2), q2,
     +        gtarget(2,imsequ), gtarget(2,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(3,imsequ) .ne. 0) then
              write (iqpr2, 910) 'Q1''', gpesi(3), xi1,
     +        gtarget(3,imsequ), gtarget(3,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(4,imsequ) .ne. 0) then
              write (iqpr2, 910) 'Q2''', gpesi(4), xi2,
     +        gtarget(4,imsequ), gtarget(4,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(5,imsequ) .ne. 0) then
              write (iqpr2, 910) 'Q1''''', gpesi(5), xin1,
     +        gtarget(5,imsequ), gtarget(5,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(6,imsequ) .ne. 0) then
              write (iqpr2, 910) 'Q2''''', gpesi(6), xin2,
     +        gtarget(6,imsequ), gtarget(6,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(7,imsequ) .ne. 0) then
              write (iqpr2, 910) 'DQ1DE1', gpesi(7), dq1de1,
     +        gtarget(7,imsequ), gtarget(7,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(8,imsequ) .ne. 0) then
              write (iqpr2, 910) 'DQ1DE2', gpesi(8), dq1de2,
     +        gtarget(8,imsequ), gtarget(8,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(9,imsequ) .ne. 0) then
              write (iqpr2, 910) 'DQ2DE2', gpesi(9), dq2de2,
     +        gtarget(9,imsequ), gtarget(9,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(10,imsequ) .ne. 0) then
              write (iqpr2, 910) 'DTUNE', gpesi(10), dtune,
     +        gtarget(10,imsequ), gtarget(10,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(11,imsequ) .ne. 0) then
              write (iqpr2, 910) 'TUNX', gpesi(11), tunx,
     +        gtarget(11,imsequ), gtarget(11,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(12,imsequ) .ne. 0) then
              write (iqpr2, 910) 'TUNY', gpesi(12), tuny,
     +        gtarget(12,imsequ), gtarget(12,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(13,imsequ) .ne. 0) then
              write (iqpr2, 910) 'DYNAPFRAC', gpesi(13), dynapfrac,
     +        gtarget(13,imsequ), gtarget(13,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(14,imsequ) .ne. 0) then
              write (iqpr2, 910) 'SMEAR', gpesi(14), smear,
     +        gtarget(14,imsequ), gtarget(14,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(15,imsequ) .ne. 0) then
              write (iqpr2, 910) 'TRTURNS', gpesi(15), trturns,
     +        gtarget(15,imsequ), gtarget(15,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(16,imsequ) .ne. 0) then
              write (iqpr2, 910) 'LYAPUNOV', gpesi(16), yapunov,
     +        gtarget(16,imsequ), gtarget(16,imsequ), fvec(i)**2
              i = i + 1
            endif

*---- Fixpoint search.
            if (fixpointfl) then
              if (igflag(17,imsequ) .ne. 0) then
                write (iqpr2, 910) 'XEND', gpesi(17), zendyn(1),
     +          zstart(1), zstart(1), fvec(i)**2
                i = i + 1
              endif
              if (igflag(18,imsequ) .ne. 0) then
                write (iqpr2, 910) 'PXEND', gpesi(18), zendyn(2),
     +          zstart(2), zstart(2), fvec(i)**2
                i = i + 1
              endif
              if (igflag(19,imsequ) .ne. 0) then
                write (iqpr2, 910) 'YEND', gpesi(19), zendyn(3),
     +          zstart(3), zstart(3), fvec(i)**2
                i = i + 1
              endif
              if (igflag(20,imsequ) .ne. 0) then
                write (iqpr2, 910) 'PYEND', gpesi(20), zendyn(4),
     +          zstart(4), zstart(4), fvec(i)**2
                i = i + 1
              endif
              if (igflag(21,imsequ) .ne. 0) then
                write (iqpr2, 910) 'TEND', gpesi(21), zendyn(5),
     +          zstart(5), zstart(5), fvec(i)**2
                i = i + 1
              endif
              if (igflag(22,imsequ) .ne. 0) then
                write (iqpr2, 910) 'PTEND', gpesi(22), zendyn(6),
     +          zstart(6), zstart(6), fvec(i)**2
                i = i + 1
              endif
*---- End point constraints.
            else
              if (igflag(17,imsequ) .ne. 0) then
                write (iqpr2, 910) 'XEND', gpesi(17), zendyn(1),
     +          gtarget(17,imsequ), gtarget(17,imsequ), fvec(i)**2
                i = i + 1
              endif
              if (igflag(18,imsequ) .ne. 0) then
                write (iqpr2, 910) 'PXEND', gpesi(18), zendyn(2),
     +          gtarget(18,imsequ), gtarget(18,imsequ), fvec(i)**2
                i = i + 1
              endif
              if (igflag(19,imsequ) .ne. 0) then
                write (iqpr2, 910) 'YEND', gpesi(19), zendyn(3),
     +          gtarget(19,imsequ), gtarget(19,imsequ), fvec(i)**2
                i = i + 1
              endif
              if (igflag(20,imsequ) .ne. 0) then
                write (iqpr2, 910) 'PYEND', gpesi(20), zendyn(4),
     +          gtarget(20,imsequ), gtarget(20,imsequ), fvec(i)**2
                i = i + 1
              endif
              if (igflag(21,imsequ) .ne. 0) then
                write (iqpr2, 910) 'TEND', gpesi(21), zendyn(5),
     +          gtarget(21,imsequ), gtarget(21,imsequ), fvec(i)**2
                i = i + 1
              endif
              if (igflag(22,imsequ) .ne. 0) then
                write (iqpr2, 910) 'PTEND', gpesi(22), zendyn(6),
     +          gtarget(22,imsequ), gtarget(22,imsequ), fvec(i)**2
                i = i + 1
              endif
            endif

*---- Invariant constraints.
            if (igflag(23,imsequ) .ne. 0) then
              write (iqpr2, 910) 'WXMIN', gpesi(23), wxmin,
     +        gtarget(23,imsequ), gtarget(23,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(24,imsequ) .ne. 0) then
              write (iqpr2, 910) 'WXMAX', gpesi(24), wxmax,
     +        gtarget(24,imsequ), gtarget(24,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(25,imsequ) .ne. 0) then
              write (iqpr2, 910) 'WYMIN', gpesi(25), wymin,
     +        gtarget(25,imsequ), gtarget(25,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(26,imsequ) .ne. 0) then
              write (iqpr2, 910) 'WYMAX', gpesi(26), wymax,
     +        gtarget(26,imsequ), gtarget(26,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(27,imsequ) .ne. 0) then
              write (iqpr2, 910) 'WXYMIN', gpesi(27), wxymin,
     +        gtarget(27,imsequ), gtarget(27,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(28,imsequ) .ne. 0) then
              write (iqpr2, 910) 'WXYMAX', gpesi(28), wxymax,
     +        gtarget(28,imsequ), gtarget(28,imsequ), fvec(i)**2
              i = i + 1
            endif
            if (igflag(29,imsequ) .ne. 0) then
              write (iqpr2, 910) 'FORMULA', gpesi(29), formula,
     +        gtarget(29,imsequ), gtarget(29,imsequ), fvec(i)**2
              if (iformula .ne. 0) call flclos(iformula, error)
              i = i + 1
            endif
          endif
        endif
      endif

  910 format(t32,'GLOBAL'/t45,a,t56,1p,e12.6,4e16.6)

      end
+dk mtvary
      subroutine mtvary
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   VARY command.                                                      *
* Attributes:                                                          *
*   NAME      (name)    Parameter name.                                *
*   STEP      (real)    Initial step size.                             *
*   LOWER     (real)    Lower limit.                                   *
*   UPPER     (real)    Upper limit.                                   *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca matgroup
+ca vargroup
+ca message
+ca mtlink
+ca mtcvar
+ca minuit
+ca refer
+ca status
+ca wstack
+ca datatype
      integer idata,iref,jref
      double precision temp

      character*(mcnam) atrnam
      logical           isleng, skip

*---- Variable name is required.
      call mtvfnd('VARY', skip)
      if (.not. (skip .or. error)) then

*---- Give message if an element length is varied.
        isleng = .false.
        if (iq(lref+mbpr) .eq. mpelm) then
          call uhtoc(q(lptr+mvattr), mcwrd, atrnam, mcnam)
          isleng = atrnam .eq. 'L'
        endif

*---- Parameter should be real.
        lref = lq(lptr-1)
        iref = iq(lptr+mvbias)
        jref = mbat + (iref - 1) * mcsiz
        if (iq(lref+jref+mctyp) / 10 .ne. mtflt) then
          call rdfail('MTVARY', 1, 'Parameter is not real value.')
          go to 9999
        endif

*---- Dependent parameter becomes independent, if varied.
        lcexp = lq(lref-iref)
        if (lcexp .ne. 0) then
          call rdwarn('MTVARY', 1,
     +    'Parameter depends on other values --- dependence ignored.')
          call aadrop(lcexp)
          iq(lref+jref+mctyp) = 10*mtflt + 1

*---- Should not vary an element length directly.
        else if (isleng) then
          msg(1) = 'You are varying an element length,'
          msg(2) = 'this may cause the system length to change.'
          call rdwarn('MTVARY', 2, msg)
        endif

*---- Get old value before matching.
        call utgflt(lref, iref, iref, vold)

*---- Check step size and limits.
        vstep = 0.0
        vmin = 0.0
        vmax = 0.0
        call utgflt(lccmd, 2, 4, vstep)
        if (vstep .le. 0.0) then
          msg(1) = 'VARY command expects a positive STEP,'
          msg(2) = 'omitting such a value may cause trouble later.'
          call rdwarn('MTVARY', 2, msg)
        endif
        ivcode = 0
        idata = mbat + 2*mcsiz
        if (mod(iq(lccmd+idata+mctyp),10) .ne. 0) ivcode = ivcode + 1
        idata = idata + mcsiz
        if (mod(iq(lccmd+idata+mctyp),10) .ne. 0) ivcode = ivcode + 2
        if (ivcode .eq. 3  .and.  vmin .gt. vmax) then
          call rdwarn('MTVARY', 1,
     +    'Upper and lower limits interchanged.')
          temp = vmin
          vmin = vmax
          vmax = temp
        endif

*---- Previously variable parameter?
        if (lvar .ne. 0) then
          call rdwarn('MTVARY', 1,
     +    'Parameter is already variable --- new data will be used.')
        else
          call mzbook(2, lvar, lmvar, 1, 'BVAR', 1, 0, mmsiz, 7, 0)
          nvar = nvar + 1
        endif

*---- Copy data to variable bank.
        lq(lvar-1) = lref
        iq(lvar+mmf1) = 16*2 + 2
        iq(lvar+mmcode) = ivcode
        iq(lvar+mmbias) = iref
        iq(lvar+mmf2) = 16*8*mwflt + mreal
        call ucopy(vold, q(lvar+mmold), 4*mwflt)
        iq(lvar+mmf3) = 16*2*mwnam + 5
        call ucopy(q(lptr+mvbank), q(lvar+mmbnam), 2*mwnam)

*---- Mark working space as outdated.
        iwork = 0
        nwork = 0
        icovar = 0
      endif

 9999 end
+dk mtvfnd
      subroutine mtvfnd(comand, skip)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   VARY command.                                                      *
* Input:                                                               *
*   COMAND    (char)    Command name.                                  *
* Output:                                                              *
*   SKIP      (logical) Error flag.                                    *
*   LVAR      /MTLINK/  Variable bank.                                 *
*----------------------------------------------------------------------*
+ca aparam
      integer idata
      character*(*)     comand
      logical           skip
+ca memdum
+ca bankhead
+ca cmdgroup
+ca matgroup
+ca vargroup
+ca mtlink
+ca refer
+ca zunit
+ca datatype

*---- Variable name is required (LPTR is variable reference bank).
      skip = .false.
      idata = mbat
      lptr = lq(lccmd-1)
      lvar = 0
      if (mod(iq(lccmd+idata+mctyp),10) .eq. 0  .or.  lptr .eq. 0) then
        call aafail(comand, 1, 'Variable name required.')
        skip = .true.

*---- Unknown parameter cannot be varied (message occurs in EXFILL).
      else if (lq(lptr-1) .eq. 0) then
        skip = .true.

*---- Previously variable parameter?
      else
        lvar = lmvar
   10   if (lvar .ne. 0) then
          if (lq(lvar-1) .eq. lq(lptr-1)  .and.
     +        iq(lvar+mmbias) .eq. iq(lptr+mvbias)) go to 20
          lvar = lq(lvar)
          go to 10
        endif
   20   continue
      endif

      end
+dk mtweig
      subroutine mtweig
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   WEIGHT command.                                                    *
* Attributes:                                                          *
*   BETX     (real)    Horizontal beta.                                *
*   BETY     (real)    Vertical beta.                                  *
*   ALFX     (real)    Horizontal alpha.                               *
*   ALFY     (real)    Vertical alpha.                                 *
*   X        (real)    Horizontal position for closed orbit.           *
*   PX       (real)    Horizontal momentum for closed orbit.           *
*   Y        (real)    Vertical position for closed orbit.             *
*   PY       (real)    Vertical momentum for closed orbit.             *
*   T        (real)    Longitudinal position for closed orbit.         *
*   PT       (real)    Momentum error for closed orbit.                *
*   DX       (real)    Horizontal dispersion.                          *
*   DY       (real)    Vertical dispersion.                            *
*   DPX      (real)    Horizontal dispersion slope.                    *
*   DPY      (real)    Vertical dispersion slope.                      *
*   MUX      (real)    Horizontal phase.                               *
*   MUY      (real)    Vertical phase.                                 *
*----------------------------------------------------------------------*
+ca aparam
+ca mtpara
+ca mtcwgt
+ca refer

*---- Store given weights.
      call utgflt(lccmd, 1, maxval, wgt)

      end
+dk mtzzzz
+dk m66aaa
+dk m66add
      subroutine m66add(term1, term2, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Add two matrices.                                                  *
* Input:                                                               *
*   TERM1(6,6)  (real)  First term.                                    *
*   TERM2(6,6)  (real)  Second term.                                   *
* Output:                                                              *
*   TARGET(6,6) (real)  Sum: TARGET = TERM1 + TERM2.                   *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j
      double precision target,term1,term2
      dimension         term1(6,6), term2(6,6), target(6,6)

      do 10 i = 1, 6
      do 10 j = 1, 6
        target(i,j) = term1(i,j) + term2(i,j)
   10 continue

      end
+dk m66byv
      subroutine m66byv(amat, avec, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Multiply matrix times vector.                                      *
* Input:                                                               *
*   AMAT(6,6)   (real)  Input matrix.                                  *
*   AVEC(6)     (real)  Input vector.                                  *
* Output:                                                              *
*   TARGET(6)   (real)  Output vector: TARGET = AMAT * AVEC.           *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j
      double precision amat,avec,target,temp
      dimension         amat(6,6), avec(6), target(6)

      dimension         temp(6)

      do 20 i = 1, 6
        temp(i) = 0.0
        do 10 j = 1, 6
          temp(i) = temp(i) + amat(i,j) * avec(j)
   10   continue
   20 continue

      call ucopy(temp, target, 6*mwflt)

      end
+dk m66cpy
      subroutine m66cpy(source, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Copy matrix.                                                       *
* Input:                                                               *
*   SOURCE(6,6) (real)  Input matrix.                                  *
* Output:                                                              *
*   TARGET(6,6) (real)  Output matrix: TARGET = SOURCE.                *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j
      double precision source,target
      dimension         source(6,6), target(6,6)

      do 10 i = 1, 6
      do 10 j = 1, 6
        target(i,j) = source(i,j)
   10 continue

      end
+dk m66div
      subroutine m66div(anum, aden, target, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   "Divide" matrices, i. e. postmultiply with inverse of denominator. *
* Input:                                                               *
*   ANUM(6,6)   (real)  "Numerator" matrix.                            *
*   ADEN(6,6)   (real)  "Denominator" matrix.                          *
* Output:                                                              *
*   TARGET(6,6) (real)  "Quotient" matrix: TARGET = ANUM * ADEN**(-1). *
*   EFLAG       (logical) Error flag.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer i,irank,j
      double precision aden,anum,augmat,target
      dimension         anum(6,6), aden(6,6), target(6,6)
      logical           eflag

      dimension         augmat(6,12)

*---- Copy input to local array.
      do 10 i = 1, 6
      do 10 j = 1, 6
        augmat(i,j)   = aden(i,j)
        augmat(i,j+6) = anum(i,j)
   10 continue

*---- Solve resulting system.
      call solver(augmat, 6, 6, irank)
      if (irank .lt. 6) then
        eflag = .true.

*---- Copy result.
      else
        eflag = .false.
        do 20 i = 1, 6
        do 20 j = 1, 6
          target(i,j) = augmat(i,j+6)
   20   continue
      endif

      end
+dk m66exp
      subroutine m66exp(source, target, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   "Exponentiate" matrix.                                             *
*   Original author:    Liam Healy.                                    *
* Input:                                                               *
*   SOURCE(6,6) (real)  Input matrix.                                  *
* Output:                                                              *
*   TARGET(6,6) (real)  Output matrix: TARGET = exp(SOURCE).           *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j
      double precision b,c,source,target
      dimension         source(6,6), target(6,6)
      logical           eflag

      dimension         b(6,6), c(6,6)

      call m66mpy(source, source, b)
      call m66mpy(source, b, c)
      do 20 j = 1, 6
        do 10 i = 1, 6
          b(i,j) = (source(i,j) - c(i,j) / 12.0) / 2.0
          c(i,j) = - b(i,j)
   10   continue
        b(j,j) = b(j,j) + 1.0
        c(j,j) = c(j,j) + 1.0
   20 continue
      call m66div(b, c, target, eflag)

      end
+dk m66inv
      subroutine m66inv(source, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Invert symplectic matrix.                                          *
* Input:                                                               *
*   SOURCE(6,6) (real)  Input matrix.                                  *
* Output:                                                              *
*   TARGET(6,6) (real)  Output matrix: TARGET = tr(J) * tr(SOURCE) * J.*
*----------------------------------------------------------------------*
+ca aparam
      integer i
      double precision source,target,temp
      dimension         source(6,6), target(6,6)
      dimension         temp(6,6)

*---- TEMP = transpose(SOURCE) * J.
      do 10 i = 1, 6
        temp(i,1) = - source(2,i)
        temp(i,2) = + source(1,i)
        temp(i,3) = - source(4,i)
        temp(i,4) = + source(3,i)
        temp(i,5) = - source(6,i)
        temp(i,6) = + source(5,i)
   10 continue

*---- TARGET = transpose(J) * TEMP.
      do 20 i = 1, 6
        target(1,i) = - temp(2,i)
        target(2,i) = + temp(1,i)
        target(3,i) = - temp(4,i)
        target(4,i) = + temp(3,i)
        target(5,i) = - temp(6,i)
        target(6,i) = + temp(5,i)
   20 continue

      end
+dk m66mak
      subroutine m66mak(f2, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Compute matrix TARGET corresponding to Lie polynomial F2.          *
*   Original author:    Liam Healy.                                    *
* Input:                                                               *
*   F2          (poly)  Polynomial of order 2.                         *
* Output:                                                              *
*   TARGET(6,6) (real)  Output matrix: TARGET * v = - [J,v].           *
*----------------------------------------------------------------------*
+ca aparam
      double precision f2,target
      dimension         f2(*), target(6,6)

      target(1,1) = - f2(8)
      target(1,2) = - 2.0 * f2(13)
      target(1,3) = - f2(14)
      target(1,4) = - f2(15)
      target(1,5) = - f2(16)
      target(1,6) = - f2(17)
      target(2,1) = 2.0 * f2(7)
      target(2,2) = f2(8)
      target(2,3) = f2(9)
      target(2,4) = f2(10)
      target(2,5) = f2(11)
      target(2,6) = f2(12)
      target(3,1) = - f2(10)
      target(3,2) = - f2(15)
      target(3,3) = - f2(19)
      target(3,4) = - 2.0 * f2(22)
      target(3,5) = - f2(23)
      target(3,6) = - f2(24)
      target(4,1) = f2(9)
      target(4,2) = f2(14)
      target(4,3) = 2.0 * f2(18)
      target(4,4) = f2(19)
      target(4,5) = f2(20)
      target(4,6) = f2(21)
      target(5,1) = - f2(12)
      target(5,2) = - f2(17)
      target(5,3) = - f2(21)
      target(5,4) = - f2(24)
      target(5,5) = - f2(26)
      target(5,6) = - 2.0 * f2(27)
      target(6,1) = f2(11)
      target(6,2) = f2(16)
      target(6,3) = f2(20)
      target(6,4) = f2(23)
      target(6,5) = 2.0 * f2(25)
      target(6,6) = f2(26)

      end
+dk m66mpy
      subroutine m66mpy(fact1, fact2, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Multiply two matrices.                                             *
*   TARGET may coincide with one of the factors.                       *
* Input:                                                               *
*   FACT1(6,6)  (real)  First factor.                                  *
*   FACT2(6,6)  (real)  Second factor.                                 *
* Output:                                                              *
*   TARGET(6,6) (real)  Product matrix: TARGET = FACT1 * FACT2.        *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,k
      double precision fact1,fact2,target,temp
      dimension         fact1(6,6), fact2(6,6), target(6,6)

      dimension         temp(6,6)

      do 30 k = 1, 6
        do 10 i = 1, 6
          temp(i,k) = 0.
   10   continue
        do 20 j = 1, 6
        do 20 i = 1, 6
          temp(i,k) = temp(i,k) + fact1(i,j) * fact2(j,k)
   20   continue
   30 continue

      do 40 k = 1, 6
      do 40 i = 1, 6
        target(i,k) = temp(i,k)
   40 continue

      end
+dk m66mtr
      subroutine m66mtr(fact1, fact2, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Multiply a matrix with the transpose of another matrix.            *
*   TARGET must not coincide with either factor.                       *
* Input:                                                               *
*   FACT1(6,6)  (real)  First factor.                                  *
*   FACT2(6,6)  (real)  Second factor (will be transposed).            *
* Output:                                                              *
*   TARGET(6,6) (real)  Product: TARGET = FACT1 * tr(FACT2).           *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,k
      double precision fact1,fact2,target
      dimension         fact1(6,6), fact2(6,6), target(6,6)

      do 10 j = 1, 6
      do 10 i = 1, 6
        target(i,j) = 0.
   10 continue
      do 30 j = 1, 6
        do 20 k = 1, 6
        do 20 i = 1, 6
          target(i,j) = target(i,j) + fact1(i,k) * fact2(j,k)
   20   continue
   30 continue

      end
+dk m66nrm
      subroutine m66nrm(fm, res)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Computes the norm of a matrix.                                     *
*   Reference:          L. Collatz,                                    *
*                       Functional Analysis & Numerical Mathematics.   *
*   Source:             MARYLIE, Version 3.0.                          *
* Input:                                                               *
*   FM(6,6)     (real)  Input matrix.                                  *
* Output:                                                              *
*   RES         (real)  Norm of FM: RES = max abs column sum.          *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j
      double precision fm,res,sum
      dimension         fm(6,6)

      res = 0.
      do 20 j = 1, 6
        sum = 0.
        do 10 i = 1, 6
          sum = sum + abs(fm(i,j))
   10   continue
        res = max(res,sum)
   20 continue

      end
+dk m66one
      subroutine m66one(target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Set matrix to unity.                                               *
* Output:                                                              *
*   TARGET(6,6) (real)  Unit matrix: TARGET = I.                       *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j
      double precision target
      dimension         target(6,6)

      do 20 j = 1, 6
        do 10 i = 1, 6
          target(i,j) = 0.0
   10   continue
        target(j,j) = 1.0
   20 continue

      end
+dk m66prt
      subroutine m66prt(amat, iunit)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print matrix.                                                      *
* Input:                                                               *
*   AMAT(6,6) (real)    Matrix to be printed.                          *
*   IUNIT     (integer) Logical unit number.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iunit,j
      double precision amat
      dimension         amat(6,6)

      write (iunit, 910) ((amat(i,j), j = 1, 6), i = 1, 6)

  910 format(' ',6f12.6)

      end
+dk m66ref
      subroutine m66ref(source, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Reflect symplectic first order transform.                          *
* Input:                                                               *
*   SOURCE(6,6) (real)  Input matrix.                                  *
* Output:                                                              *
*   TARGET(6,6) (real)  Reflected matrix.                              *
*----------------------------------------------------------------------*
+ca aparam
      integer i
      double precision source,target,temp
      dimension         source(6,6), target(6,6), temp(6,6)

*---- TEMP = transpose(SOURCE) * J * signs.
      do 10 i = 1, 6
        temp(i,1) =   source(2,i)
        temp(i,2) =   source(1,i)
        temp(i,3) =   source(4,i)
        temp(i,4) =   source(3,i)
        temp(i,5) = - source(6,i)
        temp(i,6) = - source(5,i)
   10 continue

*---- TARGET = signs * transpose(J) * TEMP.
      do 20 i = 1, 6
        target(1,i) =   temp(2,i)
        target(2,i) =   temp(1,i)
        target(3,i) =   temp(4,i)
        target(4,i) =   temp(3,i)
        target(5,i) = - temp(6,i)
        target(6,i) = - temp(5,i)
   20 continue

      end
+dk m66scl
      subroutine m66scl(scalar, source, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Multiply matrix by scalar.                                         *
* Input:                                                               *
*   SCALAR      (real)  Scale factor.                                  *
*   SOURCE(6,6) (real)  Input matrix.                                  *
* Output:                                                              *
*   TARGET(6,6) (real)  Scaled matrix: TARGET = SCALAR * SOURCE.       *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j
      double precision scalar,source,target
      dimension         source(6,6), target(6,6)

      do 10 i = 1, 6
      do 10 j = 1, 6
        target(i,j) = scalar * source(i,j)
   10 continue

      end
+dk m66sta
      logical function m66sta(amat)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Check effect of a matrix on momentum.                              *
* Input:                                                               *
*   AMAT(6,6)   (real)  Input matrix.                                  *
* Result:                                                              *
*   .TRUE.              For static case     (constant p).              *
*   .FALSE.             For dynamic case    (variable p).              *
*----------------------------------------------------------------------*
+ca aparam
      integer j
      double precision amat,tol
      dimension         amat(6,6)

      parameter         (tol = 1.d-12)

      m66sta = abs(amat(6,6) - 1.0) .le. tol
      do 90 j = 1, 5
        m66sta = m66sta .and. abs(amat(6,j)) .le. tol
   90 continue

      end
+dk m66sub
      subroutine m66sub(term1, term2, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Subtract two matrices.                                             *
* Input:                                                               *
*   TERM1(6,6)  (real)  Minuend matrix.                                *
*   TERM2(6,6)  (real)  Subtrahend matrix.                             *
* Output:                                                              *
*   TARGET(6,6) (real)  Difference matrix: TARGET = TERM1 - TERM2.     *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j
      double precision target,term1,term2
      dimension         term1(6,6), term2(6,6), target(6,6)

      do 10 j = 1, 6
      do 10 i = 1, 6
        target(i,j) = term1(i,j) - term2(i,j)
   10 continue

      end
+dk m66trm
      subroutine m66trm(fact1, fact2, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Multiply the transpose of a matrix with another matrix.            *
*   TARGET must not coincide with either factor.                       *
* Input:                                                               *
*   FACT1(6,6)  (real)  First factor (will be transposed).             *
*   FACT2(6,6)  (real)  Second factor.                                 *
* Output:                                                              *
*   TARGET(6,6) (real)  Product: TARGET = tr(FACT1) * FACT2.           *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,k
      double precision fact1,fact2,target
      dimension         fact1(6,6), fact2(6,6), target(6,6)

      do 30 j = 1, 6
        do 10 i = 1, 6
          target(i,j) = 0.
   10   continue
        do 20 k = 1, 6
        do 20 i = 1, 6
          target(i,j) = target(i,j) + fact1(k,i) * fact2(k,j)
   20   continue
   30 continue
      end
+dk m66tp
      subroutine m66tp(source, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Transpose a matrix.
*   TARGET and SOURCE may overlap.                                     *
* Input:                                                               *
*   SOURCE(6,6) (real)  Input matrix.                                  *
* Output:                                                              *
*   TARGET(6,6) (real)  Transposed matrix: TARGET = tr(SOURCE).        *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j
      double precision source,target,temp
      dimension        source(6,6), target(6,6)

      dimension        temp(6,6)

      do 10 i = 1, 6
      do 10 j = 1, 6
        temp(j,i) = source(i,j)
   10 continue
      call m66cpy(temp, target)

      end
+dk m66zro
      subroutine m66zro(target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Clear a matrix to zero.                                            *
* Output:                                                              *
*   TARGET(6,6) (real)  Zero matrix: TARGET = 0.                       *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j
      double precision target
      dimension         target(6,6)

      do 10 j = 1, 6
      do 10 i = 1, 6
        target(i,j) = 0.0
   10 continue

      end
+dk m66zzz
+dk paaaaa
+dk painit
      subroutine painit(nord)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Prepare bookkeeping tables for polynomial and Lie algebra.         *
* Input:                                                               *
*   NORD      (integer) Maximum order for the tables to be built.      *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca pa6lnk
      integer index,ipaflg,itop,j,nord

      integer           jp(3), jq(3)
      data ipaflg       / 0 /

*---- Polynomials with three variables.
      if (ipaflg .eq. 0) then
        call pa3ini(nord)

*---- Polynomials with six variables.
        call pa6ini(nord)

*---- Index to rearrange a polynomial from 6 to 3 variables.
        itop = itop6(nord-1)
        call mzbook(2, larrq, larrq, 1, 'ARRQ', 0, 0, itop, 2, 0)
        call mzbook(2, larrp, larrp, 1, 'ARRP', 0, 0, itop, 2, 0)
        do 10 j = 1, itop
          jq(1) = iq(lexp6(1)+j)
          jq(2) = iq(lexp6(3)+j)
          jq(3) = iq(lexp6(5)+j)
          call paxind(jq, 3, index)
          iq(larrq+j) = index
          jp(1) = iq(lexp6(2)+j)
          jp(2) = iq(lexp6(4)+j)
          jp(3) = iq(lexp6(6)+j)
          call paxind(jp, 3, index)
          iq(larrp+j) = index
   10   continue
        ipaflg = 1
      endif

      end
+dk paxind
      subroutine paxind(jexp, nvar, index)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find Giorgelli index for a given monomial from known exponents.    *
*   Valid for polynomials in up to 6 variables, and orders up to 12.   *
* Algorithm by: David Douglas and Liam Healy.                          *
* Input:                                                               *
*   JEXP(NVAR)(integer) Set of exponents for monomial.                 *
*   NVAR      (integer) Number of variables in polynomials.            *
* Output:                                                              *
*   INDEX     (integer) Monomial index.                                *
*----------------------------------------------------------------------*
+ca aparam
      integer index,isum,jvar,nvar
      integer           jexp(nvar)

*---- Table of binomial coefficients.
      integer           ibin(0:12,5)
      data              ibin
     + / 0, 1, 3,  6, 10,  15,  21,  28,   36,   45,   55,   66,    78,
     +   0, 1, 4, 10, 20,  35,  56,  84,  120,  165,  220,  286,   364,
     +   0, 1, 5, 15, 35,  70, 126, 210,  330,  495,  715, 1001,  1365,
     +   0, 1, 6, 21, 56, 126, 252, 462,  792, 1287, 2002, 3003,  4368,
     +   0, 1, 7, 28, 84, 210, 462, 924, 1716, 3003, 5005, 8008, 12376 /

      isum  = jexp(nvar)
      index = isum
      do 10 jvar = nvar-1, 1, -1
        isum  = isum  + jexp(jvar)
        index = index + ibin(isum,nvar-jvar)
   10 continue

      end
+dk pa3dif
      subroutine pa3dif(f, jvar, nord, df)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Derivative of homogeneous polynomial in six variables.             *
* Input:                                                               *
*   F(*)      (real)    Polynomial coefficients.                       *
*   JVAR      (integer) Number of variable w.r.t. to differentiate.    *
*   NORD      (integer) Order of polynomial.                           *
* Output:                                                              *
*   DF(*)     (real)    Coefficients of derivative.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer index,iorder,jvar,lbasv,lexpv,nord
      double precision df,f
      dimension         f(*), df(*)
+ca memdum
+ca pa3lnk

      iorder = sign(abs(nord)-1,nord)

*---- Calculate derivative.
      lbasv = lq(lprd3-jvar)
      lexpv = lexp3(jvar)
      do 10 index = ibot3(iorder), itop3(iorder)
        df(index) = (iq(lexpv+index) + 1) * f(iq(lbasv+index))
   10 continue

      end
+dk pa3ini
      subroutine pa3ini(nord)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Build bookkeeping tables for polynomials in three variables.       *
* Algorithm by: Liam Healy.                                            *
* Input:                                                               *
*   NORD      (integer) Maximum order for the tables to be built.      *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca pa3lnk
      integer i,i1,i2,imax,imin,index,iord,itop,jcarry,jord,jvar,l,last,
     +lastnz,lbase,mvar,nd,nord,nterms

      parameter         (mvar = 3)
      integer           jexp(mvar)

*---- Initialize link area.
      call mzlink(0, '/PA3LNK/', lexp3(1), lprd3, lexp3(1))

*---- Calculate IBOT3(JORD) and ITOP3(JORD):
*     NTERMS is number of terms for order JORD.
*     For negative orders the limits mean all terms up to |order|.
      nterms = 1
      ibot3(0) = 1
      itop3(0) = 0
      do 10 jord = 1, nord
        nterms       = (nterms * (jord + mvar - 1)) / jord
        ibot3(jord)  = itop3(jord-1) + 1
        itop3(jord)  = itop3(jord-1) + nterms
        ibot3(-jord) = 1
        itop3(-jord) = itop3(jord)
   10 continue

*---- Set up table of indices.
      itop = itop3(nord)
      do 20 jvar = 1, mvar
        jexp(jvar) = 0
        call mzbook(2, l, lexp3(jvar), 1, 'EXP3', 0, 0, itop, 2, 0)
   20 continue
      do 90 index = 1, itop
        jcarry = jexp(mvar)
        jexp(mvar) = 0
        lastnz = 0
        do 60 jvar = 1, mvar - 1
          if (jexp(jvar) .gt. 0) lastnz = jvar
   60   continue
        if (lastnz .gt. 0) jexp(lastnz) = jexp(lastnz) - 1
        jexp(lastnz+1) = jexp(lastnz+1) + 1 + jcarry
        do 80 jvar = 1, mvar
          iq(lexp3(jvar)+index) = jexp(jvar)
   80   continue
   90 continue

*---- Set up table of products for total order up to NORD.
      itop = itop3(nord/2)
      call mzbook(2, lprd3, lprd3, 1, 'PRD3', itop, itop, 0, 2, 0)
      do 140 iord = 1, mvar
        do 130 i2 = ibot3(iord), itop3(iord)
          imin = ibot3(iord) - 1
          imax = itop3(nord-iord)
          nd = imax - imin
          call mzbook(2, lbase, lprd3, -i2, 'PR31', 0, 0, nd, 2, 0)
          do 120 i1 = imin + 1, imax
            do 110 jvar = 1, mvar
              jexp(jvar) = iq(lexp3(jvar)+i1) + iq(lexp3(jvar)+i2)
  110       continue
            call paxind(jexp, mvar, index)
            iq(lbase+i1-imin) = index
  120     continue
  130   continue
  140 continue

*---- Indices for monomial calculation:
      do 150 jvar = 1, mvar
        jexp(jvar) = jvar
  150 continue
      i2 = mvar
      last = mvar
      itop = itop3(nord-1)
      call mzbook(2, l, lind31, 1, 'ID31', 0, 0, itop, 2, 0)
      call mzbook(2, l, lind32, 1, 'ID32', 0, 0, itop, 2, 0)
      do 190 jord = 2, nord - 1
        do 180 jvar = 1, mvar
          i1 = jexp(jvar)
          jexp(jvar) = last + 1
          do 170 i = i1, i2
            last = last + 1
            iq(lind31+last) = jvar
            iq(lind32+last) = i
  170     continue
  180   continue
        i2 = last
  190 continue

      end
+dk pa6add
      subroutine pa6add(term1, term2, nord, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Add two polynomials in six variables.                              *
* Input:                                                               *
*   TERM1(*)  (real)    Coefficients of first term.                    *
*   TERM2(*)  (real)    Coefficients of second term.                   *
*   NORD      (integer) Order of polynomials:                          *
*       NORD > 0: monomials for order NORD only.                       *
*       NORD < 0: all monomials up to order NORD.                      *
* Output:                                                              *
*   TARGET(*) (real)    Coefficients of sum.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer index,nord
      double precision target,term1,term2
      dimension         target(*), term1(*), term2(*)
+ca pa6lnk

      do 10 index = ibot6(nord), itop6(nord)
        target(index) = term1(index) + term2(index)
   10 continue

      end
+dk pa6brk
      subroutine pa6brk(f, n1, g, n2, pb)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Compute Poisson bracket of two homogeneous polynomials.            *
*   The case that both orders are one is forbidden.                    *
* Source:     MARYLIE, version 5.1 (routine PBKT).                     *
* Input:                                                               *
*   F(*)      (poly)    Homogeneous polynomial of order N1.            *
*   G(*)      (poly)    Homogeneous polynomial of order N2.            *
* Output:                                                              *
*   PB(*)     (poly)    Poisson bracket [F,G], order = N1 + N2 - 2.    *
*----------------------------------------------------------------------*
+ca aparam
      integer i,i1,i2,indexp,indexq,lbasb,lbasp,lbasq,lindp,lindq,n1,n2
      double precision f,fp,fq,g,gp,gq,pb
      dimension         f(*), g(*), pb(*)
+ca memdum
+ca pa6lnk

*---- Clear result array for resulting order.
      do 10 i = ibot6(n1+n2-2), itop6(n1+n2-2)
        pb(i) = 0.0
   10 continue

*==== Loop over variable pairs.
      do 300 indexq = 1, 5, 2
        indexp = indexq + 1
        lbasq = lq(lprd6-indexq)
        lbasp = lq(lprd6-indexp)
        lindq = lexp6(indexq)
        lindp = lexp6(indexp)

*==== N1 is greater or equal to N2.
        if (n1 .ge. n2) then

*---- Special case N2 = 1.
          if (n2 .eq. 1) then
            gp = g(indexp)
            if(gp .ne. 0.0) then
              do 110 i1 = ibot6(n1-1), itop6(n1-1)
                pb(i1) = pb(i1) +
     +            gp * f(iq(lbasq+i1)) * (iq(lindq+i1) + 1)
  110         continue
            endif

            gq = g(indexq)
            if(gq .ne. 0.0) then
              do 120 i1 = ibot6(n1-1), itop6(n1-1)
                pb(i1) = pb(i1) -
     +            gq * f(iq(lbasp+i1)) * (iq(lindp+i1) + 1)
  120         continue
            endif

*---- General case N2 > 1.
          else
            do 160 i2 = ibot6(n2-1), itop6(n2-1)
              lbasb = lq(lprd6-i2) - itop6(n2-2)
              gp = g(iq(lbasp+i2)) * (iq(lindp+i2) + 1)
              if(gp .ne. 0.0) then
                do 140 i1 = ibot6(n1-1), itop6(n1-1)
                  pb(iq(lbasb+i1)) = pb(iq(lbasb+i1)) +
     +              gp * f(iq(lbasq+i1)) * (iq(lindq+i1) + 1)
  140           continue
              endif

              gq = g(iq(lbasq+i2)) * (iq(lindq+i2) + 1)
              if(gq .ne. 0.0) then
                do 150 i1 = ibot6(n1-1), itop6(n1-1)
                  pb(iq(lbasb+i1)) = pb(iq(lbasb+i1)) -
     +              gq * f(iq(lbasp+i1)) * (iq(lindp+i1) + 1)
  150           continue
              endif
  160       continue
          endif

*==== N1 is less than N2.
        else

*---- Special case N1 = 1.
          if (n1 .eq. 1) then
            fq = f(indexq)
            if(fq .ne. 0.0) then
              do 210 i2 = ibot6(n2-1), itop6(n2-1)
                pb(i2) = pb(i2) +
     +            fq * g(iq(lbasp+i2)) * (iq(lindp+i2) + 1)
  210         continue
            endif

            fp = f(indexp)
            if(fp .ne. 0.0) then
              do 220 i2 = ibot6(n2-1), itop6(n2-1)
                pb(i2) = pb(i2) -
     +            fp * g(iq(lbasq+i2)) * (iq(lindq+i2) + 1)
  220         continue
            endif

*---- General case N1 > 1.
          else
            do 280 i1 = ibot6(n1-1), itop6(n1-1)
              lbasb = lq(lprd6-i1) - itop6(n1-2)
              fq = f(iq(lbasq+i1)) * (iq(lindq+i1) + 1)
              if(fq .ne. 0.0) then
                do 260 i2 = ibot6(n2-1), itop6(n2-1)
                  pb(iq(lbasb+i2)) = pb(iq(lbasb+i2)) +
     +              fq * g(iq(lbasp+i2)) * (iq(lindp+i2) + 1)
  260           continue
              endif

              fp = f(iq(lbasp+i1)) * (iq(lindp+i1) + 1)
              if(fp .ne. 0.0) then
                do 270 i2 = ibot6(n2-1), itop6(n2-1)
                  pb(iq(lbasb+i2)) = pb(iq(lbasb+i2)) -
     +              fp * g(iq(lbasq+i2)) * (iq(lindq+i2) + 1)
  270           continue
              endif
  280       continue
          endif
        endif
  300 continue

      end
+dk pa6clr
      subroutine pa6clr(target, nord)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Clear polynomial in six variables.                                 *
* Input:                                                               *
*   NORD      (integer) Order of polynomial:                           *
*       NORD > 0: monomials for order NORD only.                       *
*       NORD < 0: all monomials up to order NORD.                      *
* Output:                                                              *
*   TARGET(*)           Coefficients of polynomial to be cleared.      *
*----------------------------------------------------------------------*
+ca aparam
      integer index,nord
      double precision target
      dimension         target(*)
+ca pa6lnk

      do 10 index = ibot6(nord), itop6(nord)
        target(index) = 0.0
   10 continue

      end
+dk pa6cpy
      subroutine pa6cpy(source, nord, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Copy polynomial.                                                   *
* Input:                                                               *
*   SOURCE(*)           Coefficients of source polynomial.             *
*   NORD      (integer) Order of polynomial:                           *
*       NORD > 0: monomials for order NORD only.                       *
*       NORD < 0: all monomials up to order NORD.                      *
* Output:                                                              *
*   TARGET(*)           Coefficients of target polynomial.             *
*----------------------------------------------------------------------*
+ca aparam
      integer index,nord
      double precision source,target
      dimension         target(*), source(*)
+ca pa6lnk

      do 10 index = ibot6(nord), itop6(nord)
        target(index) = source(index)
   10 continue

      end
+dk pa6dif
      subroutine pa6dif(f, jvar, nord, df)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Derivative of homogeneous polynomial in six variables.             *
* Input:                                                               *
*   F(*)      (real)    Polynomial coefficients.                       *
*   JVAR      (integer) Number of variable w.r.t. to differentiate.    *
*   NORD      (integer) Order of polynomial.                           *
* Output:                                                              *
*   DF(*)     (real)    Coefficients of derivative.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer index,iorder,jvar,lbasv,lexpv,nord
      double precision df,f
      dimension         f(*), df(*)
+ca memdum
+ca pa6lnk

      iorder = sign(abs(nord)-1,nord)

*---- Calculate derivative.
      lbasv = lq(lprd6-jvar)
      lexpv = lexp6(jvar)
      do 10 index = ibot6(iorder), itop6(iorder)
        df(index) = (iq(lexpv+index) + 1) * f(iq(lbasv+index))
   10 continue

      end
+dk pa6ini
      subroutine pa6ini(nord)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Build bookkeeping tables for polynomials in six variables.         *
* Algorithm by: Liam Healy.                                            *
* Input:                                                               *
*   NORD      (integer) Maximum order for the tables to be built.      *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca pa6lnk
      integer i,i1,i2,imax,imin,index,iord,itop,jcarry,jord,jvar,l,last,
     +lastnz,lbase,mvar,nd,nord,nterms

      parameter         (mvar = 6)
      integer           jexp(6)

*---- Initialize link area.
      call mzlink(0, '/PA6LNK/', lexp6(1), lprd6, lexp6(1))

*---- Calculate IBOT6(JORD) and ITOP6(JORD):
*     NTERMS is number of terms for order JORD.
*     For negative orders the limits mean all terms up to |order|.
      nterms = 1
      ibot6(0) = 1
      itop6(0) = 0
      do 10 jord = 1, 6
        nterms       = (nterms * (jord + mvar - 1)) / jord
        ibot6(jord)  = itop6(jord-1) + 1
        itop6(jord)  = itop6(jord-1) + nterms
        ibot6(-jord) = 1
        itop6(-jord) = itop6(jord)
   10 continue

*---- Set up table of indices.
      itop = itop6(nord)
      do 20 jvar = 1, mvar
        jexp(jvar) = 0
        call mzbook(2, l, lexp6(jvar), 1, 'EXP6', 0, 0, itop, 2, 0)
   20 continue
      do 90 index = 1, itop
        jcarry = jexp(mvar)
        jexp(mvar) = 0
        lastnz = 0
        do 60 jvar = 1, mvar - 1
          if (jexp(jvar) .gt. 0) lastnz = jvar
   60   continue
        if (lastnz .gt. 0) jexp(lastnz) = jexp(lastnz) - 1
        jexp(lastnz+1) = jexp(lastnz+1) + 1 + jcarry
        do 80 jvar = 1, mvar
          iq(lexp6(jvar)+index) = jexp(jvar)
   80   continue
   90 continue

*---- Set up table of products for total order up to 6.
      itop = itop6(nord/2)
      call mzbook(2, lprd6, lprd6, 1, 'PRD6', itop, itop, 0, 2, 0)
      do 140 iord = 1, 3
        do 130 i2 = ibot6(iord), itop6(iord)
          imin = ibot6(iord) - 1
          imax = itop6(6-iord)
          nd = imax - imin
          call mzbook(2, lbase, lprd6, -i2, 'PR61', 0, 0, nd, 2, 0)
          do 120 i1 = imin + 1, imax
            do 110 jvar = 1, mvar
              jexp(jvar) = iq(lexp6(jvar)+i1) + iq(lexp6(jvar)+i2)
  110       continue
            call paxind(jexp, mvar, index)
            iq(lbase+i1-imin) = index
  120     continue
  130   continue
  140 continue

*---- Indices for monomial calculation:
      do 150 jvar = 1, mvar
        jexp(jvar) = jvar
  150 continue
      i2 = mvar
      last = mvar
      itop = itop6(nord-1)
      call mzbook(2, l, lind61, 1, 'ID61', 0, 0, itop, 2, 0)
      call mzbook(2, l, lind62, 1, 'ID62', 0, 0, itop, 2, 0)
      do 190 jord = 2, nord - 1
        do 180 jvar = 1, mvar
          i1 = jexp(jvar)
          jexp(jvar) = last + 1
          do 170 i = i1, i2
            last = last + 1
            iq(lind61+last) = jvar
            iq(lind62+last) = i
  170     continue
  180   continue
        i2 = last
  190 continue

      end
+dk pa6nrm
      function pa6nrm(source, nord)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Norm of the coefficient vector for a polynomial in six variables.  *
* Input:                                                               *
*   SOURCE(*)           Coefficients of source polynomial.             *
*   NORD      (integer) Order of polynomial:                           *
*       NORD > 0: monomials for order NORD only.                       *
*       NORD < 0: all monomials up to order NORD.                      *
*----------------------------------------------------------------------*
+ca aparam
      integer index,nord
      double precision pa6nrm,source
      dimension         source(*)
+ca pa6lnk

      pa6nrm = 0.0
      do 10 index = ibot6(nord), itop6(nord)
        pa6nrm = pa6nrm + abs(source(index))
   10 continue

      end
+dk pa6prd
      subroutine pa6prd(fact1, n1, fact2, n2, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Product of two homogeneous polynomials in six variables.           *
* Input:                                                               *
*   FACT1(*)            Coefficients of first factor.                  *
*   N1                  Order of first factor.                         *
*   FACT2(*)            Coefficients of second factor.                 *
*   N2                  Order of second factor.                        *
* Output:                                                              *
*   TARGET(*)           Coefficients of product.                       *
*----------------------------------------------------------------------*
+ca aparam
      integer i1,i2,lp,n1,n2
      double precision f1,f2,fact1,fact2,target
      dimension         target(*), fact1(*), fact2(*)
+ca memdum
+ca pa6lnk

*---- N1 is greater or equal to N2.
      if (n1 .ge. n2) then
        do 20 i2 = ibot6(n2), itop6(n2)
          f2 = fact2(i2)
          if(f2 .ne. 0.0) then
            lp = lq(lprd6-i2) - itop6(n2-1)
            do 10 i1 = ibot6(n1), itop6(n1)
              target(iq(lp+i1)) = target(iq(lp+i1)) + fact1(i1) * f2
  10        continue
          endif
  20    continue

*---- N1 is less than N2.
      else
        do 70 i1 = ibot6(n1), itop6(n1)
          f1 = fact1(i1)
          if(f1 .ne. 0.0) then
          lp = lq(lprd6-i1) - itop6(n1-1)
            do 60 i2 = ibot6(n2), itop6(n2)
              target(iq(lp+i2)) = target(iq(lp+i2)) + f1 * fact2(i2)
  60        continue
          endif
  70    continue
      endif

      end
+dk pa6prt
      subroutine pa6prt(f, nord, iprnt)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print polynomials representing a map.                              *
* Input:                                                               *
*   F(*)                Coefficients of polynomial.                    *
*   NORD      (integer) All monomials up to order NORD are printed.    *
*   IPRNT     (integer) Logical unit number.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer iprnt,j,jl,jord,k,nl,nord
      double precision f,tol
      dimension         f(*)
+ca memdum
+ca pa6lnk

      parameter         (tol = 1.0d-8)
      integer           il(209)

*---- Polynomials F(1) through F(norder):
*     Check for any non-zero coefficient.
      do 90 jord = 1, nord
        nl = 0
        do 70 j = ibot6(jord), itop6(jord)
          if (abs(f(j)) .gt. tol) then
            nl = nl + 1
            il(nl) = j
          endif
   70   continue

*---- There is at least one coefficient to be printed.
        if (nl .gt. 0) then
          write (iprnt, 910) jord
          write (iprnt, 920) ((iq(lexp6(k)+il(jl)), k = 1, 6),
     +                        f(il(jl)), jl = 1, nl)
        endif
   90 continue

  910 format(' Terms of order ',i1,':')
  920 format(4(' C',6i1,' = ',1p,e14.6:5x))

      end
+dk pa6scl
      subroutine pa6scl(scalar, source, nord, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Multiply a polynomial by a scalar.                                 *
* Input:                                                               *
*   SCALAR              Scalar to multiply by.                         *
*   SOURCE(*)           Coefficients of source polynomial.             *
*   NORD                Order of polynomial:                           *
*       NORD > 0: monomials for order NORD only.                       *
*       NORD < 0: all monomials up to order NORD.                      *
* Output:                                                              *
*   TARGET(*)           Coefficients of target polynomial.             *
*----------------------------------------------------------------------*
+ca aparam
      integer index,nord
      double precision scalar,source,target
      dimension         target(*), source(*)
+ca pa6lnk
      do 10 index = ibot6(nord), itop6(nord)
        target(index) = scalar * source(index)
   10 continue
      end
+dk pa6sub
      subroutine pa6sub(term1, term2, nord, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*    Vector subtraction: TARGET = TERM1 - TERM2.                       *
* Input:                                                               *
*   TERM1(*)            Coefficients of first term.                    *
*   TERM2(*)            Coefficients of second term.                   *
*   NORD                Order of polynomial:                           *
*       NORD > 0: monomials for order NORD only.                       *
*       NORD < 0: all monomials up to order NORD.                      *
* Output:                                                              *
*   TARGET(*)           Coefficients of target polynomial.             *
*----------------------------------------------------------------------*
+ca aparam
      integer index,nord
      double precision target,term1,term2
      dimension         target(*), term1(*), term2(*)
+ca pa6lnk

      do 10 index = ibot6(nord), itop6(nord)
        target(index) = term1(index) - term2(index)
   10 continue

      end
+dk pa6sum
      subroutine pa6sum(scalar, source, nord, target)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Linear combination of two polynomials:                             *
*     Target = target + scalar * source.                               *
* Input:                                                               *
*   SCALAR              Scale factor for source.                       *
*   SOURCE(*)           Coefficients for source.                       *
*   NORD                Order of polynomials.                          *
*       NORD > 0: monomials for order NORD only.                       *
*       NORD < 0: all monomials up to order NORD.                      *
* Input/output:                                                        *
*   TARGET(*)           Coefficients for target.                       *
*----------------------------------------------------------------------*
+ca aparam
      integer index,nord
      double precision one,scalar,source,target
      dimension         target(*), source(*)
+ca pa6lnk

      parameter         (one = 1.0d0)

      if (scalar .ne. one) then
        do 10 index = ibot6(nord), itop6(nord)
          target(index) = target(index) + scalar * source(index)
   10   continue
      else
        do 20 index = ibot6(nord), itop6(nord)
          target(index) = target(index) + source(index)
   20   continue
      endif

      end
+dk pa6val
      function pa6val(poly, nord, v)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*    Evaluate polynomial of six variables.                             *
* Input:                                                               *
*   POLY(*)             Coefficients for polynomial.                   *
*   NORD                Order of polynomials.                          *
* Output:                                                              *
*   V(6)      (real)    Value of variables.                            *
*----------------------------------------------------------------------*
+ca aparam
      integer i,index,iord,nord
      double precision pa6val,poly,v,value,vect
      dimension         poly(*), v(6)
+ca memdum
+ca pa6lnk
      dimension         vect(923)

      do 10 i = 1, 6
        vect(i) = v(i)
   10 continue
      do 30 iord = 2, nord
        do 20 index = ibot6(iord), itop6(iord)
          vect(index) = vect(iq(lind61+index)) * vect(iq(lind62+index))
   20   continue
   30 continue

      value = 0.0
      do 40 index = 1, itop6(iord)
        value = value + vect(index) * poly(index)
   40 continue

      pa6val = value

      end
+dk pa6xfm
      subroutine pa6xfm(fp, nord, gm, hp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Linear transformation of arguments in a polynomial.                *
* Basic idea: MARYLIE, version 3.0 (routine XFORM).                    *
* Authors:    Liam Healy and Philippo Neri.                            *
* Algorithm:  Christoph Iselin.
* Input:                                                               *
*   FP(*)     (poly)    Homogeneous polynomial to be transformed.      *
*   NORD      (integer) Order of F.                                    *
*   GM(6,6)   (real)    Matrix to transform Z -> GM * Z.               *
* Output:                                                              *
*   HP(*)     (poly)    The result of H = F(GM * Z).                   *
*----------------------------------------------------------------------*
+ca aparam
      integer i1,i2,i3,i4,i5,i6,j2,j3,j4,j5,j6,l,l1,l2,l3,l4,l5,l6,lp,
     +m1,m2,m3,m4,m5,nord
      double precision fp,gm,hp,tp
      dimension         fp(*), gm(6,6), hp(*)
+ca memdum
+ca pa6lnk

*---- For speed reasons, this array was not put into the working space.
      dimension         tp(461)
*---- Clear result array.
      do 10 l = ibot6(nord), itop6(nord)
        hp(l) = 0.0
   10 continue

*---- Initializations.
      j2 =   6
      j3 =  27
      j4 =  83
      j5 = 209
      j6 = 461

*---- First index.
      do 190 i1 = 1, 6
        if (nord .gt. 1) then
          do 110 m1 = ibot6(nord-1), itop6(nord-1)
            tp(m1) = 0.0
  110     continue

*---- Second index.
          do 290 i2 = i1, 6
            j2 = j2 + 1
            if (nord .gt. 2) then
              do 210 m2 = ibot6(nord-2), itop6(nord-2)
                tp(m2) = 0.0
  210         continue

*---- Third index.
              do 390 i3 = i2, 6
                j3 = j3 + 1
                if (nord .gt. 3) then
                  do 310 m3 = ibot6(nord-3), itop6(nord-3)
                    tp(m3) = 0.0
  310             continue

*---- Fourth index.
                  do 490 i4 = i3, 6
                    j4 = j4 + 1
                    if (nord .gt. 4) then
                      do 410 m4 = ibot6(nord-4), itop6(nord-4)
                        tp(m4) = 0.0
  410                 continue

*---- Fifth index.
                      do 590 i5 = i4, 6
                        j5 = j5 + 1
                        if (nord .gt. 5) then
                          do 510 m5 = ibot6(nord-5), itop6(nord-5)
                            tp(m5) = 0.0
  510                     continue

*---- Sixth index.
                          do 690 i6 = i5, 6
                            j6 = j6 + 1
                            if (fp(j6) .ne. 0.0) then
                              do 620 l6 = 1, 6
                                tp(l6) = tp(l6) + fp(j6) * gm(i6,l6)
  620                         continue
                            endif
  690                     continue

*---- Finish fifth index.
                          do 570 l5 = 1, 6
                            if (gm(i5,l5) .ne. 0.0) then
                              lp = lq(lprd6-l5)
                              do 560 m5 = ibot6(nord-5), itop6(nord-5)
                                tp(iq(lp+m5)) = tp(iq(lp+m5)) +
     +                            tp(m5) * gm(i5,l5)
  560                         continue
                            endif
  570                     continue
                        else if (fp(j5) .ne. 0.0) then
                          do 580 l5 = 1, 6
                            tp(l5) = tp(l5) + fp(j5) * gm(i5,l5)
  580                     continue
                        endif
  590                 continue

*---- Finish fourth index.
                      do 470 l4 = 1, 6
                        if (gm(i4,l4) .ne. 0.0) then
                          lp = lq(lprd6-l4)
                          do 460 m4 = ibot6(nord-4), itop6(nord-4)
                            tp(iq(lp+m4)) = tp(iq(lp+m4)) +
     +                        tp(m4) * gm(i4,l4)
  460                     continue
                        endif
  470                 continue
                    else if (fp(j4) .ne. 0.0) then
                      do 480 l4 = 1, 6
                        tp(l4) = tp(l4) + fp(j4) * gm(i4,l4)
  480                 continue
                    endif
  490             continue

*---- Finish third index.
                  do 370 l3 = 1, 6
                    if (gm(i3,l3) .ne. 0.0) then
                      lp = lq(lprd6-l3)
                      do 360 m3 = ibot6(nord-3), itop6(nord-3)
                        tp(iq(lp+m3)) = tp(iq(lp+m3)) +
     +                    tp(m3) * gm(i3,l3)
  360                 continue
                    endif
  370             continue
                else if (fp(j3) .ne. 0.0) then
                  do 380 l3 = 1, 6
                    tp(l3) = tp(l3) + fp(j3) * gm(i3,l3)
  380             continue
                endif
  390         continue

*---- Finish second index.
              do 270 l2 = 1, 6
                if (gm(i2,l2) .ne. 0.0) then
                  lp = lq(lprd6-l2)
                  do 260 m2 = ibot6(nord-2), itop6(nord-2)
                    tp(iq(lp+m2)) = tp(iq(lp+m2)) +
     +                tp(m2) * gm(i2,l2)
  260             continue
                endif
  270         continue
            else if (fp(j2) .ne. 0.0) then
              do 280 l2 = 1, 6
                tp(l2) = tp(l2) + fp(j2) * gm(i2,l2)
  280         continue
            endif
  290     continue

*---- Finish first index.
          do 170 l1 = 1, 6
            if (gm(i1,l1) .ne. 0.0) then
              lp = lq(lprd6-l1)
              do 160 m1 = ibot6(nord-1), itop6(nord-1)
                hp(iq(lp+m1)) = hp(iq(lp+m1)) + tp(m1) * gm(i1,l1)
  160         continue
            endif
  170     continue
        else if (fp(i1) .ne. 0.0) then
          do 180 l1 = 1, 6
            hp(l1) = hp(l1) + fp(i1) * gm(i1,l1)
  180     continue
        endif
  190 continue

      end
+dk pazzzz
+dk plaaaa
+dk plarwe
      subroutine plarwe (ibk, actwin)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Plots Arnold web                                                   *
*                                                                      *
*--- Input                                                             *
*   IBK       (integer) array containing:                              *
*                       number of superperiods                         *
*                       number of constraints  N                       *
*                       N constraints:                                 *
*                       minimum                                        *
*                       maximum                                        *
*                       step                                           *
*                       Length L                                       *
*                       expression in polish notation of length L,     *
*                       coded as 1+, 2-, 3*, 4/, 1 KX, 2 KY, 3 KS      *
*                       + MQADD + 4, e.g. 100006 = KY                  *
*   ACTWIN       (real) active user window (WC)                        *
*                                                                      *
*----------------------------------------------------------------------*
+ca aparam
+ca plotcp
+ca plcomm
+ca strgroup
      integer ierr,ifp,ip,ipm,ipp,iselct,j,k1,k2,k3,kax,kay,klwid,ksmax,
     +kx,ky
      integer    ibk(*)
      real       actwin(4)
      integer    k(3), l(2), lstyl(0:3)
      real       s, qs, v1, v2, vm, vp, sclwid
      real       ql(2), qu(2), x(2), y(2)
      data lstyl / 1, 2, 4, 3 /

*--- set flag for first error message (following suppressed)
      ifp = 0
      if (haxis(:2) .eq. 'QX')  then
        kx = 1
      else
        kx = 2
      endif
      ky  = 3 - kx
      kax = 2 * kx -1
      kay = 2 * ky -1
      ql(kx) = actwin(kax)
      qu(kx) = actwin(kax+1)
      ql(ky) = actwin(kay)
      qu(ky) = actwin(kay+1)
      qs = qsval
      s   = ibk(1)
      if (qs .eq. 0.)  then
        ksmax = 0
      else
        ksmax = mksmax
      endif
      do 10  k1 = -ntmax, ntmax
        k(kx) = k1
        l(kx) = ntmax - abs(k1)
        do 20  k2 = -l(kx), l(kx)
          if (k1 .ne. 0 .or. k2 .ne. 0)  then
            k(ky) = k2
            l(ky) = min(l(kx) - abs(k2), ksmax)
            do 30  k3 = -l(ky), l(ky)
              k(3) = k3
              call plqcon(kx, ky, k, ibk, iselct, ierr)
              if (iselct .ne. 0 .or. ierr .ne. 0)  then
                call jsln(lstyl(min(abs(k3),3)))
                if (ierr .ne. 0 .and. ifp .eq. 0)  then
                  ifp = 1
                  call aawarn ('PLARWE', 1,
     +            'Illegal constraint --- all constraints ignored.')
                endif
*--- set line width scale factor
                klwid = max(1, 6 - abs(k1) - abs(k2))
                sclwid = klwid
                call jslwsc(sclwid)
                if (k1*k2 .lt. 0)  then
                  v1 = k(kx) * ql(kx) + k(ky) * qu(ky) + k3 * qs
                  v2 = k(kx) * qu(kx) + k(ky) * ql(ky) + k3 * qs
                else
                  v1 = k(kx) * qu(kx) + k(ky) * qu(ky) + k3 * qs
                  v2 = k(kx) * ql(kx) + k(ky) * ql(ky) + k3 * qs
                endif
                vm = min(v1, v2)
                vp = max(v1, v2)
                ipm = vm / s + 0.499 * (1. + sign(1., vm))
                ipp = vp / s - 0.499 * (1. - sign(1., vm))
                do 40  ip = max(0, ipm), ipp
                  if (k(2) .eq. 0)  then
*--- vertical line
                    y(1) = ql(2)
                    y(2) = qu(2)
                    x(1) = (ip * s - k3 * qs) / k(1)
                    x(2) = x(1)
                  else
                    x(1) = ql(1)
                    x(2) = qu(1)
                    y(1) = (ip * s - k(1) * ql(1) - k3 * qs) / k(2)
                    y(2) = (ip * s - k(1) * qu(1) - k3 * qs) / k(2)
                    if (k(1) .ne. 0)  then
                      do 50  j = 1, 2
                        if (y(j) .lt. ql(2))  then
                          x(j) = (ip * s - k(2) * ql(2) - k3 * qs)
     +                           / k(1)
                          y(j) = ql(2)
                        elseif (y(j) .gt. qu(2))  then
                          x(j) = (ip * s - k(2) * qu(2) - k3 * qs)
     +                           / k(1)
                          y(j) = qu(2)
                        endif
   50                 continue
                    endif
                  endif
                  call gvpl(2,x,y)
   40           continue
              endif
   30       continue
          endif
   20   continue
   10 continue
*--- reset line width scale factor
      call jslwsc(1.)
+ei
      end
+dk plcoli
      subroutine plcoli(sval, ipt, ipcd)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Enters variable formats, biasses etc. in banks, returns pointer    *
* Input / output:                                                      *
*   SVAL     (char)     variable name (will be completed)              *
* Output:                                                              *
*   IPT      (integer)  = 0: variable unknown, else pointer into banks *
*                       LOCC, LCNR, LPROC                              *
*   IPCD     (integer)  interpolation code for variable                *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca plotcp
+ca plcomm
+ca plotcd
+ca strgroup
+ca tbpara
+ca datatype
      integer i,i1,i2,ict,ipcd,ipt

      integer ipflg(2)

      character*(mcnam) sval, sovar(mxdep)
      character*(mxlabl) dum2

      call plgetn(0, sval, itbv, ipflg, sovar, dum2)
      if (sovar(1) .eq. ' ')  then
        ipt = 0
      else
        if (ipflg(1) .eq. 0)  sval = sovar(1)
        nocc = nocc + 1
        iq(lproc+nocc) = ipflg(1)
        ipcd           = ipflg(2)
        iq(locc+nocc)  = nform
        iq(lcnt+nocc)  = 0
        ict = 0
        do 10  i = 1, mxdep
          if (sovar(i) .ne. ' ')  then
            ict   = ict + 1
            nform = nform + 1
            call tbcol (ltab, sovar(i), i1, i2)
            if (i1 .eq. 0)  then
              ipt = 0
              goto 999
            endif
            iq(lform+nform) = i1
            iq(lbias+nform) = i2
          endif
   10   continue
        iq(lcnt+nocc) = ict
        ipt = nocc
      endif
+ei
  999 end
+dk plcurv
      subroutine plcurv (ncc, sname, annh, usex, symb, sych, ippar, np,
     +xval, yval, indx, window, actwin, ierr)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Plot one curve                                                     *
* Input:                                                               *
*   NCC      (integer)  current curve count (1,2, etc.)                *
*   SNAME    (char)     curve annotation string                        *
*   ANNH     (real)     character height                               *
*   USEX     (real)     user character height expansion                *
*   SYMB     (char)     plot symbol if code = 200                      *
*   SYCH     (real)     symbol character height                        *
*   IPPAR    (integer)  array containing the plot parameters           *
*   NP       (integer)  no. of points to plot                          *
*   XVAL     (real)     x values                                       *
*   YVAL     (real)     y values                                       *
*   INDX     (integer)  sequence index for x values                    *
*   WINDOW   (real)     array containing the window to use             *
*   ACTWIN   (real)     active (inside frame) window                   *
* Output:                                                              *
*   IERR     (integer)  0 if OK, else GXPLOT error                     *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca plotcp
+ca plcomm
+ca strgroup
      integer icolr,iecub,ierr,ilb,ipbar,ispli,istyl,isymb,j,kact,kf,
     +kft,kl,klt,maxpnt,ncc,np,npt,irow,kkt
      double precision xmd
      parameter            (maxpnt = 500)

      real                 annh, sych, xval(*), yval(*), window(*)
      real                 actwin(*), gxcubv, usex
      real                 xpos, ypos, xwpos, ywpos, xf, wsclx, wscly
      real                 xaux, yaux
      real                 rsave(20), act(4), xpl(2), ypl(2), winnor(4)
      real                 xreal(maxpnt), yreal(maxpnt), yy1d(maxpnt)
      real                 yy2d(maxpnt)

      integer              ippar(*), indx(*)
      integer              isave(20)

      character         sname*(*), symb*1, symloc*1

      save                 act

      data winnor /0., 1., 0., 1./

*--- save GKS settings
      call gxsave (isave, rsave, ierr)
      call gxswnd (window)
      wsclx = 1. / (window(2) - window(1))
      wscly = 1. / (window(4) - window(3))
      xmd = 1.e-8 * (window(2) - window(1))**2
      if (ncc .eq. 1)  then
*--- first curve in frame - reset label position array, get act.
*    window in NDC
        act(1) = (actwin(1) - window(1)) * wsclx
        act(2) = (actwin(2) - window(1)) * wsclx
        act(3) = (actwin(3) - window(3)) * wscly
        act(4) = (actwin(4) - window(3)) * wscly
      endif
      istyl = ippar(mpstyl)
      ipbar = ippar(mpbars)
      isymb = ippar(mpsymf)
      icolr = ippar(mpcolr)
      if(icolr .eq. 100)  icolr = mod(ncc-1,6) + 1
      icolr = max(1, min(icolr, 7))
      ilb = -1
      if (istyl .ne. 0)  then
*--- polyline requested
        if (np .lt. 2) goto 999
        if(istyl .eq. 100)  istyl = mod(ncc-1,4) + 1
        ispli = ippar(mpspli)
*--- get first and last blank in annotation
        call gxpnbl (sname, kft, klt)
        if (kft .ne. 0) then
*--- annotation exists
          ilb    = 0
        endif
*--- set line style
        call jsln (max (1, min (4, istyl)))
*--- set line colour
        call jsplci(icolr)
        kact = 1
    1   continue
*--- get first and last point inside
        call pliact(kact, np, indx, xval, yval, actwin, kf, kl)
*--- quit if no points inside
        if (kf .eq. 0)  goto 21
        kf = max(1, kf - 1)
        kl = min(np, kl + 1)
        npt      = 1
        xreal(1) = xval(indx(kf))
        yreal(1) = yval(indx(kf))
        do 10 j = kf + 1, kl
*--- avoid identical points
          if ((xreal(npt) - xval(indx(j)))**2 +
     +    (yreal(npt) - yval(indx(j)))**2 .gt. xmd) then
            npt        = npt + 1
            xreal(npt) = xval(indx(j))
            yreal(npt) = yval(indx(j))
          endif
          if ((j .eq. kl .and. npt .ge. 2) .or. npt .eq. maxpnt) then
*--- plot - get first curve annotation position
            if (ilb .eq. 0)
     +      call plgacn(ncc, window, act, xreal, yreal, npt, usex,
     +      xwpos, xpos, ypos, ilb)
            if (npt .eq. 2 .or. ispli .eq. 0) then
*--- no spline
              call gxpl (npt, xreal, yreal, actwin)
              if (ilb .gt. 0) then
*--- get y pos. on curve for label
                ywpos = yreal(ilb - 1) + (yreal(ilb) - yreal(ilb-1))
     +          * (xwpos  - xreal(ilb - 1))
     +          / (xreal(ilb) - xreal(ilb - 1))
                ilb = -2
              endif
            else
*--- spline
              call gxplt1 (npt, xreal, yreal, actwin)
              if (ilb .gt. 0) then
*--- get y pos. on curve for label
                call gxcubi (npt, xreal, yreal, yy1d, yy2d, iecub)
                ywpos = gxcubv (xwpos, npt, xreal, yreal, yy1d, yy2d)
                ilb   = -2
              endif
            endif
            xreal(1) = xreal(npt)
            yreal(1) = yreal(npt)
            npt = 1
          endif
   10   continue
        if (kl .lt. np)  then
          kact = kl + 1
          goto 1
        endif
      else
*--- no polyline
        if (np .eq. 0) goto 999
      endif
*--- plot symbols or bars if requested
      if (ipbar .ne. 0)  then
        call jsln (1)
*--- set line colour
        call jsplci(icolr)
        do 20 j = 1, np
          xpl(1) = xval(indx(j))
          xpl(2) = xval(indx(j))
          ypl(1) = yval(indx(j))
          ypl(2) = actwin(3)
          call gvpl (2, xpl, ypl)
   20   continue
      endif
   21 continue
      if (isymb .ne. 0)  then
*--- set marker colour
        call jspmci(icolr)
        if (isymb .le. 5)  then
          call jsmk (isymb)
          if (iq(ltbr+3) .eq. 0)  then
*--- set colour per particle
            kkt = iq(ltbr+2)
            do irow = 1, iq(ltbr+1)
              if (ippar(mpcolr) .eq. 100) icolr = mod(irow-1,6) + 1
              call jspmci(icolr)
              call gxpmsw (kkt, xval((irow-1)*kkt+1),
     +        yval((irow-1)*kkt+1), actwin)
            enddo
          else
            call gxpmsw (np, xval, yval, actwin)
          endif
        elseif (isymb .eq. 100 .or. isymb .eq. 200)  then
          if (istyl .ne. 0)  then
            if (isymb .eq. 100)  then
*--- use current curve count
              write (symloc, '(I1)')  mod (ncc, 10)
            else
              symloc= symb
            endif
          endif
*--- plot one character symbol
*    switch to normalized window
          call gxswnd (winnor)
*--- set character height
          call jschh (sych)
*--- text alignment
          call jstxal (2, 3)
*--- text expansion factor - mind distorted viewports
          call gxqrvp (xf)
          call jschxp (xf)
          do 30 j = 1, np
            if (isymb .eq. 100 .and. istyl .eq. 0)  then
*--- use current point number
              write (symloc, '(I1)')  mod (indx(j), 10)
            endif
            xaux = wsclx * (xval(indx(j)) - window(1))
            yaux = wscly * (yval(indx(j)) - window(3))
            if (xaux .gt. act(1) .and. xaux .lt. act(2)
     +      .and. yaux .gt. act(3) .and. yaux .lt. act(4))
     +      call gxtx (xaux, yaux, symloc)

   30     continue
        endif
      endif
      if (ilb .eq. -2)  then
*--- plot annotation
*    switch to normalized window
        call gxswnd (winnor)
*--- set character height
        call jschh (annh)
*--- text alignment
        call jstxal (2, 5)
*--- text expansion factor - mind distorted viewports
        call gxqrvp (xf)
        call jschxp (xf)
*--- set marker colour
          call jstxci(icolr)
*--- plot annotation string
        call gxtx (xpos, ypos, sname(kft:klt))
*--- connect to curve
        xpl(1) = xpos
        xpl(2) = xpos
        ypl(1) = ypos
        ypl(2) = (ywpos - window(3)) * wscly
        if (ypl(2) .gt. ypl(1))  ypl(1) = ypl(1) + .02
*--- set dotted line
        call jsln (3)
*--- set line colour
        call jsplci(icolr)
*--- plot line
        call gxpl (2, xpl, ypl, act)
      endif
*--- restore
      call gxrest (isave, rsave)
+ei
  999 end
+dk pldump
      subroutine pldump
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Dump the plot bank structure (partially)                           *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca plotcp
+ca plcomm
+ca plotcd
+ca strgroup
+ca zunit
      integer ivcurv,ivvar,j,l,nipri
      character         sanno*(mxlabl)
      character         sname*(mcnam), stitl*(mtitl), symb*1
      nipri = ivpar(8)
      write (iqlog, 10000)
      l = lpmain
      if (l .eq. 0)  then
        write (iqlog, 10010)
      else
        write (iqlog, 10020) iq(l-1)
        write (iqlog, 10030) iq(l + mpfont), q(l + mpfelm)
        write (iqlog, 10040) q(l + mpxsiz), q(l + mpysiz), q
     +  (l + mpascl), q(l + mplscw), q(l + mplscl), q(l + mpsscl), q
     +  (l + mptscl)
        lm1 = lq(l - mpfram - 1)
        lm2 = lq(l - mpfram - 2)
        if (lm1 .eq. 0)  then
          write (iqlog, 10050)
        else
          write (iqlog, 10060) iq(lm1 - 1), iq(lm2 - 1)
        endif
        do 30 iframe = 1, mpfram
          lframe = lq(lpmain - iframe)
          if (lframe .ne. 0) then
            write (iqlog, 10070) iframe
            l = lq(lframe - 2)
            if (l .ne. 0) then
              write (iqlog, 10090) iq(l - 1)
              write (iqlog, 10080) nipri,
     +        (q(l + j), j = 1, min (nipri, iq(l - 1)))
              write (iqlog, * ) ' '
            endif
            l = lq(lframe - 3)
            if (l .ne. 0) then
              write (iqlog, 10100) iq(l - 1)
            endif
            l = lframe
            write (iqlog, 10110) q(l + mpmin), q(l + mpmax),
     +      iq(l + mpsclf)
            call uhtoc (q(l + mpname), mcnam, sname, mcnam)
            write (iqlog, 10120) sname
            call uhtoc (q(l + mpttit), mtitl, stitl, mtitl)
            write (iqlog, 10130) stitl
            call uhtoc (q(l + mpbtit), mtitl, stitl, mtitl)
            write (iqlog, 10140) stitl
            lvvar = lq(lframe - 1)
            if (lvvar .eq. 0) then
              write (iqlog, 10150)
              goto 999
            endif
            ivvar = 0
   10       continue
            ivvar = ivvar + 1
            write (iqlog, 10160) ivvar
            l = lvvar
            write (iqlog, 10170) q(l + mpmin), q(l + mpmax), iq
     +      (l + mpsclf)
            call uhtoc (q(l + mpname), mxlabl, sanno, mxlabl)
            write (iqlog, 10180) sanno
            lvcurv = lq(lvvar - 1)
            if (lvcurv .eq. 0) then
              write (iqlog, 10190)
              goto 999
            endif
            ivcurv = 0
   20       continue
            ivcurv = ivcurv + 1
            write (iqlog, 10200) ivcurv
            l = lvcurv
            write (iqlog, 10210) iq(l + mpstyl), iq(l + mpcolr),
     +      iq(l + mpspli), iq(l + mpbars), iq(l + mpsymf)
            if (iq(l + mpsymf) .eq. 200) then
              call uhtoc (q(l + mpsymb), 1, symb, 1)
              write (iqlog, 10220) symb
            endif
            call uhtoc (q(l + mpanno), mcnam, sname, mcnam)
            write (iqlog, 10230) sname
            lvval = lq(lvcurv - 1)
            if (lvval .eq. 0) then
              write (iqlog, 10240)
              goto 999
            endif
            l = lvval
            write (iqlog, 10250) iq(l - 1)
            write (iqlog, 10080) nipri,
     +      (q(l + j), j = 1, min (nipri, iq(l - 1)))
            write (iqlog, * ) ' '
            lhval = lq(lvcurv - 3)
            if (lhval .eq. 0) then
              write (iqlog, 10260)
              goto 999
            endif
            l = lhval
            write (iqlog, 10270) iq(l - 1)
            write (iqlog, 10080) nipri,
     +      (q(l + j), j = 1, min (nipri, iq(l - 1)))
            write (iqlog, * ) ' '
            lindx = lq(lvcurv - 4)
            if (lindx .ne. 0) then
              l = lindx
              write (iqlog, 10280) iq(l - 1)
              write (iqlog, 10290) nipri,
     +        (iq(l + j), j = 1, min (nipri, iq(l - 1)))
              write (iqlog, * ) ' '
            endif
            lvcurv = lq(lvcurv)
            if (lvcurv .ne. 0) goto 20
            lvvar = lq(lvvar)
            if (lvvar .ne. 0) goto 10
          endif
   30   continue
      endif
10000 format(//' ',15('++++') // t20,'dump LPMAIN plot bank' //' ',15(
     +'++++')//)
10010 format(' WARNING: LPMAIN pointer = 0, no bank.'/)
10020 format( ' LPmain number of data words   =',i8/)
10030 format( ' font                          =',i8/
     +' start of machine plot s value =',g14.6/)
10040 format( ' x size (default = 0.)         =',g14.6/
     +' y size (ditto)                =',g14.6/
     +' annotation size               =',g14.6/
     +' line width scale factor       =',g14.6/
     +' label scale factor            =',g14.6/
     +' symbol scale factor           =',g14.6/
     +' text scale factor             =',g14.6/)
10050 format(' No machine plot banks given.'/)
10060 format( ' lengths of machine plot banks =',2i8/)
10070 format(' ',15('****') // t20,'start frame no. ',i1 //)
10080 format( ' first up to ',i3,' values       ='/(1x,5g14.6))
10090 format( ' length of hor. bank           =',i8/)
10100 format( ' length of sequence bank       =',i8/)
10110 format( ' hor. minimum                  =',g14.6/
     +' hor. maximum                  =',g14.6/
     +' scaling request (0,1,2)       =',i8/)
10120 format( ' hor. var. name                =',a/)
10130 format( ' top title                     =',a/)
10140 format( ' bottom title                  =',a/)
10150 format(' WARNING: no vert. axis banks, quit.'/)
10160 format(' ',15('+-+-') // t20,'start variable no. ',i2 //)
10170 format( ' vert. minimum                 =',g14.6/
     +' vert. maximum                 =',g14.6/
     +' scaling request (0,1,2)       =',i8/)
10180 format( ' vert. var. name               =',a/)
10190 format(' WARNING: no vert. var. banks, quit.'/)
10200 format(' ',15('----') // t20,'start curve no. ',i2 //)
10210 format( ' line style                    =',i8/
     +' colour                        =',i8/
     +' spline flag                   =',i8/
     +' bars flag                     =',i8/
     +' symbol value                  =',i8/)
10220 format( ' plot symbol                   =',a/)
10230 format( ' curve annotation              =',a/)
10240 format(' WARNING: no vert. value bank, quit.'/)
10250 format(' no. of vertical values =',i8/)
10260 format(' WARNING: no hor. value bank, quit.'/)
10270 format(' no. of hor. values     =',i8/)
10280 format( ' no. of index values           =',i8/)
10290 format( ' first up to ',i3,' values       ='/(1x,10i8))
+ei
  999 end
+dk plelma
      subroutine plelma(itp, temp, dstp, am)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Return 6x6 element matrix                                          *
* Input:                                                               *
*   ITP         (int)   type: 1 bend, 2 quad, else drift               *
*   TEMP        (real)  length, angle, k1                              *
*   DSTP        (real)  sublength                                      *
* Output:                                                              *
*   AM          (real   matrix                                         *
*                                                                      *
*----------------------------------------------------------------------*
+ca aparam
+ca pi
      integer i,itp,j
      double precision am,cangle,d,dstp,elak1,elang,eleng,eps,f,fpr,one,
     +rhoi,rk2,sangle,temp,two,twopi,zero
      parameter         (zero = 0.d0, eps = 1.d-5)
      parameter         (one = 1.d0, two = 2.d0, twopi = two * pi)

      dimension         temp(*), am(6,6)

      logical           drift

      do i = 1, 6
        do j = 1,6
          am(j,i) = zero
        enddo
        am(i,i) = one
      enddo
*--- treat quads with non-zero tilt, and bends with non-zero tilt
*    different from pi/2 as drifts
      drift = itp .eq. 0 .or. (temp(5) .ne. zero
     +.and. (itp .ne. 1 .or. abs(pi / two - abs(temp(5))) .gt. eps))
      if (drift)  then
        do 20 i = 1, 4
   20   am(i,i) = one
        am(1,2) = dstp
        am(3,4) = dstp
      else
        if (temp(5) .eq. zero)  then
          fpr = one
        else
          fpr = -one
        endif
        eleng = temp(1)
        elang = temp(2)
        elak1 = temp(3)
        do 30 i = 0, 2, 2
          rhoi = ((one + fpr) / two) * elang / eleng
          rk2  = rhoi**2 + fpr * elak1
          call tmfoc(dstp, rk2, cangle, sangle, d, f)
          am(i+1,i+1) = cangle
          am(i+2,i+2) = cangle
          am(i+1,i+2) = sangle
          am(i+2,i+1) = -rk2 * sangle
          am(i+1,6)   = rhoi * d
          am(i+2,6)   = am(i+1,i+2) * rhoi
          fpr = -fpr
   30   continue
      endif
      end
+dk plfft
      subroutine plfft
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Replace plot by plot of Fourier spectrum of hvar + i vvar          *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca plotcp
+ca plcomm
+ca plotcd
+ca strgroup
+ca zunit
      integer i,idum,ivcurv,ivvar,k,l,m,maxpft,mp,n,nm,nselc,nskip,nup,
     +nwarn
      double precision eps,hs,riv,rmax,rrv,stp
      parameter (maxpft = 14, eps = 1.e-20)
      character *(mxlabl) sanno
      character *(mcnam)  sname, svar, sdum
      character *(mtitl)  stitl, stit1, stit2, stit3
      if (lpmain .ne. 0)  then
        nselc = ivpar(6)
        nskip = max(0, ivpar(7))
        do 30 iframe = 1, mpfram
          lframe = lq(lpmain - iframe)
          if (lframe .ne. 0) then
            lvvar = lq(lframe - 1)
            if (lvvar .eq. 0) then
              call aawarn('PLFFT', 1, 'No vertical variable bank.')
              goto 999
            endif
            ivvar = 0
   10       continue
            ivvar = ivvar + 1
            lvcurv = lq(lvvar - 1)
            if (lvcurv .eq. 0) then
              call aawarn('PLFFT', 1, 'No vertical variable bank.')
              goto 999
            endif
            ivcurv = 0
   20       continue
            ivcurv = ivcurv + 1
            lvval = lq(lvcurv - 1)
            if (lvval .eq. 0) then
              call aawarn('PLFFT', 1, 'No vertical variable bank.')
              goto 999
            endif
            lhval = lq(lvcurv - 3)
            if (lhval .eq. 0) then
              call aawarn('PLFFT', 1, 'No horizontal variable bank.')
              goto 999
            endif
            if (iq(lvval-1) .lt. iq(lhval-1))  then
              call aawarn('PLFFT', 1, 'Not enough vertical values.')
              goto 999
            endif
*--- find number of tracking points (ampl**2 > eps)
            do 1  n = 1, iq(lhval-1)
              if ((q(lhval+n)**2 + q(lvval+n)**2) .lt. eps)  goto 2
    1       continue
            n = iq(lhval-1)
    2       continue
            if (n .le. 4) then
              stitl = 'only $$ points (all values may be = zero)'
              write(stitl(6:7), '(I2)') n
              call aawarn('PLFFT', 1, stitl)
            endif
            if (n - nskip .le. 0) then
              stitl = 'skip request ignored: only $$$$$ points.'
              write(stitl(28:32), '(I5)') n
              call aawarn('PLFFT', 1, stitl)
              nskip = 0
            else
              n = n - nskip
            endif
*--- find nearest power of two for FFT
            nwarn = 0
            mp = maxpft
            m = 2**mp
    3       continue
            if (n .gt. m) then
              nwarn = n
              n = m
            elseif (n .lt. m)  then
              m = m / 2
              mp = mp - 1
              goto 3
            endif
            if (nwarn .gt. 0)  then
              stitl = 'no. of points reduced from $$$$$ to $$$$$.'
              write(stitl(28:32), '(I5)') nwarn
              write(stitl(37:41), '(I5)') n
              call aawarn('PLFFT', 1, stitl)
            endif
*--- book bank for temporary storage
            call mzbook(1, ltmp, ltbr, -10, 'TMP ', 0, 0, 2 * n, 0, -1)
            do 4  i = 1, n
              if (nselc .eq. 0)  then
                rrv = q(lhval+nskip+i)
                riv = q(lvval+nskip+i)
              elseif (nselc .eq. 1)  then
                rrv =  q(lhval+nskip+i)
                riv = 0.
              else
                rrv =  q(lvval+nskip+i)
                riv = 0.
              endif
              q(ltmp+2*i-1) = rrv
              q(ltmp+2*i) = riv
    4       continue
            call cfft(q(ltmp+1), mp)
*--- restore, get min. + max.
            stp = 1. / n
            rmax = 0.
            nm = 1
            if (nselc .eq. 0)  then
              nup = n
            else
              nup = max(1, n / 2)
            endif
            do 5  i = 1, nup
              if (i .eq. 1)  then
                q(lhval+i) = 0.2 * stp
              else
                q(lhval+i) = stp * (i - 1)
              endif
              q(lvval+i) = sqrt(q(ltmp+2*i-1)**2 + q(ltmp+2*i)**2)
              if (q(lvval+i) .gt. rmax)  then
                rmax =  q(lvval+i)
                nm = i
              endif
    5       continue
            call mzdrop(0, ltmp, ' ')
            call uhtoc (q(lframe + mpname), mcnam, svar, mcnam)
            call plgetn (1, svar, itbv, idum, sdum, sname)
            call uhtoc (q(lvvar + mpname), mxlabl, sanno, mxlabl)
            call gxpnbl(sname, i, k)
            if (nselc .eq. 0)  then
              stit1 = 'FFT of: ' // sname(:k) // ' + i ' // sanno(4:)
              hs = 1.
            elseif (nselc .eq. 1)  then
              stit1 = 'FFT of: ' // sname
              hs = 0.5
            else
              stit1 = 'FFT of: ' // sanno(4:)
              hs = 0.5
            endif
            stit2 = ' ($$$$$ points)'
            write(stit2(3:7), '(I5)')  n
            stit3 = 'max. at f = '
            write(stit3(13:20), '(F8.4)')  stp * (nm - 1)
            call gxpnbl(stit1, i, k)
            stitl = stit1(:k) // stit2(:15) // '<#>' // stit3
            call uctoh (stitl, q(lframe + mpbtit), mcwrd, mtitl)
            sname = 'norm. frequency'
            call uctoh (sname, q(lframe + mpname), mcwrd, mcnam)
            iq(lhval - 1) = nup
            iq(lvval - 1) = nup
            q(lframe + mpmin) = 0.
            q(lframe + mpmax) = hs
            iq(lframe + mpsclf) = 0
            q(lvvar + mpmin) = 0.
            q(lvvar + mpmax) = rmax
            iq(lvvar + mpsclf) = 0
            sanno = 'amplitude'
            call uctoh (sanno, q(lvvar + mpname), mcwrd, mxlabl)
            l = lvcurv
            iq(l + mpstyl) = 0
            iq(l + mpcolr) = 1
            iq(l + mpspli) = 0
            iq(l + mpbars) = 1
            iq(l + mpsymf) = 0
            sname = ' '
            call uctoh (sname, q(l + mpanno), mcwrd, mcnam)
*--- loop
            lvcurv = lq(lvcurv)
            if (lvcurv .ne. 0) goto 20
            lvvar = lq(lvvar)
            if (lvvar .ne. 0) goto 10
          endif
   30   continue
      endif
+ei
  999 end
+dk plgacn
      subroutine plgacn(ncc, window, act, xreal, yreal, np, usex,
     +xwpos, xpos, ypos, ilb)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find suitable position for the curve annotation                    *
* Input:                                                               *
*   NCC      (integer)  current curve count (1,2, etc.)                *
*   WINDOW   (real)     array containing the window to use             *
*   ACT      (real)     window in NDC                                  *
*   XREAL    (real)     x values of curve                              *
*   YREAL    (real)     y values of curve                              *
*   NP       (integer)  no. of points to plot                          *
*   USEX     (real)     user character height expansion                *
* Output:                                                              *
*   XWPOS    (real)     x position of label in world coords.           *
*   XPOS     (real)     x pos. of label in NDC                         *
*   YPOS     (real)     y pos. of label in NDC                         *
*   ILB      (integer)  number of point behind label, or 0 if no       *
*                       label possible                                 *
*----------------------------------------------------------------------*
+ca aparam
+ca plotcp
+ca strgroup
      integer i,iapos,ilb,iposx,iposy,iucomp,iy,j,mpost,mposx,mposy,ncc,
     +np
      double precision xadd,yadd
      parameter            (mposx = 8, mposy = 3,
     +                      mpost = mposx * mposy)

      real                 window(*), act(*), xreal(*), yreal(*)
      real                 xwpos, xpos, ypos, usex
      real                 ywpos, xmax, xmin, xdiff, ydiff, d, t, eps
      real                 xdiag(2,2), ydiag(2,2)

      integer              kapos(mposx, mposy)
      save kapos

*--- reset position array if first curve in frame
      if (ncc .eq. 1)  call vzero(kapos, mpost)
      xdiff = window(2) - window(1)
      ydiff = window(4) - window(3)
      eps = 1.e-6 * max(xdiff, ydiff)
      xmax  = xreal(1)
      xmin  = xmax
      do 10  i = 2, np
        xmin = min(xmin, xreal(i))
        xmax = max(xmax, xreal(i))
   10 continue
   20 continue
*--- find first unoccupied position
      iapos  = iucomp(0, kapos, mpost)
      if (iapos .eq. 0)  then
        ilb = 0
      else
        iposx  = mod (iapos-1, mposx) + 1
        iposy  = (iapos-1) / mposx + 1
        kapos(iposx,iposy) = -1
*--- annot. pos. in NDC
        xpos = act(1) +
     +  0.125 * usex * (iposx - .5) * (act(2) - act(1))
        ypos = act(4) -
     +  usex * (0.05 * (act(4) - act(3)) + 0.03 * (iposy - 1))
*---- annot. position in world coord.
        xwpos = window(1) + xpos * xdiff
*--- get next if outside x values of curve
        if (xwpos .le. xmin .or. xwpos .gt. xmax)  goto 20
        ywpos = window(3) + ypos * ydiff
*--- get endpoint of both diagonals of box
        xadd = 0.0625 * xdiff
        yadd = 0.03  * ydiff
        xdiag(1,1) = xwpos - xadd
        xdiag(2,1) = xwpos + xadd
        xdiag(1,2) = xwpos - xadd
        xdiag(2,2) = xwpos + xadd
        ydiag(1,1) = ywpos
        ydiag(2,1) = ywpos + yadd
        ydiag(1,2) = ywpos + yadd
        ydiag(2,2) = ywpos
*--- make sure no part of curve cuts these lines (curve approx. by
*    straight line segments)
        do 30  i = 2, np
          if (xwpos .gt. xreal(i-1) .and. xwpos .le. xreal(i)) ilb = i
          do 40  j = 1, 2
            d = (xdiag(2,j) - xdiag(1,j)) * (yreal(i-1) - yreal(i))
     +        - (ydiag(2,j) - ydiag(1,j)) * (xreal(i-1) - xreal(i))
            if (abs(d) .lt. eps)  goto 40
            t = (xreal(i-1) - xdiag(1,j)) * (yreal(i-1) - yreal(i))
     +        - (yreal(i-1) - ydiag(1,j)) * (xreal(i-1) - xreal(i))
            t = t / d
            if (t .lt. 0. .or. t .gt. 1.)  goto 40
            t = (xdiag(2,j) - xdiag(1,j)) * (yreal(i-1) - ydiag(1,j))
     +        - (ydiag(2,j) - ydiag(1,j)) * (xreal(i-1) - xdiag(1,j))
            t = t / d
            if (t .ge. 0. .and. t .le. 1.)  goto 20
   40     continue
   30   continue
      endif
      if (ilb .gt. 0)  then
        do 50  iy = 1, mposy
   50   kapos(iposx, iy) = 1
      endif
      do 60  i = 1, mpost
   60 kapos(i,1) = max(0, kapos(i,1))
+ei
      end
+dk plgarw
      subroutine plgarw (mxb, mxc, qc, ir, ntot, ibk, ierr)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Returns Arnold web constrains in inverse Polish notation, coded    *
*                                                                      *
*--- Input                                                             *
*   MXB       (integer) max. length of output array                    *
*   MXC       (integer) max. number of constrains                      *
*   QC           (char) constrains as read                             *
*   IR        (integer) lower, upper limit, step                       *
*---Output                                                             *
*   NTOT      (integer) length occupied in output array                *
*   IBK       (integer) output array containing:                       *
*                       number of superperiods                         *
*                       number of constraints  N                       *
*                       N constraints:                                 *
*                       minimum                                        *
*                       maximum                                        *
*                       step                                           *
*                       Length L                                       *
*                       expression in polish notation of length L,     *
*                       coded as 1+, 2-, 3*, 4/, 1 KX, 2 KY, 3 KS      *
*                       + MQADD + 4, e.g. 100006 = KY                  *
*   IERR      (integer) error flag: 0 OK, else wrong expression        *
*                                                                      *
*----------------------------------------------------------------------*
+ca aparam
+ca plotcp
+ca chcode
+ca strgroup
      integer i,ic,ichar,ierr,ifirst,in,index,iv,j,kn,l,lev,lin,lstore,
     +mxb,mxc,n,nc,ncc,ntot,number
      integer ir(3,*), ibk(*)
      integer isnum(2), ienum(2), ispec(100), ioper(100)
      character * (mcstr)  qc(*), temp
      character * 4        opera
      character * 10       numeri
      character * 36       alpha
      character * 1        a
      data opera  / '+-*/' /
      data numeri / '0123456789' /
      data alpha  / 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789' /

      ierr = 0
      ntot = 2
      ncc  = 0
      do 90 ic = 1, mxc
        n = 0
*--- remove blanks
        lin = 0
        do 10 i = 1, mcstr
          if (qc(ic)(i:i) .ne. ' ')  then
            lin = lin + 1
            temp(lin:lin) = ch2upp(ichar(qc(ic)(i:i)))
          endif
   10   continue
        if (lin .ne. 0)  then
          lin = lin + 1
          temp(lin:lin) = ' '
          ncc = ncc + 1
          ibk(ntot+1) = ir(1,ic)
          ibk(ntot+2) = ir(2,ic)
          ibk(ntot+3) = ir(3,ic)
          ntot = ntot + 4
          lstore=0
          ifirst=0
          nc=0
          number=0
          lev=1
          do 11  i=1,100
            ispec(i) = 0
            ioper(i) = 0
   11     continue
*
*--- start of decoding loop
*
          do 50 in = 1, lin
            a = temp(in:in)
*
*   check for variable or number
*
            if(index(alpha, a) .ne. 0) then
              if(number .eq. 0) then
                number = 1
                nc = nc + 1
                isnum(nc) = in
              endif
            else
*
*   operator or bracket
*
              if(number .ne. 0) then
                number = 0
                ienum(nc) = in - 1
              endif
              if(a .eq. '(') then
                lev = lev + 1
              elseif(a .eq. ')') then
                if(ispec(lev) .ne. 0) then
                  ispec(lev) = 0
                  lev = lev - 1
                endif
                lev = lev - 1
              elseif(index(opera, a) .ne. 0)  then
                if(ifirst .ne. 0 .and. nc .eq. 1 .or. nc .eq. 2) then
*
*   output number(s) and/or operators
*
                  ifirst = 1
                  do 30 j = 1 , nc
                    kn = index(numeri, temp(isnum(j):isnum(j)))
                    if (kn .ne. 0)  then
*--- number
                      iv = 0
                      do 20 l = isnum(j), ienum(j)
                        kn = index(numeri, temp(l:l))
                        if (kn .eq. 0)  then
*--- illegal - letter among digits
                          ierr = 1
                          goto 999
                        endif
                        iv = 10 * iv + kn - 1
   20                 continue
                    else
*--- must be KX, KY, or KS
                      kn =
     +                (index('KXKYKS', temp(isnum(j):ienum(j))) + 1) / 2
                      if (kn .eq. 0)  then
                        ierr = 1
                        goto 999
                      endif
                      iv = mqadd + 4 + kn
                    endif
                    n = n + 1
                    ibk(ntot+n) = iv
   30             continue
                  nc=0
                endif
*
*--- set special flag for operator sequences
*
                if((a. eq. '+' .or. a .eq. '-') .and. ispec(lev) .ne. 0)
     +          then
                  ispec(lev) = 0
                  lev = lev - 1
                endif
*
*--- output operator(s)
*
                do 40 j = lstore, lev, -1
                  if(ioper(j) .ne. 0) then
                    n = n + 1
                    ibk(ntot+n) = ioper(j)
                    ioper(j) = 0
                  endif
   40           continue
                lstore = lev
                ioper(lstore) = index(opera, a) + mqadd
                if(a .eq. '+' .or. a .eq. '-') then
                  lev = lev + 1
                  ispec(lev) = 1
                endif
              endif
            endif
   50     continue
*
*   end of constraint expression - code numbers and operators left
*
          do 70 j = 1 , nc
            kn = index(numeri, temp(isnum(j):isnum(j)))
            if (kn .ne. 0)  then
*--- number
              iv = 0
              do 60 l = isnum(j), ienum(j)
                kn = index(numeri, temp(l:l))
                if (kn .eq. 0)  then
*--- illegal - letter among digits
                  ierr = 1
                  goto 999
                endif
                iv = 10 * iv + kn - 1
   60         continue
            else
*--- must be KX, KY, or KS
              kn =
     +        (index('KXKYKS', temp(isnum(j):ienum(j))) + 1) / 2
              if (kn .eq. 0)  then
                ierr = 1
                goto 999
              endif
              iv = mqadd + 4 + kn
            endif
            n = n + 1
            ibk(ntot+n) = iv
   70     continue
          do 80 j = lstore, 1, -1
            if(ioper(j) .ne. 0) then
              n = n + 1
              ibk(ntot+n) = ioper(j)
            endif
   80     continue
          ibk(ntot) = n
          ntot = ntot + n
        endif
   90 continue
      ibk(2) = ncc
+ei
  999 end
+dk plgaxn
      subroutine plgaxn (nax, vax, sax, ns)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Returns compound vertical axis annotation                          *
*                                                                      *
*--- Input                                                             *
*   NAX       (integer) no. of vert. var. names in VAX                 *
*   VAX          (char) vert. var. names                               *
*---Output                                                             *
*   SAX          (char) remaining (possibly truncated) names           *
*   NS        (integer) no. of names in SAX                            *
*----------------------------------------------------------------------*
+ca aparam
+ca plotcp
+ca strgroup
      integer i,index,j,k,k1,k1f,k2,k2f,nax,ns
      character*(mcnam) vax(*), sax(*), scut, saloc

      ns = 0
      if (nax .le. 0)  then
        sax(1) = ' '
      else
        do 10  i = 1, nax
          saloc = vax(i)
          call gxpnbl(saloc, k1, k2)
          if (k2 .gt. 1 .and. index('XY', saloc(k2:k2)) .ne. 0)  then
            scut = saloc(:k2-1)
            do 30  j = 1, ns
               if (scut .eq. sax(j))  goto 10
   30       continue
            do 20 j = i + 1, nax
              call gxpnbl(vax(j), k1f, k2f)
              if (k2 .eq. k2f)  then
                if (index('XY', vax(j)(k2:k2)) .ne. 0)  then
                  if (saloc(:k2-1) .eq. vax(j)(:k2-1))  then
                    saloc = scut
                    do 40  k = 1, ns
                      if (saloc .eq. sax(k))  goto 10
   40               continue
                  endif
                endif
              endif
   20       continue
          endif
          ns      = ns + 1
          sax(ns) = saloc
   10   continue
      endif
+ei
      end
+dk plgcmd
      subroutine plgcmd (ierr)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Returns unpacked PLOT command parameters.                          *
*                                                                      *
*+++ Input and output (except IERR) via common blocks in +CA PLCOMM    *
* Output:                                                              *
*   HAXIS        (char) variable on horizontal axis                    *
*   VAXIS        (char) variables on axes 1 - 4                        *
*   NVVAR     (integer) no. of vert. variables per axis                *
*   IVPAR     (integer) certain integer PLOT parameters                *
*   TYPE         (char) plot type for track plots                      *
*   HRANGE       (real) horizontal plot interval                       *
*   VRANGE       (real) vertical plot intervals                        *
*   TABLE        (char) table name                                     *
*   TITLE        (char) plot title                                     *
*   IRPOS     (integer) lower and upper range position                 *
*   SPARM        (char) frame selection parameter                      *
*   SORTFL, SPLIFL, MULTFL, FFTFL, DUMPFL (logical)   flags            *
*   USRV         (real) user provided ranges                           *
*   NNTV         (int)  no. of values in USRV                          *
*                                                                      *
*   IERR      (integer) =0: OK, >0 : error in command                  *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca strgroup
+ca plotcp
+ca plcomm
+ca header
+ca plotcd
+ca refer
+ca datatype
      integer i,ierr,ius,j,k,kk,l,nhor,nvert
      double precision tval
      dimension            tval(25)

      integer              itype(mppcrn)

      logical              eflag

      ierr     = 0
      irpos(1) = 0
      irpos(2) = 0
      call vzero (nvvar, 4)
      call vzero (nntv , musrv)
      call vfill (ivpar, mxipar, -1)
      ivnarw    = 0
      ntmax     = 0
      sortfl    = .false.
      splifl    = .false.
      multfl    = .false.
      helpfl    = .false.
      hrange(1) = pflmax
      hrange(2) = pflmax
      qsval = 0.
      call vfill (vrange, 8, pflmax)
      type  = ' '
      haxis = ' '
      table = ' '
      title = ' '
      sparm = ' '
      do 10 i = 1, mpmxvr
        do 10 j = 1, 4
          vaxis(i,j) = ' '
   10 continue
*--- set defaults for K_x etc. selection criteria (Q_y/Q_x plot)
      do 11  i = 1, mxqcnd
        iqrang(1,i) = 0
        iqrang(2,i) = 0
        iqrang(3,i) = 1
        qcond(i)    = ' '
   11 continue

      call utgtyp (lccmd, itype)
*--- take VAXIS parameters if given, else take VAXIS1...4
      if (itype(1) .ne. 0)  then
        do 20 i = 1, mpmxvr
          if (itype(i) .ne. 0)  then
            call utgnam (lccmd, i, i, vaxis(i,1))
            nvvar(1) = nvvar(1) + 1
          endif
   20   continue
        nvert = 1
      else
        nvert = 0
        k = mpmxvr
        do 30 i = 1,4
          do 30 j = 1, mpmxvr
            k = k + 1
            if (itype(k) .ne. 0)  then
              nvert = nvert + 1
              call utgnam (lccmd, k, k, vaxis(j,i))
              nvvar(i) = nvvar(i) + 1
            endif
   30   continue
      endif
      k = 5 * mpmxvr + 1
      if (itype(k) .ne. 0)  then
        call utgnam (lccmd, k, k, haxis)
        nhor = 1
      else
        nhor = 0
      endif
      do 40 i = 1, mxipar
        k = k + 1
        if (itype(k) .ne. 0)  call utgint (lccmd, k, k, ivpar(i))
   40 continue
*--- sort option
      k = k + 1
      if (itype(k) .ne. 0)  call utglog (lccmd, k, k, sortfl)
*--- spline option
      k = k + 1
      if (itype(k) .ne. 0)  call utglog (lccmd, k, k, splifl)
*--- multiple option
      k = k + 1
      if (itype(k) .ne. 0)  call utglog (lccmd, k, k, multfl)
*--- help flag (prints list of all variables, suppresses plot)
      k = k + 1
      if (itype(k) .ne. 0)  call utglog (lccmd, k, k, helpfl)
*--- Fast Fourier Transform option
      fftfl = ivpar(6) .ge. 0
*--- dump flag (dumps plot bank, suppresses plot)
      dumpfl = ivpar(8) .ge. 0
      if (nvert .eq. 0)  then
        call aawarn('PLGCMD', 1, 'No vertical variable.')
        ierr = 1
        goto 999
      endif
      if (nhor .eq. 0)  then
        call aawarn('PLGCMD', 1, 'No horizontal variable.')
        ierr = 2
        goto 999
      endif
      call utgflt (lccmd, k + 1, k + 2, tval)
      do 50 i = 1, 2
        k = k + 1
        if (itype(k) .ne. 0)  hrange(i) = tval(i)
   50 continue
      call utgflt (lccmd, k+1, k+8, tval)
      kk = 0
      do 70 j = 1, 2
        do 60 i = 1, 4
          kk = kk + 1
          k  = k + 1
          if (itype(k) .ne. 0)  vrange(j,i) = tval(kk)
   60   continue
   70 continue
      k = k + 1
      if (itype(k) .ne. 0)  call utgnam (lccmd, k, k, table)
      k = k + 1
      if (itype(k) .ne. 0)  then
        call utgstr (lccmd, k, k, title)
      else
        if (ctitle .eq. ' ')  then
          title = sequnam
        else
          title = ctitle
        endif
      endif
      k = k + 1
      if (itype(k) .ne. 0) call utgnam (lccmd, k, k, sparm)
      k = k + 1
      if (itype(k) .ne. 0)  then
        l = lq(lccmd - k)
        if (l .ne. 0) then
          call utgrng (l, lcseq, irpos(1), irpos(2), eflag)
          if (eflag) then
            ierr = 3
            goto 999
          endif
        else
          call aawarn('PLGCMD', 1, 'Currently no line exists.')
          ierr = 4
          goto 999
        endif
      endif
      do 90  ius = 1, musrv
        call utgflt (lccmd, k+1, k+25, tval)
        do 80 j = 1, 25
          k = k + 1
          if (itype(k) .ne. 0) then
            nntv(ius) = nntv(ius) + 1
            usrv(nntv(ius),ius) = tval(j)
          endif
   80   continue
   90 continue
      k = k + 1
      if (itype(k) .ne. 0)  call utgint (lccmd, k, k, ntmax)
      ntmax = min(ntmax, mntmax)
      do 100 i = 1, mxqcnd
        k = k + 1
        if (itype(k) .ne. 0)  then
          call utgstr (lccmd, k, k, qcond(i))
          ivnarw = 1
        endif
        do 110  j = 1, 3
          k = k + 1
          if (itype(k) .ne. 0)  then
            call utgint (lccmd, k, k, iqrang(j,i))
            ivnarw = 1
          endif
  110   continue
  100 continue
*--- temporary QS variable
      k = k + 1
      call utgflt (lccmd, k, k, tval)
      if (itype(k) .ne. 0)  qsval = tval(1)
*--- plot file name (HIGZ only)
      k = k + 1
      call utgstr (lccmd, k, k, plfnam)
      if (itype(k) .eq. 0)  plfnam = plpnam
+ei
  999 end
+dk plgetn
      subroutine plgetn (iflag, svar, it, ipflg, sovar, sname)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Finds variable, dependent variables, axis and curve annotations    *
* Input:                                                               *
*   IFLAG    (integer)  0 for dependent variables and process flag,    *
*                       1 for axis, 2 for curve, 3 for trunc. name,    *
*                       4 to print the axis names on IQLOG             *
*   SVAR        (char)  variable to be looked up.                      *
*   IT          (int)   table number (see PLGTBS).                     *
* Output:                                                              *
*   IPFLG(1) (integer)  process flag: 0 as is, 1 take root, else call  *
*                       function PLPVAL                                *
*   IPFLG(2) (integer)  interpol. flag: 0 spline, else call            *
*                       function PLINTP                                *
*   SOVAR       (char)  array of (up to MXDEP) dependent variables     *
*   SNAME       (char)  requested annotation                           *
*----------------------------------------------------------------------*
+ca aparam
+ca plotcp
+ca strgroup
+ca zunit
      integer i,iflag,index,iref,it,j,k1,k1f,k2,k2f

      integer           ipflg(2)

      character         svar*(mcnam), sovar(*)*(mcnam),
     +                     sname * (mxlabl)
      character         svlabl(mnvar)*(mxlabl)
      character         svanno(mnvar)*(mxlabl)
      character         svname(mnvar)*(mcnam)
*--- strings:
*   SVLABL   plot prescriptions for variables on axis labels
*   SVANNO   plot prescriptions for variables in annotations
*   SVNAME   names of variables known to the program

      integer              iproc(mnvar,3), intpo(mnvar)
      integer              ivdep(mnvar,mxdep,3)

      data (svname(j), j = 1, 32) /
     +'S', 'SIZE', 'DELTAP',
     +'QS', 'X', 'Y', 'XSIZE', 'YSIZE',
     +'DT', 'XN', 'YN', 'PXN', 'PYN',
     +'GAMMATR', 'XRMS', 'YRMS',
     +'XMAX', 'YMAX', 'BXMAX',
     +'BYMAX', 'DXMAX', 'DYMAX',
     +'TN', 'T', 'TURNS', 'PARTICLE', 'ALFA',
     +'PTN', 'WT', 'PHIT',
     +'RBXMAX',
     +'RBYMAX' /
      data (svname(j), j = 33, mnvar) /
     +'BETX', 'RBETX',
     +'ALFX', 'MUX', 'DX',
     +'DPX', 'QX', 'PX', 'WX',
     +'PHIX', 'DMUX',
     +'DDX', 'DDPX', 'IWX',
     +'XIX',
     +'BETY', 'RBETY',
     +'ALFY', 'MUY', 'DY',
     +'DPY', 'QY', 'PY', 'WY',
     +'PHIY', 'DMUY',
     +'DDY', 'DDPY', 'IWY',
     +'XIY', 'XNS', 'PXNS', 'WXS',
     +'YNS', 'PYNS', 'WYS',
     +'ENERGY', 'SPINTUNE',
     +'POLTOTAL', 'POLDIFFX', 'POLDIFFY', 'PT' /

      data (svlabl(j), j = 1, 32) /
     +'s (m)', 'n<G>s<G> (mm)', '<G>d<G><?>E<?>/p<?>0<?>c',
     +'Q<?>s<?>', 'x (m)', 'y (m)', 'n<G>s<G> (mm)', 'n<G>s<G> (mm)',
     +'ct (m)', 'x<?>n<?>', 'y<?>n<?>', 'p<?>xn<?>', 'p<?>yn<?>',
     +'<G>g<G><?>tr<?>', 'X<?>rms<?> (m)', 'Y<?>rms<?> (m)',
     +'X<?>max<?> (m)', 'Y<?>max<?> (m)', '<G>b<G><?>x_max<?> (m)',
     +'<G>b<G><?>y_max<?> (m)', 'D<?>x_max<?> (m)', 'D<?>y_max<?> (m)',
     +'t<?>n<?>', 'ct (m)', 'turns', 'particle', '<G>a<G>',
     +'p<?>t_n<?>', 'W<?>t<?>', '<G>F<G><?>t<?> (rad/2<G>p<G>)',
     +'<G>b<G><?>x_max<?><!>1/2<!> (m<!>1/2<!>)',
     +'<G>b<G><?>y_max<?><!>1/2<!> (m<!>1/2<!>)' /
      data (svlabl(j), j = 33, mnvar) /
     +'<G>b<G><?>x<?> (m)', '<G>b<G><?>x<?><!>1/2<!> (m<!>1/2<!>)',
     +'<G>a<G><?>x<?>', '<G>m<G><?>x<?> (rad/2<G>p<G>)', 'D<?>x<?> (m)',
     +'D<?>px<?>', 'Q<?>x<?>', 'p<?>x<?>/p<?>0<?>', 'W<?>x<?>',
     +'<G>F<G><?>x<?> (rad/2<G>p<G>)', 'd<G>m<G><?>x<?>/d<G>d<G>',
     +'dD<?>x<?>/d<G>d<G> (m)', 'dD<?>px<?>/d<G>d<G>', 'W<?>x<?> (m)',
     +'XI<?>x<?>',
     +'<G>b<G><?>y<?> (m)', '<G>b<G><?>y<?><!>1/2<!> (m<!>1/2<!>)',
     +'<G>a<G><?>y<?>', '<G>m<G><?>y<?> (rad/2<G>p<G>)', 'D<?>y<?> (m)',
     +'D<?>py<?>', 'Q<?>y<?>', 'p<?>y<?>/p<?>0<?>', 'W<?>y<?>',
     +'<G>F<G><?>y<?> (rad/2<G>p<G>)', 'd<G>m<G><?>y<?>/d<G>d<G>',
     +'dD<?>y<?>/d<G>d<D> (m)', 'dD<?>py<?>/d<G>d<G>', 'W<?>y<?> (m)',
     +'XI<?>y<?>', 'x<?>ns<?>', 'p<?>x_ns<?>', 'W<?>xs<?>',
     + 'y<?>ns<?>', 'p<?>y_ns<?>', 'W<?>ys<?>',
     + 'E[GeV]', 'spintune',
     + 'polarization','polarization','polarization','p<?>t<?>' /

      data (svanno(j), j = 1, 32) /
     +'s', 'n<G>s<G>', '<G>d<G>',
     +'Q<?>s<?>', 'x', 'y', 'n<G>s<G><?>x<?>', 'n<G>s<G><?>y<?>',
     +'ct', 'x<?>n<?>', 'y<?>n<?>', 'p<?>xn<?>', 'p<?>yn<?>',
     +'<G>g<G><?>tr<?>', 'X<?>rms<?>', 'Y<?>rms<?>',
     +'X<?>max<?>', 'Y<?>max<?>', '<G>b<G><?>x_max<?>',
     +'<G>b<G><?>y_max<?>', 'D<?>x_max<?>', 'D<?>y_max<?>',
     +'t<?>n<?>', 't', 'turns', 'particle', '<G>a<G>',
     +'p<?>t_n<?>', 'W<?>t<?>', '<G>F<G><?>t<?>',
     +'<G>b<G><?>x_max<?><!>1/2<!>',
     +'<G>b<G><?>y_max<?><!>1/2<!>' /
      data (svanno(j), j = 33, mnvar) /
     +'<G>b<G><?>x<?>', '<G>b<G><?>x<?><!>1/2<!>',
     +'<G>a<G><?>x<?>', '<G>m<G><?>x<?>', 'D<?>x<?>',
     +'D<?>px<?>', 'Q<?>x<?>', 'p<?>x<?>', 'W<?>x<?>',
     +'<G>F<G><?>x<?>', '<G>m<G><?>x<?>''',
     +'D<?>x<?>''', 'D<?>px<?>''', 'W<?>x<?>',
     +'XI<?>x<?>',
     +'<G>b<G><?>y<?>', '<G>b<G><?>y<?><!>1/2<!>',
     +'<G>a<G><?>y<?>', '<G>m<G><?>y<?>', 'D<?>y<?>',
     +'D<?>py<?>', 'Q<?>y<?>', 'p<?>y<?>', 'W<?>y<?>',
     +'<G>F<G><?>y<?>', '<G>m<G><?>y<?>''',
     +'D<?>y<?>''', 'D<?>py<?>''', 'W<?>y<?>',
     +'XI<?>y<?>', 'x<?>ns<?>', 'p<?>x_ns<?>', 'W<?>xs<?>',
     + 'y<?>ns<?>', 'p<?>y_ns<?>', 'W<?>ys<?>',
     + ' ', ' ',
     + 'p<?>tot<?>', 'p<?>diff_x<?>', 'p<?>diff_y<?>', 'p<?>t<?>'/

      data (iproc(j,1), j = 1, 32) /
     +0, 0, 0,
     +0, 0, 0, 0, 0,
     +0, 2, 3, 4, 5,
     +0, 0, 0,
     +0, 0, 0,
     +0, 0, 0,
     +6, 0, 0, 0, 0,
     +7, 8, 9,
     +1,
     +1 /

      data (iproc(j,1), j = 33, mnvar) /
     +0, 1,
     +0, 0, 0,
     +0, 0, 0, 0,
     +0, 0,
     +0, 0, 0,
     +0,
     +0, 1,
     +0, 0, 0,
     +0, 0, 0, 0,
     +0, 0,
     +0, 0, 0,
     +0, 14, 15, 16,
     +17, 18, 19,
     +0, 0,
     +0, 0, 0, 0 /

      data (iproc(j,2), j = 1, 32) /
     +0, 0, 0,
     +0, 0, 0, 0, 0,
     +0, 2, 3, 4, 5,
     +0, 0, 0,
     +0, 0, 0,
     +0, 0, 0,
     +6, 0, 0, 0, 0,
     +7, 8, 9,
     +1,
     +1 /

      data (iproc(j,2), j = 33, mnvar) /
     +0, 1,
     +0, 0, 0,
     +0, 0, 0, 10,
     +11, 0,
     +0, 0, 0,
     +0,
     +0, 1,
     +0, 0, 0,
     +0, 0, 0, 12,
     +13, 0,
     +0, 0, 0,
     +0, 14, 15, 16,
     +17, 18, 19,
     +0, 0,
     +0, 0, 0, 0 /

      data (iproc(j,3), j = 1, 32) /
     +0, 0, 0,
     +0, 0, 0, 0, 0,
     +0, 2, 3, 4, 5,
     +0, 0, 0,
     +0, 0, 0,
     +0, 0, 0,
     +6, 0, 0, 0, 0,
     +7, 8, 9,
     +1,
     +1 /

      data (iproc(j,3), j = 33, mnvar) /
     +0, 1,
     +0, 0, 0,
     +0, 0, 0, 10,
     +11, 0,
     +0, 0, 0,
     +0,
     +0, 1,
     +0, 0, 0,
     +0, 0, 0, 12,
     +13, 0,
     +0, 0, 0,
     +0, 14, 15, 16,
     +17, 18, 19,
     +0, 0,
     +0, 0, 0, 0 /

      data (intpo(j), j = 1, 32) / 32 * 0 /
*--- in INTPO, n+100 means: take SQRT of var. n
      data (intpo(j), j = 33, mnvar) /
     +1, 101,
     +2, 3, 4,
     +5, 0, 0, 0,
     +0, 0,
     +0, 0, 0,
     +0,
     +6, 106,
     +7, 8, 9,
     +10, 0, 0, 0,
     +0, 0,
     +0, 0, 0,
     +0, 0, 0, 0,
     +0, 0, 0,
     +0, 0,
     +0, 0, 0, 0 /

      data (ivdep(j,1,1), j = 1, 32) /
     +1, 2, 3,
     +4, 5, 6, 7, 8,
     +9, 5, 6, 5, 6,
     +14, 15, 16,
     +17, 18, 19,
     +20, 21, 22,
     +24, 24, 25, 26, 27,
     +3, 3, 3,
     +19,
     +20 /
      data (ivdep(j,2,1), j = 1, 32) /
     +0, 0, 0,
     +0, 0, 0, 0, 0,
     +0, 0, 0, 40, 55,
     +0, 0, 0,
     +0, 0, 0,
     +0, 0, 0,
     +0, 0, 0, 0, 0,
     +0, 24, 24,
     +0,
     +0 /
      data (ivdep(j,1,1), j = 33, mnvar) /
     +33, 33,
     +35, 36, 37,
     +38, 39, 40, 41,
     +42, 43,
     +44, 45, 46,
     +47,
     +48, 48,
     +50, 51, 52,
     +53, 54, 55, 56,
     +57, 58,
     +59, 60, 61,
     +62, 5, 5, 5,
     +6, 6, 6,
     +69, 70,
     +71, 72, 73, 74 /
      data (ivdep(j,2,1), j = 33, mnvar) /
     +0, 0,
     +0, 0, 0,
     +0, 0, 0, 0,
     +0, 0,
     +0, 0, 0,
     +0,
     +0, 0,
     +0, 0, 0,
     +0, 0, 0, 0,
     +0, 0,
     +0, 0, 0,
     +0, 0, 40, 40,
     +0, 55, 55,
     +0, 0,
     +0, 0, 0, 0 /

      data (ivdep(j,1,2), j = 1, 32) /
     +1, 2, 3,
     +4, 5, 6, 7, 8,
     +9, 5, 6, 5, 6,
     +14, 15, 16,
     +17, 18, 19,
     +20, 21, 22,
     +24, 24, 25, 26, 27,
     +3, 3, 3,
     +19,
     +20 /
      data (ivdep(j,2,2), j = 1, 32) /
     +0, 0, 0,
     +0, 0, 0, 0, 0,
     +0, 0, 0, 40, 55,
     +0, 0, 0,
     +0, 0, 0,
     +0, 0, 0,
     +0, 0, 0, 0, 0,
     +0, 24, 24,
     +0,
     +0 /
      data (ivdep(j,1,2), j = 33, mnvar) /
     +33, 33,
     +35, 36, 37,
     +38, 39, 40, 5,
     +5, 43,
     +44, 45, 46,
     +47,
     +48, 48,
     +50, 51, 52,
     +53, 54, 55, 6,
     +6, 58,
     +59, 60, 61,
     +62, 5, 5, 5,
     +6, 6, 6,
     +69, 70,
     +71, 72, 73, 74 /
      data (ivdep(j,2,2), j = 33, mnvar) /
     +0, 0,
     +0, 0, 0,
     +0, 0, 0, 40,
     +40, 0,
     +0, 0, 0,
     +0,
     +0, 0,
     +0, 0, 0,
     +0, 0, 0, 55,
     +55, 0,
     +0, 0, 0,
     +0, 0, 40, 40,
     +0, 55, 55,
     +0, 0,
     +0, 0, 0, 0 /

      data (ivdep(j,1,3), j = 1, 32) /
     +1, 2, 3,
     +4, 5, 6, 7, 8,
     +9, 5, 6, 5, 6,
     +14, 15, 16,
     +17, 18, 19,
     +20, 21, 22,
     +24, 24, 25, 26, 27,
     +3, 3, 3,
     +19,
     +20 /
      data (ivdep(j,2,3), j = 1, 32) /
     +0, 0, 0,
     +0, 0, 0, 0, 0,
     +0, 0, 0, 40, 55,
     +0, 0, 0,
     +0, 0, 0,
     +0, 0, 0,
     +0, 0, 0, 0, 0,
     +0, 24, 24,
     +0,
     +0 /
      data (ivdep(j,1,3), j = 33, mnvar) /
     +33, 33,
     +35, 36, 37,
     +38, 39, 40, 5,
     +5, 43,
     +44, 45, 46,
     +47,
     +48, 48,
     +50, 51, 52,
     +53, 54, 55, 6,
     +6, 58,
     +59, 60, 61,
     +62, 5, 5, 5,
     +6, 6, 6,
     +69, 70,
     +71, 72, 73, 74 /
      data (ivdep(j,2,3), j = 33, mnvar) /
     +0, 0,
     +0, 0, 0,
     +0, 0, 0, 40,
     +40, 0,
     +0, 0, 0,
     +0,
     +0, 0,
     +0, 0, 0,
     +0, 0, 0, 55,
     +55, 0,
     +0, 0, 0,
     +0, 0, 40, 40,
     +0, 55, 55,
     +0, 0,
     +0, 0, 0, 0 /

      if (it .le. 0 .or. it .gt. 3)  then
        sovar(1) = svar
        sovar(2) = ' '
        sname    = svar
        ipflg(1) = 0
        ipflg(2) = 0
        goto 999
      endif
      sovar(1) = ' '
      if (iflag .eq. 4)  then
*--- printing on ECHO file requested for all names
        write(iqlog, '(/'' Number of PLOT variables ='',I5/)') mnvar
        write(iqlog, '(4X,4A18)')  (svname(i), i = 1, mnvar)
        write(iqlog, *) ' '
        goto 999
      endif
      sname = svar
*--- search in list of known variables
      do 1  iref = 1, mnvar
        if (svar .eq. svname(iref))  goto 9
    1 continue
      call gxpnbl(svar, k1, k2)
      do 2  iref = 1, mnvar
        call gxpnbl(svname(iref), k1f, k2f)
        if (k2 + 1 .eq. k2f)  then
          if (index('XY', svname(iref)(k2f:k2f)) .ne. 0)  then
            if (svar(:k2) .eq. svname(iref)(:k2))  goto 9
          endif
        endif
    2 continue
      goto 999
    9 continue
      if (iflag .eq. 0)  then
        sname = svname(iref)
        ipflg(1) = iproc(iref,it)
        ipflg(2) = intpo(iref)
        do 10  j = 1, mxdep
          if (ivdep(iref,j,it) .eq. 0)  then
            sovar(j) = ' '
          else
            sovar(j) = svname(ivdep(iref,j,it))
          endif
   10   continue
      elseif (iflag .eq. 1) then
        sname = svlabl(iref)
        if (svar .ne. svname(iref))  then
*--- incomplete match
*    replace x or y in name by blank
          call gxpnbl(sname, k1, k2)
          do 20  i = 2, k2
            if (index('XYxy', sname(i:i)) .ne. 0)  then
              sname(i:i) = ' '
            endif
   20     continue
        endif
      elseif (iflag .eq. 2) then
        sname = svanno(iref)
      elseif (iflag .eq. 3) then
        if (svar .eq. svname(iref))  then
          sname = svname(iref)
        else
          sname = svname(iref)(:k2)
        endif
      else
        sname = svar
      endif
+ei
  999 end
+dk plgtbs
      subroutine plgtbs (sval, ierr)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Returns table information such as biasses for all var. etc.        *
* Input:                                                               *
*   SVAL     (char)     table name                                     *
* Output:                                                              *
*   variables in /PLCOMM/                                              *
*   Top bank LTBR:                                                     *
*                  1 = no. of valid rows (refs. in daughter 1)         *
*                  2 = no. of valid segments (refs. daughter 2)        *
*                  3 = 0 if no parameter (all in one frame)            *
*                      1 if one frame per row                          *
*                      2 if one frame per segment                      *
*   IERR     (integer)  error flag:                                    *
*                       0 = OK                                         *
*                       else > 0                                       *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca strgroup
+ca pi
+ca plotcp
+ca plcomm
+ca plotcd
+ca refer
+ca seqflag
+ca status
+ca tbpara
+ca datatype
      integer i,icopy,ienum,ierr,iflag,iocc,ipcd,itpv,j,jbyt,jrow,jseg,
     +k,kf,kl,kt,ll,msegin,nloc,nmrow,nsbsiz,nsup,nvrw,nvsg
      double precision eps,one,tpval,tval,two,twopi,zero
      parameter         (zero = 0.d0)
      parameter         (one = 1.d0, two = 2.d0, twopi = two * pi)

      parameter            (msegin = 1000)
*
*     MSEGIN               increment for segment bank
*
      dimension            eps(3)
      real                 hrgdef(2,mtbv), vrgdef(2,4,mtbv)
*
*     EPS                  limit for diff. between user and table val.
*     HRGDEF               default values for hor. ranges
*     VRGDEF               default values for vertical ranges
*

      character         sval*(*)
      character         tnam*(mcnam), dum1*(mcnam), dum2*(mcrng)
      character         stbv(mtbv)*(mcnam)
      character         spav(mdsv,mtbv)*(mcnam)
*
*     SVAL                 input variable
*     TNAM                 table name
*     DUM1, DUM2           dummy variables
*     STBV                 table names
*     SPAV                 potential parameter names
*                          (always 1 = row, 2 = segment)

      integer              npav(mtbv), ndfv(mtbv), nmlv(mtbv)
      integer              jppv(mdsv,mtbv), ivdf(mxipar,mtbv)
      integer              ieqd(2)
      equivalence          (tval, ieqd(1))
*
*     NPAV                 no. of parameters in SPAV
*     NDFV                 number of the default parameter in SPAV
*     NMLV                 if 1 for a table, "multiple" flag used
*     JPPV                 -1   if parameter corresponds to a range
*                          0    if simple column
*                          > 0  : pointer to count in NNTV and
*                          to user specified values in USRV
*     IVDF                 plot parameter defaults (--> IVPAR)

      logical              eflag, symm, rangfl, valid, plstrg

      data eps / 1.e-6, 0.1, 0.1 /

*--- reminder: last table must remain 'any'

      data stbv / 'TWISS', 'TUNES', 'TRACK', 'SITF', 'EIGEN', 'any' /
      data spav / 'S',        'DELTAP', ' ',
     +            'DELTAP',   ' ',      ' ',
     +            'PARTICLE', 'TURNS',  ' ',
     +            ' ',        ' ',      ' ',
     +            'S',        ' ',      ' ',
     +            ' ',        ' ',      ' ' /

      data npav / 2, 1, 2, 0, 1, 0 /
      data ndfv / 2, 1, 1, 1, 1, 1 /
      data nmlv / 0, 0, 1, 0, 0, 0 /
      data jppv / -1, 1, 0,
     +             1, 0, 0,
     +             2, 3, 0,
     +             0, 0, 0,
     +            -1, 0, 0,
     +             0, 0, 0 /
      data ivdf / 0, 1, 0, 10, 1, -1, -1, -1,
     +            0, 1, 0, 10, 1, -1, -1, -1,
     +            0, 0, 1, 10, 1, -1, -1, -1,
     +            0, 1, 2, 10, 1, -1, -1, -1,
     +            0, 1, 0, 10, 1, -1, -1, -1,
     +            0, 1, 0, 10, 1, -1, -1, -1 /

      data hrgdef / 2 * pflmax,
     +              2 * pflmax,
     +              2 * pflmax,
     +              2 * pflmax,
     +              2 * pflmax,
     +              2 * pflmax /
      data vrgdef / 8 * pflmax,
     +              8 * pflmax,
     +              8 * pflmax,
     +              0., 100., 0., 100., 0., 100., 0., 100.,
     +              8 * pflmax,
     +              8 * pflmax /

      ierr = 0
      tnam = sval
      tpval = -1.e20
      do 10 itbv = 1, mtbv - 1
        if (tnam .eq. stbv(itbv))  goto 20
   10 continue
      call aawarn('PLGTBS', 1,
     +'Default plot for unknown table = ' // tnam)
      itbv = mtbv
   20 continue
      if (itbv .eq. 1 .and. .not. (stabx .and. staby)) then
        ierr = 1
        goto 999
      endif
*--- get biasses and formats of parameters
      rangfl = .false.
      do 30  i = 1, npav(itbv)
        rangfl = rangfl .or. jppv(i,itbv) .lt. 0
        call tbcol (ltab, spav(i,itbv), idsfrm(i), idsbis(i))
        if (idsfrm(i) .eq. 0)  then
          call aawarn('PLGTBS', 1,
     +    'Table does not contain ' // spav(i,itbv))
          ierr = 2
          goto 999
        endif
   30 continue
*--- set plot defaults
      do 40  i = 1, mxipar
        if (ivpar(i) .lt. 0)  ivpar(i) = ivdf(i,itbv)
   40 continue
*--- plot ranges
      do 41  i = 1, 2
        if (hrange(i) .eq. pflmax)  hrange(i) = hrgdef(i,itbv)
        do 41  j = 1, 4
          if (vrange(i,j) .eq. pflmax)  vrange(i,j) = vrgdef(i,j,itbv)
   41 continue
*--- ranges if any
      if (rangfl)  then
        call utbeam (lq(ltab-1), irg1, irg2, symm, nsup, dum1, dum2)
        if (irg1 .eq. 0 .or. irg2 .eq. 0) then
          call aawarn('PLGTBS', 1,
     +    'Table "' // tnam // '" contains no range.')
          ierr = 3
          goto 999
        endif
*--- limit to user range if valid
        if (irpos(1) .gt. 0 .and. irpos(2) .ge. irpos(1)) then
          if (irpos(1) .gt. irg2 .or. irpos(2) .lt. irg1) then
            write (dum2, '(4I8)') irpos(1), irpos(2), irg1, irg2
            call aawarn('PLGTBS', 1,
     +      'Conflicting user and table range: ' // dum2)
            ierr = 4
            goto 999
          else
            irg1 = max (irg1, irpos(1))
            irg2 = min (irg2, irpos(2))
          endif
        endif
      else
        irg1 = 1
        irg2 = iq(ltab+mtbrow)
      endif
*--- find plot parameter (one frame for each value of this par.)
      if (sparm .eq. ' ') sparm = spav(ndfv(itbv),itbv)
      if (sparm .ne. ' ')  then
        call gxpnbl(sparm, kf, kl)
        do 50  itpv = 1, mdsv
          if (sparm(:kl) .eq. spav(itpv,itbv)(:kl)) goto 60
   50   continue
        call aawarn('PLGTBS', 1, 'Unknown plot parameter = ' // sparm)
        ierr = 5
        goto 999
   60   continue
        sparm = spav(itpv,itbv)
      endif
      call gxpnbl(haxis, kf, kl)
      if (sparm(:kl) .eq. haxis(:kl)) then
*--- if parameter is hor. axis, switch to other if any
        do 70  i = 1, mdsv
          if (i .ne. itpv)  then
            sparm = spav(i,itbv)
            goto 80
          endif
   70   continue
   80   itpv = i
      endif
      if (sparm .eq. ' ' .or. multfl .and. nmlv(itbv) .ne. 0
     +.or. npav(itbv) .le. 1)  itpv = 0
*--- max. no. of rows
      nmrow = irg2 + 1 - irg1
      if (jppv(1,itbv) .gt. 0)  then
      if (nntv(jppv(1,itbv)) .gt. 0)
     +nmrow = min(nmrow, nntv(jppv(1,itbv)))
      endif
*--- book work bank
      call mzbook (1, ll, ltbr, 1, 'WORK', 10, 10, 3, 0, 0)
*--- book bank for row numbers
      call mzbook (1, lvrw, ltbr, -1, 'VRW ', 0, 0, nmrow, 0, -1)
*--- book bank for segment numbers
      call mzbook (1, lvsg, ltbr, -2, 'VSG ', 0, 0, msegin, 0, -1)
*--- book bank for pointers to LFORM and LBIAS
      call mzbook (1, locc, ltbr, -3, 'OCC ', 0, 0, mnvar, 0, -1)
*--- book bank for counts in LFORM and LBIAS
      call mzbook (1, lcnt, ltbr, -4, 'CNT ', 0, 0, mnvar, 0, -1)
*--- book bank for process flag ( 0: take variable as is, 1: take root,
*    2: process code for function PLPVAL)
      call mzbook (1, lproc, ltbr, -5, 'PROC', 0, 0, mnvar, 0, -1)
*--- book bank for formats (2 = integer, 3 = real, else d.p.)
      call mzbook (1, lform, ltbr, -6, 'FORM', 0, 0, 2 * mnvar, 0, -1)
*--- book bank for biasses in table
      call mzbook (1, lbias, ltbr, -7, 'BIAS', 0, 0, 2 * mnvar, 0, -1)
*--- book bank for interpolation flag: if 0 use spline, else process
*    code in routine PLINTP (daughters are for temp. coord. banks)
      call mzbook (1, lpint, ltbr, -8, 'PINT', maux, maux, mnvar, 0,
     +-1)
*--- book banks for string expression variables
      nexpvr = 4 * mpmxvr + 1
      call mzbook (1, lexpv, lexpv, 1, 'EXPV', nexpvr, nexpvr, 0, 0,
     +-1)
      nexpvr = 0
      nocc = 0
      nform = 0
      nsbsiz = msegin
*--- get valid rows
      nvrw = 0
      do 100  jseg = 1, iq(ltab+mtbseg)
        call tbseg (ltab, jseg, eflag)
        if (.not.eflag)  then
          do 110   jrow = irg1, irg2
            call tbset(ltab, jrow, 1, lbuf)
            if (lbuf .ne. 0)  then
              if (itbv .eq. 1)  then
*--- twiss table
                call utelem (lcseq, jrow, iflag, dum1, iocc, ienum)
*--- keep only first point, and element end points
                valid = jrow .eq. 1 .or. jbyt(iflag, 1, mcode) .eq. 1
              else
                valid = .true.
              endif
              if (valid)  then
*--- valid row
                if (idsfrm(1) .eq. 2)  then
                  tval = iq(lbuf+idsbis(1)+1)
                elseif (idsfrm(1) .eq. 3)  then
                  tval = q(lbuf+idsbis(1)+1)
                else
                  do 111  icopy = 1, mwflt
  111             ieqd(icopy) = iq(lbuf+idsbis(1)+icopy)
                endif
                if (tval .ne. tpval)  then
                  tpval = tval
                  if (jppv(1,itbv) .gt. 0)  then
                    if (nntv(jppv(1,itbv)) .gt. 0)  then
*--- user has specified values - select rows accordingly
                      k = jppv(1,itbv)
                      do 120  j = 1, nntv(k)
                        if (abs(tval - usrv(j,k)) .le. eps(k))
     +                  goto 130
  120                 continue
                      goto 110
                    endif
                  endif
                endif
              endif
*--- store row number
  130         continue
              nvrw = nvrw + 1
              iq(lvrw+nvrw) = jrow
            endif
  110     continue
          goto 140
        endif
  100 continue
  140 continue
      if (nvrw .eq. 0)  then
        call aawarn('PLGTBS', 1, 'No rows in table ' // tnam)
        ierr = 6
        goto 999
      endif
*--- get valid segments
      nvsg = 0
      do 200  jseg = 1, iq(ltab+mtbseg)
        call tbseg (ltab, jseg, eflag)
        if (.not.eflag)  then
*--- valid segment
          do 210   jrow = irg1, irg2
            call tbset(ltab, jrow, 1, lbuf)
            if (lbuf .ne. 0)  then
              if (jppv(2,itbv) .gt. 0)  then
                if (nntv(jppv(2,itbv)) .gt. 0)  then
*--- user has specified values - select segments accordingly
                  if (idsfrm(2) .eq. 2)  then
                    tval = iq(lbuf+idsbis(2)+1)
                  elseif (idsfrm(2) .eq. 3)  then
                    tval = q(lbuf+idsbis(2)+1)
                  else
                    do 211  icopy = 1, mwflt
  211               ieqd(icopy) = iq(lbuf+idsbis(2)+icopy)
                  endif
                  k = jppv(2,itbv)
                  do 220  j = 1, nntv(k)
                    if (abs(tval - usrv(j,k)) .le. eps(k)) goto 230
  220             continue
                  goto 200
                endif
              endif
  230         continue
              if (nvsg .eq. nsbsiz)  then
                call mzpush(0, lvsg, 0, msegin, 'I')
                nsbsiz = nsbsiz + msegin
              endif
*--- store segment number
              nvsg = nvsg + 1
              iq(lvsg+nvsg) = jseg
              goto 200
            endif
  210     continue
        endif
  200 continue
      if (nvsg .eq. 0)  then
        call aawarn('PLGTBS', 1, 'No segments in table ' // tnam)
        ierr = 7
        goto 999
      endif
*--- store row no., segment no., type
      iq(ltbr+1) = nvrw
      iq(ltbr+2) = nvsg
      iq(ltbr+3) = itpv
*--- check for expression variable
      if (plstrg(haxis, ltab))  then
        call exstrg(haxis, ltab, lexpv, -(nexpvr + 1) , tval, eflag)
        nexpvr = nexpvr + 1
        ihpntr = - nexpvr
        dum1 = '_' // haxis
        haxis = dum1
      else
*--- biasses and formats for variables
        call plcoli(haxis, ihpntr, ipcd)
        if (ihpntr .eq. 0)  then
          call aawarn('PLGTBS', 1, 'Horizontal variable not found.')
          ierr = 8
          goto 999
        endif
      endif
      ntvvar = 0
      kt     = 0
      do 310 i = 1, 4
        nloc = 0
        do 300 j = 1, nvvar(i)
*--- check for expression variable
          if (plstrg(vaxis(j,i), ltab))  then
            call exstrg(vaxis(j,i), ltab, lexpv, -(nexpvr + 1),
     +      tval, eflag)
            nexpvr = nexpvr + 1
            nloc = nloc + 1
            kt   = kt + 1
            dum1 = '_' // vaxis(j,i)
            vaxis(j,i) = dum1
            vaxis(nloc,ntvvar+1)   = vaxis(j,i)
            ivpntr(nloc,ntvvar+1)  = - nexpvr
            iq(lpint+kt)           = 0
          else
            call plcoli(vaxis(j,i), ivpntr(j,i), ipcd)
            if (ivpntr(j,i) .eq. 0)  then
              call aawarn('PLGTBS', 1,
     +        'Ignoring non-existing variable = ' // vaxis(j,i))
              goto 300
            else
              nloc = nloc + 1
              kt   = kt + 1
              vaxis(nloc,ntvvar+1)   = vaxis(j,i)
              ivpntr(nloc,ntvvar+1)  = ivpntr(j,i)
              iq(lpint+kt)           = ipcd
            endif
          endif
  300   continue
        if (nloc .ne. 0)  then
          ntvvar           = ntvvar+1
          nvvar(ntvvar)    = nloc
          vrange(1,ntvvar) = vrange(1,i)
          vrange(2,ntvvar) = vrange(2,i)
        endif
  310 continue
+ei
  999 end
+dk pliact
        subroutine pliact(kact, np, indx, x, y, ac, kf, kl)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Return first and last point of curve inside active window          *
* Input:                                                               *
*   KACT        (int)   starting point for check                       *
*   NP          (int)   number of points in XVAL, YVAL                 *
*   INDX        (int)   order of values (possibly sorted)              *
*   X           (real)  x values                                       *
*   Y           (real)  y values                                       *
*   AC          (real)  active window in WC                            *
* Output:                                                              *
*   KF          (int)   first point inside, or 0                       *
*   KL          (int)   last  point inside, or 0                       *
*                                                                      *
*----------------------------------------------------------------------*
+ca aparam
      integer i,kact,kf,kl,np
      double precision toleps,xtol,ytol
      real x(*), y(*), ac(4)
      integer indx(*)
      parameter (toleps = 1.e-5)

      xtol = toleps * (ac(2) - ac(1))
      ytol = toleps * (ac(4) - ac(3))
      kf = 0
      kl = 0
      do 10  i = kact, np
        if(x(indx(i)) + xtol .lt. ac(1))  goto 10
        if(x(indx(i)) - xtol .gt. ac(2))  goto 10
        if(y(indx(i)) + ytol .lt. ac(3))  goto 10
        if(y(indx(i)) - ytol .gt. ac(4))  goto 10
        kf = i
        goto 20
   10 continue
*--- no point inside
      goto 999
   20 continue
      do 30  i = kf, np
        if(x(indx(i)) + xtol .lt. ac(1))  goto 40
        if(x(indx(i)) - xtol .gt. ac(2))  goto 40
        if(y(indx(i)) + ytol .lt. ac(3))  goto 40
        if(y(indx(i)) - ytol .gt. ac(4))  goto 40
   30 continue
   40 kl = i - 1
+ei
  999 end
+dk plintp
      subroutine plintp(iep, npnt, nmax, step, vmin, vmax, ierr)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Interpolate variables plotted against s                            *
* Input:                                                               *
*   IEP         (int)   row number of first element                    *
*   NPNT        (int)   number of points  (updated !)                  *
*   NMAX        (int)   max. no. of points that should possibly appear *
*   STEP        (real)  max. dist. between two successive hor. values  *
*   VMIN        (real)  min. for 4 axes (updated!)                     *
*   VMAX        (real)  max. for 4 axes (updated!)                     *
* Output:                                                              *
*   IERR        (int)   0 if OK, else > 0                              *
*                                                                      *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca strgroup
+ca option
+ca pi
+ca plotcp
+ca plcomm
+ca plotcd
+ca refer
+ca seqflag
+ca tbpara
+ca datatype
      integer i,iecub,ienum,iep,ierr,iflag,iocc,ip,ipc,isp,itp,iv,j,jv,
     +k,ki,new,nmax,npnt,nrg,nst
      double precision am,ax0,ax1,ay0,ay1,bx0,bx1,by0,by1,dmu,dpx0,dpx1,
     +dpy0,dpy1,dstp,dx0,dx1,dy0,dy1,gamx,gamy,one,stpl,temp,tw0,tw1,
     +two,twopi,ux0,ux1,uy0,uy1,zero
      parameter         (zero = 0.d0)
      parameter         (one = 1.d0, two = 2.d0, twopi = two * pi)

      dimension         tw0(mint), tw1(mint), temp(9)
      dimension         am(6,6)
      equivalence       (bx0, tw0(1)), (ax0, tw0(2)), (ux0, tw0(3)),
     +                  (dx0, tw0(4)), (dpx0, tw0(5)),
     +                  (by0, tw0(6)), (ay0, tw0(7)), (uy0, tw0(8)),
     +                  (dy0, tw0(9)), (dpy0, tw0(10))
      equivalence       (bx1, tw1(1)), (ax1, tw1(2)), (ux1, tw1(3)),
     +                  (dx1, tw1(4)), (dpx1, tw1(5)),
     +                  (by1, tw1(6)), (ay1, tw1(7)), (uy1, tw1(8)),
     +                  (dy1, tw1(9)), (dpy1, tw1(10))

      real              step, vmin(4), vmax(4), s0, diff, gxcubv

      integer           ifm(mint), ibs(mint)

      logical           elmflg, vanflg, sqflag
      double precision edg1, edg2, sk1, an, h, corr, hgap, fint,
     +ek0(6), enfr(6,6), tw(6,6,6)
      double precision an2

      character*(mcnam) dum1
      character*(mcnam) spv(mint)

      data spv / 'BETX', 'ALFX', 'MUX', 'DX', 'DPX',
     +           'BETY', 'ALFY', 'MUY', 'DY', 'DPY' /

      ierr = 0

*--- book auxiliary banks
      do 10 i = 1, maux
        call mzbook (1, laux(i), lpint, -i, 'AUX ', 0, 0, nmax, 0, -1)
   10 continue
*---  set flags for correct, and spline interpolation
      elmflg = .false.
      vanflg = .false.
      k = 0
      do 20 iv = 1, ntvvar
        do 20 jv = 1, nvvar(iv)
          k = k + 1
          elmflg = elmflg .or. iq(lpint+k) .gt. 0
          vanflg = vanflg .or. iq(lpint+k) .eq. 0
   20 continue
      if (elmflg)  then
*--- get formats and biasses
        do 30 i = 1, mint
          call tbcol (ltab, spv(i), ifm(i), ibs(i))
   30   continue
*--- get initial Twiss parameters
        call tbset(ltab, iq(lvrw+1), 1, lbuf)
        do 40 i = 1, mint
          if (ifm(i) .eq. 3) then
            tw0(i) = q(lbuf + ibs(i) + 1)
          else
            call ucopy(q(lbuf+ibs(i)+1), tw0(i), mwflt)
          endif
   40   continue
*--- get intermediate s values, and interpolate Twiss parameters
        new = 1
*--- collect s values for final plot in bank LAUX(MAUX)
        q(laux(maux)+1) = q(lhval+1)
*--- set first point of Twiss parameters
        do 50 i = 1, mint
   50   q(laux(i)+1) = tw0(i)
        do 90 ip = 2, npnt
          s0    = q(laux(maux)+new)
          diff  = (q(lhval+ip) - s0)
          if (diff .gt. zero) then
*--- keep point - calculate number of steps for element interpol.
            call tbset(ltab, iq(lvrw+ip), 1, lbuf)
            do 60 i = 1, mint
              if (ifm(i) .eq. 3) then
                tw1(i) = q(lbuf + ibs(i) + 1)
              else
                call ucopy(q(lbuf+ibs(i)+1), tw1(i), mwflt)
              endif
   60       continue
            nst  = diff / step
            if (nst .gt. 0)  then
*--- get element parameters and Twiss parameters
              call utelem (lcseq, iq(lvrw+ip), iflag, dum1, iocc, ienum)
              isp = iq(lcelm + mbsp)
              call bmgelm(lcelm, temp)
              if (isp .eq. 1)  then
*--- drift
                itp = 0
              elseif (isp .eq. 2 .or. isp .eq. 3)  then
*--- bend
                itp = 1
                call ucopy(q(lcelm+mee1g), edg1, mwflt)
                call ucopy(q(lcelm+mee2g), edg2, mwflt)
                call ucopy(q(lcelm+mek1g), sk1, mwflt)
                call ucopy(q(lcelm+meangg), an,   mwflt)
                call ucopy(q(lcelm+megapg), hgap, mwflt)
                call ucopy(q(lcelm+meintg), fint, mwflt)
                if (isp .eq. 2) then
*--- HG001026: arc length to rectangular bend
                  an2 = an / 2.d0
                  if (an2 .ne. 0.d0 .and. rbarc)
     +            temp(1) = temp(1) * an2 / sin(an2)
                  edg1 = edg1 + an2
                  edg2 = edg2 + an2
                endif
                h = an / temp(1)
                corr = (h + h) * hgap * fint
                call tmfrng(.false.,h,sk1,edg1,zero,+one,corr,
     +          ek0,enfr,tw)
                if (temp(5) .ne. zero)  then
                  h = enfr(2,1)
                  enfr(2,1) = enfr(4,3)
                  enfr(4,3) = h
                endif
              elseif (isp .eq. 5)  then
*--- quad
                itp = 2
              else
                itp = 0
              endif
              stpl = diff / (nst + 1)
              if (bx0 .ne. zero)  then
                gamx = (one + ax0**2) / bx0
              else
                gamx = zero
              endif
              if (by0 .ne. zero)  then
                gamy = (one + ay0**2) / by0
              else
                gamy = zero
              endif
              do 70 j = 1, nst
                new = new + 1
                if (new .gt. nmax)  then
                  ierr = 1
                  goto 999
                endif
                dstp = j * stpl
                q(laux(maux)+new) = s0 + dstp
*--- element matrix 6x6
                call plelma(itp, temp, dstp, am)
                if (itp .eq. 1)  call m66mpy(am, enfr, am)
*--- interpolate Twiss parameters
*    beta_x, beta_y
                q(laux(1)+new) = -two * am(1,1) * am(1,2) * ax0
     +          + am(1,1)**2 * bx0 + am(1,2)**2 * gamx
                q(laux(6)+new) = -two * am(3,3) * am(3,4) * ay0
     +          + am(3,3)**2 * by0 + am(3,4)**2 * gamy
*--- alfa_x, alfa_y
                q(laux(2)+new) = (am(1,1) * am(2,2) + am(1,2) * am(2,1))
     +          * ax0 - am(1,1) * am(2,1) * bx0
     +          - am(1,2) * am(2,2) * gamx
                q(laux(7)+new) = (am(3,3) * am(4,4) + am(3,4) * am(4,3))
     +          * ay0 - am(3,3) * am(4,3) * by0
     +          - am(3,4) * am(4,4) * gamy
*--- mu_x, mu_y
                dmu = atan2(am(1,2), bx0 * am(1,1) - ax0 * am(1,2))
                if (dmu .lt. zero)  dmu = dmu + twopi
                q(laux(3)+new) = ux0 + dmu / twopi
                dmu = atan2(am(3,4), by0 * am(3,3) - ay0 * am(3,4))
                if (dmu .lt. zero)  dmu = dmu + twopi
                q(laux(8)+new) = uy0 + dmu / twopi
*--- D-x, D-y
                q(laux(4)+new) = am(1,1) * dx0 + am(1,2) * dpx0
     +          + am(1,6)
                q(laux(9)+new) = am(3,3) * dy0 + am(3,4) * dpy0
     +          + am(3,6)
*--- D'-x, D'-y
                q(laux(5)+new)  = am(2,1) * dx0 + am(2,2) * dpx0
     +          + am(2,6)
                q(laux(10)+new) = am(4,3) * dy0 + am(4,4) * dpy0
     +          + am(4,6)
   70         continue
            endif
            new = new + 1
            if (new .gt. nmax)  then
              ierr = 1
              goto 999
            endif
            q(laux(maux)+new) = q(lhval+ip)
            do 80 i = 1, mint
              tw0(i) = tw1(i)
   80       q(laux(i)+new) = tw1(i)
          endif
   90   continue
*--- loop over variables, replace those with codes
        i = 0
        do 110 iv = 1, ntvvar
          do 110 jv = 1, nvvar(iv)
            i = i + 1
            ipc = iq(lpint + i)
            sqflag = ipc .gt. 100
            ipc = mod(ipc, 100)
            if (ipc .gt. 0)  then
              k  = laux(ipc)
              ki = lrvc(i)
              do 100 j = 1, new
                if (sqflag)  then
                  q(ki+j) = sqrt(q(k+j))
                else
                  q(ki+j) = q(k+j)
                endif
*--- adapt min. and max.
                vmin(iv) = min(vmin(iv), q(ki+j))
                vmax(iv) = max(vmax(iv), q(ki+j))
  100         continue
            endif
  110   continue
      endif
      if (vanflg)  then
*--- get intermediate s values, and original without multiple s
        new = 1
        nrg = 1
        iq(laux(1)+1) = 1
        q(laux(2)+1)  = q(lhval+1)
*--- collect s values for final plot in bank LAUX(MAUX)
        q(laux(maux)+1) = q(lhval+1)
        do 130 ip = 2, npnt
          s0    = q(laux(maux)+new)
          diff  = (q(lhval+ip) - s0)
          if (diff .gt. zero) then
*--- keep point - calculate number of steps for interpol.
            nrg = nrg + 1
            iq(laux(1)+nrg) = ip
            q(laux(2)+nrg)  = q(lhval+ip)
            nst  = diff / step
            stpl = diff / (nst + 1)
            do 120 j = 1, nst
              new = new + 1
              if (new .gt. nmax)  then
                ierr = 1
                goto 999
              endif
              dstp = j * stpl
              q(laux(maux)+new) = s0 + dstp
  120       continue
            new = new + 1
            if (new .gt. nmax)  then
              ierr = 1
              goto 999
            endif
            q(laux(maux)+new) = q(lhval+ip)
          endif
  130   continue
        if (nrg .lt. 3)  then
          ierr = 2
          goto 999
        endif
*--- loop over variables, spline those without codes
        i  = 0
        do 160 iv = 1, ntvvar
          do 160 jv = 1, nvvar(iv)
            i = i + 1
            ipc = iq(lpint + i)
            if (ipc .eq. 0)  then
              ki = lrvc(i)
              do 140 j = 1, nrg
  140         q(laux(3)+j) = q(ki+iq(laux(1)+j))
              call gxcubi (nrg, q(laux(2)+1), q(laux(3)+1),
     +        q(laux(4)+1), q(laux(5)+1), iecub)
              do 150 j = 1, new
                q(laux(6)+j) = gxcubv(q(laux(maux)+j), nrg,
     +          q(laux(2)+1), q(laux(3)+1), q(laux(4)+1), q(laux(5)+1))
*--- adapt min. and max.
                vmin(iv) = min(vmin(iv), q(laux(6)+j))
                vmax(iv) = max(vmax(iv), q(laux(6)+j))
  150         continue
              call ucopy(q(laux(6)+1), q(ki+1), new)
            endif
  160   continue
      endif
*--- replace s values
      npnt = new
      call ucopy(q(laux(maux)+1), q(lhval+1), npnt)
+ei
  999 end
+dk plmain
      subroutine plmain (ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Switch routine (subprocess code) for plot section.                 *
* Input:                                                               *
*   IPR       (integer) Process code.                                  *
*   ISP       (integer) Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca strgroup
+ca plotcp
+ca plcomm
+ca plotcd
+ca option
+ca refer
+ca status
+ca tbpara
+ca tbcomm
+ca zunit
+ca datatype
      integer i,ierr,ifdum,ifunam,ind,inmeta,interm,ipict,ipmfst,ipmfsu,
     +ipr,iprrep,isp,itp,ival,ivdum,kstart,l,lm,mmpntg,
     +nf,npict,nplist,nunloc,nvrw,nvsg
      double precision f,rvdum,splist,spstep,tval,zero
      logical intrac

      parameter (zero = 0.d0, mmpntg = 5000)
      integer           ityp(mpparn)
      real              rdummy
      dimension         tval(mppcrn)
      dimension         splist(mmpntg)
      character         fname * 8, dummy * 8
      character         * (mcstr) strstr, sval
      character         spvars(mint) * 16, spcomm(mmpntg) * 16
      character         * (mcfil) spfnam, spinam, sout(2)

      data ipmfst / 0 /, ipmfsu / 0 /, ifunam / 0 /

      if (ipr .ne. 14)  then
        call aawarn('PLMAIN', 1, 'No plot command.')
        goto 999
      endif
*---- User-defined services.
      if (isp .le. 0  .or.  isp .gt. 10) then
        call usercm(ipr, isp)
*---- Predefined services.
      else
        inter = intrac()
        if (ipmfst .eq. 0)  then
*--- book banks for SETPLOT parameters
          if (lroot .eq. 0)  then
            call aafail('PLMAIN', 1, 'LROOT bank not present.')
            goto 999
          endif
          l = lq(lroot - mpparl)
          if (l .eq. 0)
     +    call mzbook (2, l, lroot, -mpparl, 'PLOT', 0, 0, mpparn, 3, 0)
          ipmfst = 1
        endif
        if (isp .eq. 1) then
+if .not.noplot
          if (ipmfsu .eq. 0)  then
            call mzlink (0, '/PLCOMM/', lpmain, ltab, lbuf)
            ipmfsu = 1
            plpnam = 'mad'
          endif
*--- decode command
          call plgcmd(ierr)
          if (ierr .ne. 0) goto 999
*--- get table
          if(table.eq.' ')  then
*--- no user-specified table - take last one
            if (ltable .eq. 0)  then
              call aawarn('PLMAIN', 1, 'No table exists.')
              goto 999
            endif
            call uhtoc (iq(ltable + mtbnam), mcwrd, table, mcnam)
          endif
          call tbopen (table, 1, ltab)
          if (ltab .eq. 0)  then
            call aawarn('PLMAIN', 1, 'Table not found.')
            goto 999
          endif
*--- get table name
          call tbgdsc (ltab, 'TYPE', ifdum, ivdum, rvdum, sval)
*--- get all table biasses, etc.
          call plgtbs (sval, ierr)
          if (ierr .ne. 0) goto 999
*--- paper size from SETPLOT command
          if (lroot .eq. 0) then
            call aafail('PLMAIN', 1, 'LROOT bank not present.')
            goto 999
          endif
          l = lq(lroot - mpparl)
          if (l .eq. 0) then
            call aafail('PLMAIN', 1, 'Plot parameter bank not found.')
            goto 999
          endif
          if (q(l+3) .ne. 0. .and. q(l+4) .ne. 0.) then
            call gxsvar ('XMETAF', 0, q(l+3), ' ')
            call gxsvar ('YMETAF', 0, q(l+4), ' ')
          endif
*--- set PostScript format (.ps or .eps)
          if (iq(l+9) .gt. 0)  call gxsvar('IPSEPS', iq(l+9), 0., ' ')
*--- set plot file name for each plot
          call gxsvar ('SMETNM', 0, 0., plfnam)
          if (ifunam .eq. 0)  then
*--- first time
            plpnam = plfnam
            ifunam = 1
          elseif (plpnam .ne. plfnam)  then
*--- close current .ps file if any
            call gxterm
            plpnam = plfnam
            call gxinit
          endif
          if (iplflg .eq. 0 .and. .not. dumpfl) then
*--- initalize plotting (workstations etc.)
            iplflg = 1
*--- metafile or postscript = unit 16, name='metafile' or 'mad.ps' etc.
            call flnset ('metafile', fname)
            call gxsvar ('IMETUN', 16, 0., ' ')
*--- error output on echo file - already open
            call gxeopn ('ERRORFILE', iqlog)
*--- if interactive, inquire user via IQTTIN (input) and IQTYPE
            if (inter) then
              call gxsvar ('INUNIT', iqttin, 0., ' ')
              call gxsvar ('IOUNIT', iqtype, 0., ' ')
*--- set wait time to 1 sec. (Higz only)
              call gxsvar ('WTTIME', 0, 1., ' ')
              call gxasku
            endif
*--- inhibit second MZEBRA call (Higz only)
            call gxsvar ('ICZEBR', 0, 0., ' ')
*--- set or reduce window size (only X11)
            if (iq(l+10) .gt. 0) then
              call gxsvar('NXPIX', iq(l+10), 0., ' ')
            endif
            if (iq(l+11) .gt. 0) then
              call gxsvar('NYPIX', iq(l+11), 0., ' ')
            else
              call gxsvar('NYPIX', 670, 0., ' ')
            endif
*--- inhibit initial X-Window (only X11)
            call gxsvar('ITSEOP', 1, 0., ' ')
            call gxinit
            call gxclos
          endif
*--- plot only if a workstation is open
          if (.not. dumpfl)  then
            call gxqvar ('INTERM', interm, rdummy, fname)
            call gxqvar ('INMETA', inmeta, rdummy, fname)
            if (interm .eq. 0 .and. inmeta .eq. 0) then
              call aawarn('PLMAIN', 1,
     +        'Neither terminal nor metafile open.')
              goto 999
            endif
*--- open workstation, metafile etc.
            call gxopen
          endif
*--- loop over parameter values, one plot for each, limit
          nvrw = iq(ltbr+1)
          nvsg = iq(ltbr+2)
          itp  = iq(ltbr+3)
          if (itp .eq. 0)  then
            npict = 1
          elseif (itp .eq. 1)  then
            npict = nvrw
          else
            npict = nvsg
          endif
*--- limit no. of frames to user request or default
          npict = min (npict, ivpar(4))
          do 10 ipict = 1, npict
*--- book top plot bank
            call mzbook (1, lm, lpmain, 1, 'MAIN', mpfram+3, mpfram+3,
     +      mpfelm, 0, -1)
*--- Proceed to fill plot banks.
            call plprep (ipict, itp, ierr)
            if (ierr .ne. 0) goto 20
            if (dumpfl)  then
*--- dump the plot bank to output
              call pldump
            else
*--- plot
            if (ipict .gt. 1)  call gxopen
              call plplot
              call gxwait
+if osf1
              call gxclrw
+ei
*WNT          CALL GXCLRW
              call gxclos
            endif
            call mzdrop (0, lpmain, ' ')
   10     continue
   20     continue
          call mzwipe (1)
        elseif (isp .eq. 2)  then
*--- SETPLOT command - store parameters
          if (lroot .eq. 0)  then
            call aafail('PLMAIN', 1, 'LROOT bank not present.')
            goto 999
          endif
          l = lq(lroot - mpparl)
          if (l .eq. 0)  then
            call aafail('PLMAIN', 1, 'Plot parameter bank not found.')
            goto 999
          endif
          call utgtyp (lccmd, ityp)
          call utgint (lccmd, 1, 1, ival)
          if (ityp(1) .ne. 0)  iq(l + 1) = ival
          call utgflt (lccmd, 2, 8, tval)
          do 30 i = 2, 8
            if (ityp(i) .ne. 0) q(l + i) = tval(i - 1)
   30     continue
          call utgint (lccmd, 9, 10, ival)
          if (ityp(9) .ne. 0)  iq(l + 9) = max(0, min(2, ival))
          call utgint (lccmd, 10, 11, iq(l+10))
        elseif (isp .eq. 3)  then
*--- RESPLOT command - restore defaults for plotting
          if (lroot .eq. 0)  then
            call aafail('PLMAIN', 1, 'LROOT bank not present.')
            goto 999
          endif
          l = lq(lroot - mpparl)
          if (l .eq. 0)  then
            call aafail('PLMAIN', 1, 'Plot parameter bank not found.')
            goto 999
          endif
        if (inter)  then
*--- font
          iq(l+1) = 1
*--- linewidth
          q(l+2) = 1.
*--- xsize
          q(l+3) = 0.
*--- ysize
          q(l+4) = 0.
*--- ascale, lscale, sscale, rscale
          q(l+5) = 1.
          q(l+6) = 1.
          q(l+7) = 1.
          q(l+8) = 1.
*--- pixels
          iq(l+10) = 1000
          iq(l+11) = 670
        else
*--- font
          iq(l+1) = 1
*--- linewidth
          q(l+2) = 5.
*--- xsize
          q(l+3) = 0.
*--- ysize
          q(l+4) = 0.
*--- ascale, lscale, sscale, rscale
          q(l+5) = 1.5
          q(l+6) = 2.
          q(l+7) = 2.
          q(l+8) = 1.8
*--- pixels
          iq(l+10) = 1000
          iq(l+11) = 670
        endif
+ei
        elseif (isp .eq. 4)  then
*--- SPRINT command - store parameters and execute
          if (lroot .eq. 0)  then
            call aafail('PLMAIN', 1, 'LROOT bank not present.')
            goto 999
          endif
          l = lq(lroot - mpparl)
          if (l .eq. 0)  then
            call aafail('PLMAIN', 1, 'Plot parameter bank not found.')
            goto 999
          endif
          spfnam = 'sprint'
          call utgstr(lccmd, 1, 1, spfnam)
          spinam = ' '
          call utgstr(lccmd, 2, 2, spinam)
          kstart = 2
          do 41 i = 1, mint-1
   41     spvars(i) = ' '
          call utgnam(lccmd, kstart+1, kstart+mint-1, spvars)
          iprrep = 0
          spstep = zero
          if (spinam .eq. ' ')  then
            call utgint(lccmd, kstart+mint, kstart+mint, iprrep)
            call utgflt(lccmd, kstart+mint+1, kstart+mint+1, spstep)
            nplist = 50
            do 42  i = 1, nplist
              spcomm(i) = ' '
   42       splist(i) = -1.d0
            call utgflt(lccmd, kstart+mint+2, kstart+mint+51, splist)
            if (iprrep .lt. 0 .or. spstep .eq. zero)  iprrep = 0
          else
            call flopen(spinam, 'SRFD', 0, 0, nunloc, error)
            if (error)  then
              call aawarn('sprint', 1, 'unable to open file :'//spinam)
              goto 999
            endif
            nplist = 0
   44       read (nunloc, '(a)', end = 45) strstr
            if (strstr(1:1) .ne. '#')  then
              call plgitn(2, strstr, nf, sout)
              if (nf .gt. 0)  then
                call plgfia(sout(1), ind, f, i, dummy)
                nplist = nplist + 1
                if (ind .eq. 1)  then
                  splist(nplist) = i
                elseif (ind .eq. 2 .or. ind .eq. 3)  then
                  splist(nplist) = f
                else
                  dummy = ' '
                  write(dummy, '(i8)')  nplist
                  call aawarn('sprint', 1,
     +            'illegal format, line:'//dummy)
                  nplist = nplist - 1
                  goto 45
                endif
                if (nf .eq. 2)  then
                  spcomm(nplist) = sout(2)
                else
                  spcomm(nplist) = ' '
                endif
              endif
            endif
            if (nplist .lt. mmpntg)  goto 44
   45       call flclos(nunloc, error)
          endif
*--- no user-specified table - take last one
          if (ltable .eq. 0)  then
            call aawarn('sprint', 1, 'no table exists.')
            goto 999
          endif
          call uhtoc (iq(ltable + mtbnam), mcwrd, table, mcnam)
          call tbopen (table, 1, ltab)
          if (ltab .eq. 0)  then
            call aawarn('sprint', 1, 'table not found.')
            goto 999
          endif
*--- get table name
          call tbgdsc (ltab, 'TYPE', ifdum, ivdum, rvdum, sval)
          if (sval(:5) .ne. 'TWISS')  then
            call aawarn('sprint', 1, 'last table not TWISS.')
            goto 999
          endif
          call flopen(spfnam, 'SWFD', 0, 0, nunloc, error)
          call plprpr(spvars, nunloc, iprrep, spstep, nplist,
     +    splist, spcomm)
          call flclos(nunloc, error)
          call mzwipe (1)
        endif
      endif
  999 end
+dk plplot
      subroutine plplot
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Plot all types of graphs in MAD.                                   *
*   Uses GXPLOT with underlying GKS.                                   *
*----------------------------------------------------------------------*
*                                                                      *
*               input tree structure                                   *
*                                                                      *
*   LPMAIN
*    | | |
*    | | LQV1 (struct. link MPFRAM+3)
*    | |
*    | LM1,LM2 (struct. links MPFRAM+1,MPFRAM+2)
*    |
*   LFRAME (up to MPFRAM structural links)
*    | | |
*    | | (possibly index for sequence of hor. coord., structure link 3)
*    | |
*    | (possibly bank with hor. coordinates, structure link 2)
*    |
*   LVVAR --- next --- next --- ...     (structure link 1)
*    |
*    |
*   LVCURV --- next --- next --- ...    (structure link 1)
*    || ||
*    || ||
*    || |LVVAL (structural link 1)
*    || |
*    || (possibly structural link 2 to hor. coor. bank)
*    ||
*    |LHVAL (ref. link 1 = total link 3)
*    |
*    LINDX  (ref. link 2 = total link 4)
*
*   bank contents (data part):
*
*   LPMAIN:
*
*   MPFONT      font position in top bank
*   MPXSIZ      x size    - " -
*   MPYSIZ      y    - " -
*   MPASCL      annotation   - " -
*   MPLSCW      line width scale factor pos.
*   MPLSCL      label scale factor position
*   MPSSCL      symbol scale factor position
*   MPTSCL      text    - " -
*   MPFELM      start of first element in banks LM1, LM2 below
*
*   LM1:        types of elements for machine plot
*               0: drift
*               1: bend
*               2: focussing quad.
*               3: defocussing quad.
*
*   LM2:        lengths of elements
*
*   LQV1:       bank for Arnold web plot (from routine PLGARW):
*                       number of superperiods
*                       number of constraints  N
*                       N constraints:
*                       minimum
*                       maximum
*                       step
*                       Length L
*                       expression in polish notation of length L,
*                       coded as 1+, 2-, 3*, 4/, 1 KX, 2 KY, 3 KS
*                       + MQADD + 4, e.g. 100006 = KY
*
*   LFRAME:
      integer i,idum,ierr,ivax,k1dum,k2dum,k3dum,kf,kf1,kf2,kl,kl1,kl2,
     +l,masize,mlsize,mtsize,nframe,np,npar,ntcurv,nvax

*   MPMIN       hor. range minimum position in bank
*   MPMAX       hor.   "   maximum     - " -
*   MPSCLF      scale flag        - " -
*               meaning of flag: 0 = choose optimum range
*                                1 = start or end range at 0.
*
*                                2 = centre range around 0.
*                                3 = use range as is
*   MPNAME      hor. variable name position in bank
*   MPTTIT      top title position in bank
*   MPBTIT      bottom  - " -
*
*
*   LVVAR:   one bank per vertical variable axis (compound name)
*
*   MPMIN       vert. range minimum position in bank
*   MPMAX       vert.   "   maximum     - " -
*   MPSCLF      scale flag              - " -
*               meaning of flag: 0 = choose optimum range
*                                1 = start or end range at 0.
*
*                                2 = centre range around 0.
*                                3 = use range as is
*   MPVAXR      vert. axis ref. no. in bank
*   MPNAME      vert. variable name position in bank
*
*   LVCURV:  one bank per curve belonging to the "mother" axis
*
*   MPSTYL      curve style flag: 0 = no polyline
*                                 1 = solid line
*                                 2 = dashed
*                                 3 = dotted
*                                 4 = dot-dashed
*                               100 = 1,2,3,4,1,2,.... for succ. curves
*   MPSPLI      spline interpolation flag: 0 no, 1 yes
*   MPBARS      connect points to x axis (vertical bars): 0 no, 1 yes
*   MPSYMF      plot a symbol at point position:
*               0 = none
*               1 = dot, 2 = +, 3 = *, 4 = o, 5 = x
*               100 = current curve count (1, 2, etc.) modulo 10
*               200 = use first character of string at MPSYMB
*   MPCOLR      colour (same for line, symbol, and annotation)
*   MPSYMB      plot symbol position
*   MPANNO      symbol annotation position (= complete variable name)
*
*   LVVAL:
*
*   vert. curve coordinates
*
*   LHVAL (ref. link):
*
*   horizontal coordinates
*
*   LINDX (ref. link):
*
*   sequence index for hor. coord.s
*
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca plotcp
+ca plcomm
+ca header
+ca plotcd
+ca strgroup

      parameter            (mlsize = 13,mtsize = 13,masize = 20)
*--- character sizes:
*   MLSIZE    label character height
*   MTSIZE    text   - " -
*   MASIZE    annotation - " -

      character         svar*(mcnam), sname*(mxlabl), tname*(mcnam)
      character         slocn*(mtitl)
      character         stemp*(mtitl), stext*300, sform*20
      character         sdum(mxdep)*(mcnam), symb*1
      real                 prmach, symch
*--- strings:
*   SVAR     buffer for variable names etc.
*   SNAME    local name buffer
*   SLOCN    local name buffer (without leading "_")
*   STEMP    temporary buffer for titles
*   STEXT    buffer for labels etc.
*   SFORM    format buffer
*   SYMB     symbol buffer
*--- reals:
*   PRMACH fraction of viewport taken by machine plot
*   SYMCH  preset symbol character height

      data prmach /0.1/, symch /0.01/

*--- check whether main plot bank exists
      if (lpmain .le. 0) goto 80
*--- count number of frames
      nframe = 0
*--- allow max. of two frames (on top of each other)
      do 10 i = 1, 2
        l = lq(lpmain - i)
        if (l .ne. 0) nframe = nframe + 1
   10 continue
   20 if (nframe .eq. 0) goto 999
*--- reset axis and curve defaults
      call gxsdef ('AXIS', 0)
      call gxsdef ('CURVE', 0)
*--- set "new line" character (change default = '/')
      call gxsvar ('SDEFNL', idum, fdum, '%')
*--- set top of viewport - leave space to plot machine if required
      if (fpmach)  then
        yvtop = 1. - prmach
      else
        yvtop = 1.
      endif
*--- set line width scale factor
      call jslwsc (q(lpmain + mplscw))
*--- loop over frames
      do 70 iframe = 1, nframe
*--- set viewport
        vpt(1) = 0.
        vpt(2) = 1.
        vpt(3) = (iframe - 1) * yvtop / nframe
        vpt(4) = iframe * yvtop / nframe
        call gxsvpt (vpt)
*--- get link of frame bank
        lframe = lq(lpmain - iframe)
*--- find variable name in list
        call uhtoc (q(lframe + mpname), mcnam, svar, mcnam)
        call plgetn (1, svar, itbv, idum, sdum, sname)
        slocn = ' '
        call gxpnbl(sname, k1dum, k2dum)
        k3dum = 0
        do 71 idum = k1dum, k2dum
          if (sname(idum:idum) .ne. '_')  then
            k3dum = k3dum + 1
            slocn(k3dum:k3dum) = sname(idum:idum)
          endif
   71   continue
*--- prepare horizontal axis
        do 30 i = 1, 4, 3
          call gxqaxs ('X', i, npar, ipar, range, stext, sform)
*--- set character sizes for labels and text including user requests
          ipar(7)  = max (mlsize * q(lpmain + mplscl) + .01, 1.1)
          ipar(13) = max( mtsize * q(lpmain + mptscl) + .01, 1.1)
*--- text left adjusted
          ipar(10) = 1
*--- font
          ipar(11) = iq(lpmain + mpfont)
*--- axis ref. number
          ipar(21) = 1
*--- range centre etc.
          if (iq(lframe + mpsclf) .le. 0)  then
*--- automatic scaling
            ipar(22) = iq(lframe + mpsclf)
          else
*--- use range as is
            ipar(23) = 0
            range(1) = q(lframe + mpmin)
            range(2) = q(lframe + mpmax)
          endif
          if (i .eq. 1) then
*--- bottom title
            stemp = ' '
            call uhtoc (q(lframe + mpbtit), mtitl, stemp, mtitl)
*--- find first and last non-blank
            call gxpnbl (stemp, kf, kl)
            call tbgnam (ltab, tname)
            if (kf .ne. 0) then
              stext = '<#>' // slocn // '%' // stemp(kf:kl) // '%%' //
     +                'Table name = ' // tname // '%'
            else
              stext= '<#>' // slocn // '%%' // 'Table name = ' //
     +               tname // '%'
            endif
          else
*--- suppress labels on upper axis
            ipar(3) = 0
*--- ticks below axis
            ipar(4) = 1
*--- top title
            call uhtoc (q(lframe + mpttit), mcwrd, stemp, mtitl)
            call gxpnbl (stemp, kf1, kl1)
            kl1 = max (1, kl1)
*--- set top title to local picture title;
*--- if local title is different from main TITLE, add main TITLE
            if (stemp(:kl1) .ne. ctitle) then
              call gxpnbl (ctitle, kf2, kl2)
              stext = stemp(:kl1) // '%' // ctitle(:kl2)
              kl1 = kl1 + kl2 + 1
              stemp = stext
            endif
            call gxpnbl (cvers, kf2, kl2)
            kl2= max (1, kl2)
            stext = stemp(:kl1) // '%'
     +      // cvers(:kl2) // ' version ' //
     +      nvers // '<#>' // cdate // '  ' // ctime
          endif
*--- set axis parameters
          call gxsaxs ('X', i, npar, ipar, range, stext, sform)
   30   continue
*--- set min. and max. for horizontal axis
        xax(1) = q(lframe + mpmin)
        xax(2) = q(lframe + mpmax)
*--- get link to first vertical compound variable
        lvvar = lq(lframe - 1)
        if (lvvar .eq. 0) goto 100
*--- loop over compound variables
        nvax = 0
   40   nvax = nvax + 1
        ivax = iq(lvvar + mpvaxr)
        call gxqaxs ('Y', ivax, npar, ipar, range, stext, sform)
*--- set character sizes for labels and text including user requests
        ipar(7)  = max (mlsize * q(lpmain + mplscl) + .01, 1.1)
        ipar(13) = max (mtsize * q(lpmain + mptscl) + .01, 1.1)
*--- right adjusted label
        ipar(10) = 3
*--- font
        ipar(11) = iq(lpmain + mpfont)
*--- range centre etc.
        if (iq(lvvar + mpsclf) .le. 2)  then
*--- automatic scaling
          ipar(22) = iq(lvvar + mpsclf)
        else
*--- use range as is
          ipar(23) = 0
          range(1) = q(lvvar + mpmin)
          range(2) = q(lvvar + mpmax)
        endif
*--- get axis annotation
        call uhtoc (q(lvvar + mpname), mcwrd, slocn, mtitl)
        stemp = ' '
        call gxpnbl(slocn, k1dum, k2dum)
        k3dum = 0
        do 41 idum = k1dum, k2dum
          if (slocn(idum:idum) .ne. '_')  then
            k3dum = k3dum + 1
            stemp(k3dum:k3dum) = slocn(idum:idum)
          endif
   41   continue
        if (nvax .eq. 1)  then
          stext = '%' // stemp
        else
          stext = stemp
        endif
        call gxsaxs ('Y', ivax, npar, ipar, range, stext, sform)
*--- set curve parameters for frame call
        call gxqcrv (nvax, npar, ipar, symb)
        ipar(2) = ivax
        call gxscrv (nvax, npar, ipar, symb)
*--- store y values for frame scaling
        yax(2 * nvax - 1) = q(lvvar + mpmin)
        yax(2 * nvax)     = q(lvvar + mpmax)
        nptval(nvax)      = 2
        ipxval(nvax)      = 1
        ipyval(nvax)      = 2 * nvax - 1
        icvref(nvax)      = nvax
*--- loop if necessary and possible
        lvvar = lq(lvvar)
        if (lvvar .gt. 0 .and. nvax .lt. 4) goto 40
*--- if only one y axis, plot right axis with ticks only
        if (nvax .eq. 1) then
          ivax = 4
          call gxqaxs ('Y', ivax, npar, ipar, range, stext, sform)
          ipar(2)  = 0
          ipar(3)  = 0
          ipar(4)  = 1
          ipar(21) = 1
          call gxsaxs ('Y', ivax, npar, ipar, range, stext, sform)
        endif
*--- plot frame, keep windows for curves + clipping
        call gxfrm1 (nvax, nptval, ipxval, ipyval, icvref, xax, yax,
     +  window, actwin, ierr)
        if (ierr .ne. 0) goto 110
*--- now loop over vertical variables for real curve plotting
*--- get link to first vertical compound variable
        lvvar = lq(lframe - 1)
*--- loop over compound variables, count them + the curves
        nvax   = 0
        ntcurv = 0
   50   nvax   = nvax + 1
*--- get link to first curve
        lvcurv = lq(lvvar - 1)
        if (lvcurv .eq. 0) goto 120
*--- loop over curves to each vert. variable
   60   ntcurv = ntcurv + 1
*--- find variable name in list for annotation
        call uhtoc (q(lvcurv + mpanno), mcnam, svar, mcnam)
        call plgetn (2, svar, itbv, idum, sdum, sname)
        slocn = ' '
        call gxpnbl(sname, k1dum, k2dum)
        k3dum = 0
        do 61 idum = k1dum, k2dum
          if (sname(idum:idum) .ne. '_')  then
            k3dum = k3dum + 1
            slocn(k3dum:k3dum) = sname(idum:idum)
          endif
   61   continue
*--- bank containing the y values
        lvval = lq(lvcurv - 1)
        if (lvval .eq. 0) goto 130
*--- no. of points to plot
        np = iq(lvval - 1)
*--- ref. link to hor. coordinates
        lhval = lq(lvcurv - 3)
        if (lhval .eq. 0) goto 90
*--- ref. link to hor. sequence index
        lindx = lq(lvcurv - 4)
        if (lindx .eq. 0) goto 90
*--- character height including user request
        chh = 0.001 * masize * q(lpmain + mpascl)
*--- plot symbol
        call uhtoc (q(lvcurv + mpsymb), mcnam, symb, 1)
*--- call curve plot routine with simple arrays and flags
        call plcurv (ntcurv, slocn, chh, q(lpmain + mpascl), symb,
     +  symch * q(lpmain + mpsscl), iq(lvcurv + 1), np, q(lhval+1),
     +  q(lvval + 1), iq(lindx + 1), window(1,nvax), actwin(1,nvax),
     +  ierr)
        if (ierr .ne. 0) goto 140
*--- loop if necessary
        lvcurv = lq(lvcurv)
        if (lvcurv .gt. 0) goto 60
*--- loop if necessary and possible
        lvvar = lq(lvvar)
        if (lvvar .gt. 0 .and. nvax .lt. 4) goto 50
   70 continue
      if (fpmach)  then
        lm1 = lq(lpmain - mpfram - 1)
        lm2 = lq(lpmain - mpfram - 2)
        if (lm1 .ne. 0 .and. lm2 .ne. 0) then
          vpt(1) = 0.
          vpt(2) = 1.
          vpt(3) = yvtop
          vpt(4) = 1.
          call gxsvpt (vpt)
          window(3,1) = -1.
          window(4,1) = 1.
          call gxswnd (window)
          call plschm (iq(lm1 - 1), q(lpmain + mpfelm), iq(lm1 + 1),
     +    q(lm2 + 1), actwin)
        endif
      endif
*--- plot Arnold web if requested
      if (ivnarw .ne. 0)  then
        lqv1 = lq(lpmain - mpfram - 3)
        if (lqv1 .ne. 0)  call plarwe(iq(lqv1+1), actwin(1,ivnarw))
      endif
      goto 999

*--- no top graph bank given
   80 continue
*--- no hor. coord. bank
   90 continue
*--- no vert. compound banks
  100 continue
*--- GXFRM1 error
  110 continue
*--- curve for vert. var. missing
  120 continue
*--- y values missing
  130 continue
*--- PLCURV error
  140 continue
+ei
  999 end
+dk plprep
      subroutine plprep (ipict, ityp, ierr)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Prepare plot banks for routine PLPLOT                              *
*                                                                      *
*--- Input:                                                            *
*    IPICT   picture number                                            *
*    ITYP    picture type:                                             *
*            0: all points in one frame                                *
*            1: parameter is row variable                              *
*            2: parameter is segment variable                          *
*--- Output:                                                           *
*    IERR    0 if everything OK                                        *
*            else > 0                                                  *
*                                                                      *
*----------------------------------------------------------------------*
* Modified: 13-JAN-1999, M. Woodley (SLAC)                             *
*   Add sextupoles and octupoles to machine layout                     *
* Modified: 17-MAR-1999, M. Woodley (SLAC)                             *
*   Add lcavity elements to machine layout                             *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca beam
+ca cmdgroup
+ca elmgroup
+ca strgroup
+ca plotcp
+ca plcomm
+ca plotcd
+ca refer
+ca seqflag
+ca tbpara
+ca datatype
      integer i,i1,i2,ic,icopy,idum,ienum,ierp,ierr,iflag,ihbias,ihc,
     +ihf,ihform,ihp,ii,ilo,index,iocc,ipelm,ipict,ipush,irdum1,irdum2,
     +is,isp,isup,itp,ityp,iup,iv,ivbias,ivc,ivf,ivform,ivp,ivpl,j,jbyt,
     +jlo,jrow,jseg,jup,jv,k,k1,k2,kf,kl,l,lstitl,lzlast,m,n,natl,nbook,
     +nbtl,nctl,nel,npnt,nqcnd,ns,nstep,nvc,nvrw,nvsg
      double precision plpval,tval

      integer              ivord(4)

*--- dummy common to align TVAL
      common / tvdumm /    tval
      integer              ieqd(2)
      equivalence          (tval, ieqd(1))

      real                 hmin, hmax, rval, vmin(4), vmax(4)
      real                 screen, selem, xs

      logical              eflag, symm

      character*(mcnam) linnam
      character*(mcrng) rngnam
      character*(mtitl) s, stitl, sbottl
      character*(mxlabl) slab
      character*(mcnam) sym, elmnam, saxis(mpmxvr), sdum(mxdep)
      character*26      supcas,slocas

      data ivord /1, 4, 2, 3/
      data screen / 29. /, selem / 0.2 /
      data supcas /'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
      data slocas /'abcdefghijklmnopqrstuvwxyz'/

      ierr   = 0
*--- flag for machine layout plot
*--- temporary definition of fpmach !!
      fpmach = haxis(:2) .eq. 'S ' .and. itbv .eq. 1
*--- flag for Arnold web plot (set true if constraints read)
      if (ivnarw .ne. 0)  then
        ivnarw = 0
        do 1  i = 1, 4
          do 1  j = 1, nvvar(i)
          if (vaxis(j,i)(1:1) .eq. 'Q')  ivnarw = i
    1   continue
        if (itbv .ne. 2 .or. haxis(1:1) .ne. 'Q') ivnarw = 0
      endif
      lpparl = lq(lroot - mpparl)
      if (lpparl .eq. 0) then
        call aafail('PLPREP', 1, 'PLOT parameter bank not found.')
        ierr = 1
        goto 999
      endif
      if (fpmach .and. splifl .and. itbv .lt. mtbv)  then
*--- calculate min. no. of points across (see interpolation)
        call gxqvar('XMETAF', idum, xs, s)
        nstep = max(screen, xs) / selem + 2.
        nstep = min(nstep, maxitp)
      else
        nstep = 0
      endif
*--- final definition of fpmach (the HELPFL contains the NOLINE option)
      fpmach = fpmach .and. .not. helpfl
      nvrw = iq(ltbr + 1)
      nvsg = iq(ltbr + 2)
      if (ityp .eq. 0)  then
*--- all points in one frame
        ilo = 1
        iup = nvsg
        jlo = 1
        jup = nvrw
        stitl = ' '
        lstitl  = 1
      else
        call plgetn(1, sparm, itbv, idum, sdum, slab)
        call gxpnbl (slab, kf, kl)
        stitl  = slab(:kl) // ' = '
        lstitl = kl + 3
        if (ityp .eq. 1) then
*--- parameter is row variable
          ilo = 1
          iup = nvsg
          jlo = ipict
          jup = ipict
        else
*--- parameter is segment variable
          ilo = ipict
          iup = ipict
          jlo = 1
          jup = nvrw
        endif
      endif
      npnt = (iup + 1 - ilo) * (jup + 1 - jlo)
      if (npnt .le. 1 .and. itbv .eq. 1)  then
        call aawarn('PLPREP', 1, 'Zero or one point only.')
        ierr = 2
        goto 999
      elseif (npnt .le. 0)  then
        call aawarn('PLPREP', 1, 'No points to plot.')
        ierr = 2
        goto 999
      elseif (npnt .gt. maxppt)  then
        s = '         points cut at maximum'
        write (s(:8),'(I8)')  npnt
        write (s(32:39),'(I8)') maxppt
        call aawarn('PLPREP', 1, s)
        npnt = maxppt
      endif
*--- initial length for coord. banks
      nbook = npnt + nstep
*--- fill in SETPLOT options
      iq(lpmain + mpfont) = iq(lpparl + 1)
      q(lpmain + mplscw) = q(lpparl + 2)
      q(lpmain + mpxsiz) = q(lpparl + 3)
      q(lpmain + mpysiz) = q(lpparl + 4)
      q(lpmain + mpascl) = q(lpparl + 5)
      q(lpmain + mplscl) = q(lpparl + 6)
      q(lpmain + mpsscl) = q(lpparl + 7)
      q(lpmain + mptscl) = q(lpparl + 8)
*--- Prepare frames
      iframe = 1
      natl   = mpname + mtitl / mcwrd
      nbtl   = mpbtit + mtitl / mcwrd
      nctl   = mpanno + mtitl / mcwrd
        call mzbook (1, lframe, lpmain, -iframe, 'FRAM', 3, 3, nbtl, 0,
     +  -1)
        call uctoh (haxis, q(lframe + mpname), mcwrd, mcnam)
*--- copy top title from standard title
        call uctoh (title, q(lframe + mpttit), mcwrd, mtitl)
*--- compose bottom title and store
        call plptit(2, sbottl)
        call uctoh (sbottl, q(lframe + mpbtit), mcwrd, mtitl)
*--- book bank for horizontal coord.s
        call mzbook(1, lhval, lframe, -2, 'HVAL', 0, 0, nbook, 0, -1)
*--- book bank for horizontal coord.s sequence index (sorting)
        call mzbook(1, lindx, lframe, -3, 'INDX', 0, 0, nbook, 0, -1)
*--- book bank for temporary storage
        call mzbook(1, ltmp, ltbr, -9, 'TMP ', 0, 0, nbook, 0, -1)
*--- zero count for total number of vert. var.
        nvc = 0
*--- book mother banks for vert. axes
        do 30 iv = 1, ntvvar
          if (iv .eq. 1)  then
            call mzbook (1, lrvv(iv), lframe, -1, 'VVAR', 1, 1, natl, 0,
     +      -1)
          else
            l = lzlast (0, lframe - 1)
            call mzbook (1, lrvv(iv), l, 0, 'VVAR', 1, 1, natl, 0, -1)
          endif
*--- set axis reference number
          iq(lrvv(iv) + mpvaxr) = ivord(iv)
*--- get axis annotation
          if (nvvar(iv) .eq. 1)  then
            call plgetn (1, vaxis(1,iv), itbv, idum, sdum, slab)
            ns = 1
          else
            call plgaxn (nvvar(iv), vaxis(1,iv), saxis, ns)
            call plgetn (1, saxis(1), itbv, idum, sdum, slab)
          endif
          call gxpnbl (slab, k1, k2)
          s  = '<#>' // slab
          k2 = k2 + 3
          do 10 i = 2, ns
            call plgetn (1, saxis(i), itbv, idum, sdum, slab)
            call gxpnbl (slab, i1, i2)
            if (index(s(:k2),slab(:i2)) .eq. 0)  then
              s(k2 + 1:) = ', ' // slab(:i2)
              k2 = k2 + i2 + 2
            endif
   10     continue
          call uctoh (s, q(lrvv(iv) + mpname), mcwrd, mtitl)
          do 20 ic = 1, nvvar(iv)
            nvc = nvc + 1
*--- book curve banks per axis
            if (ic .eq. 1)  then
              call mzbook (1, lvcurv, lrvv(iv), -1, 'CURV', 4, 2, nctl,
     +        0, -1)
            else
              l = lzlast (0,lrvv(iv)-1)
              call mzbook (1, lvcurv, l, 0, 'CURV', 4, 2, nctl, 0, -1)
            endif
*--- set style, symbol, colour, spline flag
            iq(lvcurv + mpstyl) = ivpar(2)
            iq(lvcurv + mpbars) = ivpar(1)
            iq(lvcurv + mpcolr) = ivpar(5)
            if (splifl .and. nstep .eq. 0)  then
*--- use splines in PLCURV
              iq(lvcurv + mpspli) = 1
            else
*--- use routine PLINTP for interpolation, if any
              iq(lvcurv + mpspli) = 0
            endif
            is = ivpar(3)
            sym = ' '
            if (is .gt. 0 .and. is .le. 5 .or. is .eq. 100)  then
              continue
            elseif (is .eq. 200)  then
              m = mod(nvc - 1, 26) + 1
              sym(:1) = supcas(m:m)
            elseif (is .eq. 300)  then
              m = mod(nvc - 1, 26) + 1
              sym(:1) = slocas(m:m)
              is = 200
            elseif (is .gt. 200 .and. is .le. 226)  then
              m = is - 200
              sym(:1) = supcas(m:m)
              is = 200
            elseif (is .gt. 300 .and. is .le. 326)  then
              m = is - 300
              sym(:1) = slocas(m:m)
              is = 200
            elseif (is .ge. 400 .and. is .le. 409)  then
              write (sym(:1), '(I1)')  is - 400
              is = 200
            else
              is = 0
            endif
            iq(lvcurv + mpsymf) = is
            call uctoh (sym, q(lvcurv + mpsymb), mcwrd, mcnam)
*--- curve annotation
            call uctoh (vaxis(ic,iv), q(lvcurv + mpanno), mcwrd, mcnam)
*--- set ref. link to hor. coord.s
            lq(lvcurv-3) = lhval
*--- set ref. link to hor. coord. index
            lq(lvcurv-4) = lindx
*--- book bank for vert. var. values
            call mzbook (1, lrvc(nvc), lvcurv, -1, 'VCOR', 0, 0, nbook,
     +      0, -1)
   20     continue
   30   continue
*--- get links for valid deltap, segments, rows
        lvrw = lq(ltbr - 1)
        lvsg = lq(ltbr - 2)
*--- fill hor. and all vert. var.
        n = 0
        do 100 i = ilo, iup
          jseg = iq(lvsg + i)
          call tbseg (ltab, jseg, eflag)
          do 90 j = jlo, jup
            jrow = iq(lvrw + j)
            call tbset (ltab, jrow, 1, lbuf)
            if (n .eq. 0)  then
              if (ityp .ne. 0) then
*--- put parameter value in bottom title
                if (idsfrm(ityp) .eq. 2) then
                  ii = iq(lbuf+idsbis(ityp)+1)
                  write (stitl(lstitl+1:lstitl+12), '(I8)') ii
                else
                  if (idsfrm(ityp) .eq. 3) then
                    rval = q(lbuf+idsbis(ityp)+1)
                  else
                    do 40 icopy = 1, mwflt
   40               ieqd(icopy) = iq(lbuf+idsbis(ityp)+icopy)
                    rval = tval
                  endif
                  if (rval .eq. 0.) then
                    stitl(lstitl+1:lstitl+2) = '0.'
                  else
                    write (stitl(lstitl+1:lstitl+12), '(G12.6)') rval
                  endif
                endif
                call uctoh (stitl, q(lframe + mpbtit), mcwrd, mtitl)
              endif
            endif
            n = n + 1
            if (n .gt. npnt)  goto 100
*--- get hor. variable value
            if (ihpntr .lt. 0)  then
*--- expression variable
              call exevl1(lq(lexpv+ihpntr), ltab, lbuf, tval)
*--- RVAL is single prec. always !
              rval = tval
            else
              ihp = iq(locc+ihpntr)
              ihc = iq(lcnt+ihpntr)
              ihf = iq(lproc+ihpntr)
              if (ihf .le. 1)  then
                ihform = iq(lform+ihp+1)
                ihbias = iq(lbias+ihp+1)
                if (ihform .eq. 2) then
                  rval = iq(lbuf + ihbias + 1)
                elseif (ihform .eq. 3) then
                  rval = q(lbuf + ihbias + 1)
                else
                  do 50 icopy = 1, mwflt
   50            ieqd(icopy) = iq(lbuf+ihbias+icopy)
                  rval = tval
                endif
                if (ihf .eq. 1)  rval = sqrt (abs (rval))
              else
*--- composit variable
                rval = plpval(ihf, ihp, ihc)
              endif
            endif
            if (ityp .eq. 0)  then
              q(lhval + (j-1)*nvsg+i) = rval
            else
              q(lhval + n) = rval
            endif
            if (n .eq. 1)  then
              hmin = rval
              hmax = rval
            else
              hmin = min (hmin, rval)
              hmax = max (hmax, rval)
            endif
*--- get vert. var. values
            k = 0
            do 80 iv = 1, ntvvar
              do 70 jv = 1, nvvar(iv)
                k = k + 1
                ivpl = ivpntr(jv,iv)
                if (ivpl .lt. 0)  then
*--- expression variable
                  call exevl1(lq(lexpv+ivpl), ltab, lbuf, tval)
                  rval = tval
                else
                  ivp = iq(locc+ivpl)
                  ivc = iq(lcnt+ivpl)
                  ivf = iq(lproc+ivpl)
                  if (ivf .le. 1)  then
                    ivform = iq(lform+ivp+1)
                    ivbias = iq(lbias+ivp+1)
                    if (ivform .eq. 2) then
                      rval = iq(lbuf + ivbias + 1)
                    elseif (ivform .eq. 3) then
                      rval = q(lbuf + ivbias + 1)
                    else
                      do 60 icopy = 1, mwflt
   60                 ieqd(icopy) = iq(lbuf+ivbias+icopy)
                      rval = tval
                    endif
                    if (ivf .eq. 1)  rval = sqrt (abs (rval))
                  else
*--- composit variable
                    rval = plpval(ivf, ivp, ivc)
                  endif
                endif
                if (ityp .eq. 0)  then
                  q(lrvc(k) + (j-1)*nvsg+i) = rval
                else
                  q(lrvc(k) + n) = rval
                endif
                if (n .eq. 1 .and. jv .eq. 1)  then
                  vmin(iv) = rval
                  vmax(iv) = rval
                else
                  vmin(iv) = min (vmin(iv), rval)
                  vmax(iv) = max (vmax(iv), rval)
                endif
   70         continue
   80       continue
   90     continue
  100   continue
*--- reset position of first element
      if (fpmach)  then
*--- Book two banks for machine description
        nel = irg2 - irg1
        call mzbook (1, lm1, lpmain, -(mpfram + 1), 'PTYP', 0, 0, nel,
     +  0, -1)
        call mzbook (1, lm2, lpmain, -(mpfram + 2), 'PLEN', 0, 0, nel,
     +  0, -1)
*--- s position at start of first element
        q(lpmain + mpfelm) = q(lhval + 1)
*--- Fill banks with machine description
        i = 0
        do 130 jrow = irg1, irg2
          call utelem (lcseq, jrow, iflag, elmnam, iocc, ienum)
          if (jbyt (iflag, 1, mcode) .eq. 1)  then
            if (jrow .eq. irg1) goto 130
            i = i + 1
            isp = iq(lcelm + mbsp)
            if (isp .eq. 1)  then
*--- drift
              itp = 0
            elseif (isp .eq. 2 .or. isp .eq. 3)  then
*--- bend
              do 109 icopy = 1, mwflt
  109         ieqd(icopy) = iq(lcelm+metltb-1+icopy)
              rval = tval
              if (rval .eq. 0.)  then
                itp = 1
              else
                itp = 7
              endif
            elseif (isp .eq. 5)  then
*--- quad
              do 110 icopy = 1, mwflt
  110         ieqd(icopy) = iq(lcelm+mek1q-1+icopy)
              rval = tval * elkfact(5)
              if (rval .gt. 0.)  then
*--- focussing quad
                itp = 2
              elseif (rval .lt. 0.)  then
                itp = 3
              else
                itp = 0
              endif
*--- start addition from TR
            elseif (isp .eq. 6)  then
*--- sext
              do 111 icopy = 1, mwflt
  111         ieqd(icopy) = iq(lcelm+mek2s-1+icopy)
              rval = tval * elkfact(6)
              if (rval .gt. 0.)  then
*--- positive sext
                itp = 10
              elseif (rval .lt. 0.)  then
                itp = 11
              else
                itp = 0
              endif
            elseif (isp .eq. 7)  then
*--- oct
              do 112 icopy = 1, mwflt
  112         ieqd(icopy) = iq(lcelm+mek3o-1+icopy)
              rval = tval * elkfact(7)
              if (rval .gt. 0.)  then
*--- positive oct
                itp = 12
              elseif (rval .lt. 0.)  then
                itp = 13
              else
                itp = 0
              endif
*--- end addition from TR
            elseif (isp .eq. 14)  then
*--- horizontal kicker
              itp = 1
            elseif (isp .eq. 15 .or. isp .eq. 16)  then
*--- kicker or vertical kicker
              itp = 7
            elseif (isp .ge. 17 .and. isp .le. 19)  then
*--- monitor
              itp = 4
            elseif (isp .eq. 20 .or. isp .eq. 21)  then
*--- collimator
              itp = 5
            elseif (isp .eq. 11)  then
*--- electrostatic separator
              itp = 6
            elseif (isp .eq. 8)  then
*--- (thin) multipole - plot like dipole
              itp = 8
            elseif (isp .eq. 10)  then
*--- RF cavity
              itp = 9
            elseif (isp .eq. 27)  then
*--- lcavity
              itp = 14
            else
              itp = 0
            endif
            do 120 icopy = 1, mwflt
  120       ieqd(icopy) = iq(lcelm+melen-1+icopy)
            iq(lm1 + i) = itp
            if(itp .eq. 8)  tval = 0
            q(lm2 + i)  = tval
          endif
  130   continue
        call mzpush(0, lm1, 0, i - nel, 'I')
        call mzpush(0, lm2, 0, i - nel, 'I')
      endif
*--- if tunes table and Q-plot, decode constraints for Arnold web
      if (ivnarw .ne. 0)  then
        call mzbook (1, lqv1, lpmain, -(mpfram+3), 'ARWE', 0, 0,
     +  mxqbnk, 0, -1)
*---  # sup.-per., and symm. flag of current line sequence
        call utbeam(lcseq, irdum1, irdum2, symm, isup, linnam,
     +  rngnam)
        if (symm) isup = 2 * isup
        iq(lqv1+1) = isup
        call plgarw (mxqbnk, mxqcnd, qcond, iqrang, nqcnd,
     +  iq(lqv1+1), ierr)
        if (ierr .ne. 0)  then
          call aawarn('PLPREP', 1,
     +    'Error in Arnold web constraint --- no web.')
          call mzdrop (0, lqv1, ' ')
          ivnarw = 0
        else
          call mzpush (0, lqv1, 0, nqcnd - mxqbnk, 'I')
        endif
      endif
*--- sort if requested  and if necessary
        if (sortfl .and. .not. fpmach)  then
          call sortzv(q(lhval + 1), iq(lindx + 1), n, 1, 0, 0)
          do 140 j = 1, n
  140     q(ltmp+j) = q(lhval+iq(lindx+j))
          call ucopy(q(ltmp+1), q(lhval+1), n)
          do 160 i = 1, k
            do 150 j = 1, n
  150       q(ltmp+j) = q(lrvc(i)+iq(lindx+j))
            call ucopy(q(ltmp+1), q(lrvc(i)+1), n)
  160     continue
        endif
        call mzdrop(0, ltmp, ' ')
*--- if hor. var. = 's' and alfa, beta, mu, or D plotted, interpolate
*    with correct formulae.
        if (nstep .gt. 0 .and. npnt .gt. 2)  then
*--- interpolate
          call plintp(ipelm, npnt, nbook, (hmax - hmin) / nstep,
     +    vmin, vmax, ierp)
          if (ierp .ne. 0)  then
            call aawarn('PLPREP', 1,
     +      'Error in interpolation --- SPLINE flag ignored.')
          endif
        endif
*--- reduce bank lengths to correct values
        do 170 i = 1, k
          ipush = npnt - iq(lrvc(i)-1)
          if (ipush .lt. 0) call mzpush(0, lrvc(i), 0, ipush, 'I')
  170   continue
        ipush = npnt - iq(lhval-1)
        if (ipush .lt. 0)  call mzpush(0, lhval, 0, ipush, ' ')
        ipush = npnt - iq(lindx-1)
        if (ipush .lt. 0)  call mzpush(0, lindx, 0, ipush, ' ')
*--- set index array to standard order
        do 180 j = 1, npnt
  180   iq(lindx + j) = j
*--- if FFT requested call special FFT routine
      if (fftfl)  then
        call plfft
      else
*--- follow user options:
*    both min and max specified:  use as range
*    only min  =  0. specified :  use 0. as upper (or lower) range value
*    only max  =  0. specified :  make symmetric around 0.
*    else                      :  use fully automatic scaling
        if (hrange(1) .ne. pflmax .and. hrange(2) .ne. pflmax
     +  .and. hrange(2) .gt. hrange(1))  then
          q(lframe + mpmin) = hrange(1)
          q(lframe + mpmax) = hrange(2)
          iq(lframe + mpsclf) = 3
        else
          q(lframe + mpmin) = hmin
          q(lframe + mpmax) = hmax
          if (hrange(1) .eq. 0. .and. hrange(2) .eq. pflmax)  then
            iq(lframe + mpsclf) = 1
          elseif (hrange(1) .eq. pflmax .and. hrange(2) .eq. 0.)  then
            iq(lframe + mpsclf) = 2
          else
            iq(lframe + mpsclf) = 0
          endif
        endif
        do 190 iv = 1,ntvvar
          if (vrange(1,iv) .ne. pflmax .and. vrange(2,iv) .ne. pflmax
     +    .and. vrange(2,iv) .gt. vrange(1,iv)) then
            q(lrvv(iv) + mpmin)  = vrange(1,iv)
            q(lrvv(iv) + mpmax)  = vrange(2,iv)
            q(lrvv(iv) + mpsclf) = 3
          else
            q(lrvv(iv) + mpmin)  = vmin(iv)
            q(lrvv(iv) + mpmax)  = vmax(iv)
            if (vrange(1,iv) .eq. 0. .and. vrange(2,iv) .eq. pflmax)
     +      then
              iq(lrvv(iv) + mpsclf) = 1
            elseif (vrange(1,iv) .eq. pflmax
     +      .and. vrange(2,iv) .eq. 0.) then
              iq(lrvv(iv) + mpsclf) = 2
            else
              iq(lrvv(iv) + mpsclf) = 0
            endif
          endif
  190   continue
      endif
+ei
  999 end
+dk plprpr
      subroutine plprpr (spvars, nunloc, iprrep, spstep, nplist, splist,
     +spcomm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Print Twiss paramters at selected s values
*
*--- Input:
*    spvars  Twiss parameters to be printed
*    nunloc  output unit number
*    iprrep  repetition of step
*    spstep  step
*    nplist  no. of values in splist
*    splist  list of s values
*--- Warning: the output unit is unit 16, risk of mix with plot
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca strgroup
+ca option
+ca pi
+ca plotcp
+ca plcomm
+ca plotcd
+ca refer
+ca seqflag
+ca tbpara
+ca datatype
      integer i,icurr,ienum,iflag,iocc,ip,iprrep,irp,is,isp,itp,j,jbyt,
     +jrow,jseg,k,lastnb,ll,maxsv,nplist,nunloc,nvrw
      double precision am,ax0,ax1,ay0,ay1,bx0,bx1,by0,by1,diff,dmu,dpx0,
     +dpx1,dpy0,dpy1,dx0,dx1,dy0,dy1,gamx,gamy,one,scurr,sl,slv,splist,
     +spstep,ss,temp,tw0,tw1,two,twopi,ux0,ux1,uy0,uy1,zero
      parameter         (zero = 0.d0)
      parameter         (one = 1.d0, two = 2.d0, twopi = two * pi)
      parameter         (maxsv = 15000)

      dimension         splist(*)
      character * (*)   spcomm(*)
      dimension         slv(maxsv)
      dimension         tw0(mint), tw1(mint), temp(9)
      dimension         am(6,6)
      equivalence (bx0, tw0(1)), (ax0, tw0(2)), (ux0, tw0(3)), (dx0, tw0
     +(4)), (dpx0, tw0(5)), (by0, tw0(6)), (ay0, tw0(7)), (uy0, tw0(8)),
     +(dy0, tw0(9)), (dpy0, tw0(10))
      equivalence (bx1, tw1(1)), (ax1, tw1(2)), (ux1, tw1(3)), (dx1, tw1
     +(4)), (dpx1, tw1(5)), (by1, tw1(6)), (ay1, tw1(7)), (uy1, tw1(8)),
     +(dy1, tw1(9)), (dpy1, tw1(10))

      logical           eflag, pnflag

      integer           ibs(mint), ifm(mint), isl(mint), iref(mint)
      double precision edg1, edg2, sk1, an, h, corr, hgap, fint,
     +ek0(6), enfr(6,6), tw(6,6,6)
      double precision an2

      character         spvars(*) * 16
      character*(mcnam) spv(mint)
      character*(mcnam) eln
      character*(mcstr) strout

      data spv / 'BETX', 'ALFX', 'MUX', 'DX', 'DPX', 'BETY', 'ALFY',
     +'MUY', 'DY', 'DPY' /
      data iref / 1, 6, 2, 7, 3, 8, 4, 9, 5, 10 /

*--- book work bank
      call mzbook (1, ll, ltbr, 1, 'WORK', 9, 9, 3, 0, 0)
*--- book bank for row numbers
      call mzbook (1, lvrw, ltbr, -1, 'VRW ', 0, 0, maxsv, 0, -1)
      nvrw = 1
      ss = zero
      slv(1) = zero
      iq(lvrw+1) = 1
      do 10 i = 1, mint
   10 isl(i) = 0
      isl(1) = 1
      isl(6) = 1
      do 30 jseg = 1, iq(ltab+mtbseg)
        call tbseg (ltab, jseg, eflag)
        if (eflag)  then
          call aawarn('sprint', 1, 'internal table management error')
          goto 999
        endif
        do 20 jrow = 1, iq(ltab+mtbrow)
          call tbset(ltab, jrow, 1, lbuf)
          if (lbuf .ne. 0) then
            call utelem (lcseq, jrow, iflag, eln, iocc, ienum)
*--- keep only element end points
            if (jbyt(iflag, 1, mcode) .eq. 1) then
              call bmgelm(lcelm, temp)
*--- keep only first s, i.e. drop zero length elements
              if (temp(1) .gt. zero)  then
*--- store row number and position
                nvrw = nvrw + 1
                iq(lvrw+nvrw) = jrow
                ss = ss + temp(1)
                slv(nvrw) = ss
              endif
            endif
          endif
   20   continue
   30 continue
*--- get formats and biasses
      do 40 i = 1, mint
        call tbcol (ltab, spv(i), ifm(i), ibs(i))
   40 continue
*--- find selected variables
      pnflag = .false.
      do 60 j = 1, 9
        pnflag = pnflag .or. spvars(j) .eq. 'NAME'
        do 50 i = 1, mint
          if (spvars(j) .eq. spv(i))  then
            isl(i) = 1
            goto 60
          endif
   50   continue
   60 continue
*--- print header
      strout = '#       s       '
      k = 16
      do 70 i = 1, mint
        if (isl(iref(i)) .ne. 0)  then
          strout(k+1:k+14) = '      ' // spv(iref(i))
          k = k + 14
        endif
   70 continue
      if (pnflag)  then
        strout(k+5:k+10) = 'name'
      endif
      write(nunloc, '(a)') strout(:lastnb(strout))
      scurr = zero
      icurr = 2
      do 160 is = 1, nplist
        if (splist(is) .ge. zero .and. splist(is) .le. slv(nvrw))
     +  then
          do 150 irp = 0, iprrep
            sl = splist(is) + irp * spstep
            if (sl .ge. zero .and. sl .le. slv(nvrw))  then
              if (sl .lt. scurr) icurr = 2
              do 100 ip = icurr, nvrw
                if (sl .le. slv(ip)) then
*--- get Twiss parameters at start of element
                  call tbset(ltab, iq(lvrw+ip-1), 1, lbuf)
                  do 80 i = 1, mint
                    if (ifm(i) .eq. 3) then
                      tw0(i) = q(lbuf + ibs(i) + 1)
                    else
                      call ucopy(q(lbuf+ibs(i)+1), tw0(i), mwflt)
                    endif
   80             continue
                  icurr = ip
                  scurr = sl
                  diff = sl - slv(ip-1)
                  call tbset(ltab, iq(lvrw+ip), 1, lbuf)
                  do 90 i = 1, mint
                    if (ifm(i) .eq. 3) then
                      tw1(i) = q(lbuf + ibs(i) + 1)
                    else
                      call ucopy(q(lbuf+ibs(i)+1), tw1(i), mwflt)
                    endif
   90             continue
*--- get element parameters and Twiss parameters
                  call utelem (lcseq, iq(lvrw+ip), iflag, eln, iocc,
     +            ienum)
                  isp = iq(lcelm + mbsp)
                  call bmgelm(lcelm, temp)
                  if (isp .eq. 1) then
*--- drift
                    itp = 0
                  elseif (isp .eq. 2 .or. isp .eq. 3) then
*--- bend
                    itp = 1
                    call ucopy(q(lcelm+mee1g), edg1, mwflt)
                    call ucopy(q(lcelm+mee2g), edg2, mwflt)
                    call ucopy(q(lcelm+mek1g), sk1, mwflt)
                    call ucopy(q(lcelm+meangg), an,   mwflt)
                    call ucopy(q(lcelm+megapg), hgap, mwflt)
                    call ucopy(q(lcelm+meintg), fint, mwflt)
                    if (isp .eq. 2) then
*--- HG001026: arc length to rectangular bend
                      an2 = an / 2.d0
                      if (an2 .ne. 0.d0 .and. rbarc)
     +                temp(1) = temp(1) * an2 / sin(an2)
                      edg1 = edg1 + an2
                      edg2 = edg2 + an2
                    endif
                    h = an / temp(1)
                    corr = (h + h) * hgap * fint
                    call tmfrng(.false.,h,sk1,edg1,zero,+one,corr,
     +              ek0,enfr,tw)
                  elseif (isp .eq. 5) then
*--- quad
                    itp = 2
                  else
                    itp = 0
                  endif
                  if (bx0 .ne. zero) then
                    gamx = (one + ax0**2) / bx0
                  else
                    gamx = zero
                  endif
                  if (by0 .ne. zero) then
                    gamy = (one + ay0**2) / by0
                  else
                    gamy = zero
                  endif
*--- element matrix 6x6
                  call plelma(itp, temp, diff, am)
                  if (itp .eq. 1)  call m66mpy(am, enfr, am)
*--- interpolate Twiss parameters
*    beta_x, beta_y
                  bx1 = -two * am(1,1) * am(1,2) * ax0 + am(1,1) **2 *
     +            bx0 + am(1,2)**2 * gamx
                  by1 = -two * am(3,3) * am(3,4) * ay0 + am(3,3) **2 *
     +            by0 + am(3,4)**2 * gamy
*--- alfa_x, alfa_y
                  ax1 = (am(1,1) * am(2,2) + am(1,2) * am(2,1)) * ax0 -
     +            am (1,1) * am(2,1) * bx0 - am(1,2) * am(2,2) * gamx
                  ay1 = (am(3,3) * am(4,4) + am(3,4) * am(4,3)) * ay0 -
     +            am (3,3) * am(4,3) * by0 - am(3,4) * am(4,4) * gamy
*--- mu_x, mu_y
                  dmu = atan2(am(1,2), bx0 * am(1,1) - ax0 * am(1,2))
                  if (dmu .lt. zero) dmu = dmu + twopi
                  ux1 = ux0 + dmu / twopi
                  dmu = atan2(am(3,4), by0 * am(3,3) - ay0 * am(3,4))
                  if (dmu .lt. zero) dmu = dmu + twopi
                  uy1 = uy0 + dmu / twopi
*--- D-x, D-y
                  dx1 = am(1,1) * dx0 + am(1,2) * dpx0 + am(1,6)
                  dy1 = am(3,3) * dy0 + am(3,4) * dpy0 + am(3,6)
*--- D'-x, D'-y
                  dpx1 = am(2,1) * dx0 + am(2,2) * dpx0 + am(2,6)
                  dpy1 = am(4,3) * dy0 + am(4,4) * dpy0 + am(4,6)
                  goto 110
                endif
  100         continue
  110         continue
              strout = ' '
              write(strout, '(1p, e16.8)') sl
              k = 16
              do 120 i = 1, mint
                if (isl(iref(i)) .ne. 0) then
                  write(strout(k+1:k+14), '(1p, e14.6)') tw1(iref(i))
                  k = k + 14
                endif
  120         continue
              if (pnflag) then
                strout(k+5:) = eln
                k = k + mcnam + 4
              endif
              strout(k+1:) = spcomm(is)
              write(nunloc, '(a)') strout(:lastnb(strout))
            endif
  150     continue
        endif
  160 continue
  999 end
+dk plgfia
      subroutine plgfia(sin, ind, f, i, a)
      implicit none
************************************************************************
*
*   Purpose: get item (integer, floating point number, or string)
*
*-- Input:
*   SIN      input string
*-- Output:
*   IND      type: 1 integer, 2 floating, 3 exp. floating, 4 character
*            0 if input string is blank
*
************************************************************************
      integer i,ind,klch,l,lastnb
      double precision f

+ca aparam
      character * (*)  sin, a

      ind = 0
      if (sin .ne. ' ')  then
        l = lastnb(sin)
        if (sin(1:1) .eq. '"' .or. sin(1:1) .eq. '''')  then
          ind = 4
          a   = sin
        else
          call plgetv(sin, 1, l, i, f, ind, klch)
        endif
      endif
      end
+dk plgitn
      subroutine plgitn(n, sin, nf, sout)
      implicit none
************************************************************************
*
*   Purpose: get items (blank separated) from line
*
*-- Input:
*   N        max. number of item looked for
*   SIN      input string
*-- Output:
*   nf       no .of items found
*   SOUT     item list, left adjusted
*
************************************************************************
      integer is,itog,js,jtog,l,lastnb,n,nf

+ca aparam
      character * (*)  sin, sout(*)
      l = lastnb(sin)
      nf = 0
      itog = 0
      jtog = 0
      sout(1) = ' '
      if (sin .ne. ' ')  then
        do 10  js = 1, l
          if (sin(js:js) .eq. '"')  jtog = 1 - jtog
          if  (itog .eq. 0 .and. sin(js:js) .eq. ' '
     +    .or. itog .ne. 0 .and. (sin(js:js) .ne. ' ' .or. jtog .ne. 0))
     +    goto 10
          if (itog .eq. 0)  then
            is = js
            nf = nf + 1
          else
            sout(nf) = sin(is:js-1)
            if (nf .eq. n)  goto 20
          endif
          itog = 1 - itog
   10   continue
        if (itog .ne. 0)  sout(nf) = sin(is:l)
   20   continue
      endif
  999 end
+dk lastnb
      function lastnb(string)
      implicit none
*-----------------------------------------------------------------------
*
*--- find alst non-blank in string
*--- input
*    STRING
*--- output
*    function value = last non-blank (at least 1)
*-----------------------------------------------------------------------
+ca aparam
      integer i,lastnb,len
      character *(*) string
      do 10  i = len(string), 1, -1
        if (string(i:i) .ne. ' ')  goto 20
   10 continue
      i = 1
   20 lastnb = i
      end
+dk plgetv
      subroutine plgetv(string, i1s, i2, ii, rr, itype, klch)
      implicit none
*-----------------------------------------------------------------------
*
*--- returns a numeric constant, and its type. Constant must start on
*    STRING(I1:)
*--- input
*    STRING         string
*    I1S            start of scan
*    I2             end of scan
*--- output
*    II             integer value if ITYPE = 1
*    RR             double precision value if ITYPE = 2
*    ITYPE          1 integer, 2 floating, 3 exp. floating
*    KLCH           last ch. of var.
*
*-----------------------------------------------------------------------
+ca aparam
      integer i,i1,i1s,i2,ig,ii,index,itype,iv,ivf,k,klch
      double precision rr
      character *(*)  string
      character*1 stemp, slast
      character * 10       numeri
      integer ip(3), ic(3)

      data numeri / '0123456789' /

*--- get sign
      ig = index('-+', string(i1s:i1s))
      i1 = i1s + min(ig, 1)
      ig = (-1)**ig
      do 10 i = 1, 3
        ip(i) = 0
        ic(i) = 0
   10 continue
      ivf = 1
      itype = 1
      klch = i1
      stemp = string(i1:i1)
      iv = index(numeri, stemp)
      if (stemp .eq. '.')  then
        itype    = 2
      elseif (iv .eq. 0)  then
        klch = 0
        goto 999
      endif
      ip(1) = max(0, iv - 1)
      slast = stemp
      do 20 i = i1 + 1, i2
        stemp = string(i:i)
        k = index(numeri, stemp)
        if (k .gt. 0) then
          ip(itype) = 10 * ip(itype) + k - 1
          ic(itype) = ic(itype) + 1
        elseif(stemp .eq. '.') then
          itype = 2
        elseif(stemp .eq. 'D' .or. stemp .eq. 'd'
     +  .or. stemp .eq. 'E' .or. stemp .eq. 'e') then
          itype = 3
        elseif(slast .eq. 'D' .or. slast .eq. 'd'
     +  .or. slast .eq. 'E' .or. slast .eq. 'e') then
          if(stemp .eq. '+') then
            continue
          elseif (stemp .eq. '-') then
            ivf = -1
          else
            goto 30
          endif
        else
          goto 30
        endif
        klch=i
        slast=stemp
   20 continue
   30 continue
      if (itype .eq. 1) then
        ii = ig * ip(1)
      else
        rr = ig * (ip(1) + ip(2) / 10.d0**ic(2)) * 10.d0**(ivf * ip(3))
      endif
  999 end
+dk plptit
      subroutine plptit (ityp, stout)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Prepare title                                                      *
*                                                                      *
*--- Input:                                                            *
*    ITYP    title type:                                               *
*            1: top title                                              *
*            2: bottom title                                           *
*--- Output:                                                           *
*    STOUT   new title                                                 *
*                                                                      *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca strgroup
+ca plotcp
+ca plcomm
+ca plotcd
+ca refer
+ca seqflag
+ca tbpara
+ca datatype
      integer ifdum,ityp,ivdum,k
      double precision qs,qx,qy,xrms,yrms

      character * (*)     stout
      character * (mcnam) sdum

      stout = ' '
      if (ityp .eq. 2)  then
*--- bottom title
        if (itbv .eq. 4)  then
*--- SITF table
          call tbgdsc(ltab, 'XRMS', ifdum, ivdum, xrms, sdum)
          call tbgdsc(ltab, 'YRMS', ifdum, ivdum, yrms, sdum)
          call tbgdsc(ltab, 'QX', ifdum, ivdum, qx, sdum)
          call tbgdsc(ltab, 'QY', ifdum, ivdum, qy, sdum)
          call tbgdsc(ltab, 'QS', ifdum, ivdum, qs, sdum)
          k = 0
          if (k + 18 .gt. mtitl)  goto 999
*--- tunes
          stout(k+1:k+10) = 'Q<?>x<?> ='
          k = k + 10
          write(stout(k+1:k+7), '(F7.4)') qx
          k = k + 8
          if (k + 18 .gt. mtitl)  goto 999
          stout(k+1:k+10) = 'Q<?>y<?> ='
          k = k + 10
          write(stout(k+1:k+7), '(F7.4)') qy
          k = k + 8
          if (k + 18 .gt. mtitl)  goto 999
          stout(k+1:k+10) = 'Q<?>s<?> ='
          k = k + 10
          write(stout(k+1:k+7), '(F7.4)') qs
          k = k + 8
          if (k + 17 .gt. mtitl)  goto 999
*--- <x> and <y>
          stout(k+1:k+5) = '<x> ='
          k = k + 5
          write(stout(k+1:k+7), '(F7.4)') xrms
          k = k + 7
          stout(k+1:k+5) = '[mm] '
          k = k + 5
          if (k + 16 .gt. mtitl)  goto 999
          stout(k+1:k+5) = '<y> ='
          k = k + 5
          write(stout(k+1:k+7), '(F7.4)') yrms
          k = k + 7
          stout(k+1:k+4) = '[mm]'
        endif
      endif
+ei
  999 end
+dk plpval
      function plpval(ipflg, ipt, ict)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
*                                                                      *
* Purpose: calculates composite plot variables derived from TRACK table*
*                                                                      *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca beam
+ca cmdgroup
+ca strgroup
+ca pi
+ca plotcp
+ca plcomm
+ca plotcd
+ca tbpara
+ca datatype
      integer i,icd,ict,ifdum,ipflg,ipt,ivdum,mct,mxvar
      double precision d,one,plpval,ptn,pxn,pyn,tn,tv,two,twopi,xn,yn,
     +zero

      parameter         (zero = 0.d0)
      parameter         (one = 1.d0, two = 2.d0, twopi = two * pi)
      parameter         (mxvar = 19, mct = 6)

      dimension         d(12,mxvar), tv(mct)
      character*(mcstr) sdum
      integer           iptp(mxvar)
      save              d
      data iptp / mxvar * 999999 /

      icd = ipflg
      plpval = zero
      if (itbv .ne. 3)  goto 999
      if (icd .le. 1 .or. icd .gt. mxvar)  goto 999

*---- Copy complete track vector.
      if (iq(lform+ipt+1) .eq. 3) then
        do 10  i = 1, mct
          tv(i) = q(lbuf+i+2)
   10   continue
      else
        call ucopy(q(lbuf+3), tv, 6*mwflt)
      endif

      goto (999,  20,  30,  40,  50,  60,  70,  80,  90, 100,
     +      110, 120, 130, 140, 150, 160, 170, 180, 190), icd

*==== Horizontal plane.
*---- x_n, x_ns
   20 continue
  140 continue
      call tbgdsc(ltab, 'E12', ifdum, ivdum, d(1,icd), sdum)
      call tbgdsc(ltab, 'E22', ifdum, ivdum, d(2,icd), sdum)
      call tbgdsc(ltab, 'E32', ifdum, ivdum, d(3,icd), sdum)
      call tbgdsc(ltab, 'E42', ifdum, ivdum, d(4,icd), sdum)
      call tbgdsc(ltab, 'E52', ifdum, ivdum, d(5,icd), sdum)
      call tbgdsc(ltab, 'E62', ifdum, ivdum, d(6,icd), sdum)
      plpval = d(2,icd) * tv(1) - d(1,icd) * tv(2)
     +       + d(4,icd) * tv(3) - d(3,icd) * tv(4)
     +       + d(6,icd) * tv(5) - d(5,icd) * tv(6)

      if (icd .eq. 14) then
        call tbgdsc(ltab, 'EX', ifdum, ivdum, ex, sdum)
        if (ex .ne. zero) plpval = plpval / sqrt(ex)
      endif
      goto 1000

*---- px_n, px_ns
   40 continue
  150 continue
      call tbgdsc(ltab, 'E11', ifdum, ivdum, d(1,icd), sdum)
      call tbgdsc(ltab, 'E21', ifdum, ivdum, d(2,icd), sdum)
      call tbgdsc(ltab, 'E31', ifdum, ivdum, d(3,icd), sdum)
      call tbgdsc(ltab, 'E41', ifdum, ivdum, d(4,icd), sdum)
      call tbgdsc(ltab, 'E51', ifdum, ivdum, d(5,icd), sdum)
      call tbgdsc(ltab, 'E61', ifdum, ivdum, d(6,icd), sdum)
      plpval = d(1,icd) * tv(2) - d(2,icd) * tv(1)
     +       + d(3,icd) * tv(4) - d(4,icd) * tv(3)
     +       + d(5,icd) * tv(6) - d(6,icd) * tv(5)

      if (icd .eq. 15) then
        call tbgdsc(ltab, 'EX', ifdum, ivdum, ex, sdum)
        if (ex .ne. zero) plpval = plpval / sqrt(ex)
      endif
      goto 1000

*---- W_x, W_xs, phi_x
  100 continue
  110 continue
  160 continue
      call tbgdsc(ltab, 'E11', ifdum, ivdum, d(1, icd), sdum)
      call tbgdsc(ltab, 'E21', ifdum, ivdum, d(2, icd), sdum)
      call tbgdsc(ltab, 'E31', ifdum, ivdum, d(3, icd), sdum)
      call tbgdsc(ltab, 'E41', ifdum, ivdum, d(4, icd), sdum)
      call tbgdsc(ltab, 'E51', ifdum, ivdum, d(5, icd), sdum)
      call tbgdsc(ltab, 'E61', ifdum, ivdum, d(6, icd), sdum)
      call tbgdsc(ltab, 'E12', ifdum, ivdum, d(7, icd), sdum)
      call tbgdsc(ltab, 'E22', ifdum, ivdum, d(8, icd), sdum)
      call tbgdsc(ltab, 'E32', ifdum, ivdum, d(9, icd), sdum)
      call tbgdsc(ltab, 'E42', ifdum, ivdum, d(10,icd), sdum)
      call tbgdsc(ltab, 'E52', ifdum, ivdum, d(11,icd), sdum)
      call tbgdsc(ltab, 'E62', ifdum, ivdum, d(12,icd), sdum)
      xn  = d(8, icd) * tv(1) - d(7, icd) * tv(2)
     +    + d(10,icd) * tv(3) - d(9, icd) * tv(4)
     +    + d(12,icd) * tv(5) - d(11,icd) * tv(6)
      pxn = d(1, icd) * tv(2) - d(2, icd) * tv(1)
     +    + d(3, icd) * tv(4) - d(4, icd) * tv(3)
     +    + d(5, icd) * tv(6) - d(6, icd) * tv(5)

      if (icd .eq. 10) then
        plpval = xn**2 + pxn**2
      else if (icd .eq. 16) then
        call tbgdsc(ltab, 'EX', ifdum, ivdum, ex, sdum)
        if (ex .ne. zero) plpval = (xn**2 + pxn**2) / ex
      else if (xn .ne. zero  .or.  pxn .ne. zero) then
        plpval = atan2(pxn, xn) / twopi
        if (plpval .lt. zero) plpval = plpval + one
      endif
      goto 1000

*==== Vertical plane.
*---- y_n, y_ns
   30 continue
  170 continue
      call tbgdsc(ltab, 'E14', ifdum, ivdum, d(1,icd), sdum)
      call tbgdsc(ltab, 'E24', ifdum, ivdum, d(2,icd), sdum)
      call tbgdsc(ltab, 'E34', ifdum, ivdum, d(3,icd), sdum)
      call tbgdsc(ltab, 'E44', ifdum, ivdum, d(4,icd), sdum)
      call tbgdsc(ltab, 'E54', ifdum, ivdum, d(5,icd), sdum)
      call tbgdsc(ltab, 'E64', ifdum, ivdum, d(6,icd), sdum)
      plpval = d(2,icd) * tv(1) - d(1,icd) * tv(2)
     +       + d(4,icd) * tv(3) - d(3,icd) * tv(4)
     +       + d(6,icd) * tv(5) - d(5,icd) * tv(6)

      if (icd .eq. 17) then
        call tbgdsc(ltab, 'EY', ifdum, ivdum, ey, sdum)
        if (ex .ne. zero) plpval = plpval / sqrt(ey)
      endif
      goto 1000

*---- py_n, py_ns
   50 continue
  180 continue
      call tbgdsc(ltab, 'E13', ifdum, ivdum, d(1,icd), sdum)
      call tbgdsc(ltab, 'E23', ifdum, ivdum, d(2,icd), sdum)
      call tbgdsc(ltab, 'E33', ifdum, ivdum, d(3,icd), sdum)
      call tbgdsc(ltab, 'E43', ifdum, ivdum, d(4,icd), sdum)
      call tbgdsc(ltab, 'E53', ifdum, ivdum, d(5,icd), sdum)
      call tbgdsc(ltab, 'E63', ifdum, ivdum, d(6,icd), sdum)
      plpval = d(1,icd) * tv(2) - d(2,icd) * tv(1)
     +       + d(3,icd) * tv(4) - d(4,icd) * tv(3)
     +       + d(5,icd) * tv(6) - d(6,icd) * tv(5)

      if (icd .eq. 18) then
        call tbgdsc(ltab, 'EY', ifdum, ivdum, ey, sdum)
        if (ey .ne. zero) plpval = plpval / sqrt(ey)
      endif
      goto 1000

*---- W_y, W_ys, phi_y
  120 continue
  130 continue
  190 continue
      call tbgdsc(ltab, 'E13', ifdum, ivdum, d(1, icd), sdum)
      call tbgdsc(ltab, 'E23', ifdum, ivdum, d(2, icd), sdum)
      call tbgdsc(ltab, 'E33', ifdum, ivdum, d(3, icd), sdum)
      call tbgdsc(ltab, 'E43', ifdum, ivdum, d(4, icd), sdum)
      call tbgdsc(ltab, 'E53', ifdum, ivdum, d(5, icd), sdum)
      call tbgdsc(ltab, 'E63', ifdum, ivdum, d(6, icd), sdum)
      call tbgdsc(ltab, 'E14', ifdum, ivdum, d(7, icd), sdum)
      call tbgdsc(ltab, 'E24', ifdum, ivdum, d(8, icd), sdum)
      call tbgdsc(ltab, 'E34', ifdum, ivdum, d(9, icd), sdum)
      call tbgdsc(ltab, 'E44', ifdum, ivdum, d(10,icd), sdum)
      call tbgdsc(ltab, 'E54', ifdum, ivdum, d(11,icd), sdum)
      call tbgdsc(ltab, 'E64', ifdum, ivdum, d(12,icd), sdum)
      yn  = d(8, icd) * tv(1) - d(7, icd) * tv(2)
     +    + d(10,icd) * tv(3) - d(9, icd) * tv(4)
     +    + d(12,icd) * tv(5) - d(11,icd) * tv(6)
      pyn = d(1, icd) * tv(2) - d(2, icd) * tv(1)
     +    + d(3, icd) * tv(4) - d(4, icd) * tv(3)
     +    + d(5, icd) * tv(6) - d(6, icd) * tv(5)

      if (icd .eq. 12) then
        plpval = yn**2 + pyn**2
      else if (icd .eq. 19) then
        call tbgdsc(ltab, 'EY', ifdum, ivdum, ey, sdum)
        if (ey .ne. zero) plpval = (yn**2 + pyn**2) / ey
      else if (yn .ne. zero  .or.  pyn .ne. zero) then
        plpval = atan2(pyn, yn) / twopi
        if (plpval .lt. zero) plpval = plpval + one
      endif
      goto 1000

*==== Longitudinal plane.
*---- t_n
   60 continue
      call tbgdsc(ltab, 'E16', ifdum, ivdum, d(1,icd), sdum)
      call tbgdsc(ltab, 'E26', ifdum, ivdum, d(2,icd), sdum)
      call tbgdsc(ltab, 'E36', ifdum, ivdum, d(3,icd), sdum)
      call tbgdsc(ltab, 'E46', ifdum, ivdum, d(4,icd), sdum)
      call tbgdsc(ltab, 'E56', ifdum, ivdum, d(5,icd), sdum)
      call tbgdsc(ltab, 'E66', ifdum, ivdum, d(6,icd), sdum)
      plpval = d(2,icd) * tv(1) - d(1,icd) * tv(2)
     +       + d(4,icd) * tv(3) - d(3,icd) * tv(4)
     +       + d(6,icd) * tv(5) - d(5,icd) * tv(6)
      goto 1000

*---- pt_n
   70 continue
      call tbgdsc(ltab, 'E15', ifdum, ivdum, d(1,icd), sdum)
      call tbgdsc(ltab, 'E25', ifdum, ivdum, d(2,icd), sdum)
      call tbgdsc(ltab, 'E35', ifdum, ivdum, d(3,icd), sdum)
      call tbgdsc(ltab, 'E45', ifdum, ivdum, d(4,icd), sdum)
      call tbgdsc(ltab, 'E55', ifdum, ivdum, d(5,icd), sdum)
      call tbgdsc(ltab, 'E65', ifdum, ivdum, d(6,icd), sdum)
      plpval = d(1,icd) * tv(2) - d(2,icd) * tv(1)
     +       + d(3,icd) * tv(4) - d(4,icd) * tv(3)
     +       + d(5,icd) * tv(6) - d(6,icd) * tv(5)
      goto 1000

*---- W_t, phi_t
   80 continue
   90 continue
      call tbgdsc(ltab, 'E15', ifdum, ivdum, d(1, icd), sdum)
      call tbgdsc(ltab, 'E25', ifdum, ivdum, d(2, icd), sdum)
      call tbgdsc(ltab, 'E35', ifdum, ivdum, d(3, icd), sdum)
      call tbgdsc(ltab, 'E45', ifdum, ivdum, d(4, icd), sdum)
      call tbgdsc(ltab, 'E55', ifdum, ivdum, d(5, icd), sdum)
      call tbgdsc(ltab, 'E65', ifdum, ivdum, d(6, icd), sdum)
      call tbgdsc(ltab, 'E16', ifdum, ivdum, d(7, icd), sdum)
      call tbgdsc(ltab, 'E26', ifdum, ivdum, d(8, icd), sdum)
      call tbgdsc(ltab, 'E36', ifdum, ivdum, d(9, icd), sdum)
      call tbgdsc(ltab, 'E46', ifdum, ivdum, d(10,icd), sdum)
      call tbgdsc(ltab, 'E56', ifdum, ivdum, d(11,icd), sdum)
      call tbgdsc(ltab, 'E66', ifdum, ivdum, d(12,icd), sdum)
      tn  = d(8, icd) * tv(1) - d(7, icd) * tv(2)
     +    + d(10,icd) * tv(3) - d(9, icd) * tv(4)
     +    + d(12,icd) * tv(5) - d(11,icd) * tv(6)
      ptn = d(1, icd) * tv(2) - d(2, icd) * tv(1)
     +    + d(3, icd) * tv(4) - d(4, icd) * tv(3)
     +    + d(5, icd) * tv(6) - d(6, icd) * tv(5)

      if (icd .eq. 8) then
        plpval = tn**2 + ptn**2
      else if (tn .ne. zero  .or.  ptn .ne. zero) then
        plpval = atan2(ptn, tn) / twopi
        if (plpval .lt. zero) plpval = plpval + one
      endif
      goto 1000

 1000 iptp(icd) = ipt
+el
      plpval = 0.0
+ei
  999 end
+dk plqcon
      subroutine plqcon (kx, ky, kxys, ibk, iselct, ierr)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Checks user constraints on Arnold web                              *
*                                                                      *
*--- Input                                                             *
*   KX        (integer) position of K_x in KXYS                        *
*   KY        (integer) position of K_y in KXYS                        *
*   KXYS      (integer) array containing K_x at KX, K_y at KY, KS at 3 *
*   IBK       (integer) array containing:                              *
*                       number of superperiods                         *
*                       number of constraints  N                       *
*                       N constraints:                                 *
*                       minimum                                        *
*                       maximum                                        *
*                       step                                           *
*                       Length L                                       *
*                       expression in polish notation of length L,     *
*                       coded as 1+, 2-, 3*, 4/, 1 KX, 2 KY, 3 KS      *
*                       + MQADD + 4, e.g. 100006 = KY                  *
*--- Output                                                            *
*   ISELCT    (integer) 1 if combination of KX, KY, KS accepted,       *
*                       0 if not accepted                              *
*   IERR                0 if OK, 1 if expression illegal, 2 if / 0     *
*                                                                      *
*----------------------------------------------------------------------*
+ca aparam
+ca plotcp
+ca strgroup
      integer i,ic,ierr,ipt,iselct,k,kc,kop,kx,ky,low,lsp,lup,mqadd4,
     +nstack,nw
      integer    ibk(*), kxys(3)
      integer    kloc(3), istack(100)
      ierr = 0
      kloc(1) = kx
      kloc(2) = ky
      kloc(3) = 3
      iselct = 1
      ipt = 2
      mqadd4 = mqadd + 4
      do 10  ic = 1, ibk(2)
        low = ibk(ipt+1)
        lup = ibk(ipt+2)
        lsp = max(1, ibk(ipt+3))
        nw  = ibk(ipt+4)
        ipt = ipt + 4
*--- calculate expression given in inverse Polish
        nstack = 0
        do 20  i = 1, nw
          kc = ibk(ipt+i)
          if (kc .le. mqadd)  then
*--- simple integer
            nstack = nstack + 1
            istack(nstack) = kc
          elseif (kc .gt. mqadd4)  then
*--- K_x, K_y, or K_s
            k = kc - mqadd4
            nstack = nstack + 1
            istack(nstack) = kxys(kloc(k))
          else
*--- operator
            if (nstack .lt. 2)  then
              ierr = 1
              goto 999
            endif
            kop = kc - mqadd
            if (kop .eq. 1)  then
              istack(nstack-1) =
     +        istack(nstack-1) + istack(nstack)
            elseif (kop .eq. 2)  then
              istack(nstack-1) =
     +        istack(nstack-1) - istack(nstack)
            elseif (kop .eq. 3)  then
              istack(nstack-1) =
     +        istack(nstack-1) * istack(nstack)
            elseif (kop .eq. 4)  then
              if (istack(nstack) .eq. 0)  then
                ierr = 2
                goto 999
              endif
              istack(nstack-1) =
     +        istack(nstack-1) / istack(nstack)
            endif
            nstack = nstack - 1
          endif
   20   continue
        if (nstack .ne. 1)  then
          ierr = 1
          goto 999
        endif
        do 30  i = low, lup, lsp
          if (istack(1) .eq. i)  goto 40
   30   continue
*--- test failed
        iselct = 0
        goto 999
   40   ipt = ipt + nw
   10 continue
+ei
  999 end
+dk plschm
      subroutine plschm (nel, start, ityp, slelm, actwin)
+if .not.noplot
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Plot schema                                                        *
* Input:                                                               *
*   NEL      (integer)  no. of elements                                *
*   START       (real)  start of first element                         *
*   ITYP     (integer)  array with element types:                      *
*                       0: drift                                       *
*                       1: bend, zero tilt                             *
*                       2: focussing quad                              *
*                       3: defocussing quad                            *
*                       4: monitor                                     *
*                       5: collimator                                  *
*                       6: electrostatic separator                     *
*                       7: bend, non-zero tilt                         *
*                       8: multipole                                   *
*                       9: RF cavity                                   *
*                       10: positive sext                              *
*                       11: negative sext                              *
*                       12: positive oct                               *
*                       13: negative oct                               *
*                       14: lcavity                                    *
*   SLELM       (real)  array with element lengths                     *
*   ACTWIN      (real)  active window for curve plot (array of 4)      *
*----------------------------------------------------------------------*
* Modified: 13-JAN-1999, M. Woodley (SLAC)                             *
*   Add sextupoles and octupoles to machine layout                     *
* Modified: 17-MAR-1999, M. Woodley (SLAC)                             *
*   Add lcavity elements to machine layout                             *
*----------------------------------------------------------------------*
+ca aparam
+ca plotcp
+ca strgroup
      integer i,it,j,mparr,mptp,nel
      double precision spos
      integer              ityp(*)

      parameter            (mparr = 88, mptp = 14)
      real                 start, slelm(*), actwin(4)
      real                 shapex(mparr), shapey(mparr)
      real                 txp(2), typ(2)
      integer              npst(mptp), npnd(mptp), npsl(mparr)

      data npst   / 1,  6, 11, 16, 21,
     +              33, 43, 48,
     +              50,
     +              64, 69, 74, 79, 84 /
      data npnd   / 5, 10, 15, 20, 32,
     +              42, 47, 49,
     +              63,
     +              68, 73, 78, 83, 88 /
      data npsl   /5 * 1, 5 * 1, 5 * 1, 5 * 3, 5 * 1, 0, 4 * 1, 0, 1,
     +             1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 5 * 1, 2 * 1,
     +             6 * 1, 0, 5 * 1, 0, 1,
     +             5 * 1, 5 * 1, 5 * 1, 5 * 1, 5 * 1 /
      data shapex /0., 1., 1., 0., 0.,
     +             0., 1., 1., 0., 0.,
     +             0., 1., 1., 0., 0.,
     +             0., 1., 1., 0., 0.,
     +             0., 1., 1., 0., 0., 0., 1., 1., 0., 0., 0., 1.,
     +             0., 1., 0.5, 0.5, 0., 1., 0.5, 0.5, 0., 1.,
     +             0., 1., 1., 0., 0.,
     +             0., 0.,
     +             0., 0.25, 0.25, 0.75, 0.75, 1.,
     +             0., 0.25, 0.25, 0.75, 0.75, 1., 0., 1.,
     +             0., 1., 1., 0., 0.,
     +             0., 1., 1., 0., 0.,
     +             0., 1., 1., 0., 0.,
     +             0., 1., 1., 0., 0.,
     +             0., 1., 1., 0., 0. /
      data shapey /0.6, 0.6, -0.6, -0.6, 0.6,
     +             0., 0., 0.8, 0.8, 0.,
     +             0., 0., -0.8, -0.8, 0.,
     +             0.6, 0.6, -0.6, -0.6, 0.6,
     + 0.8, 0.8, 0.4, 0.4, 0.8, -0.8, -0.8, -0.4, -0.4, -0.8, 0., 0.,
     + 0.4, 0.4, 0.8, 0.4, -0.4, -0.4, -0.8, -0.4, 0., 0.,
     + 0.5, 0.5, -0.5, -0.5, 0.5,
     + 0.5, -0.5,
     + 0.2, 0.2, 0.8, 0.8, 0.2, 0.2,
     +-0.2, -0.2, -0.8, -0.8, -0.2, -0.2, 0., 0.,
     +             0., 0., 0.5, 0.5, 0.,
     +             0., 0., -0.5, -0.5, 0.,
     +             0., 0., 0.25, 0.25, 0.,
     +             0., 0., -0.25, -0.25, 0.,
     +             0.2, 0.2, -0.2, -0.2, 0.2 /

      spos = start
      do 10 i = 1, nel
        it = ityp(i)
        if (it .eq. 0) then
          txp(1) = spos
          txp(2) = spos + slelm(i)
          typ(1) = 0.
          typ(2) = 0.
          call gvpl (2, txp, typ)
        else
          txp(1) = spos + shapex(npst(it)) * slelm(i)
          typ(1) = shapey(npst(it))
          do 20  j = npst(it)+1, npnd(it)
            txp(2) = spos + shapex(j) * slelm(i)
            typ(2) = shapey(j)
            if (npsl(j) .gt. 0)  then
              call jsln(npsl(j))
              call gvpl(2, txp, typ)
            endif
            txp(1) = txp(2)
            typ(1) = typ(2)
   20     continue
        endif
        spos = spos + slelm(i)
   10 continue
+ei
      end
+dk plstrg
      logical function plstrg(name, ltab)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Returns TRUE when a variable is a string.                          *
* Input:                                                               *
*   NAME      (name)    Variable name.                                 *
*   LTAB(1)   (pointer) Pointer to table header bank.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,iform,ikat,ileng,iln,ipr,isp,ival,ltab,nkat
      double precision rval
      character*(mcnam) name
+ca memdum
+ca bankhead
+ca prcgroup
+ca keyword
+ca refer

      character*(mcnam) sval

*---- First test: string expression.
      plstrg = .false.
      call utleng(name, ileng)
      call difind(ldbnk, name(1:ileng), idir, lcsrc)
      if (lcsrc .ne. 0  .and.
     +    iq(lcsrc+mbpr) .eq. mpstr  .and.
     +    iq(lcsrc+mbsp) .eq. 1) then
        plstrg = .true.

*---- Second test: expression restricted to specific table.
      else
        call tbgdsc(ltab, 'TYPE', iform, ival, rval, sval)
        if (iform .eq. 5) then
          call difind(ldbnk, 'T_' // sval, idir, lcsrc)
          if (lcsrc .ne. 0  .and.
     +        iq(lcsrc+mbpr) .eq. mpstr  .and.
     +        iq(lcsrc+mbsp) .ne. 1) then
            call kwget(lq(lcsrc+1), iln, ipr, isp, nkat)
            call utlook(name(1:ileng), katnam, nkat, ikat)
            if (ikat .ne. 0) plstrg = .true.
          endif
        endif
      endif

      end
+dk plzzzz
+dk praaaa
+dk prhead
      subroutine prhead(cmdnam, title, deltap, nord, nline, npage)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print global page header on print file.                            *
* Input:                                                               *
*   TITLE     (char)    Header text.                                   *
*   CMDNAM    (char)    Command name.                                  *
*   DELTAP    (real)    Delta(p)/p.                                    *
*   NORD      (integer) Order of the map (not printed if zero).        *
* Input/output:                                                        *
*   NLINE     (integer) Current line number.                           *
*   NPAGE     (integer) Current page number.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer mhead,nline,nord,npage
      double precision deltap
        character*(*)   cmdnam, title
+ca memdum
+ca bankhead
+ca range
+ca refer
+ca zunit

      parameter         (mhead = 4)

      call prpage(iqpr2)
      write (iqpr2, 910) title, cmdnam, linnam, rngnam
      if (nord .lt. 0) then
        write (iqpr2, 920) symm, nsup, npage
      else if (nord .eq. 0) then
        write (iqpr2, 930) deltap, symm, nsup, npage
      else
        write (iqpr2, 940) deltap, symm, nsup, nord, npage
      endif
      call prline(iqpr2)
      nline = mhead

  910 format(' ',a,t31,a,t51,'line: ',a,t84,'range: ',a)
  920 format(t31,'symm: ',l1,t51,'super:',i4,
     +       t122,'page',i6)
  930 format(' Delta(p)/p: ',f12.6,t31,'symm: ',l1,t51,'super:',i4,
     +       t122,'page',i6)
  940 format(' Delta(p)/p: ',f12.6,t31,'symm: ',l1,t51,'super:',i4,
     +       t84,'nord:',i4,t122,'page',i6)

      end
+dk prline
      subroutine prline(iunit)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print a line of dashes.                                            *
* Input:                                                               *
*   IUNIT     (integer) Logical unit number.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer iunit

      write (iunit,910)

  910 format(' ',13('----------'))

      end
+dk prpage
      subroutine prpage(iunit)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print page header.                                                 *
* Input:                                                               *
*   IUNIT     (integer) Logical unit number.                           *
*----------------------------------------------------------------------*
+ca aparam
+ca header
      integer iunit

      write (iunit,910) ctitle, nvers, cdate, ctime

  910 format('1',a80,'  "MAD" Version: ',a8,'  Run: ',a8,'  ',a8)

      end
+dk przzzz
+dk rdaaaa
+dk rdfail
      subroutine rdfail(rout, lines, text)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print fatal error message and display offending statement.         *
* Input:                                                               *
*   ROUT      (char)    Calling routine name.                          *
*   LINES     (integer) Number of lines in message.                    *
*   TEXT      (char)    Message.                                       *
*----------------------------------------------------------------------*
+ca aparam
      integer i,leng,lines
      character*(*)     rout, text(lines)
+ca status
+ca zunit

      call utleng(text(1), leng)
      write (iqlog, 910) rout, text(1)(1:leng)
      do 90 i = 2, lines
        call utleng(text(i), leng)
        write (iqlog, 920) text(i)(1:leng)
   90 continue
      call rdmark
      nfail = nfail + 1
      error = .true.

  910 format(' '/' ',a,'.',t11,'*** Error *** ',a)
  920 format(t11,a)

      end
+dk rdfind
      subroutine rdfind(string)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find first occurrence of a character occurring in STRING.          *
*----------------------------------------------------------------------*
+ca aparam
      integer index
      character*(*)     string
+ca stbuff

   10 if (jtok .le. ntok  .and.  index(string,token(jtok)) .eq. 0) then
        jtok = jtok + 1
        go to 10
      endif

      end
+dk rdform
      subroutine rdform(ip1, ip2, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Mark positions of balanced parentheses.                            *
* Output:                                                              *
*   IP1      (integer)  position of open parenthesis.                  *
*   IP2      (integer)  position of closing parenthesis.               *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ip1,ip2,level
      logical           eflag
+ca stbuff

      character*1       c1, c2

      eflag = .false.
      ip1 = 0

*---- Care about ( ), [ ], or ;.
      if (token(jtok) .eq. '(') then
        c1 = '('
        c2 = ')'
      else if (token(jtok) .eq. '[') then
        c1 = '['
        c2 = ']'
      else
        go to 9999
      endif
      level = 1
      ip1 = jtok

*---- Loop until closing bracket found.
  100 continue
        jtok = jtok + 1
        if (token(jtok) .eq. c2) then
          level = level - 1
          if (level .le. 0) go to 200
        else if (token(jtok) .eq. c1) then
          level = level + 1
        else if (token(jtok) .eq. ';') then
          go to 200
        endif
      if (token(jtok) .ne. ';') go to 100

*---- Check for balanced brackets.
  200 continue
      if (level .ne. 0) then
        call rdfail('RDFORM', 1, 'Unbalanced parentheses or brackets.')
        eflag = .true.
      else
        ip2 = jtok
        jtok = jtok + 1
        eflag = .false.
      endif

 9999 end
+dk rdinit
      subroutine rdinit
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initialize input buffers.                                          *
*----------------------------------------------------------------------*
+ca aparam
+ca lnbuff
      character*(ltext) txtlin
      equivalence       (txtlin, text(1))
+ca stbuff

*---- Line buffer.
      lintxt = 0
      jtext = ltext + 1
      ntext = ltext
      txtlin = ' '

*---- Statement buffer.
      lintok = 0
      jtok = 0
      ntok = 0

      end
+dk rdint
      subroutine rdint(ivalue, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Read and decode integer.                                           *
* Return values:                                                       *
*   IVALUE   (integer)  Value decoded.                                 *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ichar,idig,index,ival,ivalue
      logical           eflag
+ca chcode
+ca stbuff
      logical           minus

      eflag = .true.
      minus = .false.
      if (token(jtok) .eq. '+') then
        jtok = jtok + 1
      else if (token(jtok) .eq. '-') then
        jtok = jtok + 1
        minus = .true.
      endif
      ival = 0
   10 continue
      idig = ichtyp(ichar(token(jtok)))
      if (idig .le. 9) then
        ival = 10 * ival + idig
        eflag = .false.
        jtok = jtok + 1
        go to 10
      endif
      if (minus) ival = - ival
      if (eflag) then
        call rdfail('RDINT', 1, 'Integer expected.')
        ivalue = 0
      else if (index('.DE', token(jtok)) .ne. 0) then
        call rdskip('0123456789.E')
        call rdfail('RDINT', 1, 'Real value not allowed.')
        eflag = .true.
        ivalue = 0
      else
        ivalue = ival
      endif

      end
+dk rdline
      subroutine rdline
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Read input line, skip blank lines and comments.
*   Special DOOM version: read lines from buffer if flag
*----------------------------------------------------------------------*
+ca aparam
+ca message
+ca lnbuff
+ca option
+ca status
+if doom
      integer lch
+ei
      character*(ltext) txtlin
      equivalence       (txtlin, text(1))
+ca zunit
+if doom
+ca dmcommon
+ei
*---- Give prompt if reading from console.
  100 continue
        if (prompt) write (iqtype, 910)
+if doom
        if (dmdict)  then
          call dmgline('MAD-8-DICT ', txtlin, lch)
          if (lch .le. 0)  goto 110
        else
          read (iqread, 920, end=110) txtlin
        endif
+ei
+if standard
        read (iqread, 920, end=110) txtlin
+ei
        lintxt = lintxt + 1
        go to 120

*---- End of file?
  110   continue
        txtlin = 'END_FILE! *** Generated line ***'

*---- Write input echo.
  120   continue
        if (echo) then
          if (mod(lintxt, 5) .eq. 0) then
            write (iqlog, 940) lintxt, txtlin
          else
            write (iqlog, 950) txtlin
          endif
        endif

*---- Skip comment lines and blank lines.
      if (text(1) .eq. '!'  .or.  txtlin .eq. ' ') go to 100
      jtext = 1
      ntext = ltext

  910 format(' M: ==>')
  920 format(a80)
  930 format('Read error on unit',i4,', line number',i6,'.')
  940 format(' ',i9,5x,a80)
  950 format(15x,a80)

      end
+dk rdlogc
      subroutine rdlogc(lval, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Read and decode logical value.                                     *
* Return values:                                                       *
*   LVAL   (logical)    Value decoded.                                 *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer lword
      logical           lval, eflag
+ca stbuff
+ca zunit

      logical           dot
      character*8       word

      eflag = .false.
      dot = .false.
      if (token(jtok) .eq. '.') then
        dot = .true.
        jtok = jtok + 1
      endif

*---- Read token for logical.
      call rdword(word, lword)
      if (lword .eq. 0) go to 800

*---- Do dots match?
      if (dot) then
        if (word(lword:lword) .ne. '.') go to 800
        word = word(1:lword-1)
      endif

*---- Look for valid values.
      if      (word .eq. 'F'  .or.
     +         word .eq. 'N'  .or.
     +         word .eq. 'FALSE'  .or.
     +         word .eq. 'NO'  .or.
     +         word .eq. 'OFF') then
        lval = .false.
        go to 9999
      else if (word .eq. 'T'  .or.
     +         word .eq. 'Y'  .or.
     +         word .eq. 'TRUE'  .or.
     +         word .eq. 'YES'  .or.
     +         word .eq. 'ON') then
        lval = .true.
        go to 9999
      endif

*---- Invalid value.
  800 continue
      call rdfail('RDLOGC', 1, 'Logical value expected.')

 9999 end
+dk rdmark
      subroutine rdmark
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print offending statement after an error message.                  *
*----------------------------------------------------------------------*
+ca aparam
+ca stbuff
+ca zunit
      integer j

      write (iqlog, 910) lintok
      write (iqlog, 920) (token(j), j = 1, jtok - 1), ('?', j = 1, 3),
     +                   (token(j), j = jtok, ntok)
      write (iqlog, 930)

  910 format(t11,'Statement beginning at line',i6,':')
  920 format(t11,70a1)
  930 format(' ')

      end
+dk rdnumb
      subroutine rdnumb(rval, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Read and decode real value.                                        *
* Output:                                                              *
*   RVAL   (real)       Value decoded.                                 *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ichar,idig,index,ise,ive,npl
      double precision one,rval,sig,ten,val,zero
      logical           eflag
+ca chcode
+ca stbuff

      logical           dig,   pnt
      parameter         (zero = 0.0d0)
      parameter         (one =  1.0d0)
      parameter         (ten = 10.0d0)

      eflag = .false.
      rval = zero

*---- Any numeric character?
      if (ichtyp(ichar(token(jtok))) .le. 9  .or.
     +    index('+-.',token(jtok)) .ne. 0) then
        val = zero
        sig = one
        ive = 0
        ise = 1
        npl = 0
        dig = .false.
        pnt = .false.

*---- Sign.
        if (token(jtok) .eq. '+') then
          jtok = jtok + 1
        else if (token(jtok) .eq. '-') then
          sig = - one
          jtok = jtok + 1
        endif

*---- Digit or decimal point?
   10   continue
        idig = ichtyp(ichar(token(jtok)))
        if (idig .le. 9) then
          val = ten * val + float(idig)
          dig = .true.
          if (pnt) npl = npl + 1
          jtok = jtok + 1
          go to 10
        else if (token(jtok) .eq. '.') then
          if (pnt) eflag = .true.
          pnt = .true.
          jtok = jtok + 1
          go to 10
        endif
        eflag = eflag  .or.  (.not. dig)

*---- Exponent?
        if (token(jtok) .eq. 'D'  .or.  token(jtok) .eq. 'E'  .or.
     +      token(jtok) .eq. 'd'  .or.  token(jtok) .eq. 'e') then
          jtok = jtok + 1
          dig = .false.
          if (token(jtok) .eq. '+') then
            jtok = jtok + 1
          else if (token(jtok) .eq. '-') then
            ise = -1
            jtok = jtok + 1
          endif
   20     continue
          idig = ichtyp(ichar(token(jtok)))
          if (idig .le. 9) then
            ive = 10 * ive + idig
            dig = .true.
            jtok = jtok + 1
            go to 20
          endif
          if (.not. dig) then
            eflag = .true.

*---- Expect a separator after a number group.
          else if (ichtyp(ichar(token(jtok))) .le. 9  .or.
     +             index('.DE', token(jtok)) .ne. 0) then
            call rdskip('0123456789.DE')
            eflag = .true.
          endif
        endif

*---- Return value
        if (eflag) then
          call rdfail('RDNUMB', 1, 'Incorrect real value.')
        else
          rval = sig * val * ten ** (ise * ive - npl)
        endif
      else
        call rdfail('RDNUMB', 1, 'Real value expected.')
        eflag = .true.
      endif

      end
+dk rdskip
      subroutine rdskip(string)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Skip any character(s) occurring in "STRING".                       *
*----------------------------------------------------------------------*
+ca aparam
      integer index
      character*(*)     string
+ca stbuff

   10 if (jtok .le. ntok  .and.  index(string,token(jtok)) .ne. 0) then
        jtok = jtok + ntok
        if(jtok .lt. ntok) go to 10
      endif

      end
+dk rdstat
      subroutine rdstat(eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Read a statement into the statement buffer, skip emtpy statements. *
* Output:                                                              *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ichar,index
      logical           eflag
+ca message
+ca chcode
+ca lnbuff
+ca stbuff

      character*1       c, cp, q
      logical           ovrun
+ca bslash

*---- Read next line if finished with last one.
      eflag = .false.
      if (jtext .gt. ntext) call rdline

*---- Note starting line number.
      lintok = lintxt
      jtok = 1
      ntok = 0
      cp = ';'

*---- Copy statement to statement buffer.
  100 continue

*---- Get next character on current line.
        if (jtext .le. ntext) then
          c = ch2upp(ichar(text(jtext)))
          jtext = jtext + 1
        else
          c = ';'
        endif

*---- End of statement.
        if (c .eq. ';'  .or.  c .eq. '!') then
          if (ntok .ge. lentok) go to 800
          ntok = ntok + 1
          token(ntok) = ';'
          if (c .eq. '!') jtext = ntext + 1
          eflag = .false.
          go to 9999

*---- Continue on next line.
        else if (c .eq. '&') then
          call rdline
          go to 100

*---- Single or double quote.
        else if (c .eq. '"'  .or.  c .eq. '''') then
          if (ntok .ge. lentok) go to 800

*---- Copy single quote (prime) to name.
          if ((c .eq. '''')  .and.
     +        (ichtyp(ichar(cp)) .le. 10 .or.
     +         index('.''_', cp) .ne. 0)) then
            ntok = ntok + 1
            token(ntok) = c
            cp = c

*---- Copy opening quote to string.
          else
            ovrun = .false.
            q = c
            ntok = ntok + 1
            token(ntok) = c

*---- Copy string to statement buffer.
  200       continue

*---- Get next character.
              if (jtext .gt. ntext) then
                if (.not. ovrun) then
                  call rdwarn('RDSTAT', 1,
     +            'String overruns end of line.')
                  ovrun = .true.
                endif
                call rdline
              endif
              c = text(jtext)
              jtext = jtext + 1

*---- If quote, look for a second quote to continue string.
              if (c .eq. q) then
                if (ntok .ge. lentok) go to 800
                ntok = ntok + 1
                token(ntok) = c
                cp = c
                if (text(jtext) .ne. q) go to 100
                jtext = jtext + 1
              endif

*---- Move character to string.
              if (ntok .ge. lentok) go to 800
              ntok = ntok + 1
              token(ntok) = c
            go to 200
          endif

*---- Remove string of blanks.
        else if (c .eq. ' ') then
  300     if (jtext .le. ntext) then
            c = text(jtext)
            jtext = jtext + 1
            if (c .eq. ' ') go to 300
            if (c .eq. '&') then
              call rdline
              go to 300
            endif
            jtext = jtext - 1
          endif

*---- Replace blank string by comma.
          if ((ichtyp(ichar(cp)) .le. 10 .or.
     +         index('.''"@$)]',cp) .ne. 0)  .and.
     +        (ichtyp(ichar(c)) .le. 10 .or.
     +         index('.''"@$([#',c) .ne. 0)) then
            if (ntok .ge. lentok) go to 800
            ntok = ntok + 1
            cp = ','
            token(ntok) = ','
          else
            cp = ' '
          endif

*---- Any other character goes to statement buffer.
        else
          if (ntok .ge. lentok) go to 800
          ntok = ntok + 1
          token(ntok) = c
          cp = c
        endif
      go to 100

*---- Statement buffer overflow.
  800 continue
      write (msg, 910) lentok
  910 format('Statement too long for input buffer, available length = ',
     +       i5)
      call rdfail('RDSTAT', 1, msg)
      token(ntok) = ';'

 9999 end
+dk rdstrg
      subroutine rdstrg(string, number)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Read and decode a quoted string.                                   *
* Output:                                                              *
*   STRING   (char)     Value decoded.                                 *
*   NUMBER   (integer)  Characters actually read.                      *
*----------------------------------------------------------------------*
+ca aparam
      integer len,length,number
      character*(*)     string
+ca stbuff

      character*1       q
+ca bslash

*---- Expect quote.
      q = token(jtok)

      jtok = jtok + 1
      length = len(string)
      number = 0
      string = ' '

*---- Loop over characters.
   10 continue

*---- Remove escapes, "\". Take following character even if special.
        if (token(jtok) .eq. bslash) then
          jtok = jtok + 1

*---- End of string?
        else if (token(jtok) .eq. q) then
          jtok = jtok + 1
          if (token(jtok) .ne. q) go to 9999
        endif
        if (number .lt. length) then
          number = number + 1
          string(number:number) = token(jtok)
        endif
        jtok = jtok + 1
      go to 10

 9999 end
+dk rdtest
      subroutine rdtest(string, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Verify that next character is one of those in "STRING".            *
* Input:                                                               *
*   STRING   (char)     Character(s) expected.                         *
* Output:                                                              *
*   EFLAG    (logical)  Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer index,len
      character*(*)     string
      logical          eflag
+ca stbuff
+ca message

      eflag = .false.
      if (index(string, token(jtok)) .eq. 0) then
        if (len(string) .eq. 1) then
          msg(1) = '"' // string // '" expected.'
          call rdfail('RDTEST', 1, msg)
        else
          msg(1) = 'One of "' // string // '" expected.'
          call rdfail('RDTEST', 1, msg)
        endif
        eflag = .true.
      endif

      end
+dk rdwarn
      subroutine rdwarn(rout, lines, text)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print warning message and display offending statement.             *
* Input:                                                               *
*   ROUT      (char)    Calling routine name.                          *
*   LINES     (integer) Number of lines in message.                    *
*   TEXT      (char)    Message.                                       *
*----------------------------------------------------------------------*
+ca aparam
      integer i,leng,lines
      character*(*)     rout, text(lines)
+ca option
+ca status
+ca zunit

      if (warn) then
        call utleng(text(1), leng)
        write (iqlog, 910) rout, text(1)(1:leng)
        do 90 i = 2, lines
          call utleng(text(i), leng)
          write (iqlog, 920) text(i)(1:leng)
   90   continue
        call rdmark
        nwarn = nwarn + 1
      endif

  910 format(' '/' ',a,'.',t11,'## Warning ## ',a)
  920 format(t11,a)

      end
+dk rdword
      subroutine rdword(word, number)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Read and decode a possibly quoted identifier.                      *
* Output:                                                              *
*   WORD     (char*(*)) Decoded value.                                 *
*   NUMBER   (integer)  Number of characters actually read.            *
*----------------------------------------------------------------------*
+ca aparam
      integer ichar,index,len,length,number
      character*(*)     word
+ca chcode
+ca stbuff

      length = len(word)
      number = 0
      word = ' '

*---- If quoted, call string decoder.
      if (token(jtok) .eq. '"'  .or.  token(jtok) .eq. '''') then
        call rdstrg(word, number)

*---- Expect a letter to start word.
      else if (ichtyp(ichar(token(jtok))) .eq. 10) then

*---- Pack character to word.
   10   continue
          if (number .lt. length) then
            number = number + 1
            word(number:number) = token(jtok)
          endif
          jtok = jtok + 1
        if (ichtyp(ichar(token(jtok))) .le. 10) go to 10
        if (index('.''_', token(jtok)) .ne. 0) go to 10
      endif

      end
+dk rdzzzz
+dk spaaaa
+dk spmain
      subroutine spmain(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   This is a dummy for the SITF/SODOM main routine.                   *
*   It can be replaced to hook in user commands.                       *
* Input:                                                               *
*   IPR       (integer) Process code.                                  *
*   ISP       (integer) Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer ipr,isp

      call rdwarn('SPMAIN', 1, 'Polarization not in this version.')

      end
+dk spzzzz
+dk suaaaa
+dk suangl
      subroutine suangl(w, theta, phi, psi)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Given a rotation matrix, compute the survey angles.                *
* Input:                                                               *
*   W(3,3)    (real)    Rotation matrix.                               *
* Output:                                                              *
*   THETA     (real)    Azimuthal angle.                               *
*   PHI       (real)    Elevation angle.                               *
*   PSI       (real)    Roll angle.                                    *
*----------------------------------------------------------------------*
+ca aparam
      double precision a,arg,b,phi,proxim,psi,theta,twopi,utwopi,w
      dimension         w(3,3)

+ca pi
      parameter         (twopi = 2.0d0 * pi, utwopi = 1.0d0 / twopi)
      proxim(a,b) = a + twopi * anint((b - a) * utwopi)

      arg = sqrt(w(2,1)**2 + w(2,2)**2)
      phi = atan2(w(2,3), arg)
      if (arg .gt. 1.0e-20) then
        theta = proxim(atan2(w(1,3), w(3,3)), theta)
        psi = proxim(atan2(w(2,1), w(2,2)), psi)
      else
        psi = proxim(atan2(-w(1,2), w(1,1))-theta, psi)
      endif

      end
+dk sucopy
      subroutine sucopy(vs, ws, vd, wd)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Copy rotation matrix and position vector.                          *
* Input:                                                               *
*   VS(3)     (real)    Position vector.                               *
*   WS(3,3)   (real)    Rotation matrix.                               *
* Output:                                                              *
*   VD(3)     (real)    Position vector.                               *
*   WD(3,3)   (real)    Rotation matrix.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer i,k
      double precision vd,vs,wd,ws
      dimension         vs(3), ws(3,3), vd(3), wd(3,3)

      do 90 k = 1, 3
        vd(k) = vs(k)
        do 80 i = 1, 3
          wd(i,k) = ws(i,k)
   80   continue
   90 continue

      end
+dk suelem
      subroutine suelem(elmlen, arclen, ve, we)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Compute Displacement and rotation for one element.                 *
* Output:                                                              *
*   ELMLEN    (real)    Nominal element length.                        *
*   ARCLEN    (real)    Element length along design orbit.             *
*   VE(3)     (real)    Displacement of exit w.r.t. entry.             *
*   WE(3,3)   (real)    Rotation of exit w.r.t. entry.                 *
* Reference pointer used:                                              *
*   LCELM     /REFER/   Current element bank.                          *
* Local links:                                                         *
*   LSEQ                Beam lines sequence for a lump.                *
*----------------------------------------------------------------------*
* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Added LCAVITY element at ISP 27                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ienum,iflag,ileng,ilm,ils,ilv,iocc,isp,jbit,lseq
      double precision angle,arclen,cospsi,costhe,ds,dx,elmlen,sinpsi,
     +sinthe,tilt,ve,we,zero
      dimension         ve(3), we(3,3)

+ca memdum
+ca bankhead
+ca beam
+ca cmdgroup
+ca elmgroup
+ca markbits
+ca prcgroup
+ca seqgroup
+ca message
+ca refer
+ca wstack

      parameter         (zero = 0.0d0)

      character*(mcnam) elmnam
      integer bvpos
      parameter         (bvpos = 24)
      logical bvflag

*---- Define default values.
      bvflag = .false.
      llump = 0
 1000 continue
      elmlen = 0.0
      arclen = 0.0
      angle = 0.0
      tilt = 0.0

*---- Branch on subprocess code.
      call suiden(ve, we)
      isp = iq(lcelm+mbsp)
      go to ( 10,  20,  30,  40,  50,  60,  70,  80,  90, 100,
     +       110, 120, 130, 140, 150, 160, 170, 180, 190, 200,
     +       210, 220, 230, 240, 250, 260, 270, 280, 290, 300,
     +       310, 310, 310, 310, 310, 310, 310, 310, 310, 310), isp

*---- Drift space.
   10 continue

*---- Arbitrary matrix.
   40 continue

*---- Quadrupole.
   50 continue

*---- Sextupole.
   60 continue

*---- Octupole.
   70 continue

*---- Solenoid.
   90 continue

*---- RF cavity.
  100 continue

*---- Electrostatic separator.
  110 continue

*---- Kickers.
  140 continue
  150 continue
  160 continue

*---- Monitors.
  170 continue
  180 continue
  190 continue

*---- Apertures.
  200 continue
  210 continue

*---- Marker.
  250 continue

*---- Beam-beam.
  220 continue

*---- lcavity
  270 continue
*---- Reserved.
  280 continue
  290 continue
  300 continue

*---- Beam instrument.
  240 continue
        call ucopy(q(lcelm+melen), elmlen, mwflt)
        arclen = elmlen
        ve(3) = elmlen
      go to 500

*---- Rectangular bend.
   20 continue
        call ucopy(q(lcelm+melen), elmlen, mwflt)
        call ucopy(q(lcelm+meangb), angle, mwflt)
        call ucopy(q(lcelm+metltb), tilt, mwflt)
        call ucopy(q(lcelm+meintbx+3*mcsiz), bvflag, 1)
        if (bvflag)  angle = beambv * angle
        if (angle .eq. 0.0) then
          dx = 0.0
          ds = elmlen
          arclen = elmlen
        else
          dx = - elmlen * sin(angle / 2.0)
          ds = + elmlen * cos(angle / 2.0)
          arclen = elmlen * angle / (2.0 * sin(angle / 2.0))
        endif
      go to 490

*---- Sector bend.
   30 continue
        call ucopy(q(lcelm+melen), elmlen, mwflt)
        call ucopy(q(lcelm+meangb), angle, mwflt)
        call ucopy(q(lcelm+metltb), tilt, mwflt)
        call ucopy(q(lcelm+meintbx+3*mcsiz), bvflag, 1)

        if (bvflag)  angle = beambv * angle
        if (angle .eq. 0.0) then
          dx = 0.0
          ds = elmlen
          arclen = elmlen
        else
          dx = (elmlen / angle) * (cos(angle) - 1.0)
          ds = (elmlen / angle) * sin(angle)
          arclen = elmlen
        endif
      go to 490

*---- Multipoles.
   80 continue
        call ucopy(q(lcelm+meklm), angle, mwflt)
        call ucopy(q(lcelm+metltm), tilt, mwflt)
        call utglog(lcelm, bvpos, bvpos, bvflag)
*--- HG000915 use bv flag to possibly invert angle
        if (bvflag) angle = beambv * angle
        dx = 0.0
        ds = 0.0
      go to 490

*---- General bend (dipole, quadrupole, and skew quadrupole).
  260 continue
        call ucopy(q(lcelm+melen), elmlen, mwflt)
        call ucopy(q(lcelm+meangg), angle, mwflt)
        call ucopy(q(lcelm+metltg), tilt, mwflt)
        call ucopy(q(lcelm+meintgx+3*mcsiz), bvflag, 1)

        if (bvflag)  angle = beambv * angle
        if (angle .eq. 0.0) then
          dx = 0.0
          ds = elmlen
          arclen = elmlen
        else
          dx = - elmlen * sin(angle / 2.0)
          ds = + elmlen * cos(angle / 2.0)
          arclen = elmlen * angle / (2.0 * sin(angle / 2.0))
        endif
      go to 490

*---- Rotation around S-axis.
  120 continue
        call ucopy(q(lcelm+meangr), angle, mwflt)
        we(1,1) = cos(angle)
        we(2,1) = sin(angle)
        we(1,2) = - we(2,1)
        we(2,2) = + we(1,1)
      go to 500

*---- Rotation around Y-axis.
  130 continue
        call ucopy(q(lcelm+meangr), angle, mwflt)
        we(1,1) = cos(angle)
        we(3,1) = sin(angle)
        we(1,3) = - we(3,1)
        we(3,3) = + we(1,1)
      go to 500

*---- User-defined elements.
  310 continue
        call suuser(elmlen, arclen, ve, we)
      go to 500

*---- Lump.
  230 continue

*---- Avoid recursive call.
        if (jbit(iq(lcelm),mxlmp) .ne. 0) then
          call diname(ldbnk, iq(lcelm+mbnam), elmnam)
          call utleng(elmnam, ileng)
          msg(1) =
     +    'LUMP "' // elmnam(1:ileng) // '" has a recursive definition,'
          msg(2) = 'identity transformation used.'
          call aawarn('SUELEM', 2, msg)
          go to 500
        endif
        call sbit1(iq(lcelm), mxlmp)

*---- Stack data for element.
        call mzbook(2, llump, llump, 1, 'LSTK', 2, 1, 4, 2, 0)
        lq(llump-2) = lcelm

*---- Expand the element sequence for this lump.
*     Avoid dropping of a previous sequence.
        call lnrefe(lcelm, 4, lseq, llump, -1)
        iq(llump+1) = iq(lseq+msr1)
        iq(llump+2) = iq(lseq+msr2)
        iq(llump+3) = iq(lseq+msr1) - 1

*---- Assign working space for accumulation of transform.
        iq(llump+4) = iwork
        ils = iwork
        ilv = iwork + 2
        ilm = iwork + 5
        iwork = iwork + 14
        if (iwork .gt. nwork) then
          call mzwork(0, dq(1), dq(iwork+1), 2)
          nwork = iwork
        endif
        dq(ils+1) = 0.0
        dq(ils+2) = 0.0
        call suiden(dq(ilv+1), dq(ilm+1))

*---- Find first element and compute its transform.
        go to 510

*---- Common for bends and multipoles: Displacement and rotation matrix.
  490 continue
      cospsi = cos(tilt)
      sinpsi = sin(tilt)
      costhe = cos(angle)
      sinthe = sin(angle)
      ve(1) = dx * cospsi
      ve(2) = dx * sinpsi
      ve(3) = ds
      we(1,1) = costhe * cospsi**2 + sinpsi**2
      we(2,1) = (costhe - 1.0) * cospsi * sinpsi
      we(3,1) = sinthe * cospsi
      we(1,2) = we(2,1)
      we(2,2) = costhe * sinpsi**2 + cospsi**2
      we(3,2) = sinthe * sinpsi
      we(1,3) = - we(3,1)
      we(2,3) = - we(3,2)
      we(3,3) = costhe

*---- End of element calculation; check for LUMP.
  500 continue
      if (llump .eq. 0) go to 550

*---- Accumulate transform for lump.
      ils = iq(llump+4)
      ilv = ils + 2
      ilm = ils + 5
      dq(ils+1) = dq(ils+1) + arclen
      dq(ils+2) = dq(ils+2) + elmlen
      call sutrak(dq(ilv+1), dq(ilm+1), ve, we)

*---- Test for end of sequence.
  510 iq(llump+3) = iq(llump+3) + 1
      if (iq(llump+3) .le. iq(llump+2)) then
        lseq = lq(llump-1)
        call utelem(lseq, iq(llump+3), iflag, elmnam, iocc, ienum)
        if (iq(lcelm+mbpr) .eq. mpelm) go to 1000
        go to 510
      endif

*---- Clear call bit.
      lcelm = lq(llump-2)
      call sbit0(iq(lcelm), mxlmp)

*---- Store length for current lump.
      call ucopy(dq(ils+2), q(lcelm+melen), mwflt)

*---- Return transform.
      arclen = dq(ils+1)
      elmlen = dq(ils+2)
      call ucopy(dq(ilv+1), ve, 3 * mwflt)
      call ucopy(dq(ilm+1), we, 9 * mwflt)

*---- Release working space and unstack.
      iwork = iq(llump+4)
      call lndrop(lq(llump-1))
      call mzdrop(0, llump, '.')
      if (llump .ne. 0) go to 500
  550 continue

      end
+dk suhead
      subroutine suhead(lines, nline, npage)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Conditionally print page header for survey.                        *
* Input:                                                               *
*   LINES     (integer) Number of lines to be printed.                 *
*   NLINE     (integer) Current line position on page.                 *
*   NPAGE     (integer) Current page number.                           *
*   LINNAM    (char)    Beam line name.                                *
*   RNGNAM    (char)    Range name.                                    *
*----------------------------------------------------------------------*
+ca aparam
+ca range
+ca zunit
      integer lenhed,lines,nline,npage
      double precision zero

      character*(*)     title

+ca maxlin
      parameter         (lenhed = 4, zero = 0.0d0)
      parameter         (title = 'Survey.')

      nline = nline + lines
      if (nline .gt. maxlin) then
        npage = npage + 1
        call prhead('SURVEY', title, zero, -1, nline, npage)
        nline = nline + lenhed + lines
        write (iqpr2, 910)
        call prline(iqpr2)
      endif

  910 format('       E L E M E N T   S E Q U E N C E       ',
     +       ' I            P O S I T I O N S            ',
     +       ' I               A N G L E S'/
     +       ' pos.  element occ.     sum(L)       arc     ',
     +       ' I     x             y             z       ',
     +       ' I     theta         phi           psi'/
     +       ' no.   name    no.      [m]          [m]     ',
     +       ' I     [m]           [m]           [m]     ',
     +       ' I     [rad]         [rad]         [rad]')

      end
+dk suiden
      subroutine suiden(v, w)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Set up identity transform for survey.                              *
* Output:                                                              *
*   V(3)      (real)    Displacement = 0.                              *
*   W(3,3)    (real)    Rotation = identity.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer i
      double precision v,w
      dimension         v(3), w(3,3)

      do 10 i = 1, 3
        v(i) = 0.
        w(i,1) = 0.
        w(i,2) = 0.
        w(i,3) = 0.
        w(i,i) = 1.
   10 continue

      end
+dk suline
      subroutine suline(ipos2, elmlen, arclen, vl, wl)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Compute Displacement and rotation for one element.                 *
* Input:                                                               *
*   IPOS2     (integer) Position of END in main beam line.             *
* Output:                                                              *
*   ELMLEN    (real)    Sum of nominal element lengths.                *
*   ARCLEN    (real)    Line length along design orbit.                *
*   VL(3)     (real)    Displacement of exit w.r.t. entry.             *
*   WL(3,3)   (real)    Rotation of exit w.r.t. entry.                 *
* Reference pointer used:                                              *
*   LCELM     /REFER/   Current line bank, or current element.         *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,ipos,ipos2,jdir,k
      double precision arc,arclen,el,elmlen,ve,vl,vt1,vt2,vt3,we,wl,
     +wt1k,wt2k,wt3k
      dimension         vl(3), wl(3,3)

+ca memdum
+ca bankhead
+ca prcgroup
+ca seqgroup
+ca refer

      dimension         ve(3), we(3,3)

*---- Initialize.
      elmlen = 0.0
      arclen = 0.0
      call suiden(vl, wl)
      idir = iq(lq(lcseq-msdir)+ipos2)

*---- Loop backwards over the line until its beginning is found.
      do 80 ipos = ipos2 - 1, 1, - 1
        jdir = iq(lq(lcseq-msdir)+ipos)
        if (jdir .eq. idir) go to 90
        lcelm = lq(ldbnk(3)-jdir)
        if (iq(lcelm+mbpr) .eq. mpelm) then
          call suelem(el, arc, ve, we)
          vt1 = ve(1) + we(1,1)*vl(1) + we(1,2)*vl(2) + we(1,3)*vl(3)
          vt2 = ve(2) + we(2,1)*vl(1) + we(2,2)*vl(2) + we(2,3)*vl(3)
          vt3 = ve(3) + we(3,1)*vl(1) + we(3,2)*vl(2) + we(3,3)*vl(3)
          vl(1) = vt1
          vl(2) = vt2
          vl(3) = vt3
          do 10 k = 1, 3
            wt1k = we(1,1)*wl(1,k) + we(1,2)*wl(2,k) + we(1,3)*wl(3,k)
            wt2k = we(2,1)*wl(1,k) + we(2,2)*wl(2,k) + we(2,3)*wl(3,k)
            wt3k = we(3,1)*wl(1,k) + we(3,2)*wl(2,k) + we(3,3)*wl(3,k)
            wl(1,k) = wt1k
            wl(2,k) = wt2k
            wl(3,k) = wt3k
   10     continue
          elmlen = elmlen + el
          arclen = arclen + arc
        endif
   80 continue

*---- Restore element pointer.
   90 continue
      lcelm = lq(ldbnk(3)-idir)

      end
+dk sumain
      subroutine sumain(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Switch routine (subprocess code) for survey section.               *
* Input:                                                               *
*   IPR       (integer) Process code.                                  *
*   ISP       (integer) Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca wstack
      integer ipr,isp

*---- User-defined services.
      if (isp .le. 0  .or.  isp .gt. 10) then
        call usercm(ipr, isp)

*---- SURVEY.
      else if (isp .eq. 1) then
        call survey
      endif

*---- Drop working space.
      iwork = 0
      nwork = 0
      call mzwork(0, dq(1), dq(1), - 1)

      end
+dk sumtrx
      subroutine sumtrx(the, phi, psi, w)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Given three survey angles, compute rotation matrix.                *
* Input:                                                               *
*   THE       (real)    Azimuthal angle.                               *
*   PHI       (real)    Elevation angle.                               *
*   PSI       (real)    Roll angle.                                    *
* Output:                                                              *
*   W(3,3)    (real)    Rotation matrix.                               *
*----------------------------------------------------------------------*
+ca aparam
      double precision cosphi,cospsi,costhe,phi,psi,sinphi,sinpsi,
     +sinthe,the,w
      dimension         w(3,3)

      costhe = cos(the)
      sinthe = sin(the)
      cosphi = cos(phi)
      sinphi = sin(phi)
      cospsi = cos(psi)
      sinpsi = sin(psi)
      w(1,1) = + costhe * cospsi - sinthe * sinphi * sinpsi
      w(1,2) = - costhe * sinpsi - sinthe * sinphi * cospsi
      w(1,3) =                     sinthe * cosphi
      w(2,1) =                              cosphi * sinpsi
      w(2,2) =                              cosphi * cospsi
      w(2,3) =                              sinphi
      w(3,1) = - sinthe * cospsi - costhe * sinphi * sinpsi
      w(3,2) = + sinthe * sinpsi - costhe * sinphi * cospsi
      w(3,3) =                     costhe * cosphi

      end
+dk survey
      subroutine survey
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Execute SURVEY command.                                            *
* Attributes, must be given in this order in the dictionary:           *
*   X0        (real)    Initial X position.                            *
*   Y0        (real)    Initial Y position.                            *
*   Z0        (real)    Initial Z position.                            *
*   THETA0    (real)    Initial azimuthal angle.                       *
*   PHI0      (real)    Initial elevation angle.                       *
*   PSI0      (real)    Initial roll angle.                            *
*   TFS       (logical) TFS option: TAPE in TFS format
*   TAPE      (logical) TAPE option: File name.                        *
*----------------------------------------------------------------------*
* Modified: 01-APR-1999, M. Woodley (SLAC)                             *
*   If we're doing tape file output and there are LCAVITY elements in  *
*   the current beamline, initialize ENER1 (in COMMON /OPTIC1/) using   *
*   ENERGY from BEAM common, and call TMLCAV for each one to update    *
*   ENERGY                                                             *
*----------------------------------------------------------------------*
+ca aparam
+ca bankhead
+ca seqflag
+ca seqgroup
+ca memdum
+ca message
+ca optic1
+ca range
+ca refer
+ca status
+ca zunit
+if doom
+ca dmcommon
+ei
+ca beam
      integer           isp
      logical           domap, anylcav, fmap
      double precision  el, orbt(6), ek(6), re(6,6), te(6,6,6)
      integer i,icode,idisk,ienum,iflag,ilnum,iocc,ipos,isup,jbit,
     +jbyt,k,l_seq,nline,npage,lastnb
      double precision a,arc,arclen,b,circ,cm,data,dist,dphi,dpsi,
     +dtheta,elmlen,phi,phi0,proxim,psi,psi0,rmax,rmin,sig,
     +sums,t,theta,theta0,tm,twopi,utwopi,v,v0,v1,v2,ve,w,w0,w1,w2,
     +we,tx

      logical           eflag,  fprt, tape
      character         elmnam*(mcnam), filnam*(mcfil)
      dimension         ve(3), v(3), v0(3), v1(3), v2(3), sig(3), cm(3)
      dimension         we(3,3), w(3,3), w0(3,3), w1(3,3), w2(3,3)
*   VE, WE              Current element.
*   V, W                Global position.
*   V0, W0              Initial global position.
*   V1, W1              One (half) superperiod.
*   V2, W2              Symmetric half of superperiod.
*   SIG                 Signs for reflection.
*   CM                  Centre of machine.
      dimension         data(6)
      equivalence       (v0(1), data(1)), (theta0, data(4))
      equivalence       (phi0,  data(5)), (psi0,   data(6))
*   tm  temporary centre
*   tx  closure error
      dimension         t(3), tm(3), tx(3)
      equivalence       (t(1), theta), (t(2), phi), (t(3), psi)
+ca maxlin
+ca pi
      parameter         (twopi = 2.0d0 * pi, utwopi = 1.0d0 / twopi)
      logical tfsf
+if doom
      integer j, lzero, ncsurv, ndelta
*   ts  centre + closure error
      double precision ts(mtwscol)
      integer positions(nsrv_col)
      character *(mcnam) prep_list(nsrv_col), surv_table(nsrv_col)
      double precision s_coord(nsrv_col, 2)
      equivalence (s_coord, optics_tb)
      logical selt
      data ts / mtwscol * 0.d0 /
      data surv_table / 'S', 'X', 'Y', 'Z', 'THETA', 'PHI', 'PSI' /
+ei
      proxim(a,b) = a + twopi * anint((b - a) * utwopi)

*---- Check main beam line, and retrieve its description.
      call lnchck('SURVEY', eflag)
      if (eflag) go to 9999
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Retrieve command attributes.
      do 10 i = 1, 6
        data(i) = 0.
   10 continue
      tfsf = .false.
      call utgflt(lccmd, 1, 6, data)

*---- Set up initial V and W.
      suml = 0.
      sums = 0.
      call sumtrx(theta0, phi0, psi0, w0)
      theta = theta0
      phi = phi0
      psi = psi0
      call sucopy(v0, w0, v, w)

+if doom
      filnam = ' '
      call utgstr(lccmd, 8, 8, filnam)
      tape = filnam .ne. ' '
      if (.not. strict)  then
+ei
*---- Initial disk output.
      call utglog(lccmd, 7, 7, tfsf)
      filnam = ' '
      call utgstr(lccmd, 8, 8, filnam)
      tape = .false.
      if (filnam .ne. ' ') then
        call flopen(filnam, 'SWFD', 0, 0, idisk, eflag)
        if (.not. eflag) then
          tape = .true.
          if (tfsf)  then
            call sutfsf(idisk)
          else
            call tphead(idisk, 'SURVEY')
            call tpelem('INITIAL', idisk)
            write (idisk, 810) v, suml, theta, phi, psi
          endif
          lcelm = 0
        endif
      endif
+if doom
      endif
+ei
*---- If we're doing tape file output, check for presence of LCAVITY
*     elements in current beamline ... if there are any, initialize
*     ENER1 (in COMMON /OPTIC1/) using the ENERGY value from BEAM common
*     and then call TMLCAV for each one to update ENER1 and ENERGY
      domap = (tape .and. anylcav())
      if (domap) ener1 = en0
*---- Clear counts.
      npage = 0
      nline = maxlin
      l_seq = 0
+if doom
      do i = 1, 3
        tm(i) = 0.d0
      enddo
+ei
*==== Print and storage loop.
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        if (lcelm .ne. 0) then
+if doom
          selt = jbit(iflag,moptc) .ne. 0
+ei
          fprt = jbit(iflag,mprnt) .ne. 0  .or.
     +           ipos .eq. irg1  .or.  ipos .eq. irg2
          icode = jbyt(iflag,1,mcode)
          if (icode .eq. 1) then
            call suelem(elmlen, arclen, ve, we)
            suml = suml + elmlen
            sums = sums + arclen
            call sutrak(v, w, ve, we)
            call suangl(w, theta, phi, psi)
+if doom
            do i = 1, 3
              tm(i) = tm(i) + v(i)
            enddo
            if (tape .and. selt) then
              l_seq = l_seq + 1
              elm_nam(l_seq) = elmnam
              occt(l_seq) = iocc
              s_coord(1, l_seq) = suml
              do j = 1, 3
                s_coord(j+1, l_seq) = v(j)
                s_coord(j+4, l_seq) = t(j)
              enddo
            endif
            if (.not. strict)  then
+ei
            if (tape) then
              if (domap) then
                isp = iq(lcelm+mbsp)
                if (isp .eq. 27) call tmlcav(.false., .false.,
     +            orbt, fmap, el, ek, re, te)
              endif
              if (tfsf)  then
                write
     +          (idisk, '(''  "'',a,''"'',t21,i5,1p,8e18.10)')
     +          elmnam(:lastnb(elmnam)), iocc,
     +                           suml, sums, v, theta, phi, psi
              else
                call tpelem(elmnam, idisk)
                write (idisk, 810) v, suml, theta, phi, psi
              endif
            endif
+if doom
            endif
+ei
          endif
*---- Print, if print flag set, or if at limit of range.
          if (fprt) then
            call suhead(1, nline, npage)
            if (icode .eq. 1) then
              write (iqpr2, 910) ienum, elmnam, iocc,
     +                           suml, sums, v, theta, phi, psi
            else if (icode .eq. 2) then
              write (iqpr2, 920) elmnam, iocc,
     +                           suml, sums, v, theta, phi, psi
            else
              write (iqpr2, 930) elmnam, iocc,
     +                           suml, sums, v, theta, phi, psi
            endif
          endif
        endif
   90 continue

*==== Trailer record.
*     Refer (half) superperiod to initial local system.
      do 120 i = 1, 3
        cm(i) = v0(i)
        v1(i) = w0(1,i) * (v(1) - v0(1))
     +        + w0(2,i) * (v(2) - v0(2))
     +        + w0(3,i) * (v(3) - v0(3))
        do 110 k = 1, 3
          w1(i,k) = w0(1,i)*w(1,k) + w0(2,i)*w(2,k) + w0(3,i)*w(3,k)
  110   continue
  120 continue
      circ = suml
      arc = sums
      ilnum = 1

*---- Make symmetric half superperiod.
      if (symm) then
        sig(1) = 1.
        sig(2) = 1.
        sig(3) = - 1.
        do 140 i = 1, 3
          v2(i) = - sig(i) * (w1(1,i)*v1(1)+w1(2,i)*v1(2)+w1(3,i)*v1(3))
          do 130 k = 1, 3
            w2(i,k) = sig(k) * w1(k,i) * sig(i)
  130     continue
  140   continue

*---- Track to end of superperiod.
        call sutrak(v, w, v2, w2)
        call suangl(w, theta, phi, psi)
        circ = suml + suml
        arc = sums + sums
        ilnum = 2
        call suhead(1, nline, npage)
        write (iqpr2, 930) elmnam, ilnum, circ, arc, v, theta, phi, psi
      endif

*---- Only 1 superperiod?
      if (nsup .le. 1) then
        do i = 1, 3
          tx(i) = v(i) - v0(i)
          if (l_seq .gt. 0)  tm(i) = tm(i) / l_seq
        enddo
        dtheta = theta - proxim(theta0, theta)
        dphi = phi - proxim(phi0, phi)
        dpsi = psi - proxim(psi0, psi)
        write (iqpr2, 940)
        call suhead(5, nline, npage)
        write (iqpr2, 950) circ, arc
        write (iqpr2, 970) tx, dtheta, dphi, dpsi
        write (iqpr2, 940)
+if doom
        if (.not. strict)  then
+ei
        if (tape)  then
          if (tfsf)  then
            write (idisk, '(''@ CIRCUM'',t21,''%e  '',1p,e18.10)')
     +      circ
          else
            write (idisk, 820) circ
          endif
        endif
+if doom
        endif
        ts(1) = circ
        do i = 1, 3
          ts(i+1) = tm(i)
          ts(i+4) = t(i)
        enddo
+ei
*---- Deal with other superperiods.
      else
        do 190 isup = 2, nsup
          cm(1) = cm(1) + v(1)
          cm(2) = cm(2) + v(2)
          cm(3) = cm(3) + v(3)
          call sutrak(v, w, v1, w1)
          call suangl(w, theta, phi, psi)
          circ = circ + suml
          arc = arc + sums
          ilnum = ilnum + 1
          call suhead(1, nline, npage)
          write (iqpr2, 930) elmnam, ilnum, circ, arc, v, theta,phi,psi

*---- Symmetric half of superperiod.
          if (symm) then
            call sutrak(v, w, v2, w2)
            call suangl(w, theta, phi, psi)
            circ = circ + suml
            arc = arc + sums
            ilnum = ilnum + 1
            call suhead(1, nline, npage)
            write (iqpr2, 930) elmnam, ilnum, circ, arc,
     +                         v, theta, phi, psi
          endif
  190   continue

*---- Centre of machine.
        do i = 1, 3
          cm(i) = cm(i) / float(nsup)
          tx(i) = v(i) - v0(i)
        enddo
        dtheta = theta - proxim(theta0, theta)
        dphi = phi - proxim(phi0, phi)
        dpsi = psi - proxim(psi0, psi)

*---- Minimum and maximum radius.
        do 220 i = 1, 3
          v(i) = v0(i)
          do 210 k = 1, 3
            w(i,k) = w0(i,k)
  210     continue
  220   continue
        rmin = sqrt((v(1)-cm(1))**2+(v(2)-cm(2))**2+(v(3)-cm(3))**2)
        rmax = rmin
        do 300 ipos = irg1, irg2
          call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
          if (lcelm .ne. 0) then
            if (jbyt(iflag,1,mcode) .eq. 1) then
              call suelem(elmlen, arclen, ve, we)
              call sutrak(v, w, ve, we)
              dist = sqrt((v(1)-cm(1))**2+(v(2)-cm(2))**2+
     +                    (v(3)-cm(3))**2)
              rmin = min(rmin, dist)
              rmax = max(rmax, dist)
            endif
          endif
  300   continue
        write (iqpr2, 940)
        call suhead(6, nline, npage)
        write (iqpr2, 950) circ, arc
        write (iqpr2, 960) cm, rmin, rmax
        write (iqpr2, 970) tx, dtheta, dphi, dpsi
        write (iqpr2, 940)
+if doom
        ts(1) = circ
        do i = 1, 3
          ts(i+1) = cm(i)
          ts(i+4) = 0.d0
        enddo
        if (.not. strict)  then
+ei
        if (tape) then
          if (tfsf)  then
            write (idisk, '(''@ CENTRE'',t21,1p,3(''%e  '',e18.10))')
     +      cm
            write (idisk,
     +      '(''@ RMIN,RMAX,CIRC'',t21,1p,3(''%e  '',e18.10))')
     +      rmin, rmax, circ
          else
            write (idisk, 830) cm, rmin, rmax, circ
          endif
        endif
+if doom
        endif
+ei
      endif
+if doom
      if (tape .and. l_seq .gt. 0)  then
*--- put into doom
        if (lcseq .gt. 0)  then
          call uhtoc(q(lcseq+msbn), mcwrd, seqname, mcnam)
        else
          seqname = ' '
        endif
        ndelta = 1
        pos_flag = 3
        ncsurv = nsrv_col
        lzero = 0
        call doom_setvar('twiss_count ', lzero)
        call doom_prtab(surv_table, ncsurv, mcnam, prep_list,
     +  positions)
        call doom_pthead(filnam, seqname, ndelta, l_seq,
     +  mtwscol, ts, ncsurv, pos_flag, prep_list, positions)
        call doom_ptbody(filnam, seqname, ncsurv, l_seq,
     +                   mcnam, elm_nam, occt, s_coord)
      endif
+ei
+if doom
      if (.not. strict)  then
+ei
*---- Summary record on "tape".
      if (tape) then
        call flclos(idisk, error)
        if (.not. error) then
          call flname(idisk, filnam)
          msg(1) = 'Output written on file: ' // filnam
          call aainfo('SURVEY', 1, msg)
        endif
      endif
+if doom
      endif
+ei
  810 format(1p,4e16.9/3e16.9)
  820 format(48x/32x,1p,e16.9)
  830 format(1p,3e16.9/3e16.9)
  910 format(' ',i5,' ',a8,i4,2f13.6,f15.6,2f14.6,f15.6,2f14.6)
  920 format(' begin ',a8,i4,2f13.6,f15.6,2f14.6,f15.6,2f14.6)
  930 format(' end   ',a8,i4,2f13.6,f15.6,2f14.6,f15.6,2f14.6)
  940 format(' ',13('----------'))
  950 format( 1x,'total length =',f18.6,10x,'arc length   =',f18.6)
  960 format( 1x,'x(centre)    =',f18.6,10x,'y(centre)    =',f18.6,
     +       10x,'z(centre)    =',f18.6/
     +        1x,'r(min)       =',f18.6,10x,'r(max)       =',f18.6)
  970 format( 1x,'error(x)     =',e22.6, 6x,'error(y)     =',e22.6,
     +        6x,'error(z)     =',e22.6/
     +        1x,'error(theta) =',e22.6, 6x,'error(phi)   =',e22.6,
     +        6x,'error(psi)   =',e22.6)

 9999 end
+dk sutfsf
      subroutine sutfsf(idisk)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*     writes survey TFS out file header
* Input:  idisk (integer)  unit number
*----------------------------------------------------------------------*
      integer k, idisk, lastnb
+ca header
      character * (68) form11, form12, form21, form22
      character * (160) form
      character * 8 tmp
      data form11, form12 /
     +'(''* NAME'',t21,''OCC'',t26,''S'',t44,''S_ARC'',t62,''X'',t80,',
     +'''Y'',t98,''Z'',t116,''THETA'',t134,''PHI'',t152,''PSI'')' /
      data form21, form22 /
     +'(''$ %16s'',t21,''%hd'',t26,''%e'',t44,''%e'',t62,''%e'',t80,',
     +'''%e'',t98,''%e'',t116,''%e'',t134,''%e'',t152,''%e'')' /
      form = form11 // form12
      write (idisk, form)
      form = form21 // form22
      write (idisk, form)
      write (idisk, '(''@ TYPE'',t21,''%08s "SURVEY"'')')
      write (idisk, '(''@ ORIGIN'',t21,''%07s "MAD-x"'')')
      write (idisk, '(''@ DATE'',t21,''%10s  "'',a,''"'')') cdate
      write (idisk, '(''@ TIME'',t21,''%10s  "'',a,''"'')') ctime
      tmp = '%  s'
      k = min(lastnb(ctitle)+2,80)
      write (tmp(2:3), '(i2.2)') k
      write (idisk, '(''@ COMMENT'',t21,a4, '' "'',a,''"'')')
     +tmp(:4), ctitle(:k)
      end
+dk sutran
      subroutine sutran(w, v, we)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Transform rotation W and displacement V from entrance to exit.     *
* Input:                                                               *
*   W(3,3)    (real)    Rotation matrix w.r.t. input system.           *
*   V(3)      (real)    Displacement w.r.t. input system.              *
*   WE(3,3)   (real)    Rotation matrix due to element.                *
* Output:                                                              *
*   W(3,3)    (real)    Rotation matrix w.r.t. output system.          *
*   V(3)      (real)    Displacement w.r.t. output system.             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,k
      double precision v,vt,w,we,wt
      dimension         w(3,3), v(3), we(3,3)

      dimension         wt(3,3), vt(3)

*---- VT := transpose(WE) * V;
*     WT := transpose(WE) * W;
      do 20 i = 1, 3
        vt(i) = we(1,i)*v(1) + we(2,i)*v(2) + we(3,i)*v(3)
        do 10 k = 1, 3
          wt(i,k) = we(1,i)*w(1,k) + we(2,i)*w(2,k) + we(3,i)*w(3,k)
   10   continue
   20 continue

*---- V := VT       [= transpose(WE) * V];
*     W := WT * WE  [= transpose(WE) * W * WE];
      do 40 i = 1, 3
        v(i) = vt(i)
        do 30 k = 1, 3
          w(i,k) = wt(i,1)*we(1,k) + wt(i,2)*we(2,k) + wt(i,3)*we(3,k)
   30   continue
   40 continue

      end
+dk sutrak
      subroutine sutrak(v, w, ve, we)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Update global position.                                            *
* Input:                                                               *
*   V(3)      (real)    Global displacement before element.            *
*   W(3,3)    (real)    Global rotation matrix before element.         *
*   VE(3)     (real)    Displacement due to element.                   *
*   WE(3,3)   (real)    Rotation due to element.                       *
* Output:                                                              *
*   V(3)      (real)    Global displacement after element.             *
*   W(3,3)    (real)    Global rotation matrix after element.          *
*----------------------------------------------------------------------*
+ca aparam
      integer i
      double precision v,ve,w,we,wt1,wt2,wt3
      dimension         v(3), w(3,3), ve(3), we(3,3)

      do 10 i = 1, 3
        v(i) = v(i) + w(i,1)*ve(1) + w(i,2)*ve(2) + w(i,3)*ve(3)
        wt1 = w(i,1)*we(1,1) + w(i,2)*we(2,1) + w(i,3)*we(3,1)
        wt2 = w(i,1)*we(1,2) + w(i,2)*we(2,2) + w(i,3)*we(3,2)
        wt3 = w(i,1)*we(1,3) + w(i,2)*we(2,3) + w(i,3)*we(3,3)
        w(i,1) = wt1
        w(i,2) = wt2
        w(i,3) = wt3
   10 continue

      end
+dk suuser
      subroutine suuser(elmlen, arclen, ve, we)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   This routine must be replaced to handle survey calculations for    *
*   user-defined elements (example see routine SUELEM).                *
*   It can safely assume that the survey data are set to identity.     *
* Output:                                                              *
*   ELMLEN    (real)    Nominal element length.                        *
*   ARCLEN    (real)    Element length along design orbit.             *
*   VE(3)     (real)    Displacement of exit w.r.t. entry.             *
*   WE(3,3)   (real)    Rotation of exit w.r.t. entry.                 *
* Reference pointer used:                                              *
*   LCELM               Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
+ca refer
      double precision arclen,elmlen,ve,we

      end
+dk suzzzz
+dk svaaaa
+dk svattr
      subroutine svattr(lbank, ilink, itype)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Format one attribute value for SAVE or VIEW command.               *
* Input:                                                               *
*   LBANK(1)  (pointer) Pointer to data bank.                          *
*   ILINK     (integer) Attribute number.                              *
*   ITYPE     (integer) Attribute type code.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer icase,icode,idata,idir,ilen,ilink,itype,ival,ls
      double precision rval
      integer           lbank(1)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca refer
+ca datatype

      character*(mcnam) name
      character*(mcstr)   string
      character*(mcrng) rngnam
      logical           lval

*---- Branch on data type.
*            NAM  INT  FLT  DEF  LOG  STR  LIN  RNG  CST  VAR
      go to (10,  20,  30,  30,  40,  50,  60,  70,  80,  90), itype
      go to 100

*---- Name.
   10 continue
        call utgnam(lbank, ilink, ilink, name)
        call svname(name)
      go to 100

*---- Integer.
   20 continue
        call utgint(lbank, ilink, ilink, ival)
        call svint(ival)
      go to 100

*---- Real or deferred expression.
   30 continue
        lcexp = lq(lbank(1)-ilink)
        if (lcexp .ne. 0) then
          call svexpr(lcexp)
        else
          call utgflt(lbank, ilink, ilink, rval)
          call svreal(rval)
        endif
      go to 100

*---- Logical.
   40 continue
        call utglog(lbank, ilink, ilink, lval)
        if (lval) then
          call svlitt('.TRUE.')
        else
          call svlitt('.FALSE.')
        endif
      go to 100

*---- String.
   50 continue
        call utgstr(lbank, ilink, ilink, string)
        idata = mbat + (ilink - 1) * mcsiz
        ilen = min(iq(lbank(1)+idata+mcval), mcstr)
        call svstrg(string(1:ilen))
      go to 100

*---- Beam line.
   60 continue
        idata = mbat + (ilink - 1) * mcsiz
        icase = iq(lbank(1)+idata+mctyp)
        idir  = iq(lbank(1)+idata+mcval)

*---- Anonymous line in parentheses.
        if (icase .eq. 10 * mtlin + 3) then
          lcatt = lq(ldbnk(3)-idir)
          call svlist(lcatt)

*---- Named beam line.
        else
          call diname(ldbnk, idir, name)
          call svname(name)

*---- Actual argument list.
          if (icase .eq. 10 * mtlin + 2) then
            lcatt = lq(lbank(1)-ilink)
            call svlist(lcatt)
          endif
        endif
      go to 100

*---- Place (range).
   70 continue
        call enrang(lq(lbank(1)-ilink), rngnam)
        call utleng(rngnam, ls)
        call svlitt(rngnam(1:ls))
      go to 100

*---- Constraint.
   80 continue
        lcatt = lq(lbank(1)-ilink)
        icode = iq(lcatt+2)
        if (icode .ne. 2) then
          if (icode .eq. 4) then
            call svlitt('=')
          else
            call svlitt('>')
          endif
          lcexp = lq(lcatt-1)
          if (lcexp .ne. 0) then
            call svexpr(lcexp)
          else
            call ucopy(q(lcatt+2+mcval), rval, mwflt)
            call svreal(rval)
          endif
        endif
        if (icode .eq. 2  .or.  icode .eq. 3) then
          call svlitt('<')
          lcexp = lq(lcatt-2)
          if (lcexp .ne. 0) then
            call svexpr(lcexp)
          else
            call ucopy(q(lcatt+2+mcsiz+mcval), rval, mwflt)
            call svreal(rval)
          endif
        endif
      go to 100

*---- Variable.
   90 continue
        lcvar = lq(lbank(1)-ilink)
        call svvref(lcvar)

*---- Common exit point.
  100 continue

      end
+dk svbank
      subroutine svbank(lbank)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save data for one data bank (element or command).                  *
* Input:                                                               *
*   LBANK(1)  (pointer) Bank pointer.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer icat,idata,ikat,iln,ipr,isp,itype,j1,j2,j3,ndim,nkat
      integer           lbank(1)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca keyword
+ca refer
+ca datatype

      character*(mcnam) label, class
      logical           doname

*---- Retrieve label and keyword definition.
      lcelm = lbank(1)
      lckey = lq(lcelm+1)
      call diname(ldbnk, iq(lcelm+mbnam), label)
      call kwget(lckey, iln, ipr, isp, nkat)
      call diname(ldkey, iq(lckey+mbnam), class)

*---- Class name.
      if (iq(lcelm+mbpr) .eq. mpelm) then
        if (iq(lcelm+mbsp) .eq. 1  .and.
     +      label(1:1) .eq. '['  .and.  label(8:) .eq. ']') then
          go to 9999
        endif
        lcsrc = lq(lcelm-iq(lcelm+mbat)-mbecls)
        if (lcsrc .ne. 0) then
          call diname(ldbnk, iq(lcsrc+mbnam), class)
        endif
      endif

*---- Save label and keyword.
      call svbegn
      if (label .ne. ' ') then
        call svname(label)
        call svlitt(': ')
      endif
      call svname(class)

*---- Loop over all attributes.
      idata = mbat
      icat  = 1
      do 90 ikat = 1, nkat
        itype  = iatype(ikat)
        doname = .true.

*---- Set dimension count.
        ndim = 0
        if (iadim1(ikat) .gt. 1) ndim = 1
        if (iadim2(ikat) .gt. 1) ndim = 2
        if (iadim3(ikat) .gt. 1) ndim = 3

*---- Loop over attribute's dimensions.
        do 80 j3 = 1, iadim3(ikat)
        do 80 j2 = 1, iadim2(ikat)
        do 80 j1 = 1, iadim1(ikat)

*---- Test for defined attribute value.
          if (mod(iq(lcelm+idata+mctyp),10) .ne. 0) then
            call svlitt(', ')

*---- Output name, if no previous value for the same attribute.
*     Special treatment for constraints: Name always written.
            if (doname  .or. itype .eq. mtcon) then
              call svname(katnam(ikat))

*---- Output indices, if attribute is dimensioned.
              if (ndim .ge. 1) then
                call svlitt('(')
                call svint(j1)
                if (ndim .ge. 2) then
                  call svlitt(',')
                  call svint(j2)
                  if (ndim .ge. 3) then
                    call svlitt(',')
                    call svint(j3)
                  endif
                endif
                call svlitt(')')
              endif
              if (itype .ne. mtcon) call svlitt('=')
            endif
            call svattr(lcelm, icat, itype)
            doname = .false.
          else
            doname = .true.
          endif
          idata = idata + mcsiz
          icat  = icat  + 1
   80   continue
   90 continue

      call svdump

 9999 end
+dk svbegn
      subroutine svbegn
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initialize buffer for SAVE or VIEW command.                        *
*----------------------------------------------------------------------*
+ca aparam
+ca savbuf

      isvbuf = 0

      end
+dk svcont
      subroutine svcont
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Output one line for SAVE or VIEW command, in view of continuation. *
*----------------------------------------------------------------------*
+ca aparam
+ca savbuf

      if (isvbuf .gt. 0) then
        isvbuf = isvbuf + 1
        savbuf(isvbuf:isvbuf) = '&'
        write (isave, '(A)') savbuf(1:isvbuf)
        isvbuf = 0
      endif

      end
+dk svdict
      subroutine svdict(lkey)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Encode a keyword bank for SAVE or VIEW command.                    *
* Input:                                                               *
*   LKEY(1)   (pointer) Pointer to keyword bank.                       *
*----------------------------------------------------------------------*
+ca aparam
      integer idata,ikat,iln,ipr,isp,itype,nkat
      integer           lkey(1)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca keyword
+ca refer

      character*10      types
      character*(mcnam) label

      data types        / 'NIRDLSBPCV' /

*---- Label and "keyword" to first line.
      call svbegn
      call diname(ldkey, iq(lkey(1)+mbnam), label)
      call svname(label)
      call svlitt(': ')
      call svname('KEYWORD')

*---- Retrieve keyword data.
      call kwget(lkey, iln, ipr, isp, nkat)

*---- Process and subprocess.
      call svlitt(', PR = ')
      call svint(ipr)
      call svlitt(', SP = ')
      call svint(isp)

*---- Loop over attributes.
      idata = mbat
      do 90 ikat = 1, nkat
        call svlitt(', ')
        call svcont
        call svname(katnam(ikat))
        call svlitt(' = (')
        itype = iatype(ikat)
        call svlitt(types(itype:itype))
        call svlitt('(')
        call svint(iadim1(ikat))

*---- Treat extra dimensions.
        if (iadim2(ikat) .gt. 1  .or.  iadim3(ikat) .gt. 1) then
          call svlitt(',')
          call svint(iadim2(ikat))
          if (iadim3(ikat) .gt. 1) then
            call svlitt(',')
            call svint(iadim3(ikat))
          endif
        endif
        call svlitt(')')

*---- Default value, if present.
        if (mod(iq(lq(lkey(1)-2)+idata+mctyp),10) .ne. 0) then
          call svlitt(', = ')
          lcdef = lq(lkey(1)-2)
          call svattr(lcdef, idata, iatype(ikat))
        endif

*---- Close group, continue if more.
        call svlitt(')')
   90 continue
      call svdump

      end
+dk svdump
      subroutine svdump
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Dump last line for SAVE or VIEW operation.                         *
*----------------------------------------------------------------------*
+ca aparam
+ca savbuf

      if (isvbuf .gt. 0) then
        write (isave, '(A)') savbuf(1:isvbuf)
        isvbuf = 0
      endif

      end
+dk svexpr
      subroutine svexpr(lexp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save complete expression.                                          *
* Input:                                                               *
*   LEXP(1)   (pointer) Pointer to expression bank.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ioplev,iopr,iopr1,ip,jp,lp
      double precision rval
      integer           lexp(1)
+ca memdum
+ca expgroup
+ca exstak
+ca fundef
+ca refer

      integer           istack(maxstk), lstack(maxstk)
      character*4       cstack(maxstk)
      character*1       c1

*---- Expression limits excluding 'put'.
      level = 1
      istack(level) = 1
      lstack(level) = iq(lexp(1)-2)
      cstack(level) = '    '

*==== Procedure "save expression".
  100 continue
        ip = istack(level)
        lp = lstack(level)
        iopr = iq(lexp(1)+(lp-1)*mxsiz+mxop)

*---- Single operand?
        if (ip .eq. lp) then

*---- Reference.
          if (iopr .le. -2) then
            lcvar = lq(lexp(1)-ip)
            call svvref(lcvar)

*---- Constant.
          else if (iopr .eq. -1) then
            call ucopy(q(lexp(1)+(lp-1)*mxsiz+mxval), rval, mwflt)
            call svreal(rval)

*---- Argument-less function.
          else if (narg(iopr) .eq. 0) then
            call svname(funnam(iopr))
            call svlitt('()')

*---- Illegal item.
          else
            call aafail('SVEXPR', 1, 'Invalid expression seen:')
            call exdump(lexp)
            go to 9999
          endif

*---- The last item (LP) must be an operator.
        else if (ip .lt. lp) then
          if (iopr .le. 0) then
            call aafail('SVEXPR', 1, 'Invalid expression seen:')
            call exdump(lexp)
            go to 9999

*---- Unary operator: Operand is (IP to LP-1).
          else if (narg(iopr) .eq. 1) then
            istack(level) = lp + 1
            if (level .ge. maxstk) go to 800
            level = level + 1
            istack(level) = ip
            lstack(level) = lp - 1
            cstack(level) = '    '
            c1 = funnam(iopr)(1:1)

*---- Unary plus or minus sign.
            if (c1 .eq. '-'  .or. c1 .eq. '+') then
              call svlitt(c1)

*---- Function name.
            else
              call svname(funnam(iopr))
            endif

*---- Write parentheses only if required.
            iopr1 = iq(lexp(1)+(lp-2)*mxsiz+mxop)
            if (ipre(iopr1) .le. ipre(iopr)) then
              call svlitt('(')
              cstack(level) = ')   '
            endif
            go to 100

*---- Binary operator: Search backward to find end of first operand.
          else if (narg(iopr) .eq. 2) then
            ioplev = 0
            do 110 jp = lp, ip, -1
              iopr = iq(lexp(1)+(jp-1)*mxsiz+mxop)
              if (iopr .le. 0) then
                ioplev = ioplev - 1
                if (ioplev .eq. 0) go to 120
              else if (narg(iopr) .eq. 2) then
                ioplev = ioplev + 1
              endif
  110       continue

*---- Operands not found.
            call aafail('SVEXPR', 1, 'Invalid expression seen:')
            call exdump(lexp)
            go to 9999

*---- Operands found: (IP to JP-1) and (JP to LP-1).
  120       continue
            istack(level) = lp + 1
            if (level .ge. maxstk) go to 800
            level = level + 1
            istack(level) = jp
            lstack(level) = lp - 1
            cstack(level) = '    '
            if (level .ge. maxstk) go to 800
            level = level + 1
            istack(level) = ip
            lstack(level) = jp - 1
            cstack(level) = '    '

*---- Binary operator: Deal with operator precedence to decide about ().
            iopr = iq(lexp(1)+(lp-1)*mxsiz+mxop)
            if (ifun(iopr) .eq. 1) then
              cstack(level)(2:2) = funnam(iopr)(1:1)
              iopr1 = iq(lexp(1)+(jp-2)*mxsiz+mxop)
              if (ipre(iopr1) .lt. ipre(iopr)) then
                call svlitt('(')
                cstack(level)(1:1) = ')'
              endif
              iopr1 = iq(lexp(1)+(lp-2)*mxsiz+mxop)
              call ucopy(q(lexp(1)+(lp-2)*mxsiz+mxval), rval, mwflt)
              if (ipre(iopr1) .le. ipre(iopr)  .or.
     +            iopr1 .eq. -1  .and.  rval .lt. 0.0) then
                cstack(level)(3:3) = '('
                cstack(level-1) = ')   '
              endif

*---- Function with two arguments.
            else
              call svname(funnam(iopr))
              call svlitt('(')
              cstack(level) = ',   '
              cstack(level-1) = ')   '
            endif
            go to 100
          endif
        endif

*---- End of expression: Unstack parentheses and/or operators.
        do 130 i = 1, 4
          c1 = cstack(level)(i:i)
          if (c1 .ne. ' ') then
            call svlitt(c1)
          endif
  130   continue
        level = level - 1
      if (level .gt. 0) go to 100
      go to 9999

*---- Stack overflow.
  800 continue
      call aafail('SVEXPR', 1, 'Expression stack overflow.')

 9999 end
+dk svhelp
      subroutine svhelp
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Help on command keywords.                                          *
* Attribute:                                                           *
*   KEYWORD   (name)    Keyword to be shown (blank: list all keywords).*
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca keyword
+ca refer
+ca savbuf
+ca zunit
      integer i,ikey,iln,ipr,isp,j,lbank,lkey,n,nkat,nkey

      character*(mcnam) key, name(8)
      character*12      kattyp(10)

      data kattyp
     +  / 'name',       'integer',    'real',       'deferred',
     +    'logical',    'string',     'beamline',   'range',
     +    'constraint', 'variable' /

*---- Retrieve keyword name.
      key = ' '
      call utgnam(lccmd, 1, 1, key)

*---- Blank keyword: list all known keywords in alphabetical order.
      if (key .eq. ' ') then
        write (iqlog, 910)
        n = 0
        do 10 i = 1, iq(ldkey(3)+1)
          j = iq(ldkey(1)+i)
          n = n + 1
          call diname(ldkey, j, name(n))
          if (n .ge. 8) then
            write (iqlog, 920) name
            n = 0
          endif
   10   continue
        write (iqlog, 920) (name(i), i = 1, n)
        write (iqlog, 930)

*---- Otherwise find keyword and show its attributes.
      else
        call utleng(key, nkey)
        call difind(ldkey, key(1:nkey), ikey, lkey)
        if (ikey .eq. 0) then
          write (iqlog, 940) key
        else
          call kwget(lkey, iln, ipr, isp, nkat)
          write (iqlog, 950) key
          write (iqlog, 960) (katnam(j), kattyp(iatype(j)),
     +      iadim1(j), iadim2(j), iadim3(j), j = 1, nkat)
          isave = iqlog
          write (iqlog, 970)
          lbank = lq(lkey-2)
          call svbank(lbank)
        endif
      endif

  910 format(' '/' Known commands:')
  920 format(4('  ',a16))
  930 format(' Type "HELP, command" for help about "command".'/' ')
  940 format(' '/' Keyword "',a,'" is unknown.'/
     +       ' Type "HELP" to list known commands.'/' ')
  950 format(' '/' Command: ',a/
     +       ' Attribute        type      dimension ',4x,
     +       ' Attribute        type      dimension ')
  960 format(' ',a16,' ',a10,'(',i2,',',i2,',',i2,')',
     +        5x,a16,' ',a10,'(',i2,',',i2,',',i2,')')
  970 format(' Default values used for attribute name without value:')

      end
+dk svint
      subroutine svint(ival)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Format an integer value for SAVE of VIEW command.                  *
* Input:                                                               *
*   IVAL      (integer) Value to be written.                           *
*----------------------------------------------------------------------*
+ca aparam
+ca savbuf
      integer ival,js,ns

      character*10      string

*---- Encode integer.
      write (string, '(I10)') ival

*---- Save number string.
      do 10 js = 1, 10
        if (string(js:js) .ne. ' ') go to 20
   10 continue
   20 continue
      ns = 11 - js
      if (isvbuf + ns .gt. 78) call svcont
      savbuf(isvbuf+1:isvbuf+ns) = string(js:10)
      isvbuf = isvbuf + ns

      end
+dk svline
      subroutine svline(lbank)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save beam line or replacement list definition.                     *
* Input:                                                               *
*   LBANK(1)  (pointer) Pointer to data bank.                          *
*   ILINK     (integer) Attribute number.                              *
*----------------------------------------------------------------------*
+ca aparam
      integer isp,jform,lform
      double precision half,one,zero
      integer           lbank(1)
+ca memdum
+ca bankhead
+ca refer
+ca datatype

      character*(mcnam) frmnam, linnam, refnam
      parameter         (zero = 0.0d0, half = 0.5d0, one = 1.0d0)

*---- Name of line or list.
      call diname(ldbnk, iq(lbank(1)+mbnam), linnam)
      call svbegn
      call svname(linnam)

*---- Beam line: Formal arguments, if present.
*     Skip dummy line names created for anonymous lists.
      isp = iq(lbank(1)+mbsp)
      if (isp .eq. 1  .and.  linnam(1:5) .ne. '*LIN.') then
        lform = lq(lbank(1)-1)
        if (lform .ne. 0) then
          do 10 jform = 1, iq(lform-1), mwnam
            if (jform .eq. 1) then
              call svlitt('(')
            else
              call svlitt(', ')
            endif
            call uhtoc(q(lform+jform), mcwrd, frmnam, mcnam)
            call svname(frmnam)
   10     continue
          call svlitt(')')
        endif

*---- LINE keyword.
        call svlitt(': LINE=')
        call svlist(lbank)
        call svdump

*---- Beam sequence: SEQUENCE keyword.
      else if (isp .eq. 2) then
        call svlitt(': SEQUENCE, REFER=')
        refnam = 'CENTRE'
        call utgnam(lbank, 1, 1, refnam)
        call svname(refnam)
        call svdump
        call svseq(lbank)

*---- Replacement list: LIST keyword.
      else if (isp .eq. 3) then
        call svlitt(': LIST=')
        call svlist(lbank)
        call svdump
      endif

      end
+dk svlist
      subroutine svlist(llist)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save beam line list of replacement list.                           *
* Input:                                                               *
*   LLIST(1)  (pointer) Pointer to list bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer iact,icell,idir,iform,ihead,irep
      integer           llist(1)
+ca memdum
+ca bankhead
+ca lingroup
+ca refer

      character*(mcnam) name

      icell = 0
      ihead = iq(llist(1)+mlhd)

*---- Procedure "save list".
  100 continue
      iq(llist(1)+ihead+mlref) = icell
      icell = iq(llist(1)+ihead+mlnxt)
      call svlitt('(')

*---- Repetition count.
  200 continue
      irep = iq(llist(1)+icell+mlrep)
      if (irep .lt. 0) then
        call svlitt('-')
        irep = - irep
      endif
      if (irep .ne. 1) then
        call svint(irep)
        call svlitt('*')
      endif

*---- Sublist reference.
      if (iq(llist(1)+icell+mltyp) .eq. 4) then
        ihead = iq(llist(1)+icell+mlref)
        if (ihead .gt. iq(llist(1)+mlf2)) go to 100
        iform = ((ihead - iq(llist(1)+mlf1)) / (2 * mlsiz)) * mwnam
        call uhtoc(q(lq(llist(1)-1)+iform+1), mcwrd, name, mcnam)
        call svname(name)

*---- Name reference.
      else
        idir = iq(llist(1)+icell+mlref)
        call diname(ldbnk, idir, name)
        call svname(name)

*---- Actual arguments, if present.
        iact = iq(llist(1)+icell+mlact)
        if (iact .ne. 0) then
          ihead = iact
          go to 100
        endif
      endif

*---- Go to next list member.
  300 continue
      icell = iq(llist(1)+icell+mlnxt)
      if (iq(llist(1)+icell+mltyp) .ge. 4) then
        call svlitt(',')
        go to 200
      endif
      call svlitt(')')

*---- End of procedure "save list".
      ihead = icell
      icell = iq(llist(1)+ihead+mlref)
      iq(llist(1)+ihead+mlref) = 0
      if (icell .ne. 0) go to 300

      end
+dk svlitt
      subroutine svlitt(string)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Format an string for SAVE or VIEW command.                         *
* Input:                                                               *
*   STRING    (char)    String to be output.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer len,ns
      character*(*)     string
+ca savbuf

      ns = len(string)
      if (isvbuf + ns .ge. 78) call svcont
      savbuf(isvbuf+1:isvbuf+ns) = string
      isvbuf = isvbuf + ns

      end
+dk svmain
      subroutine svmain
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save selected part(s) of structure; SAVE command.                  *
* Attribute:                                                           *
*   FILENAME  (string)  Name of file to be written.                    *
*   PATTERN   (char)    Pattern to be matched (default all).           *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca prcgroup
+ca strgroup
+ca message
+ca header
+ca refer
+ca savbuf
+ca zunit
      integer idir,ipr,isp,jdir

      logical           dosave, eflag
      character*(mcfil) filnam*(mcfil), label*(mcnam), patt*(mcstr)

*---- File name.
      filnam = 'save'
      call utgstr(lccmd, 1, 1, filnam)

*---- Fetch patterns.
      patt = ' '
      call utgstr(lccmd, 2, 2, patt)
      if (patt .eq. ' ') then
        lref1 = 0
      else
        call utpatt(patt, lref1)
      endif

*---- Open SAVE file.
      call flopen(filnam, 'SWFD', 0, 0, isave, eflag)
      if (eflag) go to 9999

*---- Title.
      call flname(isave, filnam)
      if (ctitle .ne. ' ') write (isave, 910) ctitle
      write (isave, 920) cdate, ctime, filnam

*==== Save all definitions which are not part of the dictionary.
      dosave = .true.

*---- Pass 1: Save element definitions.
      do 10 idir = iq(ldbnk(3)+3) + 1, iq(ldbnk(3)+1)
        lccls = lq(ldbnk(3)-idir)
        if (lccls .ne. 0) then
          ipr   = iq(lccls+mbpr)
          jdir  = iq(lccls+mbnam)
          if (ipr .eq. mpelm  .and.  jdir .eq. idir  .and.
     +        lccls .ne. lq(lq(lccls+1)-3)) then
            call diname(ldbnk, idir, label)
            if (lref1 .ne. 0) call utmtpt(lref1, label, dosave)
            if (dosave) call svbank(lccls)
          endif
        endif
   10 continue

*---- Pass 2: Save beam lines and sequences.
      do 20 idir = iq(ldbnk(3)+3) + 1, iq(ldbnk(3)+1)
        lccls = lq(ldbnk(3)-idir)
        if (lccls .ne. 0) then
          ipr = iq(lccls+mbpr)
          isp = iq(lccls+mbsp)
          if (ipr .eq. mplin) then
            call diname(ldbnk, idir, label)
            if (lref1 .ne. 0) call utmtpt(lref1, label, dosave)
            if (dosave) call svline(lccls)
          endif
        endif
   20 continue

*---- Pass 3: Save parameter definitions.
      do 30 idir = iq(ldbnk(3)+3) + 1, iq(ldbnk(3)+1)
        lccls = lq(ldbnk(3)-idir)
        if (lccls .ne. 0) then
          ipr = iq(lccls+mbpr)
          if (ipr .eq. mppar) then
            call diname(ldbnk, idir, label)
            if (lref1 .ne. 0) call utmtpt(lref1, label, dosave)
            if (dosave) call svparm(lccls)
          endif
        endif
   30 continue

*---- End of save.
      write (isave, 930)
      call flclos(isave, eflag)
      if (.not. eflag) then
        msg(1) = 'Definitions saved on file: ' // filnam
        call aainfo('SVMAIN', 1, msg)
      endif

*---- Drop the pattern.
      if (lref1 .ne. 0) then
        call mzdrop(0, lref1, 'L')
      endif

  910 format('TITLE &'/'"',a77,'"'/'!')
  920 format('! DATE AND TIME: ',t21,a,2x,a/'!'/'! FILE:',t21,a/'!')
  930 format('RETURN !')

 9999 end
+dk svname
      subroutine svname(name)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save a name for SAVE or VIEW command.                              *
*   Also treats labels with special characters.                        *
* Input:                                                               *
*   NAME      (char)    Name to be written.                            *
*----------------------------------------------------------------------*
+ca aparam
      integer ichar,index,js,ks,ls,mc,ns
      character*(mcnam) name
+ca chcode
+ca savbuf

      logical           quotes
      character*1       c1
      parameter         (mc = 2 * mcnam)
      character*(mc)    string

*---- Normal name, or special character at start?
      quotes = ichtyp(ichar(name(1:1))) .ne. 10
      string(1:1) = name(1:1)

*---- Loop through characters of name, inserting escapes as needed.
      ls = 1
      ns = 1
      call utleng(name, ks)
      do 10 js = 2, ks
        c1 = name(js:js)
        if (ichtyp(ichar(c1)).gt.10 .and. index('.''_', c1).eq.0) then
          quotes = .true.
        endif
        ls = ls + 1
        string(ls:ls) = c1
        if (c1 .eq. '"') then
          ls = ls + 1
          string(ls:ls) = c1
        endif
        if (c1 .ne. ' ') ns = ls
   10 continue

*---- New line if near end - don't break within quotes.
      if (isvbuf + ns .gt. 76) call svcont
      if (quotes) then
        isvbuf = isvbuf + 1
        savbuf(isvbuf:isvbuf) = '"'
      endif
      savbuf(isvbuf+1:isvbuf+ns) = string(1:ns)
      isvbuf = isvbuf + ns
      if (quotes) then
        isvbuf = isvbuf + 1
        savbuf(isvbuf:isvbuf) = '"'
      endif

      end
+dk svparm
      subroutine svparm(lbank)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save parameter definition.                                         *
* Input:                                                               *
*   LBANK(1)  (pointer) Pointer to parameter definition bank.          *
*----------------------------------------------------------------------*
+ca aparam
      integer           lbank(1)
+ca memdum
+ca bankhead
+ca refer
+ca datatype

      character*(mcnam) parnam

*---- Constant or parameter.
      if (iq(lbank(1)+mbsp) .ne. 3) then
        call svbegn
        call diname(ldbnk, iq(lbank(1)+mbnam), parnam)
        call svname(parnam)
        if (iq(lbank(1)+mbsp) .eq. 1) then
          call svlitt(': CONSTANT = ')
        else if (iq(lbank(1)+mbsp) .eq. 2) then
          call svlitt(' := ')
        endif
        call svattr(lbank, 1, mtflt)
        call svdump

*---- Plot variable.
      else
        call svbank(lbank)
      endif

      end
+dk svreal
      subroutine svreal(rval)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Format a real value for SAVE or VIEW command.                      *
* Input:                                                               *
*   RVAL      (real)    Value to be written.                           *
*----------------------------------------------------------------------*
+ca aparam
+ca savbuf
      integer iexp,js,ls,ns
      double precision rval,ten

      character*25      string
      character*5       expo
      parameter         (ten = 10.0d0)

*---- Special case for zero.
      if (rval .eq. 0.0) then
        call svlitt('0.0')

*---- Is scaling required?
      else
        if (abs(rval) .lt. 100.0  .and.  abs(rval) .gt. 0.01) then
          iexp = 0
        else
          iexp = log10(abs(rval))
          rval  = rval * ten**(-iexp)
        endif
        write (string(1:20), '(F20.12)') rval

*---- Drop trailing zeros.
        do 10 ls = 20, 10, -1
          if (string(ls:ls) .ne. '0') go to 20
   10   continue
        ls = 9
   20   continue

*---- Append exponent, if non-zero.
        if (iexp .ne. 0) then
          write (expo, '(''E'',I4)') iexp
          string(ls+1:ls+5) = expo
          ls = ls + 5
        endif

*---- Save number string.
        ns = 0
        do 40 js = 1, ls
          if (string(js:js) .ne. ' ') then
            ns = ns + 1
            string(ns:ns) = string(js:js)
          endif
   40   continue
        if (isvbuf + ns .gt. 78) call svcont
        savbuf(isvbuf+1:isvbuf+ns) = string(1:ns)
        isvbuf = isvbuf + ns
      endif

      end
+dk svseq
      subroutine svseq(lbank)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save a beam line sequence. SAVE or VIEW command.                   *
* Input:                                                               *
*   LBANK(1)  (pointer) Pointer to sequence bank.                      *
*----------------------------------------------------------------------*
+ca aparam
      integer idata,idir,ipos
      double precision pos
      integer           lbank(1)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca refer
+ca datatype

      character*(mcnam) label, class

*---- Loop on sequence list.
      idata = mbat + mcsiz + 2
      do 100 ipos = 2, iq(lq(lbank(1)-1)+1)
        idir = iq(lq(lbank(1)-1)+ipos)
        call diname(ldbnk, idir, label)
        idir = iq(lq(ldbnk(3)-idir)+mbnam)
        call diname(ldbnk, idir, class)
        call svbegn
        call svlitt('   ')
        call svname(label)
        call svlitt(': ')
        call svname(class)
        call svlitt(', AT=')
        if (lq(lbank(1)-ipos) .ne. 0) then
          call svattr(lbank(1), ipos, mtflt)
        else
          call ucopy(q(lbank(1)+idata), pos, mwflt)
          call svreal(pos)
        endif
        call svdump
        idata = idata + mwflt
  100 continue

*---- End of sequence.
      call svbegn
      call svlitt('ENDSEQUENCE')
      call svdump

      end
+dk svshow
      subroutine svshow
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Show definitions.                                                  *
* Attribute:                                                           *
*   COMMAND   (name)    Command to be shown (blank: list all commands).*
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca prcgroup
+ca refer
+ca savbuf
+ca zunit
      integer i,icmd,j,l,lcmd,n,ncmd

      character*(mcnam) label, name(8)

*---- Retrieve command name.
      label = ' '
      call utgnam(lccmd, 1, 1, label)

*---- Blank command: list all known commands in alphabetical order.
      if (label .eq. ' ') then
        write (iqlog, 910)
        n = 0
        do 10 i = 1, iq(ldbnk(3)+1)
          j = iq(ldbnk(1)+i)
          l = lq(ldbnk(3)-j)
          call diname(ldbnk, j, label)
          if (l .ne. 0  .and.  label .ne. ' ') then
            if (iq(l+mbpr) .ne. mpelm  .or. iq(l+mbsp) .ne. 1  .or.
     +          label(1:1) .ne. '['  .or.  label(8:) .ne. ']') then
              n = n + 1
              name(n) = label
              if (n .ge. 8) then
                write (iqlog, 920) name
                n = 0
              endif
            endif
          endif
   10   continue
        if (n .ne. 0) write (iqlog, 920) (name(i), i = 1, n)
        write (iqlog, 930)

*---- Otherwise find command and show its attributes.
      else
        call utleng(label, ncmd)
        call difind(ldbnk, label(1:ncmd), icmd, lcmd)
        if (lcmd .eq. 0) then
          write (iqlog, 940) label
        else
          isave = iqlog
          if (iq(lcmd+mbpr) .eq. mppar) then
            write (iqlog, 950) label
            call svparm(lcmd)
          else if (iq(lcmd+mbpr) .eq. mpelm) then
            write (iqlog, 950) label
            call svbank(lcmd)
          else if (iq(lcmd+mbpr) .eq. mplin) then
            write (iqlog, 950) label
            call svline(lcmd)
          else if (iq(lcmd+mbpr) .eq. mpsub) then
            write (iqlog, 950) label
            call svsubr(lcmd)
          else
            write (iqlog, 960) label
            call svbank(lcmd)
          endif
        endif
      endif

  910 format(' '/' Known commands and definitions:')
  920 format(4('  ',a16))
  930 format(' Type "SHOW, name" for information about "name".')
  940 format(' '/' Name "',a,'" is unknown.'/
     +       ' Type "SHOW" to list known names.'/' ')
  950 format(' '/' Definition: ',a)
  960 format(' '/' Command: ',a)

      end
+dk svslin
      subroutine svslin
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Build beam line from range selected in USE command.                *
* Input:                                                               *
*   LBANK(1)  (pointer) Pointer to data bank.                          *
*   ILINK     (integer) Attribute number.                              *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca prcgroup
+ca seqgroup
+ca header
+ca range
+ca refer
+ca savbuf
+ca status
+ca wstack
+ca datatype
      integer idir,idrft,iline,ipos,ipos1,ipos2,jbit,jdir,l,maxnum,
     +mxuse,ndrft,nline
      double precision rval,tol

      parameter         (maxnum = 250, mxuse = 10)
      parameter         (tol = 1.0d-8)

      character*(mcnam) elmnam
      character*(mcfil) filnam
      logical           seen

*---- Check main beam line.
      call lnchck('SAVELINE', error)
      if (error) go to 9999

*---- Retrieve beam line descripbbtion.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Name of line (default is main line name).
      call utgnam(lccmd, 1, 1, linnam)

*---- File name.
      filnam = 'line'
      call utgstr(lccmd, 2, 2, filnam)
      call flopen(filnam, 'SWFD', 0, 0, isave, error)
      if (.not. error) then

*---- Reserve working storage for drift lengths.
        nwork = 100
        call mzwork(0, dq(1), dq(nwork+1), -1)

*---- Phase 1: Save beam line by pieces.
        write (isave, '(''! Snapshot date: '',A,'' Time: '',A/1X)')
     +    cdate, ctime
        write (isave, '(''! Beam lines from SAVELINE command:''/1X)')
        nline = 0
        ndrft = 0

        do 50 ipos1 = irg1, irg2, maxnum
          nline = nline + 1
          write (elmnam, '(''L'',I6.6)') nline
          call svbegn
          call svname(elmnam)
          call svlitt(': LINE = (')
          ipos2 = min(ipos1+maxnum-1,irg2)
          seen = .false.
          do 40 ipos = ipos1, ipos2
            idir = iq(lsdir+ipos)
            lcelm = lq(ldbnk(3)-idir)
            if (iq(lcelm+mbpr) .eq. mpelm) then
              call diname(ldbnk, iq(lcelm+mbnam), elmnam)

*---- Not a generated drift space.
              if (elmnam(1:1).ne.'[' .or. elmnam(8:8).ne.']') then
                if (seen) call svlitt(', ')
                seen = .true.
                call svname(elmnam)
*---- Mark all superclasses of this element for output.
   10           if (lcelm .ne. 0) then
                  call sbit1(iq(lcelm), mxuse)
                  lcelm = lq(lcelm)
                  go to 10
                endif

*---- A generated drift space.
*     Set up table of different lengths.
              else
                call ucopy(q(lcelm+melen), rval, mwflt)
                if (abs(rval) .gt. tol) then
                  do 20 idrft = 1, ndrft
                    if (abs(dq(idrft) - rval) .lt. tol) go to 30
   20             continue

*---- No equal drift found.
                  ndrft = ndrft + 1
                  idrft = ndrft
                  if (ndrft .gt. nwork) then
                    nwork = nwork + 100
                    call mzwork(0, dq(1), dq(nwork+1), -1)
                  endif
                  dq(ndrft) = rval

*---- Output the drift number.
   30             continue
                  write (elmnam, '(''D'',I6.6)') idrft
                  if (seen) call svlitt(', ')
                  seen = .true.
                  call svname(elmnam)
                endif
              endif
            endif
   40     continue
          call svlitt(')')
          call svdump
          write (isave, '(1X)')
   50   continue

*---- Phase 2: Combine sublines.
        call svbegn
        call svname(linnam)
        call svlitt(': LINE = (')
        do 60 iline = 1, nline
          write (elmnam, '(''L'',I6.6)') iline
          call svname(elmnam)
          if (iline .lt. nline) call svlitt(',')
   60   continue
        call svlitt(')')
        call svdump

*---- Phase 3: Save all referred element definitions,
*     excluding generated drift spaces.
        write (isave, '(1X/''! Element definitions:''/1X)')
        do 70 idir = iq(ldbnk(3)+3) + 1, iq(ldbnk(3)+1)
          lcelm = lq(ldbnk(3)-idir)
          if (lcelm .ne. 0  .and.
     +        iq(lcelm+mbpr) .eq. mpelm  .and.
     +        iq(lcelm+mbsp) .ne. 1  .or.
     +        jbit(iq(lcelm),mxuse) .ne. 0) then
            jdir = iq(lcelm+mbnam)
            iq(lcelm+mbnam) = idir
            call svsnap(lcelm)
            iq(lcelm+mbnam) = jdir
            call sbit0(iq(lcelm),mxuse)
          endif
   70   continue

*---- Phase 4: Write all generated drift spaces.
        write (isave, '(1X/''! Generated drifts:''/1X)')
        do 80 idrft = 1, ndrft
          write (isave, '(''D'',I6.6,'': DRIFT, L = '',F12.6)')
     +      idrft, dq(idrft)
   80   continue

*---- Close output file.
        write (isave, '(1X/''RETURN'')')
        call flclos(isave, error)
        if (.not. error) then
          call flname(isave, filnam)
          call utleng(linnam, l)
          call aainfo('SVSLIN', 1, 'Beam line "' // linnam(1:l)
     +      // '" and definitions written on file: ' // filnam)
        endif

*---- Release working storage.
        iwork = 0
        nwork = 0
        call mzwork(0, dq(1), dq(1), -1)
      endif

 9999 end
+dk svsnap
      subroutine svsnap(lbank)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save snapshot data for one element bank.                           *
* Input:                                                               *
*   LBANK(1)  (pointer) Bank pointer.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer icat,idata,ikat,iln,ipr,isp,itype,nkat
      double precision rval
      integer           lbank(1)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca keyword
+ca refer
+ca datatype

      character*(mcnam) label, class

*---- Retrieve label and keyword definition.
      lcelm = lbank(1)
      lckey = lq(lcelm+1)
      call diname(ldbnk, iq(lcelm+mbnam), label)
      call kwget(lckey, iln, ipr, isp, nkat)
      call diname(ldkey, iq(lckey+mbnam), class)

*---- Class name.
      if (iq(lcelm+mbpr) .eq. mpelm) then
        if (iq(lcelm+mbsp) .eq. 1  .and.
     +      label(1:1) .eq. '['  .and.  label(8:) .eq. ']') then
          go to 9999
        endif
        lcsrc = lq(lcelm-iq(lcelm+mbat)-mbecls)
        if (lcsrc .ne. 0) then
          call diname(ldbnk, iq(lcsrc+mbnam), class)
        endif
      endif

*---- Save label and keyword.
      call svbegn
      if (label .ne. ' ') then
        call svname(label)
        call svlitt(': ')
      endif
      call svname(class)

*---- Loop over all attributes.
      idata = mbat
      icat  = 1
      do 90 ikat = 1, nkat
        itype  = iatype(ikat)

*---- Test for defined real attribute value.
        if (itype .eq. mtflt  .and.
     +      mod(iq(lcelm+idata+mctyp),10) .ne. 0) then
          call svlitt(', ')
          call svname(katnam(ikat))
          call svlitt('=')
          call ucopy(q(lcelm+idata+mcval), rval, mwflt)
          call svreal(rval)
        endif
        idata = idata + mcsiz
        icat  = icat  + 1
   90 continue

      call svdump

 9999 end
+dk svsubr
      subroutine svsubr(lsub)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save a subroutine defintion.                                       *
* Input:                                                               *
*   LSUB(1)   (pointer) Subroutine bank.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer isp,isub,lbnk,lprc
      integer           lsub(1)
+ca memdum
+ca bankhead
+ca refer

      call svbank(lsub)
      isp = iq(lsub(1)+mbsp)
      if (isp .eq. 1 .or. isp .eq. 5 .or. isp .eq. 8) then
        lprc = lq(lsub(1)-1)

*---- Skip one pointer (stack pointer space).
        do 10 isub = 2, iq(lprc-3)
          lbnk = lq(lprc-isub)
          call svbank(lbnk)
   10   continue

        call svbegn
        if (iq(lsub(1)+mbsp) .eq. 1) then
          call svlitt('ENDDO')
        else if (iq(lsub(1)+mbsp) .eq. 5) then
          call svlitt('ENDSUBROUTINE')
        else
          call svlitt('ENDIF')
        endif
        call svdump
      endif

      end
+dk svstrg
      subroutine svstrg(string)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Format a quoted string for SAVE of VIEW command.                   *
* Input:                                                               *
*   STRING    (char)    String to be output.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer ileng,istep,istrg,len
      character*(*)     string
+ca savbuf

      ileng = len(string)
      if (isvbuf + ileng .gt. 76) call svcont
      isvbuf = isvbuf + 1
      savbuf(isvbuf:isvbuf) = '"'
      istrg = 0
   10 if (istrg .lt. ileng) then
        istep = min(ileng - istrg, 80 - isvbuf)
        savbuf(isvbuf+1:isvbuf+istep) = string(istrg+1:istrg+istep)
        isvbuf = isvbuf + istep
        istrg = istrg + istep
        if (istrg .lt. ileng) then
          write (isave, '(A)') savbuf
          isvbuf = 0
        endif
        go to 10
      endif
      if (isvbuf .ge. 80) then
        write (isave, '(A)') savbuf
        isvbuf = 0
      endif
      isvbuf = isvbuf + 1
      savbuf(isvbuf:isvbuf) = '"'

      end
+dk svvref
      subroutine svvref(lvar)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save a variable reference.                                         *
* Input:                                                               *
*   LVAR(1)   (pointer) Pointer to the variable reference bank.        *
*----------------------------------------------------------------------*
+ca aparam
      integer ind1,ind2,ind3,ndim
      integer           lvar(1)
+ca memdum
+ca vargroup

      character*(mcnam) name

*---- Bank name.
      call uhtoc(q(lvar(1)+mvbank), mcwrd, name, mcnam)
      call svname(name)

*---- Attribute name.
      if (iq(lvar(1)+mvseen) .eq. 2) then
        call svlitt('[')
        call uhtoc(q(lvar(1)+mvattr), mcwrd, name, mcnam)
        call svname(name)

*---- Set dimension count.
        ndim = 0
        ind1 = iq(lvar(1)+mvind1)
        ind2 = iq(lvar(1)+mvind2)
        ind3 = iq(lvar(1)+mvind3)
        if (ind1 .gt. 1) ndim = 1
        if (ind2 .gt. 1) ndim = 2
        if (ind3 .gt. 1) ndim = 3

*---- Indices, if present.
        if (ndim .ge. 1) then
          call svlitt('(')
          call svint(ind1)
          if (ndim .ge. 2) then
            call svlitt(',')
            call svint(ind2)
            if (ndim .ge. 3) then
              call svlitt(',')
              call svint(ind3)
            endif
          endif
          call svlitt(')')
        endif
        call svlitt(']')
      endif

      end
+dk svzzzz
+dk tbaaaa
+dk tbbuff
      subroutine tbbuff(nbuf)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Lift table buffer banks, organized as a queue.                     *
*   Internal routine for table manager, not to be called directly.     *
* Input:                                                               *
*   LTBSAV    /TBCOMM/  Table manager bank (reference pointer).        *
*   NBUF      (integer) Minimum number of buffers in memory.           *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca message
+ca tbcomm
+ca quest
+ca tbpara
      integer ikey,ileng,jbit,jbuf,last,ltbbky,nbuf,
     +need,nrow,nwid,nwrd,nzbank

      character*(mcnam) tnam

*---- Drop buffer queue, if it exists, but too small.
      if (jbit(iq(ltbsav),mtbbuf) .ne. 0  .and.
     +    nzbank(0, lq(ltbsav-mtbfst)) .lt. nbuf) then
        call tbdump(ltbsav)
      endif

*---- Lift bank for buffer keys and pointers.
      if (jbit(iq(ltbsav),mtbbuf) .eq. 0) then
        nwid = iq(ltbsav+mtbwid)
        nrow = iq(ltbsav+mtbrow)
        call mzbook(2, ltbbky, ltbsav, -mtbbky, 'BKEY', nrow, 0, nrow,
     +              2, 0)

*---- If first segment exists, load its keys.
        iq(ltbbky-5) = 1
        ikey = iq(lq(ltbsav-mtbsky)+1)
        if (ikey .ne. 0) call tbread(ltbbky, ikey)

*---- Find amount of free space without garbage collect.
        call mzneed(2, 0, ' ')
        nwrd = iquest(11)

*---- If space is getting low, try to free some more.
        need = 2 * nrow * (nwid + 10)
        if (need .ge. nwrd) then
          ltbcur = ltable
   10     if (ltbcur .gt. 0) then
            if (jbit(iq(ltbcur),mtbact) .eq. 0) call tbdump(ltbcur)
            ltbcur = lq(ltbcur)
            go to 10
          endif

*---- Force garbage collection.
          call mzneed(2, need, 'G')
          nwrd = iquest(11) + need
        endif

*---- Memory space insufficient even for minimum number of buffers.
        if (nwrd .lt. nbuf * (nwid + 10)) then
          call uhtoc(q(ltbsav+mtbnam), mcwrd, tnam, mcnam)
          call utleng(tnam, ileng)
          msg(1) = 'Insufficient memory for loading table "'
     +    // tnam(1:ileng) // '".'
          call aafail('TBBUFF', 1, msg)
        else

*---- Can we keep complete table in memory?
          if (nwrd .ge. need) then
            last = nrow

*---- Otherwise keep only the minimum number of buffers.
          else
            last = nbuf
          endif

*---- Build buffer queue.
          call mzbook(2, ltbtmp, ltbsav, -mtbfst, 'BUFF', 0, 0, nwid,
     +                0, 0)
          iq(ltbtmp-5) = 0
          lq(ltbsav-mtblst) = ltbtmp
          do 20 jbuf = 2, last
            call mzbook(2, ltbtmp, ltbsav, -mtbfst, 'BUFF', 0, 0, nwid,
     +                  0, 0)
            iq(ltbtmp-5) = 0
   20     continue

*---- Table is ready for use.
          call sbit1(iq(ltbsav), mtbbuf)
        endif
      endif

      end
+dk tbchck
      subroutine tbchck(rnam, ltab, ok)
      implicit none

*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Check validity of a table pointer.                                 *
*   Internal routine for table manager, not to be called directly.     *
* Input:                                                               *
*   RNAM      (char*6)  Name of calling routine.                       *
*   LTAB(1)   (pointer) Table pointer to be checked.                   *
* Output:                                                              *
*   OK        (logical) Flag for success.                              *
*----------------------------------------------------------------------*
+ca aparam
      character*6       rnam
      integer           ltab(*)
      logical           ok
+ca memdef
+ca message

      character*4       bank

*---- Is pointer in range?
      ok = .false.
      if (ltab(1) .le. 0  .or.  ltab(1) .gt. mwflt*memlen) then
        write (msg, 910) ltab(1)
        call aawarn(rnam, 1, msg)

*---- Is LTAB a valid table bank?
      else
        call uhtoc(q(ltab(1)-4), mcwrd, bank, 4)
        if (bank .eq. 'TAB ') then
          ok = .true.
        else
          write (msg, 910) ltab(1)
          call aawarn(rnam, 1, msg)
        endif
      endif

  910 format('Invalid table bank pointer',i10,'.')

      end
+dk tbclos
      subroutine tbclos(ltab)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Mark table structure as not in use (to allow dumping).             *
* Input:                                                               *
*   LTAB(1)   (pointer) Table manager bank (reference pointer).        *
*----------------------------------------------------------------------*
+ca aparam
      integer           ltab(*)
+ca memdum
+ca tbpara

      logical           ok

      call tbchck('TBCLOS', ltab, ok)
      if (ok) call sbit0(iq(ltab(1)), mtbact)
      ltab(1) = 0

      end
+dk tbcol
      subroutine tbcol(ltab, colnam, iform, ibias)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find bias of a given table column.                                 *
* Input:                                                               *
*   LTAB(1)   (pointer) Pointer to open table.                         *
*   COLNAM    (char)    Name of desired column.                        *
* Output:                                                              *
*   IFORM     (integer) Zebra format code.                             *
*   IBIAS     (integer) Bias of column in buffer banks.                *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,iform,jcol,leng,lnam,n
      integer           ltab(*)
      character*(*)     colnam
+ca memdum
+ca tbpara

      logical           ok
      character*(mcnam) name, temp

*---- Check validity.
      call tbchck('TBCOL', ltab, ok)
      iform = 0
      ibias = 0

*---- Search for desired column; try unabbreviated form.
      if (ok) then
        lnam = lq(ltab(1)-mtbcnm)
        temp = colnam
        do 10 jcol = 1, iq(ltab(1)+mtbcol)
          call uhtoc(q(lnam+1), mcwrd, name, mcnam)
          if (name .eq. temp) then
            iform = iq(lq(ltab(1)-mtbcfm)+jcol)
            ibias = iq(lq(ltab(1)-mtbcps)+jcol)
            go to 9999
          endif
          lnam = lnam + mwnam
   10   continue

*---- COLNAM not found:  Try abbreviations,  N counts ambiguities.
        call utleng(colnam, leng)
        lnam = lq(ltab(1)-mtbcnm)
        n = 0
        do 20 jcol = 1, iq(ltab(1)+mtbcol)
          call uhtoc(q(lnam+1), mcwrd, name, mcnam)
          if (name(1:leng) .eq. colnam) then
            iform = iq(lq(ltab(1)-mtbcfm)+jcol)
            ibias = iq(lq(ltab(1)-mtbcps)+jcol)
            n = n + 1
          endif
          lnam = lnam + mwnam
   20   continue
        if (n .ne. 1) then
          iform = 0
          ibias = 0
        endif
      endif

 9999 end
+dk tbcrea
      subroutine tbcrea(tnam, nseg, nrow, ncol, cnam, icfrm, nbuf, ltab)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Create table buffer structure for writing.                         *
* Input:                                                               *
*   TNAM      (char)    Table name.                                    *
*   NSEG      (integer) Number of table segments.                      *
*   NROW      (integer) Number of table rows per segment.              *
*   NCOL      (integer) Number of table columns.                       *
*   CNAM(*)   (char)    Column names.                                  *
*   ICFRM(*)  (integer) Zebra format codes for columns.                *
*   NBUF      (integer) Minimum number of buffers in memory.           *
* Output:                                                              *
*   LTAB(1)   (pointer) Table manager bank (reference pointer).        *
*----------------------------------------------------------------------*
+ca aparam
      integer ileng,jcol,l,lcfrm,lcnam,lzlong,nbuf,
     +ncol,nd,nr,nrow,ns,nseg,nwid
      double precision dummy
      character*(mcnam) tnam, cnam(*)
      integer           ltab(*), icfrm(*)
+ca memdum
+ca message
+ca header
+ca tbcomm
+ca tbpara

      integer           iname(mwnam)

*---- Look for previous definition.
*     Keep table pointer in common to avoid trouble when booking.
      call uctoh(tnam, iname, mcwrd, mcnam)
      ltbsav = lzlong(0, ltable, mwnam, iname, mtbnam)
      if (ltbsav .ne. 0) then
        call tbdrop(ltbsav)
        call utleng(tnam, ileng)
        msg(1) = 'Table buffer "' // tnam(1:ileng)
     +  // '" already exists --- previous version deleted.'
        call aawarn('TBCREA', 1, msg)
      endif

*---- Lift new table banks.
      nr = mtblst
      ns = mtbfst
      call mzbook(2, ltbsav, ltable, 1, 'TAB ', nr, ns, mtbsiz, 7, 0)
      iq(ltbsav+mtbf1)  = 4 * 16 + 2
      iq(ltbsav+mtbseg) = nseg
      iq(ltbsav+mtbrow) = nrow
      iq(ltbsav+mtbcol) = ncol
      iq(ltbsav+mtbf2)  = mwnam * 16 + 5
      call ncopy(iname, iq(ltbsav+mtbnam), mwnam)

*---- Store column names.
      nd = mwnam * ncol
      call mzbook(2, lcnam, ltbsav, -mtbcnm, 'CNAM', 0, 0, nd, 5, 0)
      do 10 jcol = 1, ncol
        call uctoh(cnam(jcol), iq(lcnam+1), mcwrd, mcnam)
        lcnam = lcnam + mwnam
   10 continue

*---- Store column formats.
      call mzbook(2, lcfrm, ltbsav, -mtbcfm, 'CFRM', 0, 0, ncol, 2, 0)
      call ncopy(icfrm, iq(lcfrm+1), ncol)

*---- Store column bias.
      call mzbook(2, l, ltbsav, -mtbcps, 'CPOS', 0, 0, ncol + 1, 2, 0)
      nwid = 0
      do 20 jcol = 1, ncol

*---- Integer or single precision real
        if (icfrm(jcol) .le. 3) then
          nwid = nwid + 1

*---- Double precision real.
        else if (icfrm(jcol) .eq. 4) then
          nwid = nwid + 2

*---- Hollerith.
        else if (icfrm(jcol) .eq. 5) then
          nwid = nwid + mwnam
        endif
        iq(l+jcol+1) = nwid
   20 continue

*---- Store buffer length.
      iq(ltbsav+mtbwid) = nwid

*---- Lift bank for segment storage keys.
      call mzbook(2, l, ltbsav, -mtbsky, 'SKEY', 0, 0, nseg, 2, 0)

*---- Mark table as in use (before lifting buffers, to avoid dumping).
      call sbit1(iq(ltbsav), mtbact)

*---- Add standard descriptors.
      call tbpdsc(ltbsav, 'TIME', 5, 0, dummy, ctime)
      call tbpdsc(ltbsav, 'DATE', 5, 0, dummy, cdate)
      call tbpdsc(ltbsav, 'ORIGIN', 5, 0, dummy, 'MAD '//nvers//cvers)
      call tbpdsc(ltbsav, 'COMMENT', 5, 0, dummy, ctitle)

*---- Build buffer queue.
      call tbbuff(nbuf)
      ltab(1) = ltbsav

      end
+dk tbdata
      subroutine tbdata(iform, ival, rval, sval)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode one table field according to format code and length.        *
* Input:                                                               *
*   IFORM     (integer) Zebra format code, with extensions:            *
*                       11 = character, 12 = octal, 13 = hexadecimal.  *
* Output:                                                              *
*   IVAL      (integer) Decoded value, if integer.                     *
*   RVAL      (real)    Decoded value, if real.                        *
*   SVAL      (char)    Decoded value, if string or name.              *
*----------------------------------------------------------------------*
+ca aparam
      integer ichar,idigit,iform,index,ival
      double precision rval
      character*(*)     sval
+ca chcode
+ca mchpar
+ca stbuff

      character*1       ch
      logical           eflag

*---- Skip leading blanks.
   10 if (jtok .le. ntok  .and.  token(jtok) .eq. ' ') then
        jtok = jtok + 1
        go to 10
      endif

*==== Unset value.
      if (token(jtok) .eq. '~') then
        jtok = jtok + 1

*---- Bit string or integer.
        if (iform .le. 2) then
          ival = intmax

*---- Single or double precision real.
        else if (iform .le. 4) then
          rval = fltmax

*---- String.
        else if (iform .eq. 5) then
          sval = '~'

*---- Character: becomes string.
        else if (iform .eq. 11) then
          iform = 5
          sval = '~'

*---- Octal number: becomes bit string.
        else if (iform .eq. 12) then
          iform = 1
          ival = intmax

*---- Hexadecimal number: becomes bit string.
        else if (iform .eq. 13) then
          iform = 1
          ival = intmax
        endif

*==== Ordinary value.
*---- Integer or bit string.
      else
        if (iform .le. 2) then
          call rdint(ival, eflag)

*---- Real: Always returned in double precision.
        else if (iform .le. 4) then
          call rdnumb(rval, eflag)

*---- String.
        else if (iform .eq. 5) then
          call tbname(sval)

*---- Character: becomes string.
        else if (iform .eq. 11) then
          iform = 5
          sval = token(jtok)
          jtok = jtok + 1

*---- Octal number: becomes bit string.
        else if (iform .eq. 12) then
          iform = 1
          ival = 0
   20     idigit = index('01234567',token(jtok)) - 1
          if (idigit .ge. 0) then
            ival = 8 * ival + idigit
            jtok = jtok + 1
            go to 20
          endif

*---- Hexadecimal number: becomes bit string.
        else if (iform .eq. 13) then
          iform = 1
          ival = 0
   30     ch = ch2upp(ichar(token(jtok)))
          idigit = index('0123456789ABCDEF',ch) - 1
          if (idigit .ge. 0) then
            ival = 16 * ival + idigit
            jtok = jtok + 1
            go to 30
          endif
        endif
      endif

      end
+dk tbdrop
      subroutine tbdrop(ltab)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Delete a table structure. If no tables are left, clean out file.   *
* Input:                                                               *
*   LTAB(1)   (pointer) Table manager bank (reference pointer).        *
*----------------------------------------------------------------------*
+ca aparam
      integer           ltab(*)
+ca tbcomm
+ca tbpara

      logical           ok

      call tbchck('TBDROP', ltab, ok)
      if (ok) then
        call mzdrop(0, ltab, '.')
        ltab(1) = 0
        if (ltable .eq. 0) call tbinit(0)
      endif

      end
+dk tbdump
      subroutine tbdump(ltab)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Dump table structure and release space used.                       *
* Input:                                                               *
*   LTAB(1)   (pointer) Table manager bank (reference pointer).        *
*----------------------------------------------------------------------*
+ca aparam
      integer jbit
      integer           ltab(*)
+ca memdum
+ca tbcomm
+ca tbpara

      logical           ok

*---- Check validity of table.
      call tbchck('TBDUMP', ltab, ok)
      if (ok) then

*---- Write modified buffers.
        ltbtmp = lq(ltab(1)-mtbfst)
   10   if (ltbtmp .gt. 0) then
          if (jbit(iq(ltbtmp),mtbmod) .ne. 0) then
            call tbwrit(ltbtmp, lq(ltab(1)-mtbbky), iq(ltbtmp-5))
          endif
          ltbtmp = lq(ltbtmp)
          go to 10
        endif

*---- Write buffer key bank, if modified.
        ltbtmp = lq(ltab(1)-mtbbky)
        if (jbit(iq(ltbtmp),mtbmod) .ne. 0) then
          call tbwrit(ltbtmp, lq(ltab(1)-mtbsky), iq(ltbtmp-5))
        endif

*---- Drop buffer queue and buffer key bank.
        lq(ltab(1)-mtblst) = 0
        call mzdrop(0, lq(ltab(1)-mtbfst), 'L')
        call mzdrop(0, lq(ltab(1)-mtbbky), '.')

*---- Table has no buffers.
        call sbit0(iq(ltab(1)), mtbbuf)
      endif

      end
+dk tbfile
      subroutine tbfile
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Open direct-access file for table manager.                         *
*   Machine dependent routine, internal to table manager.              *
*----------------------------------------------------------------------*
+ca aparam
+ca tbcomm
      integer irecl

      character*(mcfil) ftabl

+if osf1
      irecl = 512
+el
      irecl = 4 * 512
+ei
*WNT  IRECL = 512
      irecl = 4 * 512 ! *AIX
      call flnset('table', ftabl)
      open (unit = itabun, file = ftabl, access = 'DIRECT',
     +      status = 'UNKNOWN', recl = irecl)
      itbfil = 123456

      end
+dk tbform
      subroutine tbform(iform, ileng)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode a single table descriptor format.                           *
* Output:                                                              *
*   IFORM     (integer) Zebra format code, with extensions:            *
*                       11 = character, 12 = octal, 13 = hexadecimal.  *
*   ILENG     (integer) Field length expected.                         *
*----------------------------------------------------------------------*
+ca aparam
+ca stbuff
      integer idigit,iform,ileng,index,j

*---- "C" like format control codes, and their MAD equivalent.
      character*1       code(12)
      integer           ifcod(12)
      logical           long

      data code         / 'c', 'd', 'e', 'E', 'f', 'g',
     +                    'i', 'o', 's', 'u', 'x', 'X' /
      data ifcod        / 11,   2,   3,   3,   3,   3,
     +                     2,  12,   5,   1,  13,  13  /

      iform = 0
      ileng = 0
      long = .false.

*---- Skip leading blanks.
   10 if (jtok .le. ntok) then
        if (token(jtok) .eq. ' ') then
          jtok = jtok + 1
          go to 10
        endif

*---- Check leading percent sign.
        if (token(jtok) .ne. '%') then
          call rdfail('TBFORM', 1, 'Format does not begin with "%".')
        else
          jtok = jtok + 1

*---- Decode field length.
   20     continue
          idigit = index('0123456789',token(jtok)) - 1
          if (idigit .ge. 0) then
            ileng = 10 * ileng + idigit
            jtok = jtok + 1
            go to 20
          endif
          if (token(jtok) .eq. 'l'  .or.  token(jtok) .eq. 'h') then
            long = token(jtok) .eq. 'l'
            jtok = jtok + 1
          endif

*---- Decode format character.
          do 80 j = 1, 12
            if (token(jtok) .eq. code(j)) then
              iform = ifcod(j)
              if (long  .and.  iform .eq. 3) iform = 4
              go to 90
            endif
   80     continue
          call rdfail('TBFORM', 1, 'Unknown format code.')
   90     continue
          jtok = jtok + 1
        endif
      endif

 9999 end
+dk tbgdsc
      subroutine tbgdsc(ltab, dname, iform, ival, rval, sval)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find a descriptor for a table.                                     *
* Input:                                                               *
*   LTAB(1)   (pointer) Table bank pointer.                            *
*   DNAME     (char)    Descriptor name.                               *
* Output:                                                              *
*   IFORM     (integer) Zebra format code.                             *
*   IVAL      (integer) Value to be stored, if integer.                *
*   RVAL      (real)    Value to be stored, if real.                   *
*   SVAL      (char)    Value to be stored, if string or name.         *
*----------------------------------------------------------------------*
+ca aparam
      integer iform,ival,l,len,ll,lzlong
      double precision rval
      integer           ltab(*)
      character*(*)     dname, sval
+ca memdum
+ca message
+ca tbpara
+ca tbcomm

      character*(mcnam) tname
      integer           iname(mwnam)

*---- Find descriptor bank.
      ival = 0
      rval = 0.0
      sval = ' '
      tname = dname
      call uctoh(tname, iname, mcwrd, mcnam)
      ltbdsc = lzlong(0, lq(ltab(1)-mtbdsc), mwnam, iname, 2)
      if (ltbdsc .eq. 0) then
        call uhtoc(q(ltab(1)+mtbnam), mcwrd, tname, mcnam)
        call utleng(tname, l)
        msg(1) = 'Table descriptor "' // dname
     +  // '" not found in table "' // tname(1:l) // '".'
        call aawarn('TBGDSC', 1, msg)
      else
        iform = mod(iq(ltbdsc+mwnam+2),16)

*---- Integer.
        if (iform .le. 2) then
          ival = iq(ltbdsc+mwnam+3)

*---- Single precision real.
        else if (iform .eq. 3) then
          rval = q(ltbdsc+mwnam+3)

*---- Double precision real.
        else if (iform .eq. 4) then
          call ucopy(q(ltbdsc+mwnam+3), rval, 2)

*---- String or name.
        else if (iform .eq. 5) then
          ll = min(len(sval), mcwrd * (iq(ltbdsc+mwnam+2) / 16))
          call uhtoc(q(ltbdsc+mwnam+3), mcwrd, sval, ll)
        endif
      endif

      end
+dk tbget
      subroutine tbget(iwords, nbl, nwid, iret)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Read a block from Cray SSD or direct access file.                  *
*   Machine dependent routine.                                         *
* Input:                                                               *
*    IWORDS(*)    Block to be read.                                    *
*    NBL          Block number to read.                                *
*    NWID         Number of words to read.                             *
* Output:                                                              *
*    IRET         Return code:                                         *
*                 0 = OK                                               *
*                 3 = Error occurred during read.                      *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iret,istat,j,k,nbl,nwid
      integer           iwords(*)
+ca tbcomm

*---- Open direct access file.
      if (itbfil .eq. 0) call tbfile

*---- Read block.
      i = nbl
      do 10  j = 1, nwid, 512
        i = i + 1
        read (itabun, rec=i, iostat=istat) (iwords(k), k = j, j+511)
   10 continue

*---- Test for error.
      iret = 0
      if (istat .ne. 0) iret = 3

      end
+dk tbgnam
      subroutine tbgnam(ltab, tnam)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Return name of a table.                                            *
* Input:                                                               *
*   LTAB(1)   (pointer) Table manager bank (reference pointer).        *
* Output:                                                              *
*   TNAM      (char)    Table name.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer           ltab(*)
      character*(mcnam) tnam
+ca memdum
+ca tbpara

      logical           ok

*---- Check validity of table.
      call tbchck('TBGNAM', ltab, ok)
      if (ok) then
        call uhtoc(q(ltab(1)+mtbnam), mcwrd, tnam, mcnam)
      endif

      end
+dk tbinit
      subroutine tbinit(iunit)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initialize table manager.                                          *
* Input.                                                               *
*   IUNIT     (integer) Logical unit for direct access file.           *
*----------------------------------------------------------------------*
+ca aparam
+ca tbcomm
      integer itbflg,iunit

      data itbflg       / 0 /

*---- First initialization?
      if (itbflg .eq. 0) then
        call mzlink(0, '/TBCOMM/', ltable, ltbbuf, ltbtmp)
        itbflg = 1
        itbfil = 0
      endif

*---- Logical unit number.
      if (iunit .ne. 0) itabun = iunit

*---- Reset various counters.
      koff = 0
      nblock = 0
      icurr = - 1
      nbout = - 1
      ncmax = 0
      nrbmod = 0

      end
+dk tbinpt
      subroutine tbinpt(key, nwid, iwords, iret)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Read a record from Cray SSD or direct access file.                 *
*   For usage see TBOUTP.                                              *
* Input:                                                               *
*    KEY          Record identifier (an integer returned by TBOUTP).   *
* Output:                                                              *
*    NWID         Number of words read.                                *
*    IWORDS       The NWID words read.                                 *
*                      -1 = Read, but record length changed.           *
*                 0 = OK.                                              *
*                 1 = Key KEY is not valid.                            *
*                 2 = Package not initialized.                         *
*                 3 = Error occurred during transfer.                  *
*   Author: H. Grote    CERN / LEP                   nov. 14, 1988     *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ibl,irb,iret,ist,jbyt,k,key,n,nt,
     +nwid,nwin
      integer           iwords(*)
+ca tbcomm

*---- Check validity of key.
      iret = 0
      ibl = jbyt(key, 17, 16)
      k = jbyt(key, 1, 16) - 1
      if (key.lt.0 .or. k.gt.mleng .or. ibl.gt.nbout+mnblck) then
        iret = 1
        go to 9999

*---- Still in output buffer.
      else
        irb = 1
        if (ibl .gt. nbout) then
          irb = 2

*---- Not in input buffer.
        else if (ibl .ne. icurr) then

*---- Make sure read buffer is free.
          if (nrbmod .ne. 0) then
            call tbput(itbbuf(1,1), icurr, mleng, iret)
            if (iret .ne. 0) go to 9999
            nrbmod = 0
          endif

*---- Load new block to read buffer.
          call tbget(itbbuf(1,1), ibl, mleng, iret)
          if (iret .ne. 0) go to 9999
          icurr = ibl
        endif
      endif

*---- Transfer.
      nwin = itbbuf(k+1,irb)
      k = k + 1
      nt = min(nwin,nwid)
      ist = 0

   10 continue
      n = min(nt, mleng-k)

      do 20 i = 1, n
        iwords(ist+i) = itbbuf(k+i,irb)
   20 continue

      nt = nt - n

*---- Do we need another block?
      if (nt .gt. 0) then
        ist = ist + n
        ibl = ibl + mnblck

*---- Block needed resides in write buffer.
        if (ibl .gt. nbout) then
          irb = 2

*---- Make sure read buffer is free.
        else
          if (nrbmod .ne. 0) then
            call tbput(itbbuf(1,1), icurr, mleng, iret)
            if (iret .ne. 0) go to 9999
            nrbmod = 0
          endif

*---- Load new block.
          call tbget(itbbuf(1,1), ibl, mleng, iret)
          if (iret .ne. 0) go to 9999
          icurr = ibl
        endif
        k = 0
        go to 10
      endif

*---- Check record length.
      if (nwid .ne. nwin) iret = -1
      nwid = min(nwid,nwin)

 9999 end
+dk tblist
      subroutine tblist
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   List a TFS table, TABLE command.                                   *
* Attribute:                                                           *
*   NAME       (name)    Table to be listed.                           *
*   COLUMN(*)  (string)  Column expressions.                           *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca chcode
+ca keyword
+ca mchpar
+ca option
+ca refer
+ca status
+ca tbcomm
+ca tbhead
+ca tbpara
+ca zunit
      integer icol,ifrm,il,iln,ipos,ipr,irow,iseg,isp,isum,j,
     +ncol,nkat,nl,nsum
      double precision colval,rval,sumval

      character*(mcnam) tbname, colnam(100), sumnam(100), xname
      dimension         colval(100), sumval(100)
      integer           iform(100), ibias(100)
      logical           eflag

*---- Decode table name.
      tbname = ' '
      call utgnam(lccmd, 1, 1, tbname)
      call tbopen(tbname, 1, ltbtab)
      if (ltbtab .eq. 0) go to 9999

*---- Get keyword dimensions.
      call kwget(lckey, iln, ipr, isp, nkat)

*---- Book bank for columns.
      ltbcol = 0
      nl = iadim1(2)
      call mzbook(2, ltbcol, ltbcol, 1, 'TEXP', nl, nl, 0, mreal, 0)

*---- Fetch column names.
      do 10 icol = 1, nl
        colnam(icol) = ' '
   10 continue
      call utgnam(lccmd, 2, iadim1(2)+1, colnam)

*---- Decode column names.
      ncol = 0
      do 20 icol = 1, nl
        if (colnam(icol) .ne. ' ') then
          ncol = ncol + 1
          call tbcol(ltbtab, colnam(icol), iform(icol), ibias(icol))
          if (iform(icol) .eq. 0) then
            call exstrg(colnam(icol), ltbtab, ltbcol, -ncol,
     +                  colval(icol), eflag)
          endif
        endif
   20 continue

*---- Book bank for sums.
      ltbsum = 0
      nl = iadim1(3)
      call mzbook(2, ltbsum, ltbsum, 1, 'TSUM', nl, nl, 0, mreal, 0)

*---- Fetch sum names.
      do 30 isum = 1, nl
        sumnam(isum) = ' '
   30 continue
      call utgnam(lccmd, iadim1(2)+2, iadim1(2)+iadim1(3)+1, sumnam)

*---- Decode expression names.
      nsum = 0
      do 40 isum = 1, nl
        if (sumnam(isum) .ne. ' ') then
          nsum = nsum + 1
          call exstrg(sumnam(isum), ltbtab, ltbsum, -nsum, rval, eflag)
          sumval(nsum) = 0.0
        endif
   40 continue

*---- Quit in case of error.
      if (error  .or.  ncol + nsum .eq. 0) go to 9999

*---- Loop over table segments.
      do 190 iseg = 1, iq(ltbtab+mtbseg)
        call tbseg(ltbtab, iseg, eflag)

*---- Table header.
        if (.not. eflag) then
          if (ncol .ne. 0) then
            call prpage(iqpr2)
            write (iqpr2, 910) tbname, iseg
            call prline(iqpr2)
            write (iqpr2, 920) (colnam(j), j = 1, ncol)
            call prline(iqpr2)
          endif

*---- Loop over table rows.
          do 180 irow = 1, iq(ltbtab+mtbrow)
            call tbset(ltbtab, irow, 1, ltbbuf)
            if (ltbbuf .ne. 0) then
              do 160 icol = 1, ncol
                ifrm = iform(icol)
                ipos = ibias(icol)

                if (ifrm .eq. 0) then
                  call exevl1(lq(ltbcol-icol), ltbtab, ltbbuf, rval)
                  write (cname(icol), '(G20.12)') rval
                else if (ifrm .le. 2) then
                  write (cname(icol), '(I8)') iq(ltbbuf+ipos+1)
                else if (ifrm .eq. 3) then
                  write (cname(icol), '(G14.6)') q(ltbbuf+ipos+1)
                else if (ifrm .eq. 4) then
                  call ucopy(q(ltbbuf+ipos+1), rval, mwflt)
                  write (cname(icol), '(G20.12)') rval
                else if (ifrm .eq. 5) then
                  call uhtoc(q(ltbbuf+ipos+1), mcwrd, xname, mcnam)
                  call utleng(xname, il)
                  cname(icol) = '  "' // xname(1:il) // '"'
                endif
  160         continue

              write (iqpr2, 940) irow, (cname(icol), icol = 1, ncol)

*---- Evaluate sum expressions.
              do 170 isum = 1, nsum
                if (lq(ltbsum-isum) .ne. 0) then
                  call exevl1(lq(ltbsum-isum), ltbtab, ltbbuf, rval)
                  sumval(isum) = sumval(isum) + rval
                endif
  170         continue
            endif
  180     continue
        endif
  190 continue

*---- Write sums.
      if (nsum .ne. 0) then
        call prline(iqpr2)
        do 290 isum = 1, nsum
          if (double) then
            write (iqpr2, 960) sumnam(isum), sumval(isum)
          else
            write (iqpr2, 970) sumnam(isum), sumval(isum)
          endif
  290   continue
        call prline(iqpr2)
      endif

*---- Close table.
      call tbclos(ltbtab)

*---- Drop expression banks.
*     Since expressions are not linked, no need to call AADROP.
      call mzdrop(0, ltbcol, 'L')
      call mzdrop(0, ltbsum, 'L')

  910 format(' Listing of table "',a,'", segment no. ',i8)
  920 format((t10,6(4x,a16):))
  940 format(' ',i8,' ',6a20:/(t11,6a20:))
  960 format(' ',a,' = ',g20.12)
  970 format(' ',a,' = ',g12.6)

 9999 end
+dk tbname
      subroutine tbname(sval)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Decode a string in TFS system notation.                            *
* Output:                                                              *
*   SVAL      (char)    String read.                                   *
*----------------------------------------------------------------------*
+ca aparam
      integer ilen,len
      character*(*)     sval
+ca stbuff

*---- Skip leading blanks.
      sval = ' '
      ilen = 0
   10 if (jtok .le. ntok) then
         if (token(jtok) .eq. ' ') then
           jtok = jtok + 1
           go to 10
         endif

*---- If quoted string, go to RDSTRG.
        if (token(jtok) .eq. '"') then
          call rdstrg(sval, ilen)

*---- Otherwise, string is up to next blank.
        else
   20     continue
            if (ilen .lt. len(sval)) then
              ilen = ilen + 1
              sval(ilen:ilen) = token(jtok)
            endif
            jtok = jtok + 1
          if (token(jtok) .ne. ' ') go to 20
        endif
      endif

      end
+dk tbopen
      subroutine tbopen(tnam, nbuf, ltab)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Re-open table buffer structure for reading or updating.            *
* Input:                                                               *
*   TNAM      (char)    Table name.                                    *
*   NBUF      (integer) Minimum number of buffers in memory.           *
* Output:                                                              *
*   LTAB(1)   (pointer) Table manager bank (reference pointer).        *
*----------------------------------------------------------------------*
+ca aparam
      integer ileng,lzlong,nbuf
      character*(mcnam) tnam
      integer           ltab(*)
+ca memdum
+ca message
+ca tbcomm
+ca tbpara

      integer           iname(mwnam)

*---- Blank name returns last table created.
*     Keep table pointer in common to avoid trouble when booking.
      if (tnam .eq. ' ') then
        ltbsav = ltable
        call uhtoc(q(ltbsav+mtbnam), mcwrd, tnam, mcnam)

*---- Search for definition.
      else
        call uctoh(tnam, iname, mcwrd, mcnam)
        ltbsav = lzlong(0, ltable, mwnam, iname, mtbnam)
      endif

*---- Message when no table available.
      if (ltbsav .eq. 0) then
        call utleng(tnam, ileng)
        msg(1) = 'Table "' // tnam(1:ileng) // '" not found.'
        call aafail('TBOPEN', 1, msg)

*---- Mark table as in use and create buffer queue.
      else
        call sbit1(iq(ltbsav), mtbact)
        call tbbuff(nbuf)
      endif
      ltab(1) = ltbsav

      end
+dk tboutp
      subroutine tboutp(key, nwid, iwords, iret)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Write a record to Cray SSD or direct access file.                  *
* Input:                                                               *
*    KEY          Record identifier (zero or integer generated by a    *
*                 previous call to TBOUTP).                            *
*    NWID           Number of words to write.                          *
*    IWORDS       Buffer containing the NWID words.                    *
* Output:                                                              *
*    KEY          Record identifier.                                   *
*    IRET         Return code:                                         *
*                      -1 = Written, but record length changed.        *
*                 0 = OK                                               *
*                 1 = Key KEY is not valid.                            *
*                 2 = No more user space available.                    *
*                 3 = Error occurred during transfer.                  *
* Usage:                                                               *
*   The routines TBINPT and TBOUTP allow to write and read random      *
*   access files in the Cray SSD (Solid-state Storage Device) or on    *
*   disk with records of arbitrary length.                             *
*   Each record is identified by a unique key generated by TBOUTP.     *
*   A write request with a zero key causes a new record to be written, *
*   and a new key to be returned.                                      *
*   A write request with a non-zero key causes the record to be        *
*   superseded by the new information. Reading and writing of a        *
*   record can occur any number of times.                              *
* Restrictions:                                                        *
*   The length of an already existing record cannot be increased.      *
*   If a write request is issued for an existing key, the record       *
*   is cut at the length of the previous (!) record.                   *
*   There is no garbage collection or drop mechanism: each request     *
*   with a zero key requires new space.                                *
*   Author: H. Grote    CERN / LEP                   nov. 14, 1988     *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ibl,irb,iret,ist,jbyt,k,key,n,newkey,
     +nt,nwid,nwout
      integer iwords(*)
+ca tbcomm

*---- Is this a new write?
      iret = 0
      if (key .eq. 0) then
        newkey = 1

*---- Write if buffer full.
        if (koff .eq. mleng) then
          call tbput(itbbuf(1,2), nblock, mleng, iret)
          if (iret .ne. 0) go to 9999
          nbout = nblock
          nblock = nblock + mnblck
          koff = 0
        endif

*---- Build new key.
        call sbyt(koff + 1, key, 1, 16)
        call sbyt(nblock, key, 17, 16)
        k = koff
        ibl = nblock
        irb = 2
        nwout = nwid

*---- Key was given - write into old space.
      else

*---- Check validity of key.
        newkey = 0
        ibl = jbyt(key, 17, 16)
        k = jbyt(key, 1, 16) - 1
        if (key.lt.0 .or. k.gt.mleng .or. ibl.gt.nbout+mnblck) then
          iret = 1
          go to 9999
        endif

*---- Still in output buffer.
        irb = 1
        if (ibl .gt. nbout) then
          irb = 2

*---- Make sure read buffer is free.
        else if (ibl .ne. icurr) then
          if (nrbmod .ne. 0) then
            call tbput(itbbuf(1,1), icurr, mleng, iret)
            if (iret .ne. 0) go to 9999
          endif

*---- Load new block.
          call tbget(itbbuf(1,1), ibl, mleng, iret)
          if (iret .ne. 0) go to 9999
          icurr = ibl
        endif
        nwout = min(nwid, itbbuf(k+1,irb))
      endif

*---- Transfer.
      itbbuf(k+1,irb) = nwout
      k = k + 1
      nt = nwout
      ist = 0
   20 continue

*---- Copy data to buffer; mark read buffer as modified.
      if (irb .eq. 1) nrbmod = 1
      n = min(nt, mleng-k)
      do 30 i = 1, n
        itbbuf(k+i,irb) = iwords(ist+i)
   30 continue
      nt = nt - n
      if (newkey .ne. 0) koff = k + n

*---- Do we need another block?
      if (nt .gt. 0) then
        ist = ist + n
        ibl = ibl + mnblck

*---- Next block resides in output buffer or does not yet exist.
        if (ibl .gt. nbout) then
          irb = 2

*---- Have to add another block: write output buffer.
          if (ibl .gt. nblock) then
            call tbput(itbbuf(1,2), nblock, mleng, iret)
            if (iret .ne. 0) go to 9999
            nbout = nblock
            nblock = ibl
          endif

*---- Need another input block.
        else

*---- Make sure input buffer is free.
          if (nrbmod .ne. 0) then
            call tbput(itbbuf(1,1), icurr, mleng, iret)
            if (iret .ne. 0) go to 9999
          endif

*---- If new record uses partial buffer, load buffer first.
          if (nt .lt. mleng) then
            call tbget(itbbuf(1,1), ibl, mleng, iret)
            if (iret .ne. 0) go to 9999
          endif
          icurr = ibl
        endif
        k = 0
        go to 20
      endif

*---- Has truncation occurred?
      if (nwout .ne. nwid) iret = -1
      nwid = min(nwout,nwid)

 9999 end
+dk tbpdsc
      subroutine tbpdsc(ltab, dname, iform, ival, rval, sval)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Add a descriptor to a table.                                       *
* Input:                                                               *
*   LTAB(1)   (pointer) Table bank pointer.                            *
*   DNAME     (char)    Descriptor name.                               *
*   IFORM     (integer) Zebra format code.                             *
*   IVAL      (integer) Value to be stored, if integer.                *
*   RVAL      (real)    Value to be stored, if real.                   *
*   SVAL      (char)    Value to be stored, if string or name.         *
*----------------------------------------------------------------------*
+ca aparam
      integer iform,ileng,ival,nd,nword
      double precision rval
      integer           ltab(*)
      character*(*)     dname, sval
+ca memdum
+ca tbpara
+ca tbcomm

      character*100     tval
      character*(mcnam) tname
      logical           ok

*---- Check for valid table.
      call tbchck('TBPDSC', ltab, ok)
      if (ok) then

*---- Integer or bit string.
        if (iform .le. 2) then
          nd = mwnam + 3
          call mzbook(2, ltbdsc, ltab, -mtbdsc, 'DESC', 0, 0, nd, 7, 0)
          iq(ltbdsc+mwnam+2) = 16 * 1 + iform
          iq(ltbdsc+mwnam+3) = ival

*---- Single precision real.
        else if (iform .eq. 3) then
          nd = mwnam + 3
          call mzbook(2, ltbdsc, ltab, -mtbdsc, 'DESC', 0, 0, nd, 7, 0)
          iq(ltbdsc+mwnam+2) = 16 * 1 + 3
          q(ltbdsc+mwnam+3) = rval

*---- Double precision real.
        else if (iform .eq. 4) then
          nd = mwnam + 4
          call mzbook(2, ltbdsc, ltab, -mtbdsc, 'DESC', 0, 0, nd, 7, 0)
          iq(ltbdsc+mwnam+2) = 16 * 2 + 4
          call ucopy(rval, q(ltbdsc+mwnam+3), 2)

*---- String or name.
        else if (iform .eq. 5) then
          tval = sval
          call utleng(tval, ileng)
          nword = max((ileng - 1) / mcwrd, 0) + 1
          ileng = mcwrd * nword
          nd = mwnam + 2 + nword
          call mzbook(2, ltbdsc, ltab, -mtbdsc, 'DESC', 0, 0, nd, 7, 0)
          iq(ltbdsc+mwnam+2) = 16 * nword + 5
          call uctoh(tval, iq(ltbdsc+mwnam+3), mcwrd, ileng)
        endif

*---- Store name and type.
        iq(ltbdsc+1) = 16 * mwnam + 5
        tname = dname
        call uctoh(tname, iq(ltbdsc+2), mcwrd, mcnam)
      endif

      end
+dk tbput
      subroutine tbput(iwords, nbl, nwid, iret)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Write a block to Cray SSD or direct access file.                   *
*   Machine dependent routine.                                         *
* Input:                                                               *
*    IWORDS(*)    Block to be written.                                 *
*    NBL          Block number to write.                               *
*    NWID         Number of words to write.                            *
* Output:                                                              *
*    IRET         Return code:                                         *
*                 0 = OK                                               *
*                 3 = Error occurred during write.                     *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iret,istat,j,k,nbl,nwid
      integer           iwords(*)
+ca tbcomm

*---- Open direct access file.
      if (itbfil .eq. 0) call tbfile

*---- Write block.
      i = nbl
      do 10  j = 1, nwid, 512
        i = i + 1
        write (itabun, rec=i, iostat=istat) (iwords(k), k = j, j+511)
   10 continue

*---- Test for error.
      iret = 0
      if (istat .ne. 0) iret = 3

 9999 end
+dk tbqdsc
      subroutine tbqdsc(ltab, dname, iform)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Query descriptor for a table.                                      *
* Input:                                                               *
*   LTAB(1)   (pointer) Table bank pointer.                            *
*   DNAME     (char)    Descriptor name.                               *
* Output:                                                              *
*   IFORM     (integer) Zebra format code.                             *
*----------------------------------------------------------------------*
+ca aparam
      integer iform,lzlong
      integer           ltab(*)
      character*(*)     dname
+ca memdum
+ca tbpara
+ca tbcomm

      character*(mcnam) tname
      integer           iname(mwnam)

*---- Find descriptor bank.
      tname = dname
      call uctoh(tname, iname, mcwrd, mcnam)
      ltbdsc = lzlong(0, lq(ltab(1)-mtbdsc), mwnam, iname, 2)
      if (ltbdsc .eq. 0) then
        iform = 0
      else
        iform = mod(iq(ltbdsc+mwnam+2),16)
      endif

      end
+dk tbread
      subroutine tbread(lbuf, ikey)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Read a table buffer.                                               *
*   Internal routine for table manager, not to be called directly.     *
* Input:                                                               *
*   LBUF(1)   (pointer) Buffer bank to be loaded.                      *
*   IKEY      (integer) Key for data retrieval.                        *
*----------------------------------------------------------------------*
+ca aparam
      integer ifrst,ikey,ilast,ileng,iret,nwid
      integer           lbuf(*)
+ca memdum
+ca message
+ca tbpara

      character*(mcnam) tnam

*---- Record exists --- read.
      nwid = iq(lbuf(1)-1)
      if (ikey .ne. 0) then
        call tbinpt(ikey, nwid, iq(lbuf(1)+1), iret)
        if (iret .eq. 0) then
          call sbit0(iq(lbuf(1)), mtbmod)
        else
          call uhtoc(q(lq(lbuf(1)+1)+mtbnam), mcwrd, tnam, mcnam)
          call utleng(tnam, ileng)
          msg(1)(1:34) = 'Reading table "' // tnam(1:ileng) // '",'
          if (iret .eq. 1) then
            msg(1)(35:) = 'Unknown key.'
          else if (iret .eq. 2) then
            msg(1)(35:) = 'Unable to read.'
          else if (iret .eq. 3) then
            msg(1)(35:) = 'Read error.'
          else
            msg(1)(35:) = 'Record length error.'
          endif
          call aafail('TBREAD', 1, msg)
        endif

*---- No record exists --- clear.
      else
        ifrst = lbuf(1) + 1
        ilast = lbuf(1) + nwid
        call uzero(q, ifrst, ilast)
      endif

      end
+dk tbrtfs
      subroutine tbrtfs(tnam, iunit)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Read a table in TFS coded format (ASCII or EBCDIC).                *
*   This routine uses a local link L. Be careful with Zebra calls.     *
* Input:                                                               *
*   TNAM      (char)    Name for stored table.                         *
*   IUNIT     (integer) Logical unit number to be read.                *
*----------------------------------------------------------------------*
+ca aparam
      integer iform,ileng,ipos,iunit,ival,j,jcol,jrow,jseg,l,linsav,
     +lzlong,mrow,mseg,nd,nfrm,nnam,nr,nrow,ns,nseg,
     +nwid
      double precision rval
      character*(mcnam) tnam
+ca memdum
+ca message
+ca header
+ca status
+ca stbuff
      character*1024    text
      equivalence       (text, token(1))
+ca tbcomm
+ca tbhead
+ca tbpara

      character         sval*99, tname*20
      integer           iname(mwnam)

*---- Look for previous definition.
      call uctoh(tnam, iname, mcwrd, mcnam)
      ltbsav = lzlong(0, ltable, mwnam, iname, mtbnam)
      if (ltbsav .ne. 0) then
        call tbdrop(ltbsav)
        call utleng(tnam, ileng)
        msg(1) = 'Table buffer already exists "' // tnam(1:ileng)
     +  // '" ---- previous version deleted.'
        call aawarn('TBRTFS', 1, msg)
      endif

*---- Lift main table bank.
      nr = mtblst
      ns = mtbfst
      call mzbook(2,ltbsav,ltable,1,'TAB ',nr,ns,mtbsiz,7,0)
      iq(ltbsav+mtbf1) = 16 * 4 + 2
      iq(ltbsav+mtbf2) = 16 * mwnam + 5
      call ncopy(iname, iq(ltbsav+mtbnam), mwnam)
      nfrm = 0
      nnam = 0
      nrow = 0
      nseg = 0
      call sbit1(iq(ltbsav), mtbact)

*---- Read one line.
      linsav = lintok
      lintok = 0
   10 continue
        jtok = 1
        read (iunit, '(A)', end = 90) text
        lintok = lintok + 1
        call utleng(text, ntok)
        token(ntok+1) = ' '

*---- Header line containing names.
        if (token(jtok) .eq. '*') then
          if (nrow .ne. 0  .or.  nseg .ne. 0) then
            call rdfail('TBRTFS', 1, 'Header line out of order.')
          else if (nnam .ne. 0) then
            call rdfail('TBRTFS', 1, 'Redundant header line.')
          else
            jtok = jtok + 1
   20       if (jtok .le. ntok) then
              call tbname(tname)
              if (tname .eq. ' ') go to 30
              if (nnam .lt. maxcol) then
                nnam = nnam + 1
                cname(nnam) = tname
                go to 20
              else
                write (msg, 910) maxcol
  910           format('Number of columns exceeds limit of ',i3,'.')
                call rdfail('TBRTFS', 1, msg)
              endif
            endif
   30       continue
          endif
          nd = mwnam * nnam
          call mzbook(2,l,ltbsav,-mtbcnm,'CNAM',0,0,nd,5,0)
          do 40 j = 1, nnam
            call uctoh(cname(j), iq(l+1), mcwrd, mcnam)
            l = l + mwnam
   40     continue
          iq(ltbsav+mtbcol) = nnam

*---- Header line containing data formats.
        else if (token(jtok) .eq. '$') then
          if (nrow .ne. 0  .or.  nseg .ne. 0) then
            call rdfail('TBRTFS', 1, 'Header line out of order.')
          else if (nfrm .ne. 0) then
            call rdfail('TBRTFS', 1, 'Redundant header line.')
          else
            jtok = jtok + 1
   50       if (jtok .le. ntok) then
              call tbform(iform, ileng)
              if (iform .eq. 0) go to 60
              if (nfrm .lt. maxcol) then
                nfrm = nfrm + 1
                icfrm(nfrm) = iform
                iclen(nfrm) = ileng
                go to 50
              else
                write (msg, 920) maxcol
  920           format('Number of formats exceeds limit of ',i3,'.')
                call rdfail('TBRTFS', 1, msg)
              endif
            endif
   60       continue
          endif
          call mzbook(2,l,ltbsav,-mtbcfm,'CFRM',0,0,nfrm,2,0)
          call ncopy(icfrm, iq(l+1), nfrm)
          nd = nfrm + 1
          call mzbook(2,l,ltbsav,-mtbcps,'CPOS',0,0,nd,2,0)
          nwid = 0
          do 70 jcol = 1, nfrm
            if (icfrm(jcol) .le. 3) then
              nwid = nwid + 1
            else if (icfrm(jcol) .eq. 4) then
              nwid = nwid + 2
            else if (icfrm(jcol) .eq. 5) then
              nwid = nwid + mwnam
            endif
            iq(l+jcol+1) = nwid
   70     continue
          iq(ltbsav+mtbwid) = nwid

*---- Descriptor line.
        else if (token(jtok) .eq. '@') then
          jtok = jtok + 1
          call tbname(tname)
          call tbform(iform, ileng)
          call tbdata(iform, ival, rval, sval)
          call tbpdsc(ltbsav, tname, iform, ival, rval, sval)

*---- Segment descriptor line.
        else if (token(jtok) .eq. '!') then
          if (text(2:8) .eq. 'Segment') then
            if (nseg .eq. 0) then
              if (nrow .ne. 0  .or.  nwid .eq. 0) then
                call rdfail('TBRTFS', 1, 'Header line out of order.')
              else
                read (text, '(8X,3I8)') jseg, nseg, nrow
                call mzbook(2,l,ltbsav,-mtbsky,'SKEY',0,0,nseg,2,0)
                iq(ltbsav+mtbseg) = nseg
                iq(ltbsav+mtbrow) = nrow
                call tbbuff(nrow)
              endif
            else
              read (text, '(8X,3I8)') jseg, mseg, mrow
              call tbseg(ltbsav, jseg, error)
            endif
            nrow = 0
          endif

*---- Data line.
        else if (token(jtok) .ne. '%'  .and.
     +           token(jtok) .ne. '#') then
          if (nnam .eq. 0  .or.  nfrm .eq. 0) then
            call rdfail('TBRTFS', 1, 'Table header line missing.')
          else if (nnam .ne. nfrm) then
            call rdfail('TBRTFS', 1,
     +      'Numbers of names and formats are not the same.')
          else
            nrow = nrow + 1
            if (nseg .ne. 0) then
              call tbset(ltbsav, nrow, 3, ltbbuf)
              if (ltbbuf .eq. 0) go to 10
            else
              call mzbook(2,ltbbuf,ltbsav,-mtbfst,'BUFF',0,0,nwid,0,0)
              iq(ltbbuf-5) = nrow
              call sbit1(iq(ltbbuf), mtbmod)
            endif

*---- Decode data line.
            do 80 jcol = 1, nnam
              iform = icfrm(jcol)
              ileng = iclen(jcol)
              ipos = iq(lq(ltbsav-mtbcps)+jcol)
              call tbdata(iform, ival, rval, sval)
              if (iform .le. 2) then
                iq(ltbbuf+ipos+1) = ival
              else if (iform .eq. 3) then
                q(ltbbuf+ipos+1) = rval
              else if (iform .eq. 4) then
                call ucopy(rval, q(ltbbuf+ipos+1), 2)
              else if (iform .eq. 5) then
                call uctoh(sval, iq(ltbbuf+ipos+1), mcwrd, mcnam)
              endif
   80       continue
          endif
        endif
      go to 10

*---- End of table reached. Test for error.
   90 continue
      lintok = linsav
      if (error) then
        call mzdrop(0, ltbsav, '.')

*---- Complete buffer structure, if not segmented.
      else
        call ztopsy(0, lq(ltbsav-mtbdsc))
        if (nseg .eq. 0) then
          call mzbook(2, l,ltbsav,-mtbsky,'SKEY',0,0,1,2,0)
          iq(ltbsav+mtbseg) = 1
          iq(ltbsav+mtbrow) = nrow
          lq(ltbsav-mtblst) = lq(ltbsav-mtbfst)
          call ztopsy(0, lq(ltbsav-mtbfst))
          call mzbook(2,l,ltbsav,-mtbbky,'BKEY',nrow,0,nrow,2,0)
          iq(l-5) = 1
          ltbtmp = lq(ltbsav-mtbfst)
          do 110 jrow = 1, nrow
            lq(l-jrow) = ltbtmp
            ltbtmp = lq(ltbtmp)
  110     continue
          call sbit1(iq(ltbsav), mtbbuf)
        endif
      endif

      end
+dk tbseg
      subroutine tbseg(ltab, iseg, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Change active segment of a table.                                  *
*   This routine uses the fact that TBWRIT does not call Zebra.        *
* Input:                                                               *
*   LTAB(1)   (pointer) Table manager bank.                            *
*   ISEG      (integer) Number of segment desired.                     *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ifrst,ikey,ilast,ileng,iseg,jbit
      integer           ltab(*)
      logical           eflag
+ca memdum
+ca message
+ca tbpara
+ca tbcomm

      logical           ok
      character*(mcnam) tnam

*---- Check validity of table.
      call tbchck('TBSEG ', ltab, ok)
      eflag = .not. ok
      if (ok) then

*---- Is table open?
        call uhtoc(q(ltab(1)+mtbnam), mcwrd, tnam, mcnam)
        call utleng(tnam, ileng)
        if (jbit(iq(ltab(1)),mtbact) .eq. 0) then
          msg(1) = 'Table buffer "' // tnam(1:ileng)
     +    // '" is not active.'
          call aafail('TBSEG', 1, msg)
          eflag = .true.

*---- Is desired segment in range?
        else if (iseg .le. 0  .or.  iseg .gt. iq(ltab(1)+mtbseg)) then
          write (msg, 910) tnam(1:ileng), iseg
  910     format('Table buffer "',a,'" has no segment no. ',i10)
          call aafail('TBSEG', 1, msg)
          eflag = .true.

*---- Is the desired segment already active?
        else if (iq(lq(ltab(1)-mtbbky)-5) .ne. iseg) then

*---- Write modified buffers.
          ltbtmp = lq(ltab(1)-mtbfst)
   10     if (ltbtmp .gt. 0) then
            if (jbit(iq(ltbtmp),mtbmod) .ne. 0) then
              call tbwrit(ltbtmp, lq(ltab(1)-mtbbky), iq(ltbtmp-5))
              call sbit0(iq(ltbtmp),mtbmod)
              iq(ltbtmp-5) = 0
            endif
            ltbtmp = lq(ltbtmp)
            go to 10
          endif

*---- Write buffer key bank, if modified.
          ltbtmp = lq(ltab(1)-mtbbky)
          if (jbit(iq(ltbtmp),mtbmod) .ne. 0) then
            call tbwrit(ltbtmp, lq(ltab(1)-mtbsky), iq(ltbtmp-5))
          endif

*---- Set up buffer key bank for new segement.
          iq(ltbtmp-5) = iseg
          ikey = iq(lq(ltab(1)-mtbsky)+iseg)
          if (ikey .ne. 0) then
            call tbread(ltbtmp, ikey)
          else
            call uzero(q, ltbtmp + 1, ltbtmp + iq(ltab(1)+mtbrow))
          endif
          ifrst = ltbtmp - iq(ltab(1)+mtbrow)
          ilast = ltbtmp - 1
          call uzero(lq, ifrst, ilast)
        endif
      endif

      end
+dk tbset
      subroutine tbset(ltab, irow, iflag, lbuf)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Make sure that a table line is accessible.                         *
* Input:                                                               *
*   LTAB(1)   (pointer) Table manager bank.                            *
*   IROW      (integer) Number of table line desired.                  *
*   IFLAG     (integer) Operation type flag:                           *
*                       1: read, 2: update, 3: write.                  *
* Output:                                                              *
*   LBUF(1)   (pointer) Buffer bank.                                   *
*----------------------------------------------------------------------*
+ca aparam
      integer iflag,ifrst,ikey,ilast,ileng,iold,irow,jbit
      integer           ltab(*), lbuf(*)
+ca memdum
+ca message
+ca tbpara

      logical           ok
      character*(mcnam) tnam

*---- Check validity of table.
      call tbchck('TBSET ', ltab, ok)
      if (ok) then

*---- Is table open?
        call uhtoc(q(ltab(1)+mtbnam), mcwrd, tnam, mcnam)
        call utleng(tnam, ileng)
        if (jbit(iq(ltab(1)),mtbact) .eq. 0) then
          msg(1) = 'Table buffer "' // tnam(1:ileng)
     +    // '" is not active.'
          call aafail('TBSET', 1, msg)
          lbuf(1) = 0

*---- Is position number in range?
        else if (irow .le. 0  .or.  irow .gt. iq(ltab(1)+mtbrow)) then
          call uhtoc(q(ltab(1)+mtbnam), mcwrd, tnam, mcnam)
          write (msg, 910) tnam(1:ileng), irow
  910     format('Table buffer "',a,'" has no row no. ',i10)
          call aafail('TBSET', 1, msg)
          lbuf(1) = 0

*---- Do we have to allocate a buffer?
        else
          lbuf(1) = lq(lq(ltab(1)-mtbbky)-irow)
          if (lbuf(1) .eq. 0) then

*---- Does the row exist for read?
            ikey = iq(lq(ltab(1)-mtbbky)+irow)
            if (iflag .ne. 1  .or.  ikey .ne. 0) then

*---- Take first buffer in queue and link it to end of queue.
              lbuf(1) = lq(ltab(1)-mtbfst)
              if (lbuf(1) .ne. lq(ltab(1)-mtblst)) then
                call zshunt(0, lbuf, lq(ltab(1)-mtblst), 0, 0)
                lq(ltab(1)-mtblst) = lbuf(1)
              endif

*---- If buffer is modified, write it out.
              if (jbit(iq(lbuf(1)),mtbmod) .ne. 0) then
                call tbwrit(lbuf, lq(ltab(1)-mtbbky), iq(lbuf(1)-5))
              endif

*---- Relink buffer to proper position in buffer pointer bank.
              iold = iq(lbuf(1)-5)
              if (iold .ne. 0) lq(lq(ltab(1)-mtbbky)-iold) = 0
              lq(lq(ltab(1)-mtbbky)-irow) = lbuf(1)
              iq(lbuf(1)-5) = irow

*---- Initialize buffer.
              if (iflag .le. 2  .and.  ikey .ne. 0) then
                call tbread(lbuf, ikey)
              else
                ifrst = lbuf(1) + 1
                ilast = lbuf(1) + iq(lbuf(1)-1)
                call uzero(q, ifrst, ilast)
              endif
            endif
          endif

*---- Update or write: Mark buffer as modified.
          if (iflag .ge. 2) then
            call sbit1(iq(lbuf(1)), mtbmod)

*---- Write: Clear buffer.
            if (iflag .eq. 3) then
              ifrst = lbuf(1) + 1
              ilast = lbuf(1) + iq(lbuf(1)-1)
              call uzero(q, ifrst, ilast)
            endif
          endif
        endif
      endif

      end
+dk tbwrit
      subroutine tbwrit(lbuf, lkey, ipos)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Write out a table line buffer.                                     *
*   Internal routine for table manager, not to be called directly.     *
* Input:                                                               *
*   LBUF(1)   (pointer) Buffer bank to be written.                     *
*   LKEY(1)   (pointer) Key bank.                                      *
*   IPOS      (integer) Position of key in key bank.                   *
*                       If non-zero on input, overwriting occurs.      *
*----------------------------------------------------------------------*
+ca aparam
      integer ikey,ileng,ipos,iret,nwid
      integer           lbuf(*), lkey(*)
+ca memdum
+ca message
+ca tbpara

      character*(mcnam) tnam

*---- Write buffer.
      nwid = iq(lbuf(1)-1)
      ikey = iq(lkey(1)+ipos)
      call tboutp(ikey, nwid, iq(lbuf(1)+1), iret)

*---- Error message required?
      if (iret .ne. 0) then
        call uhtoc(q(lq(lbuf(1)+1)+mtbnam), mcwrd, tnam, mcnam)
        call utleng(tnam, ileng)
        msg(1)(1:33) = 'Writing "' // tnam(1:ileng) // '",'
        if (iret .eq. 1) then
          msg(1)(34:) = 'Invalid key.'
        else if (iret .eq. 2) then
          msg(1)(34:) = 'Unable to write.'
        else if (iret .eq. 3) then
          msg(1)(34:) = 'Write error.'
        else
          msg(1)(34:) = 'Record length error.'
        endif
        call aafail('TBWRIT', 2, msg)

*---- Mark key bank as modified.
      else if (iq(lkey(1)+ipos) .eq. 0) then
        iq(lkey(1)+ipos) = ikey
        call sbit1(iq(lkey(1)),mtbmod)
      endif

      end
+dk tbwtfs
      subroutine tbwtfs(tnam, iunit)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Write a complete table in TFS format (ASCII or EBCDIC).            *
* Input:                                                               *
*   TNAM      (char)    Name of table to be written.                   *
*   IUNIT     (integer) Logical unit number to be written.             *
*----------------------------------------------------------------------*
+ca aparam
      integer iform,il,ileng,ipos,iunit,jcol,jleng,jrow,jseg,leng,lfm,
     +lnm,lps,ncol,nrow,nseg
      double precision rval
      character*(mcnam) tnam
+ca memdum
+ca mchpar
+ca option
+ca tbcomm
+ca tbhead
+ca tbpara

      character*(mcnam) tname, xname
      character*99      sval
      logical           eflag

*---- Open table.
      call tbopen(tnam, 1, ltbtab)
      if (ltbtab .eq. 0) go to 9999

*---- Prepare column header lines and compute record length.
      lnm = lq(ltbtab-mtbcnm)
      lfm = lq(ltbtab-mtbcfm)
      ncol = iq(ltbtab+mtbcol)
      call ncopy(iq(lfm+1), icfrm, ncol)
      do 10 jcol = 1, ncol
        cname(jcol) = ' '
        call uhtoc(q(lnm+1), mcwrd, cname(jcol), mcnam)
        lnm = lnm + mwnam
        call utleng(cname(jcol), leng)
        if (icfrm(jcol) .eq. 1) then
          cform(jcol) = '%hd'
          iclen(jcol) = max(leng,8)
        else if (icfrm(jcol) .eq. 2) then
          cform(jcol) = '%hd'
          iclen(jcol) = max(leng,8)
        else if (icfrm(jcol) .eq. 3) then
          if (double) then
            cform(jcol) = '%le'
            iclen(jcol) = max(leng,20)
          else
            cform(jcol) = '%e'
            iclen(jcol) = max(leng,14)
          endif
        else if (icfrm(jcol) .eq. 4) then
          cform(jcol) = '%le'
          iclen(jcol) = max(leng,20)
        else if (icfrm(jcol) .eq. 5) then
          write (cform(jcol), '(''%'',I2.2,''s'')') mcnam
          iclen(jcol) = mcnam+2
        endif
   10 continue

*---- Write column header lines.
      write (iunit, 960) (cname(jcol)(1:iclen(jcol)), jcol = 1, ncol)
      write (iunit, 970) (cform(jcol)(1:iclen(jcol)), jcol = 1, ncol)

*---- Write table descriptor lines.
      ltbdsc = lq(ltbtab-mtbdsc)
   20 if (ltbdsc .ne. 0) then
        call uhtoc(q(ltbdsc+2), mcwrd, tname, mcnam)
        iform = mod(iq(ltbdsc+mwnam+2),16)
        if (iform .eq. 1) then
          if (iq(ltbdsc+mwnam+3) .eq. intmax) then
            write (iunit, 900) tname, '%hd '
          else
            write (iunit, 910) tname, '%hd ', iq(ltbdsc+mwnam+3)
          endif
        else if (iform .eq. 2) then
          if (iq(ltbdsc+mwnam+3) .eq. intmax) then
            write (iunit, 900) tname, '%hd '
          else
            write (iunit, 910) tname, '%hd ', iq(ltbdsc+mwnam+3)
          endif
        else if (iform .eq. 3) then
          if (q(ltbdsc+mwnam+3) .gt. 0.9 * fltmax) then
            write (iunit, 900) tname, '%e  '
          else if (double) then
            write (iunit, 930) tname, '%le ', q(ltbdsc+mwnam+3)
          else
            write (iunit, 920) tname, '%e  ', q(ltbdsc+mwnam+3)
          endif
        else if (iform .eq. 4) then
          call ucopy(q(ltbdsc+mwnam+3), rval, 2)
          if (rval .gt. 0.9 * fltmax) then
            write (iunit, 900) tname, '%le '
          else
            write (iunit, 930) tname, '%le ', rval
          endif
        else if (iform .eq. 5) then
          ileng = mcwrd * (iq(ltbdsc+mwnam+2) / 16)
          call uhtoc(q(ltbdsc+mwnam+3), mcwrd, sval, ileng)
          if (sval(1:ileng) .eq. '~') then
            write (iunit, 940) tname, ileng
          else
            call utleng(sval(1:ileng), jleng)
            write (iunit, 950) tname, ileng, sval(1:jleng)
          endif
        endif
        ltbdsc = lq(ltbdsc)
        go to 20
      endif

*---- Output table lines.
      nrow = iq(ltbtab+mtbrow)
      nseg = iq(ltbtab+mtbseg)
      lps = lq(ltbtab-mtbcps)
      do 90 jseg = 1, nseg
        call tbseg(ltbtab, jseg, eflag)
        if (.not. eflag) then
          if (nseg .gt. 1) write (iunit, 980) jseg, nseg, nrow
          do 80 jrow = 1, nrow
            call tbset(ltbtab, jrow, 1, ltbbuf)
            if (ltbbuf .ne. 0) then
              do 70 jcol = 1, ncol
                iform = icfrm(jcol)
                ipos = iq(lps+jcol)
                if (iform .le. 2) then
                  if (iq(ltbbuf+ipos+1) .eq. intmax) then
                    cname(jcol) = '       ~'
                  else
                    write (cname(jcol), '(I8)') iq(ltbbuf+ipos+1)
                  endif
                else if (iform .eq. 3) then
                  if (q(ltbbuf+ipos+1) .gt. 0.9 * fltmax) then
                    cname(jcol) = '   ~'
                  else if (double) then
                    write (cname(jcol), '(G20.12)') q(ltbbuf+ipos+1)
                  else
                    write (cname(jcol), '(G14.6)') q(ltbbuf+ipos+1)
                  endif
                else if (iform .eq. 4) then
                  call ucopy(q(ltbbuf+ipos+1), rval, 2)
                  if (rval .gt. 0.9 * fltmax) then
                    cname(jcol) = '   ~'
                  else
                    write (cname(jcol), '(G20.12)') rval
                  endif
                else if (iform .eq. 5) then
                  call uhtoc(q(ltbbuf+ipos+1), mcwrd, xname, mcnam)
                  call utleng(xname, il)
                  cname(jcol) = '"' // xname(1:il) // '"'
                endif
   70         continue
              write (iunit, 990)
     +          (cname(jcol)(1:iclen(jcol)), jcol = 1, ncol)
            endif
   80     continue
        endif
   90 continue

*---- Close TFS table.
      call tbclos(ltbtab)

  900 format('@ ',a,' ',a4,' ~')
  910 format('@ ',a,' ',a4,' ',i8)
  920 format('@ ',a,' ',a4,' ',g12.6)
  930 format('@ ',a,' ',a4,' ',g20.12)
  940 format('@ ',a,' %',i2.2,'s ~')
  950 format('@ ',a,' %',i2.2,'s "',a,'"')
  960 format('*',50(' ',a:))
  970 format('$',50(' ',a:))
  980 format('!Segment',3i8)
  990 format(' ',50(' ',a:))

 9999 end
+dk tbzzzz
+dk tmaaaa
+dk tmali1
      subroutine tmali1(ipos, fsec, orb1, orb2, rm, tm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for orbit displacement at entry of an element.       *
* Input:                                                               *
*   IPOS      (integer) Position in beam line (not used).              *
*   FSEC      (logical) If true, return second order terms.            *
*   ORB1(6)   (real)    Orbit before misalignment.                     *
* Output:                                                              *
*   ORB2(6)   (real)    Orbit after misalignment.                      *
*   RM(6,6)   (real)    First order transfer matrix w.r.t. orbit.      *
*   TM(6,6,6) (real)    Second order terms.                            *
* Important common data:                                               *
*   LCALI     /REFER/   Current misalignment pointer.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer ipos
      double precision d,ds,dx,dy,orb1,orb2,orbt,phi,psi,rm,s2,the,tm,w
      logical           fsec
      dimension         orb1(6), orb2(6), rm(6,6), tm(6,6,6)
+ca memdum
+ca beam
+ca refer

      dimension         d(6), w(3,3), orbt(6)

*---- Build rotation matrix and compute additional drift length.
      call ucopy(q(lcali+1), d, 6*mwflt)
      dx  = d(1)
      dy  = d(2)
      ds  = d(3)
      the = d(5)
      phi = d(4)
      psi = d(6)
      call sumtrx(the, phi, psi, w)
      s2 = (w(1,3) * dx + w(2,3) * dy + w(3,3) * ds) / w(3,3)

*---- F2 terms (transfer matrix).
      call m66one(rm)
      rm(2,2) = w(1,1)
      rm(2,4) = w(2,1)
      rm(2,6) = w(3,1) / betas
      rm(4,2) = w(1,2)
      rm(4,4) = w(2,2)
      rm(4,6) = w(3,2) / betas

      rm(1,1) =   w(2,2) / w(3,3)
      rm(1,2) = rm(1,1) * s2
      rm(1,3) = - w(1,2) / w(3,3)
      rm(1,4) = rm(1,3) * s2
      rm(3,1) = - w(2,1) / w(3,3)
      rm(3,2) = rm(3,1) * s2
      rm(3,3) =   w(1,1) / w(3,3)
      rm(3,4) = rm(3,3) * s2
      rm(5,1) = w(1,3) / (w(3,3) * betas)
      rm(5,2) = rm(5,1) * s2
      rm(5,3) = w(2,3) / (w(3,3) * betas)
      rm(5,4) = rm(5,3) * s2
      rm(5,6) = - s2 / (betas * gammas)**2

*---- Second-order effects are ignored (coefficients all of order 1).
      if (fsec) then
        call uzero(tm, 1, 216*mwflt)
      endif

*---- Track orbit.
      call m66byv(rm, orb1, orbt)
      orb2(1) = orbt(1) - (w(2,2) * dx - w(1,2) * dy) / w(3,3)
      orb2(2) = orbt(2) + w(3,1)
      orb2(3) = orbt(3) - (w(1,1) * dy - w(2,1) * dx) / w(3,3)
      orb2(4) = orbt(4) + w(3,2)
      orb2(5) = orbt(5) - s2 / betas
      orb2(6) = orbt(6)

      end
+dk tmali2
      subroutine tmali2(ipos, fsec, orb1, orb2, rm, tm)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for orbit displacement at exit of an element.        *
* Input:                                                               *
*   IPOS      (integer) Position in beam line.                         *
*   FSEC      (logical) If true, return second order terms.            *
*   ORB1(6)   (real)    Orbit before misalignment.                     *
* Output:                                                              *
*   ORB2(6)   (real)    Orbit after misalignment.                      *
*   RM(6,6)   (real)    First order transfer matrix w.r.t. orbit.      *
*   TM(6,6,6) (real)    Second order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank (used in SUELEM).         *
*   LCALI     /REFER/   Current misalignment pointer.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer ipos
      double precision arc,d,ds,dx,dy,el,orb1,orb2,orbt,phi,psi,rm,s2,
     +the,tm,v,ve,w,we
      logical           fsec
      dimension         orb1(6), orb2(6), rm(6,6), tm(6,6,6)
+ca memdum
+ca bankhead
+ca prcgroup
+ca beam
+ca refer

      dimension         d(6), v(3), ve(3), w(3,3), we(3,3), orbt(6)

*---- Misalignment rotation matrix w.r.t. entrance system.
      call ucopy(q(lcali+1), d, 6*mwflt)
      dx  = d(1)
      dy  = d(2)
      ds  = d(3)
      the = d(5)
      phi = d(4)
      psi = d(6)
      call sumtrx(the, phi, psi, w)

*---- VE and WE represent the change of reference.
      if (iq(lcelm+mbpr) .eq. mplin) then
        call suline(ipos, el, arc, ve, we)
      else
        call suelem(el, arc, ve, we)
      endif

*---- Misalignment displacements at exit w.r.t. entrance system.
      v(1) = dx + w(1,1)*ve(1)+w(1,2)*ve(2)+w(1,3)*ve(3)-ve(1)
      v(2) = dy + w(2,1)*ve(1)+w(2,2)*ve(2)+w(2,3)*ve(3)-ve(2)
      v(3) = ds + w(3,1)*ve(1)+w(3,2)*ve(2)+w(3,3)*ve(3)-ve(3)

*---- Convert all references to exit, build additional drift.
      call sutran(w, v, we)
      s2 = - (w(1,3) * v(1) + w(2,3) * v(2) + w(3,3) * v(3)) / w(3,3)

*---- Transfer matrix.
      call m66one(rm)
      rm(1,1) = w(1,1)
      rm(3,1) = w(2,1)
      rm(5,1) = w(3,1) / betas
      rm(1,3) = w(1,2)
      rm(3,3) = w(2,2)
      rm(5,3) = w(3,2) / betas

      rm(2,2) =   w(2,2) / w(3,3)
      rm(1,2) = rm(2,2) * s2
      rm(4,2) = - w(1,2) / w(3,3)
      rm(3,2) = rm(4,2) * s2
      rm(2,4) = - w(2,1) / w(3,3)
      rm(1,4) = rm(2,4) * s2
      rm(4,4) =   w(1,1) / w(3,3)
      rm(3,4) = rm(4,4) * s2
      rm(2,6) = w(1,3) / (w(3,3) * betas)
      rm(1,6) = rm(2,6) * s2
      rm(4,6) = w(2,3) / (w(3,3) * betas)
      rm(3,6) = rm(4,6) * s2
      rm(5,6) = - s2 / (betas * gammas)**2

*---- Second-order effects are ignored (coefficients all of order 1).
      if (fsec) then
        call uzero(tm, 1, 216*mwflt)
      endif

*---- Track orbit.
      orbt(1) = orb1(1) + (w(2,2) * v(1) - w(1,2) * v(2)) / w(3,3)
      orbt(2) = orb1(2) - w(3,1)
      orbt(3) = orb1(3) + (w(1,1) * v(2) - w(2,1) * v(1)) / w(3,3)
      orbt(4) = orb1(4) - w(3,2)
      orbt(5) = orb1(5) - s2 / betas
      orbt(6) = orb1(6)
      call m66byv(rm, orbt, orb2)

      end
+dk tmarb
      subroutine tmarb(fsec, ftrk, orbit, fmap, el, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for arbitrary element.                               *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer i1,i2
      double precision ek,el,orbit,re,te
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6)
+ca refer

*---- Initialize.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)

*---- Length of element.
      fmap = .true.
      el = 0.0
      i2 = 2
      call utgflt(lcelm, i2, i2, el)

*---- Clear element kick, and replace given elements.
      i1 = i2 + 1
      i2 = i2 + 6
      call utgflt(lcelm, i1, i2, ek)

*---- Set unit matrix, and replace given elements.
      i1 = i2 + 1
      i2 = i2 + 36
      call utgflt(lcelm, i1, i2, re)

*---- Second order terms, clear all and replace given elements.
      if (fsec) then
        call uzero(te, 1, 216*mwflt)
        i1 = i2 + 1
        i2 = i2 + 216
        call utgflt(lcelm, i1, i2, te)
      endif

*---- Track orbit.
      fmap = .true.
      if (ftrk) call tmtrak(ek, re, te, orbit, orbit)

      end
+dk tmbb
      subroutine tmbb(fsec, ftrk, parvec, orbit, fmap, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* purpose:
*   transport map for beam-beam element.
* input:
*   fsec      (logical) must be .true. for this purpose
*   ftrk      (logical) must be true for this purpose
*   parvec    (double)  BB element parameter vector:
*                       1:  sigma_x [m]
*                       2:  sigma_y [m]
*                       3:  x_offset [m]
*                       4:  y_offset [m]
*                       5:  classical particle radius [m]
*                       6:  total bunch charge [electron charges] of
*                           opposite beam
*                       7:  gamma = E / (m c^2)
* input/output:
*   orbit(6)  (double)  closed orbit (only kick is added since BB thin)
* output:
*   fmap      (logical) true if map calculated
*   ek(6)     (double)  kick due to element.
*   re(6,6)   (double)  transfer matrix.
*   te(6,6,6) (double)  second-order terms.
*----------------------------------------------------------------------*
+ca aparam
+ca bbcomm
+ca option
      logical fsec, ftrk, fmap
      double precision parvec(*), orbit(*), ek(*), re(6,*), te(6,6,*)
      double precision zero, one, two, three, explim, pi
      parameter (zero = 0.d0, one = 1.0d0, two = 2.0d0, three = 3.0d0)
*     if x > explim, exp(-x) is outside machine limits.
      parameter         (explim = 150.0d0)
      integer i, j, k
      double precision sx, sy, xm, ym, sx2, sy2, xs, ys, rho2, fk, tk,
     +exk,phix, phiy, rho4, phixx, phixy, phiyy, rho6, rk, exkc, xb, yb,
     +phixxx, phixxy, phixyy, phiyyy, crx, cry, xr, yr, r, r2, cbx, cby
*---- initialize.
      if (bbd_flag .ne. 0 .and. .not. bborbit)  then
        if (bbd_cnt .eq. bbd_max)  then
          call aawarn('TMBB', 1, 'maximum bb number reached')
        else
          bbd_cnt = bbd_cnt + 1
          bbd_loc(bbd_cnt) = bbd_pos
          bb_kick(1,bbd_cnt) = zero
          bb_kick(2,bbd_cnt) = zero
        endif
      endif
      fmap = .true.
      pi = 3.141592653589793d0
      do i = 1, 6
        ek(i) = zero
        do j = 1, 6
          re(j,i) = zero
          if (fsec)  then
            do k = 1, 6
              te(k,j,i) = zero
            enddo
          endif
        enddo
        re(i,i) = one
      enddo
      sx = parvec(1)
      sy = parvec(2)
      xm = parvec(3)
      ym = parvec(4)
      fk = two * parvec(5) * parvec(6) / parvec(7)
      if (fk .ne. zero)  then
*---- if tracking is desired ...
        if (ftrk) then
          sx2 = sx * sx
          sy2 = sy * sy
          xs  = orbit(1) - xm
          ys  = orbit(3) - ym

*---- limit formulas for sigma(x) = sigma(y).
          if (abs(sx2 - sy2) .le. 1.0d-3 * (sx2 + sy2)) then
            rho2 = xs * xs + ys * ys

*---- limit case for xs = ys = 0.
            if (rho2 .eq. zero) then
              re(2,1) = fk / (two * sx2)
              re(4,3) = fk / (two * sx2)

*---- general case.
            else
              tk = rho2 / (two * sx2)
              if (tk .gt. explim) then
                exk  = zero
                exkc = one
                phix = xs * fk / rho2
                phiy = ys * fk / rho2
              else
                exk  = exp(-tk)
                exkc = one - exk
                phix = xs * fk / rho2 * exkc
                phiy = ys * fk / rho2 * exkc
              endif

*---- orbit kick - only applied if option bborbit (HG 5/12/01), 
*     else stored
              if (bborbit) then
                orbit(2) = orbit(2) + phix
                orbit(4) = orbit(4) + phiy
              elseif (bbd_flag .ne. 0)  then
                bb_kick(1,bbd_cnt) = phix
                bb_kick(2,bbd_cnt) = phiy
              endif
*---- first-order effects.
              rho4 = rho2 * rho2
              phixx = fk * (- exkc * (xs*xs - ys*ys) / rho4
     +                      + exk * xs*xs / (rho2 * sx2))
              phixy = fk * (- exkc * two * xs * ys / rho4
     +                      + exk * xs*ys / (rho2 * sx2))
              phiyy = fk * (+ exkc * (xs*xs - ys*ys) / rho4
     +                      + exk * ys*ys / (rho2 * sx2))
              re(2,1) = phixx
              re(2,3) = phixy
              re(4,1) = phixy
              re(4,3) = phiyy

*---- second-order effects.
              if (fsec) then
                rho6 = rho4 * rho2
                phixxx = fk*xs * (+ exkc * (xs*xs - three*ys*ys) / rho6
     +            - exk * (xs*xs - three*ys*ys) / (two * rho4 * sx2)
     +            - exk * xs*xs / (two * rho2 * sx2**2))
                phixxy = fk*ys * (+ exkc * (three*xs*xs - ys*ys) / rho6
     +            - exk * (three*xs*xs - ys*ys) / (two * rho4 * sx2)
     +            - exk * xs*xs / (two * rho2 * sx2**2))
                phixyy = fk*xs * (- exkc * (xs*xs - three*ys*ys) / rho6
     +            + exk * (xs*xs - three*ys*ys) / (two * rho4 * sx2)
     +            - exk * ys*ys / (two * rho2 * sx2**2))
                phiyyy = fk*ys * (- exkc * (three*xs*xs - ys*ys) / rho6
     +            + exk * (three*xs*xs - ys*ys) / (two * rho4 * sx2)
     +            - exk * ys*ys / (two * rho2 * sx2**2))
                te(2,1,1) = phixxx
                te(2,1,3) = phixxy
                te(2,3,1) = phixxy
                te(4,1,1) = phixxy
                te(2,3,3) = phixyy
                te(4,1,3) = phixyy
                te(4,3,1) = phixyy
                te(4,3,3) = phiyyy
              endif
            endif

*---- case sigma(x) > sigma(y).
          else
            r2 = two * (sx2 - sy2)
            if (sx2 .gt. sy2) then
              r  = sqrt(r2)
              rk = fk * sqrt(pi) / r
              xr = abs(xs) / r
              yr = abs(ys) / r
              call cperrf(xr, yr, crx, cry)
              tk = (xs * xs / sx2 + ys * ys / sy2) / two
              if (tk .gt. explim) then
                exk = 0.0
                cbx = 0.0
                cby = 0.0
              else
                exk = exp(-tk)
                xb  = (sy / sx) * xr
                yb  = (sx / sy) * yr
                call cperrf(xb, yb, cbx, cby)
              endif

*---- case sigma(x) < sigma(y).
            else
              r  = sqrt(-r2)
              rk = fk * sqrt(pi) / r
              xr = abs(xs) / r
              yr = abs(ys) / r
              call cperrf(yr, xr, cry, crx)
              tk = (xs * xs / sx2 + ys * ys / sy2) / two
              if (tk .gt. explim) then
                exk = 0.0
                cbx = 0.0
                cby = 0.0
              else
                exk = exp(-tk)
                xb  = (sy / sx) * xr
                yb  = (sx / sy) * yr
                call cperrf(yb, xb, cby, cbx)
              endif
            endif

            phix = rk * (cry - exk * cby) * sign(one, xs)
            phiy = rk * (crx - exk * cbx) * sign(one, ys)
*---- orbit kick - only applied if option bborbit (HG 5/12/01), 
*     else stored
            if (bborbit) then
              orbit(2) = orbit(2) + phix
              orbit(4) = orbit(4) + phiy
            elseif (bbd_flag .ne. 0)  then
              bb_kick(1,bbd_cnt) = phix
              bb_kick(2,bbd_cnt) = phiy
            endif

*---- first-order effects.
            phixx = (two / r2) * (- (xs * phix + ys * phiy)
     +                            + fk * (one - (sy / sx) * exk))
            phixy = (two / r2) * (- (xs * phiy - ys * phix))
            phiyy = (two / r2) * (+ (xs * phix + ys * phiy)
     +                            - fk * (one - (sx / sy) * exk))
            re(2,1) = phixx
            re(2,3) = phixy
            re(4,1) = phixy
            re(4,3) = phiyy

*---- second-order effects.
            if (fsec) then
              phixxx = (- phix - (xs * phixx + ys * phixy)
     +                  + fk * xs * sy * exk / sx**3) / r2
              phixxy = (- phiy - (xs * phixy - ys * phixx)) / r2
              phixyy = (+ phix - (xs * phiyy - ys * phixy)) / r2
              phiyyy = (+ phiy + (xs * phixy + ys * phiyy)
     +                  - fk * ys * sx * exk / sy**3) / r2
              te(2,1,1) = phixxx
              te(2,1,3) = phixxy
              te(2,3,1) = phixxy
              te(4,1,1) = phixxy
              te(2,3,3) = phixyy
              te(4,1,3) = phixyy
              te(4,3,1) = phixyy
              te(4,3,3) = phiyyy
            endif
          endif

*---- no tracking desired.
        else
          re(2,1) = fk / (sx * (sx + sy))
          re(4,3) = fk / (sy * (sx + sy))
        endif
      endif
      end
+dk tmbend
      subroutine tmbend(fsec, ftrk, orbit, fmap, el, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for bending magnets of all types.                    *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EL        (real)    Element length.                                *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer isp,nd,i,j
      double precision an,corr,ct,dh,e1,e2,ek,ek0,el,field,fint,h,h1,h2,
     +hgap,hx,hy,one,orbit,pt,re,rfac,rw,sk1,sk2,sks,st,te,three,tilt,
     +tw,two,x,y
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6)
      double precision an2
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca option
+ca refer
+ca stflag
+ca tmcomm
+ca synch
      double precision fintx
      logical bvflag

      parameter         (one = 1.0d0, two = 2.0d0, three = 3.0d0)

      dimension         field(2,0:2)
      dimension         ek0(6), rw(6,6), tw(6,6,6)

      bvflag = .false.
*---- Test for non-zero length.
      call ucopy(q(lcelm+melen),  el,   mwflt)
      fmap = el .ne. 0.0
      if (fmap) then
        isp = iq(lcelm+mbsp)

*---- RBEND or SBEND.
        if (isp .ne. 26) then
          call ucopy(q(lcelm+meangb), an, mwflt)
          call ucopy(q(lcelm+metltb), tilt, mwflt)
          call ucopy(q(lcelm+mek1b), sk1, mwflt)
          call ucopy(q(lcelm+mee1b), e1, mwflt)
          call ucopy(q(lcelm+mee2b), e2, mwflt)
          call ucopy(q(lcelm+mek2b), sk2, mwflt)
          call ucopy(q(lcelm+meh1b), h1, mwflt)
          call ucopy(q(lcelm+meh2b), h2, mwflt)
          call ucopy(q(lcelm+megapb), hgap, mwflt)
          call ucopy(q(lcelm+meintb), fint, mwflt)
          call ucopy(q(lcelm+meintbx+3*mcsiz), bvflag, 1)
          call ucopy(q(lcelm+meintbx), fintx, mwflt)
          sks = 0.0

*---- GBEND.
        else
          call ucopy(q(lcelm+meangg), an, mwflt)
          call ucopy(q(lcelm+metltg), tilt, mwflt)
          call ucopy(q(lcelm+mek1g), sk1, mwflt)
          call ucopy(q(lcelm+mee1g), e1, mwflt)
          call ucopy(q(lcelm+mee2g), e2, mwflt)
          call ucopy(q(lcelm+meksg), sks, mwflt)
          call ucopy(q(lcelm+meh1g), h1, mwflt)
          call ucopy(q(lcelm+meh2g), h2, mwflt)
          call ucopy(q(lcelm+megapg), hgap, mwflt)
          call ucopy(q(lcelm+meintg), fint, mwflt)
          call ucopy(q(lcelm+meintgx), fintx, mwflt)
          call ucopy(q(lcelm+meintgx+3*mcsiz), bvflag, 1)
          sk2 = 0.0
        endif
*--- HG000915 use bv flag to possibly invert angle
        if (bvflag) an = beambv * an
        if (isp .eq. 2) then
*--- HG001026: arc length to rectangular bend
          an2 = an / 2.d0
          if (an2 .ne. 0.d0 .and. rbarc)  el = el * an2 / sin(an2)
          e1 = e1 + an2
          e2 = e2 + an2
        endif
        h = an / el

*---- Fetch field errors and change coefficients using DELTAS.
        if (lcfld .ne. 0) then
          nd = min(6*mwflt,iq(lcfld-1))
          call uzero(field, 1, 6*mwflt)
          call ucopy(q(lcfld+1), field, nd)
*--- HG000915 use bv flag to possibly invert angle
          if (bvflag) field(1,0) = beambv * field(1,0)
          dh = (- h * deltas + field(1,0) / el) / (one + deltas)
          sk1 = (sk1 + field(1,1) / el) / (one + deltas)
          sk2 = (sk2 + field(1,2) / el) / (one + deltas) * cohelp
          sks = (sks + field(2,1) / el) / (one + deltas) * cohelp
        else
          dh = - h * deltas / (one + deltas)
          sk1 = sk1 / (one + deltas)
          sk2 = sk2 / (one + deltas) * cohelp
          sks = sks / (one + deltas) * cohelp
        endif
*--- apply inversion and scaling
        sk1 = sk1 * elmfact(1)
        sks = sks * elmfact(1)
        sk2 = sk2 * elmfact(2)

*---- Half radiation effects at entrance.
        if (ftrk .and. dorad) then
          ct = cos(tilt)
          st = sin(tilt)
          x =   orbit(1) * ct + orbit(3) * st
          y = - orbit(1) * st + orbit(3) * ct
          hx = h + dh + sk1*(x - h*y**2/two) + sks*y +
     +         sk2*(x**2 - y**2)/two
          hy = sks * x - sk1*y - sk2*x*y
          rfac = (arad * gammas**3 * el / three)
     +         * (hx**2 + hy**2) * (one + h*x) * (one - tan(e1)*x)
          pt = orbit(6)
          orbit(2) = orbit(2) - rfac * (one + pt) * orbit(2)
          orbit(4) = orbit(4) - rfac * (one + pt) * orbit(4)
          orbit(6) = orbit(6) - rfac * (one + pt) ** 2
        endif

*---- Body of the dipole.
        if (isp .ne. 26) then
          call tmsect(.true., el, h, dh, sk1, sk2, ek, re, te)
        else
          call tmgsec(.true., el, h, dh, sk1, sks, ek, re, te)
        endif

*---- Fringe fields.
        corr = (h + h) * hgap * fint
        call tmfrng(.true., h, sk1, e1, h1, +one, corr, ek0, rw, tw)
        call tmcat1(.true., ek, re, te, ek0, rw, tw, ek, re, te)
*---- Tor: use FINTX if set
        if (fintx .gt. 0) then
          corr = (h + h) * hgap * fintx
        else
          corr = (h + h) * hgap * fint
        endif
        call tmfrng(.true., h, sk1, e2, h2, -one, corr, ek0, rw, tw)
        call tmcat1(.true., ek0, rw, tw, ek, re, te, ek, re, te)

*---- Apply tilt.
        if (tilt .ne. 0.0) then
          call tmtilt(.true., tilt, ek, re, te)
          cplxy = .true.
        endif

*---- Track orbit.
        if (ftrk) then
          call tmtrak(ek, re, te, orbit, orbit)

*---- Half radiation effects at exit.
          if (dorad) then
            x =   orbit(1) * ct + orbit(3) * st
            y = - orbit(1) * st + orbit(3) * ct
            hx = h + dh + sk1*(x - h*y**2/two) + sks*y +
     +           sk2*(x**2 - y**2)/two
            hy = sks * x - sk1*y - sk2*x*y
            rfac = (arad * gammas**3 * el / three)
     +           * (hx**2 + hy**2) * (one + h*x) * (one - tan(e2)*x)
            pt = orbit(6)
            orbit(2) = orbit(2) - rfac * (one + pt) * orbit(2)
            orbit(4) = orbit(4) - rfac * (one + pt) * orbit(4)
            orbit(6) = orbit(6) - rfac * (one + pt) ** 2
          endif
        endif

*---- Identity map.
      else
        call uzero(ek, 1, 6*mwflt)
        call m66one(re)
        if (fsec) call uzero(te, 1, 216*mwflt)
      endif

*---- Tor: set parameters for sychrotron integral calculations
      rhoinv = h
      blen = el
      end
+dk tmcat
      subroutine tmcat(fsec, rb, tb, ra, ta, rd, td)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Concatenate two TRANSPORT maps.                                    *
*   This routine is time-critical and is carefully optimized.          *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   RB(6,6), TB(6,6,6)  Second map in beam line order.                 *
*   RA(6,6), TA(6,6,6)  First map in beam line order.                  *
* Output:                                                              *
*   RD(6,6), TD(6,6,6)  Result map.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer i1,i2,i3
      double precision ra,rb,rd,rw,ta,tb,td,ts,tw
      logical           fsec
      dimension         rb(6,6), tb(36,6), ra(6,6), ta(6,6,6)
      dimension         rd(6,6), td(6,6,6)

      dimension         rw(6,6), tw(6,6,6), ts(36,6)

*---- Transfer matrix.
      do 20 i2 = 1, 6
      do 20 i1 = 1, 6
        rw(i1,i2) = rb(i1,1) * ra(1,i2) + rb(i1,2) * ra(2,i2)
     +            + rb(i1,3) * ra(3,i2) + rb(i1,4) * ra(4,i2)
     +            + rb(i1,5) * ra(5,i2) + rb(i1,6) * ra(6,i2)
   20 continue

*---- Second order terms.
      if (fsec) then
        do 40 i3 = 1, 6
        do 40 i1 = 1, 36
          ts(i1,i3) = tb(i1,1) * ra(1,i3) + tb(i1,2) * ra(2,i3)
     +              + tb(i1,3) * ra(3,i3) + tb(i1,4) * ra(4,i3)
     +              + tb(i1,5) * ra(5,i3) + tb(i1,6) * ra(6,i3)
   40   continue

        do 60 i2 = 1, 6
        do 60 i3 = i2, 6
        do 60 i1 = 1, 6
          tw(i1,i2,i3) =
     +        rb(i1,1) * ta(1,i2,i3) + rb(i1,2) * ta(2,i2,i3)
     +      + rb(i1,3) * ta(3,i2,i3) + rb(i1,4) * ta(4,i2,i3)
     +      + rb(i1,5) * ta(5,i2,i3) + rb(i1,6) * ta(6,i2,i3)
     +      + ts(i1,   i2) * ra(1,i3) + ts(i1+ 6,i2) * ra(2,i3)
     +      + ts(i1+12,i2) * ra(3,i3) + ts(i1+18,i2) * ra(4,i3)
     +      + ts(i1+24,i2) * ra(5,i3) + ts(i1+30,i2) * ra(6,i3)
          tw(i1,i3,i2) = tw(i1,i2,i3)
   60   continue
      endif

*---- Copy result.
      call ucopy(rw, rd, 36*mwflt)
      if (fsec) call ucopy(tw, td, 216*mwflt)

      end
+dk tmcat1
      subroutine tmcat1(fsec, eb, rb, tb, ea, ra, ta, ed, rd, td)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Concatenate two TRANSPORT maps including zero-order terms.         *
*   This routine is time-critical and is carefully optimized.          *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   EB(6), RB(6,6), TB(6,6,6)  Second map in beam line order.          *
*   EA(6), RA(6,6), TA(6,6,6)  First map in beam line order.           *
* Output:                                                              *
*   ED(6), RD(6,6), TD(6,6,6)  Result map.                             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ij,j,k
      double precision ea,eb,ed,es,ew,ra,rb,rd,rw,ta,tb,td,ts,tw,two
      logical           fsec
      dimension         eb(6), rb(6,6), tb(36,6)
      dimension         ea(6), ra(6,6), ta(6,6,6)
      dimension         ed(6), rd(6,6), td(6,6,6)

      parameter         (two = 2.0d0)

      dimension         ew(6), rw(6,6), tw(6,6,6), ts(36,6), es(6,6)

*---- Second order terms.
      if (fsec) then

*---- Auxiliary terms.
        do 30 k = 1, 6

*---- Sum over S of TB(I,S,K) * EA(S).
          do 10 i = 1, 6
            es(i,k) = tb(i   ,k) * ea(1) + tb(i+ 6,k) * ea(2)
     +              + tb(i+12,k) * ea(3) + tb(i+18,k) * ea(4)
     +              + tb(i+24,k) * ea(5) + tb(i+30,k) * ea(6)
   10     continue

*---- Sum over S of TB(I,J,S) * RA(S,K).
          do 20 ij = 1, 36
            ts(ij,k) = tb(ij,1) * ra(1,k) + tb(ij,2) * ra(2,k)
     +               + tb(ij,3) * ra(3,k) + tb(ij,4) * ra(4,k)
     +               + tb(ij,5) * ra(5,k) + tb(ij,6) * ra(6,k)
   20     continue
   30   continue

*---- Final values.
        do 90 k = 1, 6

*---- Zero-order terms.
          ew(k) = eb(k) + (rb(k,1) + es(k,1)) * ea(1)
     +                  + (rb(k,2) + es(k,2)) * ea(2)
     +                  + (rb(k,3) + es(k,3)) * ea(3)
     +                  + (rb(k,4) + es(k,4)) * ea(4)
     +                  + (rb(k,5) + es(k,5)) * ea(5)
     +                  + (rb(k,6) + es(k,6)) * ea(6)

*---- First-order terms.
          do 40 j = 1, 6
            rw(j,k) = (rb(j,1) + two * es(j,1)) * ra(1,k)
     +              + (rb(j,2) + two * es(j,2)) * ra(2,k)
     +              + (rb(j,3) + two * es(j,3)) * ra(3,k)
     +              + (rb(j,4) + two * es(j,4)) * ra(4,k)
     +              + (rb(j,5) + two * es(j,5)) * ra(5,k)
     +              + (rb(j,6) + two * es(j,6)) * ra(6,k)
   40     continue

*---- Second-order terms.
          do 60 j = k, 6
            do 50 i = 1, 6
              tw(i,j,k) =
     +          + (rb(i,1)+two*es(i,1))*ta(1,j,k) + ts(i   ,j)*ra(1,k)
     +          + (rb(i,2)+two*es(i,2))*ta(2,j,k) + ts(i+ 6,j)*ra(2,k)
     +          + (rb(i,3)+two*es(i,3))*ta(3,j,k) + ts(i+12,j)*ra(3,k)
     +          + (rb(i,4)+two*es(i,4))*ta(4,j,k) + ts(i+18,j)*ra(4,k)
     +          + (rb(i,5)+two*es(i,5))*ta(5,j,k) + ts(i+24,j)*ra(5,k)
     +          + (rb(i,6)+two*es(i,6))*ta(6,j,k) + ts(i+30,j)*ra(6,k)
              tw(i,k,j) = tw(i,j,k)
   50       continue
   60     continue
   90   continue

*---- Copy second-order terms.
        call ucopy(tw, td, 216*mwflt)

*---- Second-order not desired.
      else
        do 190 k = 1, 6

*---- Zero-order terms.
          ew(k) = eb(k) + rb(k,1) * ea(1) + rb(k,2) * ea(2)
     +                  + rb(k,3) * ea(3) + rb(k,4) * ea(4)
     +                  + rb(k,5) * ea(5) + rb(k,6) * ea(6)

*---- First-order terms.
          do 110 j = 1, 6
            rw(j,k) = rb(j,1) * ra(1,k) + rb(j,2) * ra(2,k)
     +              + rb(j,3) * ra(3,k) + rb(j,4) * ra(4,k)
     +              + rb(j,5) * ra(5,k) + rb(j,6) * ra(6,k)
  110     continue
  190   continue
      endif

*---- Copy zero- and first-order terms.
      call ucopy(ew, ed, 6*mwflt)
      call ucopy(rw, rd, 36*mwflt)

      end
+dk tmclor
      subroutine tmclor(lseq, deltap, show, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find closed orbit for a beam line sequence.                        *
* Input:                                                               *
*   LSEQ(1)   (pointer) Beam line sequence bank.                       *
*   DELTAP    (real)    Relative energy error.                         *
*   SHOW      (logical) Print flag.                                    *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
* Important common data:                                               *
*   ORBIT0(6) /OPTIC0/  Initial conditions for closed orbit, returned. *
*   RT(6,6)   /MAPTRN/  Transfer matrix for (half) superperiod.        *
*----------------------------------------------------------------------*
+ca aparam
      integer i,irank,itmax,itra,k
      double precision a,as,b,bs,cogood,costep,deltap,det,err,guess,one,
     +small,two,zero
      integer           lseq(*)
      logical           show, eflag
+ca memdum
+ca seqgroup
+ca message
+ca beam
+ca coesti
+ca mapelm
+ca maptrn
+ca optic0
+ca optic1
+ca option
+ca stflag
+ca tmcomm
+ca zunit
+ca thrcom

      dimension         a(6,7), b(4,5), as(3,4), bs(2,3)
      equivalence       (a(1,1), b(1,1), as(1,1), bs(1,1))
      dimension         guess(6)
      logical           m66sta, symm
      character*(mcnam) linnam
      character*(mcrng) rngnam
      parameter         (itmax = 50)
      parameter         (one = 1.0d0, zero = 0.0d0, two = 2.0d0)
      parameter         (small = 0.01d0)

*---- Initialize.
      cohelp = one
      costep = one
      cogood = zero
      symm = iq(lseq(1)+msym) .ne. 0
      call uhtoc(q(lseq(1)+msbn), mcwrd, linnam, mcnam)
      call uhtoc(q(lseq(1)+msrn), mcwrd, rngnam, 40)
      if (show) then
        write (iqlog, 910) linnam, rngnam, deltap, symm
        write (iqlog, 920) 0, coest
      endif
  910 format(' '/' TMCLOR.  Searching for closed orbit, beam line: "',
     +       a,'", range: ',a/
     +       t11,'Delta(p)/p =',f12.6,', symmetry = ',l1/
     +       ' Iteration',5x,'x',11x,'px',10x,'y',11x,'py',10x,'t',11x,
     +       'deltap',6x,'error')

*---- Initialize guess.
      eflag = .false.

      call ucopy(coest, guess, 6*mwflt)
*---- Restart with best guess.
   10 continue
      call ucopy(guess, orbit0, 6*mwflt)

*---- Iteration for closed orbit.
      do 300 itra = 1, itmax

*---- Track orbit and transfer matrix.
        call tmfrst(lseq, eflag)
        if (eflag) go to 810
*---- Solve for dynamic case.
        if (docav  .and.  .not. m66sta(rt)) then
          err = 0.0
          if (symm) then
            call aafail('TMCLOR', 1,
     +      'SYMM not allowed with line containing RF cavities'
     +      // ' and/or synchrotron radiation.')
          else
            do 130 i = 1, 6
              do 120 k = 1, 6
                a(i,k) = rt(i,k)
  120         continue
              a(i,i) = a(i,i) - 1.0
              a(i,7) = orbit(i) - orbit0(i)
              err = max(abs(a(i,7)), err)
  130       continue
            call solver(a, 6, 1, irank)
            if (irank .lt. 6) go to 820
            do 140 i = 1, 6
              orbit0(i) = orbit0(i) - a(i,7)
  140       continue
          endif

*---- Solve for static case.
        else
          if (symm) then
            det = rt(2,1) * rt(4,3) - rt(2,3) * rt(4,1)
            orbit0(1) = orbit0(1) -
     +        (rt(4,3) * orbit(2) - rt(2,3) * orbit(4)) / det
            orbit0(3) = orbit0(3) -
     +        (rt(2,1) * orbit(4) - rt(4,1) * orbit(2)) / det
            err = max(abs(orbit(2)),abs(orbit(4)))
          else
            err = 0.0
            do 230 i = 1, 4
              do 220 k = 1, 4
                b(i,k) = rt(i,k)
  220         continue
              b(i,i) = b(i,i) - 1.0
              b(i,5) = orbit(i) - orbit0(i)
              err = max(abs(b(i,5)), err)
  230       continue
            call solver(b, 4, 1, irank)
            if (irank .lt. 4) go to 820
            do 240 i = 1, 4
              orbit0(i) = orbit0(i) - b(i,5)
  240       continue
          endif
        endif

*---- Message and convergence test.
        if (show) write (iqlog, 920) itra, orbit0, err
  920   format(' ',i9,1p,6e14.6,e16.6)
*        print *, ' '
*        print '(1p,6e14.6)', ((rt(k,i),i=1,6),k=1,6)
        if (err .lt. cotol) go to 830
  300 continue

*---- No convergence.
      write (msg(1), 930) itmax
  930 format('Closed orbit did not converge in ',i5,' iterations.')
      costep = costep / two
      go to 850

*---- Overflow problems.
  810 continue
      write (iqlog, 940) itra
  940 format(' An overflow occurred in iteration ',i2,'.')
      if (.not. adcofl)  goto 850
      if (adthfl .or. ndccnt .ne. 0)  then
        if (show)  then
          msg(1) =
     +    'Unable to find closed orbit with threader.'
          call aafail('TMCLOR', 1, msg)
        endif
        goto 981
      else
        adthfl = .true.
        if (show) write (iqlog, *) 'Switching Threader on.'
        goto 10
      endif

*---- Matrix inversion problems.
  820 continue
      msg(1) = 'Singular matrix occurred during closed orbit search.'
      go to 850

*---- Converged with current factor.
  830 continue
      if (cohelp .ge. one) go to 890
      if (costep .le. small) go to 880
      write (msg(1), 950) cohelp
  950 format('Succeeded to find closed orbit for sextupoles reduced to',
     +       2p,f6.2,' percent.')
      call ucopy(orbit0, guess, 6*mwflt)
      cogood = cohelp
      if (itra .eq. 1) then
        costep = costep * two
      else if (itra .gt. 3) then
        costep = costep / two
      endif
      cohelp = min(cogood + costep, one)
      if (show) then
        write (msg(2), 960) cohelp
  960   format('Continuing with sextupoles increased to',
     +       2p,f6.2,' percent.')
        call aainfo('TMCLOR', 2, msg)
      endif
      go to 10

*---- Test for possible restart.
  850 continue
      if (costep .le. small) go to 880
      costep = costep / two
      cohelp = min(cogood + costep, one)
      if (show) then
        write (msg(2), 970) cohelp
  970   format('Restarting with sextupoles reduced to',
     +         2p,f6.2,' percent.')
        call aainfo('TMCLOR', 2, msg)
      endif
      go to 10

*---- Exit with best orbit so far.
  880 continue
      if (show) then
        msg(1) =
     +    'Unable to find closed orbit for full sextupole settings.'
        write (msg(2), 980) cogood
  980   format('The best orbit found had the sextupoles reduced to',
     +         2p,f7.2,' percent.')
        call aafail('TMCLOR', 2, msg)
      endif
  981 continue
      call ucopy(guess, orbit0, 6*mwflt)
      eflag = .true.

*---- Restore closed orbit help factor.
  890 cohelp = one
      if (optflg(20))  call ucopy(orbit0, coest, 6*mwflt)
*---- switch threader off
      adthfl = .false.

      end
+dk tmcorr
      subroutine tmcorr(fsec, ftrk, fract, orbit, fmap, el, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for orbit correctors.                                *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
*   FRACT     (real)    Fraction of length to be used.                 *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EL        (real)    Element length.                                *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer isp
      double precision dl,dpx,dpy,ek,el,ferror,fract,half,one,orbit,pt,
     +re,rfac,rfac2,te,three,two,xkick,ykick
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca codata
+ca refer
+ca stflag
+ca physicpm
      logical bvflag

      parameter         (half   = 0.5d0, one    = 1.0d0)
      parameter         (two    = 2.0d0, three  = 3.0d0)

      dimension         ferror(2)

*---- Initialize.
      bvflag = .false.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)
      if (fsec) call uzero(te, 1, 216*mwflt)

*---- Tracking desired, use corrector map.
      if (ftrk) then

*---- Original setting.
        call ucopy(q(lcelm+melen), el, mwflt)
        dl = el * fract
        isp = iq(lcelm+mbsp)
        if (isp .eq. 14) then
          call ucopy(q(lcelm+mekick), xkick, mwflt)
          call ucopy(q(lcelm+mekick+mcsiz), bvflag, 1)
          ykick = 0.0
        else if (isp .eq. 16) then
          call ucopy(q(lcelm+mekick), ykick, mwflt)
          call ucopy(q(lcelm+mekick+mcsiz), bvflag, 1)
          xkick = 0.0
        else
          call ucopy(q(lcelm+mekick), xkick, mwflt)
          call ucopy(q(lcelm+mekick+mcsiz), ykick, mwflt)
          call ucopy(q(lcelm+mekick+2*mcsiz), bvflag, 1)
        endif
*---- Correction from C.O. correction algorithm.
        if (dokick  .and.  lccom .ne. 0) then
          call ucopy(q(lccom+1), xcm, 2*mwflt)
        else
          xcm = 0.0
          ycm = 0.0
        endif

*---- Field errors.
        if (lcfld .ne. 0) then
          call ucopy(q(lcfld+1), ferror, 2*mwflt)
        else
          ferror(1) = 0.0
          ferror(2) = 0.0
        endif

*---- Sum up total kicks.
        dpx = (xcm + xkick + ferror(1)) / (one + deltas)
        dpy = (ycm + ykick + ferror(2)) / (one + deltas)
*--- HG000915 use bv flag to possibly invert angle
        if (bvflag) then
          dpx = beambv * dpx
          dpy = beambv * dpy
        endif
        if (dpy .ne. 0.0) cplxy = .true.

*---- Half kick at entrance.
        orbit(2) = orbit(2) + half * dpx
        orbit(4) = orbit(4) + half * dpy

*---- Half radiation effects at entrance.
        if (dorad  .and.  dl .ne. 0.0) then
          rfac = arad * gammas**3 * (dpx**2 + dpy**2) / (three * dl)
          pt = orbit(6)
          orbit(2) = orbit(2) - rfac * (one + pt) * orbit(2)
          orbit(4) = orbit(4) - rfac * (one + pt) * orbit(4)
          orbit(6) = orbit(6) - rfac * (one + pt) ** 2
        endif

*---- Drift to end.
        if (dl .ne. 0.0) then
          call tmdrf(fsec, ftrk, fract, orbit, fmap, el, ek, re, te)
        endif
        fmap = .true.

*---- Half radiation effects at exit.
        if (dorad  .and.  dl .ne. 0.0) then
          rfac2 = rfac
          pt = orbit(6)
          orbit(2) = orbit(2) - rfac * (one + pt) * orbit(2)
          orbit(4) = orbit(4) - rfac * (one + pt) * orbit(4)
          orbit(6) = orbit(6) - rfac * (one + pt) ** 2
        endif

*---- Half kick at exit.
        orbit(2) = orbit(2) + half * dpx
        orbit(4) = orbit(4) + half * dpy

*---- No orbit track desired, use drift map.
      else
        call tmdrf(fsec, ftrk, fract, orbit, fmap, el, ek, re, te)
      endif

      end
+dk tmderi
      subroutine tmderi(tt, disp, rtp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Derivative of linear transfer matrix w.r.t. delta(p)/p.            *
* Input:                                                               *
*   TT(6,6,6) (real)    Second-order terms.                            *
*   DISP(6)   (real)    Dispersion.                                    *
* Output:                                                              *
*   RTP(6,6)  (real)    Derivative matrix.                             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,k
      double precision disp,rtp,temp,tt
      dimension         tt(6,6,6), disp(6), rtp(6,6)

      do 30 i = 1, 6
        do 20 k = 1, 6
          temp = 0.0
          do 10 j = 1, 6
            temp = temp + tt(i,j,k) * disp(j)
   10     continue
          rtp(i,k) = 2.0 * temp
   20   continue
   30 continue

      end
+dk tmdrf
      subroutine tmdrf(fsec, ftrk, fract, orbit, fmap, el, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for drift space.                                     *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
*   FRACT     (real)    Fraction of length to be used.                 *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EL        (real)    Element length.                                *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      double precision dl,ek,el,fract,orbit,re,te
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer
      integer i, j
*---- Initialize.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)

*---- Fetch length from pool.
      call ucopy(q(lcelm+melen), el, mwflt)
      dl = el * fract
      fmap = dl .ne. 0.0

*---- First-order terms.
      re(1,2) = dl
      re(3,4) = dl
      re(5,6) = dl/(betas*gammas)**2
      ek(5) = dl*dtbyds

*---- Second-order terms.
      if (fsec) then
        call uzero(te, 1, 216*mwflt)
        te(1,2,6) = - dl / (2.0 * betas)
        te(1,6,2) = te(1,2,6)
        te(3,4,6) = te(1,2,6)
        te(3,6,4) = te(3,4,6)
        te(5,2,2) = te(1,2,6)
        te(5,4,4) = te(5,2,2)
        te(5,6,6) = te(1,2,6) * 3.0 / (betas * gammas) ** 2
      endif

*---- Track orbit.
      if (ftrk) call tmtrak(ek, re, te, orbit, orbit)

      end
+dk tmfoc
      subroutine tmfoc(el, sk1, c, s, d, f)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Compute linear focussing functions.                                *
* Input:                                                               *
*   EL        (real)    Length.                                        *
*   SK1       (real)    Quadrupole strength.                           *
* Output:                                                              *
*   C         (real)    Cosine-like function.             c(k,l)       *
*   S         (real)    Sine-like function.               s(k,l)       *
*   D         (real)    Dispersion function.              d(k,l)       *
*   F         (real)    Integral of dispersion function.  f(k,l)       *
*----------------------------------------------------------------------*
+ca aparam
      double precision c,d,el,f,qk,qkl,qkl2,s,sk1

      qk = sqrt(abs(sk1))
      qkl = qk * el
      qkl2 = sk1 * el**2

      if (abs(qkl2) .le. 1.0e-2) then
        c = (1.0 - qkl2 * (1.0 - qkl2 / 12.0) /  2.0)
        s = (1.0 - qkl2 * (1.0 - qkl2 / 20.0) /  6.0) * el
        d = (1.0 - qkl2 * (1.0 - qkl2 / 30.0) / 12.0) * el**2 / 2.0
        f = (1.0 - qkl2 * (1.0 - qkl2 / 42.0) / 20.0) * el**3 / 6.0
      else
        if (qkl2 .gt. 0.0) then
          c = cos(qkl)
          s = sin(qkl) / qk
        else
          c = cosh(qkl)
          s = sinh(qkl) / qk
        endif
        d = (1.0 - c) / sk1
        f = (el  - s) / sk1
      endif

      end
+dk tmfrng
      subroutine tmfrng(fsec, h, sk1, edge, he, sig, corr, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for fringe field of a dipole.                        *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   H         (real)    Curvature of magnet body.                      *
*   SK1       (real)    Quadrupole strength in magnet body.            *
*   EDGE      (real)    Edge focussing angle.                          *
*   HE        (real)    Curvature of pole face.                        *
*   SIG       (real)    Sign: +1.0 for entry, -1.0 for exit.           *
*   CORR      (real)    Correction factor according to SLAC 75.        *
* Output:                                                              *
*   EK(6)     (real)    Kick due to fringe field.                      *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second order terms.                            *
*----------------------------------------------------------------------*
+ca aparam
      double precision corr,edge,ek,h,he,hh,psip,re,secedg,sig,sk1,
     +tanedg,te
      logical           fsec
      dimension         ek(6), re(6,6), te(6,6,6)

*---- Initialize.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)

*---- Linear terms.
      tanedg = tan(edge)
      secedg = 1.0 / cos(edge)
      psip = edge - corr * secedg * (1.0 + sin(edge)**2)
      re(2,1) = + h * tanedg
      re(4,3) = - h * tan(psip)

*---- Second-order terms.
      if (fsec) then
        call uzero(te, 1, 216*mwflt)
        hh = sig * (h/2)
        te(1,1,1) = - hh * tanedg**2
        te(1,3,3) = + hh * secedg**2
        te(2,1,1) = (h/2) * he * secedg**3 + sk1 * tanedg
        te(2,1,2) = - te(1,1,1)
        te(2,3,3) = hh * h * tanedg**3 - te(2,1,1)
        te(2,3,4) = + te(1,1,1)
        te(3,1,3) = - te(1,1,1)
        te(4,1,3) = - te(2,1,1)
        te(4,1,4) = + te(1,1,1)
        te(4,2,3) = - te(1,3,3)
        if (sig .gt. 0.0) then
          te(2,3,3) = te(2,3,3) + (h*secedg)**2 * tanedg/2
        else
          te(2,1,1) = te(2,1,1) - (h*tanedg)**2 * tanedg/2
          te(4,1,3) = te(4,1,3) + (h*secedg)**2 * tanedg/2
        endif
        call tmsymm(te)
      endif

      end
+dk tmfrst
      subroutine tmfrst(lseq, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Transfer matrix w.r.t. actual orbit for one (half) superperiod.    *
*   Misalignment and field errors are considered.                      *
* Input:                                                               *
*   LSEQ(1)   (pointer) Beam line expansion bank.                      *
*   EFLAG     (logical) Overflow flag.                                 *
* Output:                                                              *
* Important common data:                                               *
*   RT(6,6)   /MAPTRN/  Transfer matrix for one (half) superperiod.    *
*   ORBIT0(6) /OPTIC0/  Initial conditions for reference orbit.        *
*   ORBIT(6)  /OPTIC1/  Final conditions for reference orbit.          *
*   SUML      /OPTIC1/  Cumulated length.                              *
*   LCELM     /REFER/   Current element bank.                          *
*   LCALI     /REFER/   Current misalignment pointer.                  *
*   LCFLD     /REFER/   Current field error pointer.                   *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ibpos,icode,icount,ieflag,ienum,iflag,inbpos,iocc,ipos,
     +itp,j,jbit,jbyt,k,nunloc,iml_flag
      double precision el,ten
      integer           lseq(*)
      logical           eflag
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca seqflag
+ca seqgroup
+ca mapelm
+ca maptrn
+ca optic0
+ca optic1
+ca refer
+ca status
+ca stflag
+ca zunit
+ca thrcom
+if doom
      common / fixmult / ipos, iml_flag
+ei
      parameter         (ten = 10.0d0)

      logical           fdump, fmap
      character*(mcnam) elmnam
      character * 60 stxt

*---- Initialize.
      eflag = .false.
      iml_flag = 1234
      icount = 0
      ieflag = 0
      if (adthfl)  ndccnt = ndccnt + 1
    3 continue
      call vzero(ndflag, mmaxel)
      call vzero(reforb, 6*mwflt)
    5 continue
      call ucopy(orbit0, orbit, 6*mwflt)
      cplxy = .false.
      cplxt = .false.
      suml = 0.0
      call m66one(rt)
*   buffer occupation
      ndocc = 0
*   position of current element ipos in buffer
      ibpos = 0
*--- (re)start position
      ipos = iq(lseq(1)+msr1) - 1
*   last ipos with flag set
      nlpos = ipos
   20 continue
      ipos = ipos + 1
      if (adthfl)  then
        ibpos = ibpos + 1
        if (ibpos .gt. mwind) ibpos = 1
        if (ndocc .lt. mwind)  ndocc = ndocc + 1
        ndtype(ibpos) = 0
      endif
        call utelem(lseq, ipos, iflag, elmnam, iocc, ienum)
        fdump = jbit(iflag,mfrst) .ne. 0
        icode = jbyt(iflag,1,mcode)
        if (fdump) write (iqlog, 910) elmnam

*---- Misalignment at entrance.
        if (icode .ne. 3  .and.  lcali .ne. 0) then
          call tmali1(ipos, .false., orbit, orbit, re, te)
          if (fdump) then
            write (iqlog, 920) ((re(i,j), j=1,6), i=1,6)
            write (iqlog, 950) orbit
          endif
          call m66mpy(re, rt, rt)
        endif

*---- Element matrix and length.
        if (icode .eq. 1) then
          if (adthfl)  then
            itp = iq(lcelm+mbsp)
            ndtype(ibpos) = itp
            ndpos(ibpos) = ipos
          endif
          call tmmap(.true., .true., orbit, fmap, el, ek, re, te)
          if (fmap) then
            if (fdump) then
              write (iqlog, 930) ((re(i,j), j=1,6), i=1,6)
              write (iqlog, 950) orbit
            endif
            call m66mpy(re, rt, rt)
            suml = suml + el
          endif
        endif
        if (adthfl)  adsuml(ibpos) = suml
*---- Misalignment at exit.
        if (icode .ne. 2  .and.  lcali .ne. 0) then
          call tmali2(ipos, .false., orbit, orbit, re, te)
          if (fdump) then
            write (iqlog, 940) ((re(i,j), j=1,6), i=1,6)
            write (iqlog, 950) orbit
          endif
          call m66mpy(re, rt, rt)
        endif
        if (adthfl)  then
          call ucopy(orbit, adorbt(1,ibpos), 6 * mwflt)
          call ucopy(rt, admatr(1,1,ibpos), 36 * mwflt)
          if (ipos .eq. iq(lseq(1)+msr2))  then
*--- close end of line
            if (ieflag .eq. 2)  goto 30
            ieflag = ieflag + 1
            call ucopy(orbit0, reforb, 6*mwflt)
            call tmthrd(lseq, ipos, ibpos, ieflag, inbpos)
            goto 17
          elseif (ndflag(ipos) .eq. 0)  then
            do 15  j = 1, 4
              if (abs(orbit(j) - reforb(j)) .gt. adtol(j)) then
                if (itp .lt. 14 .or. itp .gt. 16)  then
                  call tmthrd(lseq, ipos, ibpos, 1 + (j-1)/2, inbpos)
                  goto 17
                endif
              endif
   15       continue
          endif
          goto 16
   17     continue
          icount = icount + 1
          if (icount .gt. nditer)  then
            stxt = 'over $$$$$$ restart iterations -> Threader exit'
            write(stxt(6:11), '(i6)')  nditer
            call aawarn('tmfrst', 1, stxt)
            eflag = .true.
            goto 30
          endif
          if (inbpos .eq. 0)  goto 5
*--- restart at first corrector (from orbit + matrix of prev. element)
          ibpos = inbpos
          ipos = ndpos(inbpos)
          suml = adsuml(inbpos)
          call ucopy(adorbt(1,ibpos), orbit, 6*mwflt)
          call ucopy(admatr(1,1,ibpos), rt, 36*mwflt)
          goto 20
        endif
   16   continue
        if (adthfl)  then
          call ucopy(orbit, orbkpt(1,ipos), 6*mwflt)
          skpt(ipos) = suml
        endif
*---- Test for overflow.
        do 10 j = 1, 6
          if (abs(orbit(j)) .ge. ten) then
            eflag = .true.
            go to 30
          endif
   10   continue
        if (ipos .lt. iq(lseq(1)+msr2))      goto 20
   30 continue
      if (adthfl .and. adwofl)  then
        call flopen('threader.orbit', 'SWFD', 0, 0, nunloc, error)
        if (.not. error)  then
          write(nunloc,1001)
          k = iq(lseq(1)+msr1)
          write(nunloc,1002) k, skpt(k), (orbkpt(j,k), j = 1, 6)
          do 31 k = iq(lseq(1)+msr1)+1, ipos
            if (skpt(k) .gt. skpt(k-1))
     +      write(nunloc,1002) k, skpt(k), (orbkpt(j,k), j = 1, 6)
   31     continue
          call flclos(nunloc, error)
          if (.not. error)  then
            write(iqlog, *) 'Threader orbit written into threader.orbit'
          endif
        endif
      endif
*--- use threader only in first iteration
      adthfl = .false.

  910 format(' '/' TMFRST.  Entering "',a,'".')
  920 format(t11,'Misalignment at entrance:'/(' ',6e16.8))
  930 format(t11,'Element transfer matrix:'/(' ',6e16.8))
  940 format(t11,'Misalignment at exit:'/(' ',6e16.8))
  950 format(t11,'Orbit:'/(' ',6e16.8))
 1001 format('# ipos', t14, 's', t28, 'x', t41, 'p_x', t56, 'y',
     +t69, 'p_y', t83, '-ct', t97, 'd_p')
 1002 format(i6, 1p, 7e14.6)

  999 end
+dk tmgsec
      subroutine tmgsec(fsec, el, h, dh, sk1, sks, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for bending magnets of all types.                    *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   EL        (real)    Length of the magnet body.                     *
*   H         (real)    Reference curvature of magnet.                 *
*   DH        (real)    Dipole field error.                            *
*   SK1       (real)    Quadrupole strength.                           *
*   SKS       (real)    Skew quadrupole strengh.                       *
* Output:                                                              *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
*----------------------------------------------------------------------*
+ca aparam
      double precision c1,c2,cphi,d1,d2,dh,dif,ek,el,f1,f2,h,one,re,
     +root,s1,s2,sk1,sks,sphi,sum,te,three,two,w1,w2,xlm1,xlm2,zero
      logical           fsec
      dimension         ek(6), re(6,6), te(6,6,6)
+ca beam

      parameter         (zero = 0.0d0)
      parameter         (one = 1.0d0, two = 2.0d0, three = 3.0d0)

*---- Initialize.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)

*---- First-order terms.
      sum  = h**2 / two
      dif  = sum + sk1
      root = sqrt(dif**2 + sks**2)
      cphi = dif / root
      sphi = sks / root
      xlm1 = sum + (dif*cphi - sks*sphi)
      xlm2 = sum - (dif*cphi - sks*sphi)
      call tmfoc(el, xlm1, c1, s1, d1, f1)
      call tmfoc(el, xlm2, c2, s2, d2, f2)
      w1 = - xlm1 * s1
      w2 = - xlm2 * s2

      re(1,1) = ((c1 + c2) + (c1 - c2) * cphi) / two
      re(1,2) = ((s1 + s2) + (s1 - s2) * cphi) / two
      re(2,1) = ((w1 + w2) + (w1 - w2) * cphi) / two
      re(2,2) = re(1,1)

      re(1,3) = (c2 - c1) * sphi / two
      re(1,4) = (s2 - s1) * sphi / two
      re(2,3) = (w2 - w1) * sphi / two
      re(2,4) = re(1,3)

      re(3,1) = (c2 - c1) * sphi / two
      re(3,2) = (s2 - s1) * sphi / two
      re(4,1) = (w2 - w1) * sphi / two
      re(4,2) = re(3,1)

      re(3,3) = ((c1 + c2) - (c1 - c2) * cphi) / two
      re(3,4) = ((s1 + s2) - (s1 - s2) * cphi) / two
      re(4,3) = ((w1 + w2) - (w1 - w2) * cphi) / two
      re(4,4) = re(1,1)

      re(1,6) = h * ((d1 + d2) + (d1 - d2) * cphi) / two
      re(2,6) = h * ((s1 + s2) + (s1 - s2) * cphi) / two
      re(3,6) = h * (d2 - d1) / two
      re(4,6) = h * (s2 - s1) / two
      re(5,1) = - re(2,6)
      re(5,2) = - re(1,6)
      re(5,3) = - re(4,6)
      re(5,4) = - re(3,6)
      re(5,6) = el/(betas*gammas)**2 -
     +          h**2 * ((f1 + f2) + (f1 - f2) * cphi) / two
      ek(5)   = el * dtbyds

*---- Second-order terms.
      if (fsec) then
        call uzero(te, 1, 216*mwflt)
      endif

      end
+dk tminv
      subroutine tminv(rs, ts, rd, td)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Invert a TRANSPORT map.                                            *
* Input:                                                               *
*   RS(6,6), TS(6,6,6)  Source map.                                    *
* Output:                                                              *
*   RD(6,6), TD(6,6,6)  Destination map.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer i,i1,i2,i3,k
      double precision rd,rs,t,td,tr,trr,ts
      dimension         rs(6,6), ts(6,6,6), rd(6,6), td(6,6,6)
      dimension         tr(6), trr(6,6,6)

*---- Invert first order part.
      call m66inv(rs, rd)

*---- Invert second order part.
      do 50 i1 = 1, 6
      do 50 i2 = 1, 6
        do 20 i = 1, 6
          t = 0.0
          do 10 k = 1, 6
            t = t + ts(i1,i,k) * rd(k,i2)
   10     continue
          tr(i) = t
   20   continue
        do 40 i3 = i2, 6
          t = 0.0
          do 30 i = 1, 6
            t = t + tr(i) * rd(i,i3)
   30     continue
          trr(i1,i2,i3) = t
   40   continue
   50 continue

      do 70 i1 = 1, 6
      do 70 i2 = 1, 6
      do 70 i3 = i2, 6
        t = 0.0
        do 60 i = 1, 6
          t = t - rd(i1,i) * trr(i,i2,i3)
   60   continue
        td(i1,i2,i3) = t
        td(i1,i3,i2) = t
   70 continue

      end
+dk tmlcav
      subroutine tmlcav(fsec, ftrk, orbt, fmap, el, ek, re, te)
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for traveling wave accelerator (LCAVITY element)     *
*   with modification to the nominal energy.                           *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
* Input/output:                                                        *
*   ORBT(6)   (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EL        (real)    Element length.                                *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
* Created:  28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Routine copied and modified from TMRF and based on calculation in  *
*   Tor's MAD; transfer matrix is based on TRANSPORT matrix plus       *
*   velocity terms from TMDRIF; includes end focusing from structures  *
*   (first order only); change third input argument from ORBIT to ORBT *
* Modified: 07-SEP-1999, M. Woodley (SLAC)                             *
*   Set FMAP=.TRUE. when transfer matrix is computed here              *
* Modified: 21-SEP-1999, M. Woodley (SLAC)                             *
*   Convert to standard MAD units (electric voltage in MV, frequency   *
*   in MHz, phase angles in multiples of 2pi); ELOSS attribute units   *
*   are V/C; use DODEFL flag to turn on/off edge focusing              *
* Modified: 29-JUL-2000, M. Woodley (SLAC)                             *
*   Fix bug in structure edge focussing matrix multiplication          *
*----------------------------------------------------------------------*

      implicit none
+ca aparam
      logical           fsec, ftrk, fmap
      double precision  el,orbt(6), ek(6), re(6,6), te(6,6,6)
+ca memdum
+ca message
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca option
+ca optic1
+ca beam
+ca refer
+ca stflag
+ca physicpm
+ca pi
      double precision deltae, phi0, freq, eloss, volt_err, vrf,
     +phirf, etas, denergy, fact, alag_err, omega
      double precision twopi,ten3m,ten3p,ten6m,ten6p,zero,half,
     +one,two,three
      parameter         (twopi = 2.0 * pi)
      parameter         (ten3m = 1.0d-3, ten3p = 1.0d+3)
      parameter         (ten6m = 1.0d-6, ten6p = 1.0d+6)
      parameter         (zero = 0.0d0, half = 0.5d0)
      parameter         (one = 1.0d0, two = 2.0d0, three = 3.0d0)

      double precision  rw(6,6)
      logical           error
      logical           dodefl
      data              dodefl /.true./

*---- Fetch data from pool.
*--- length in m
      call ucopy(q(lcelm+melen), el, mwflt)
*--- deltae in MeV
      call ucopy(q(lcelm+melen+2*mcsiz), deltae, mwflt)
*--- phi0 in radians/2pi
      call ucopy(q(lcelm+melen+3*mcsiz), phi0, mwflt)
*--- freq in MHz
      call ucopy(q(lcelm+melen+4*mcsiz), freq, mwflt)

*---- Get energy loss if it was set - otherwise it is zero.
*--- eloss in V/C
      call ucopy(q(lcelm+melen+5*mcsiz), eloss, mwflt)
*--- convert to MeV
      eloss = (ten6m * eloss) * (qelect * parnum)

*---- Get errors (parameters #8 and #9).
*--- volt_err in MeV
      call ucopy(q(lcelm+melen+6*mcsiz), volt_err, mwflt)
*--- alag_err in radians/2pi
      call ucopy(q(lcelm+melen+7*mcsiz), alag_err, mwflt)

*---- If structure is excited, use full map.
      if (deltae .ne. zero .or. volt_err .ne. zero) then
        cplxt = .true.

*---- Set up.
*--- vrf, volt_err, eloss in GeV
        vrf = ten3m * deltae
        volt_err = ten3m * volt_err
        eloss = ten3m * eloss
*--- omega in radians/m
        omega = twopi * (ten6p * freq) / clight
*--- phirf and alag_err in radians
        phirf = twopi * phi0 - omega * orbt(5)
        alag_err = twopi * alag_err
*--- HG001121 start
        error = .false.
        if (ereset) then
*---- If incoming energy is not set, default it to 1 GeV ... warn user
*     later.
          if (ener1 .eq. zero) then
            ener1 = pc
            error = .true.
          endif
          if (ener1 .eq. zero) then
            ener1 = one
          endif

*---- Update relativistic terms at entrance to structure.
          en0 = ener1
        else
          ener1 = en0
        endif
*--- HG001121 end
        pc = sqrt(abs(en0**2 - amass**2))
        gamma = en0 / amass
        beta = pc / en0
        etas   = beta * gamma * (one + deltas)
        gammas = sqrt(one + etas**2)
        betas  = etas / gammas

*---- Change to the centroid energy value.
*     (NOTE: phase is referenced to the crest, NOT the zero crossing!)
        denergy = vrf * cos(phirf) - eloss ! gev

*---- Kick.
        ek(1) = zero
        ek(2) = zero
        ek(3) = zero
        ek(4) = zero
        ek(5) = zero
        ek(6) = ((vrf + volt_err) * cos(phirf + alag_err)
     +        - eloss - denergy) / (ener1 + denergy) / (one + deltas)

*---- First-order terms (for fully relativistic beams!).
        call m66one(re)
        re(6,5) = omega * vrf * sin(phirf) / (ener1 + denergy)
     +          / (one + deltas)
        re(2,2) = ener1 / (ener1 + denergy)
        re(4,4) = ener1 / (ener1 + denergy)
        re(6,6) = ener1 / (ener1 + denergy)
        if (abs(denergy/ener1) .lt. ten6m) then
          fact = one - half*denergy/ener1
        else
          fact = ener1/denergy * log(one+denergy/ener1)
        endif
        re(1,2) = el * fact
        re(3,4) = el * fact

*---- First-order R56 term from TMDRF (with change betas -> beta and
*     gammas -> gamma)
        re(5,6) = el / (betas * gammas) ** 2

*---- Add thin quads to represent focusing at structure entrance and
*     exit.
        if (dodefl) then
          call m66one(rw)
          rw(2,1) = -denergy / el / two / en0
          rw(4,3) = rw(2,1)
          call m66mpy(re, rw, re)
          call m66one(rw)
          rw(2,1) = +denergy / el / two / (en0+denergy)
          rw(4,3) = rw(2,1)
          call m66mpy(rw, re, re)
        endif

*---- Second-order terms.
        if (fsec) then
          call uzero(te, 1, 216*mwflt)
          te(6,5,5) = - omega**2 * vrf * cos(phirf) / two
     +              / (ener1 + denergy) / (one + deltas)

*---- Second-order terms from TMDRF.
          te(1,2,6) = - el / (two * beta)
          te(1,6,2) = te(1,2,6)
          te(3,4,6) = te(1,2,6)
          te(3,6,4) = te(3,4,6)
          te(5,2,2) = te(1,2,6)
          te(5,4,4) = te(5,2,2)
          te(5,6,6) = te(1,2,6) * three / (betas * gammas)**2
        endif

*---- Energy change.
        ener1 = ener1 + denergy

*---- Update relativistic terms at exit of structure.
        en0 = ener1
        pc = sqrt(abs(en0**2 - amass**2))
        gamma = en0 / amass
        beta = pc / en0
        etas   = beta * gamma * (one + deltas)
        gammas = sqrt(one + etas**2)
        betas  = etas / gammas

*---- Warn user if energy value had to be defaulted.
        if (error) then
          write (msg(1), 900) ener1 - denergy
          call aawarn ('tmlcav', 1, msg)
        endif

*---- Set FMAP flag.
        fmap = .true.

*---- Cavity not excited, use drift map.
      else
        call tmdrf(fsec, ftrk, one, orbt, fmap, el, ek, re, te)
      endif

 900  format ('Set the initial energy value to: ',1pg12.5)

      end
+dk tmlump
      subroutine tmlump(fsec, ftrk, orbit, fmap, el, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for a lump.                                          *
*   Assumes that the map has been set to identity.                     *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EL        (real)    Element length.                                *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*   LCFLD     /REFER/   Current field error pointer.                   *
* Local links:                                                         *
*   LMAP                Transfer map for a lump.                       *
*   LSEQ                Beam line sequence for a lump.                 *
*----------------------------------------------------------------------*
+ca aparam
      integer ienum,iflag,ikl,il,ileng,iocc,irl,itl,jbit,lmap,lseq,ns
      double precision ek,el,elump,orbit,re,te,zero
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca markbits
+ca prcgroup
+ca seqgroup
+ca message
+ca refer
+ca status
+ca stflag
+ca wstack

      character*(mcnam) elmnam
      logical           radsav

*---- Initialize, test for validity.
      llump = 0
      radsav = dorad
      if (dorad) then
        dorad = .false.
        call diname(ldbnk, iq(lcelm+mbnam), elmnam)
        call utleng(elmnam, ileng)
        msg(1) = 'LUMP "' // elmnam(1:ileng)
     +  // '" will ignore radiation.'
        call aawarn('TMLUMP', 1, msg)
      endif

*---- Recursive procedure to build lumps.
*     Test for available map.
  100 lmap = lq(lcelm-iq(lcelm+mbat)-mbemap)
      if (lmap .ne. 0) then
        call ucopy(q(lmap         +1), ek,   6*mwflt)
        call ucopy(q(lmap+ 6*mwflt+1), re,  36*mwflt)
        call ucopy(q(lmap+42*mwflt+1), te, 216*mwflt)
        call ucopy(q(lcelm+melen), el, mwflt)
        fmap = .true.
        go to 200
      endif

*---- Avoid recursive call.
      if (jbit(iq(lcelm),mxlmp) .ne. 0) then
        call diname(ldbnk, iq(lcelm+mbnam), elmnam)
        call utleng(elmnam, ileng)
        msg(1) = 'LUMP "' // elmnam(1:ileng)
     +    // '" has a recursive definition,'
        msg(2) = 'Identity transformation used for inner map.'
        call aafail('TMLUMP', 2, msg)
        call uzero(ek, 1, 6*mwflt)
        call m66one(re)
        call uzero(te, 1, 216*mwflt)
        go to 200
      endif

*---- Lump map must be computed; stack data for element.
      call sbit1(iq(lcelm), mxlmp)
      call mzbook(2, llump, llump, 1, 'LSTK', 4, 1, 4, 2, 0)
      lq(llump-2) = lcelm
      lq(llump-3) = lcali
      lq(llump-4) = lcfld

*---- Expand the element sequence for this lump.
*     Avoid dropping of a previous sequence.
      call lnrefe(lcelm, 4, lseq, llump, -1)
      if (error) go to 200

*---- Clear accumulated length.
      call ucopy(zero, q(lcelm+melen), mwflt)

*---- Assign working space for accumulation of map.
      iq(llump+4) = iwork
      ikl = iwork
      irl = iwork +  6
      itl = iwork + 42
      iwork = iwork + (6 + 36 + 216)
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Set initial map to identity.
      call uzero(dq(ikl+1), 1, 6*mwflt)
      call m66one(dq(irl+1))
      call uzero(dq(itl+1), 1, 216*mwflt)

*---- Simulated DO loop indices.
      iq(llump+1) = iq(lseq+msr1)
      iq(llump+2) = iq(lseq+msr2)
      iq(llump+3) = iq(lseq+msr1) - 1

*---- Loop over sequence.
*     Cannot use DO's and block IF's due to jump into this block!
  110 iq(llump+3) = iq(llump+3) + 1
      if (iq(llump+3) .gt. iq(llump+2)) go to 130
        lseq = lq(llump-1)
        call utelem(lseq, iq(llump+3), iflag, elmnam, iocc, ienum)

*---- Test for element.
        if (iq(lcelm+mbpr) .ne. mpelm) go to 110

*---- Test for inner lump.
        if (iq(lcelm+mbsp) .eq. 23) go to 100

*---- Compute map for a single element.
        call tmmap(.true., .false., orbit, fmap, el, ek, re, te)
        if (.not. fmap) go to 110

*---- Accumulate transfer matrix and kick for lump.
*     Come here after computation of an inner lump.
  120   ikl = iq(llump+4)
        irl = ikl +  6
        itl = irl + 36
        call uzero(ek, 1, 6*mwflt)
        call tmcat1(.true., ek, re, te, dq(ikl+1), dq(irl+1), dq(itl+1),
     +              dq(ikl+1), dq(irl+1), dq(itl+1))

*---- Accumulate length for lump.
        lcelm = lq(llump-2)
        call ucopy(q(lcelm+melen), elump, mwflt)
        elump = elump + el
        call ucopy(elump, q(lcelm+melen), mwflt)

*---- Advance to next component of lump.
      go to 110

*---- End of lump; unstack pointers.
  130 lcelm = lq(llump-2)
      lcali = lq(llump-3)
      lcfld = lq(llump-4)

*---- Clear call bit.
      call sbit0(iq(lcelm), mxlmp)

*---- Store transfer matrix for current lump.
      il = iq(lcelm+mbat) + mbemap
      ns = (6 + 36 + 216) * mwflt
      call mzbook(2, lmap, lcelm, -il, 'LMAP', 0, 0, ns, mreal, 0)
      ikl = iq(llump+4)
      irl = ikl +  6
      itl = irl + 36
      call ucopy(dq(ikl+1), q(lmap         +1),   6*mwflt)
      call ucopy(dq(irl+1), q(lmap+ 6*mwflt+1),  36*mwflt)
      call ucopy(dq(itl+1), q(lmap+42*mwflt+1), 216*mwflt)

*---- Return accumulated matrix.
      call ucopy(dq(ikl+1), ek,   6*mwflt)
      call ucopy(dq(irl+1), re,  36*mwflt)
      call ucopy(dq(itl+1), te, 216*mwflt)
      call ucopy(q(lcelm+melen), el, mwflt)
      fmap = .true.

*---- Release working space and unstack.
      iwork = iq(llump+4)
      call lndrop(lq(llump-1))
      call mzdrop(0, llump, '.')

*---- End of element calculation; check for outer LUMP.
  200 if (llump .ne. 0) go to 120

*---- Track orbit.
      if (ftrk) call tmtrak(ek, re, te, orbit, orbit)

*---- Restore radiation flag.
      dorad = radsav

      end
+dk tmmap
      subroutine tmmap(fsec, ftrk, orbit, fmap, el, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for a complete element.                              *
*   Optionally, follow orbit.                                          *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EL        (real)    Element length.                                *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer isp,lmap
      double precision ek,el,one,orbit,parvec,re,te,zero
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6),
     +                  parvec(mbbparam)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca message
+ca refer

      parameter         (one = 1.0d0, zero = 0.0d0)

*---- Select element type.
 1000 continue
      el = 0.0
      isp = iq(lcelm+mbsp)
      go to ( 10,  20,  30,  40,  50,  60,  70,  80,  90, 100,
     +       110, 120, 130, 140, 150, 160, 170, 180, 190, 200,
     +       210, 220, 230, 240, 250, 260, 270, 280, 290, 300,
     +       310, 310, 310, 310, 310, 310, 310, 310, 310, 310), isp

*---- Drift space, monitor, collimator, or beam instrument.
   10 continue
  170 continue
  180 continue
  190 continue
  200 continue
  210 continue
  240 continue
        call tmdrf(fsec, ftrk, one, orbit, fmap, el, ek, re, te)
      go to 500

*---- Bending magnet.
   20 continue
   30 continue
        call tmbend(fsec, ftrk, orbit, fmap, el, ek, re, te)
      go to 500

*---- Arbitrary matrix.
   40 continue
        call tmarb(fsec, ftrk, orbit, fmap, el, ek, re, te)
      go to 500

*---- Quadrupole.
   50 continue
        call tmquad(fsec, ftrk, one, orbit, fmap, el, ek, re, te)
      go to 500

*---- Sextupole.
   60 continue
        call tmsext(fsec, ftrk, one, orbit, fmap, el, ek, re, te)
      go to 500

*---- Octupole.
   70 continue
        call tmoct(fsec, ftrk, one, orbit, fmap, el, ek, re, te)
      go to 500

*---- Multipole.
   80 continue
        call tmmult(fsec, ftrk, orbit, fmap, ek, re, te)
      go to 500

*---- Solenoid.
   90 continue
        call tmsol(fsec, ftrk, one, orbit, fmap, el, ek, re, te)
      go to 500

*---- RF cavity.
  100 continue
        call tmrf(fsec, ftrk, orbit, fmap, el, ek, re, te)
      go to 500

*---- Electrostatic separator.
  110 continue
        call tmsep(fsec, ftrk, one, orbit, fmap, el, ek, re, te)
      go to 500

*---- Rotation around s-axis.
  120 continue
        call tmsrot(fsec, ftrk, orbit, fmap, ek, re, te)
      go to 500

*---- Rotation around y-axis.
  130 continue
        call tmyrot(fsec, ftrk, orbit, fmap, ek, re, te)
      go to 500

*---- Correctors.
  140 continue
  150 continue
  160 continue
        call tmcorr(fsec, ftrk, one, orbit, fmap, el, ek, re, te)
      go to 500

*---- Beam-beam.
*     (Particles/bunch taken for the opposite beam).
  220 continue
      call ucopy(q(lcelm+mesigx), parvec(1), mwflt)
      if (parvec(1) .eq. 0.d0) parvec(1) = 1.d0
      call ucopy(q(lcelm+mesigy), parvec(2), mwflt)
      if (parvec(2) .eq. 0.d0) parvec(2) = 1.d0
      call ucopy(q(lcelm+mexma), parvec(3), mwflt)
      call ucopy(q(lcelm+meyma), parvec(4), mwflt)
      parvec(5) = arad
      call ucopy(q(lcelm+mechg), parvec(6), mwflt)
      parvec(6) = parvec(6) * charge * parnum
      parvec(7) = gammas
      parvec(8) = ex
      parvec(9) = ey
      call tmbb(fsec, ftrk, parvec, orbit, fmap, ek, re, te)
      go to 500

*---- Lump.
  230 continue
        lmap = lq(lcelm-iq(lcelm+mbat)-mbemap)
        fmap = .true.
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lmap+1), ek, 6*mwflt)
        call ucopy(q(lmap+6*mwflt+1), re, 36*mwflt)
        call ucopy(q(lmap+42*mwflt+1), te, 216*mwflt)
        call tmtrak(ek,re,te,orbit,orbit)
      go to 500

*---- Marker.
  250 continue
        call uzero(ek, 1, 6*mwflt)
        call m66one(re)
        if (fsec) call uzero(te, 1, 216*mwflt)
      go to 500

*---- General bend (dipole, quadrupole, and skew quadrupole).
  260 continue
        call tmbend(fsec, ftrk, orbit, fmap, el, ek, re, te)
      go to 500

*---- LCAV cavity.
  270 continue
        call tmlcav(fsec, ftrk, orbit, fmap, el, ek, re, te)
      go to 500
*---- Reserved.
  280 continue
  290 continue
  300 continue
        call uzero(ek, 1, 6*mwflt)
        call m66one(re)
        if (fsec) call uzero(te, 1, 216*mwflt)
      go to 500

*---- User-defined elements.
  310 continue
        call tmuser(fsec, ftrk, one, orbit, fmap, el, ek, re, te)

*---- End of element calculation; check for LUMP.
  500 continue

      end
+dk tmmksm
      subroutine tmmksm(fsec)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Make transfer map for full superperiod from half superperiod.      *
* Input:                                                               *
*   FSEC      (logical) True, if second order terms are desired.       *
*----------------------------------------------------------------------*
+ca aparam
      logical           fsec
+ca mapelm
+ca maptrn
+ca optic1

*---- Second order desired?
      if (fsec) then
        call tmrefl(rt, tt, re, te)
        call tmcat(.true., re, te, rt, tt, rt, tt)
        suml = suml + suml

*---- First order only.
      else
        call m66ref(rt, re)
        call m66mpy(re, rt, rt)
        suml = suml + suml
      endif

      end
+dk tmmult
      subroutine tmmult(fsec, ftrk, orbit, fmap, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for thin multipole.                                  *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EL        (real)    Element length.                                *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer iord,na,nd,ne,nord,i,j
      double precision ang,bi,data,dbi,dbr,di,dipi,dipr,dpx,dpxr,dpy,
     +dpyr,dr,drt,ek,elrad,field,one,orbit,pt,re,rfac,te,three,
     +two,val,x,y
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca prcgroup
+ca beam
+ca refer
+ca stflag
+ca tmcomm
+ca physicpm
+ca maxmul
+if doom
+ca dmcommon
      common / fixmult / ipos, iml_flag
      integer ipos, iml_flag
      character*(mcnam) elmnam
      integer iprl, ispl, iorder, locelm
      double precision radius
+ei
      parameter         (one    = 1.0d0)
      parameter         (two    = 2.0d0, three  = 3.0d0)
      integer bvpos
      parameter         (bvpos = 24)
      logical bvflag
      dimension         data(2,0:maxmul), field(2,0:maxmul)

*---- Initialize.
      bvflag = .false.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)

+if doom
      if (iml_flag .eq. 1234)  then
        locelm = lq(ldbnk(3)-iq(lsdir+ipos))
        if (locelm .eq. 0) go to 701
        iprl = iq(locelm+mbpr)
        ispl = iq(locelm+mbsp)
        if (iprl.ne.mpelm .or. ispl.le.0 .or. ispl.gt.30) go to 701
        call diname(ldbnk, iq(lsdir+ipos), elmnam)
*--- add name, order, and radius to list if not yet done
*        radius = 0.0254    ! courtesy Meiqin Xiao FNAL
        radius = 0.017
        do i = 1, nmult
          if (elmnam .eq. multname(i))  goto 701
        enddo
        if (nmult .eq. max_mult)  then
          call aawarn('TMMULT', 1,
     +      'max. number of multipoles reached in table multname.')
          goto 701
        endif
        nmult = nmult + 1
        multname(nmult) = elmnam
        refmult(nmult) = radius
        multord(nmult) = iorder
      endif
  701 continue
+ei
*---- Multipole length for radiation.
      elrad = 0.0
      call utgflt(lcelm, 2, 2, elrad)
      fmap = .true.
      bi = 1.0 / betas

*---- Multipole components.
      nd = 2 * mwflt * (maxmul + 1)
      call uzero(data, 1, nd)
      na = min(2 * maxmul + 4, iq(lcelm+mbat))
      call utgflt(lcelm, 3, na, data)
      call utglog(lcelm, bvpos, bvpos, bvflag)
*---- Field error data.
      call uzero(field, 1, nd)
      if (lcfld .ne. 0) then
        ne = min(iq(lcfld-1), nd)
        call ucopy(q(lcfld+1), field, ne)
      endif

*---- Dipole error.
      dbr = elmfact(0) * field(1,0) / (one + deltas)
      dbi = elmfact(0) * field(2,0) / (one + deltas)

*---- Nominal dipole strength.
      ang = data(2,0)
      dipr = elmfact(0) * data(1,0) * cos(ang) / (one + deltas)
      dipi = elmfact(0) * data(1,0) * sin(ang) / (one + deltas)

*--- HG000915 use bv flag to possibly invert angle
        if (bvflag) then
          dipr = beambv * dipr
          dipi = beambv * dipi
        endif

*---- Other components and errors.
      nord = 0
      do 10 iord = 1, maxmul
        val =   data(1,iord)
        ang =   data(2,iord) * float(iord+1)
        field(1,iord) = (val*cos(ang) + field(1,iord)) / (one + deltas)
        field(2,iord) = (val*sin(ang) + field(2,iord)) / (one + deltas)
        if (field(1,iord) .ne. 0.0  .or.  field(2,iord) .ne. 0.0) then
          nord = iord
        endif
   10 continue

*--- apply inversion and scaling
      do i = 1, nord
        do j = 1, 2
          field(j,i) = field(j,i) * elmfact(i)
        enddo
      enddo

*---- Reduce sextupole field for closed orbit search.
      field(1,2) = cohelp * field(1,2)
      field(2,2) = cohelp * field(2,2)

*---- Track orbit.
      if (ftrk) then
        x = orbit(1)
        y = orbit(3)

*---- Multipole kick.
        dr = 0.0
        di = 0.0
        do 30 iord = nord, 1, -1
          drt = (dr * x - di * y) / float(iord+1) + field(1,iord)
          di  = (dr * y + di * x) / float(iord+1) + field(2,iord)
          dr  = drt
   30   continue
        dpx = dbr + (dr * x - di * y)
        dpy = dbi + (di * x + dr * y)

*---- Radiation effects at entrance.
        if (dorad  .and.  elrad .ne. 0.0) then
          dpxr = dpx + dipr
          dpyr = dpy + dipi
          rfac = arad * gammas**3 * (dpxr**2+dpyr**2) / (three*elrad)
          pt = orbit(6)
          orbit(2) = orbit(2) - rfac * (one + pt) * orbit(2)
          orbit(4) = orbit(4) - rfac * (one + pt) * orbit(4)
          orbit(6) = orbit(6) - rfac * (one + pt) ** 2
        endif

*---- Track orbit.
        orbit(2) = orbit(2) - dpx + dipr * (deltas + bi*orbit(6))
        orbit(4) = orbit(4) + dpy - dipi * (deltas + bi*orbit(6))
        orbit(5) = orbit(5) - (dipr*x - dipi*y) * bi

*---- Radiation effects at exit.
        if (dorad  .and.  elrad .ne. 0.0) then
          pt = orbit(6)
          orbit(2) = orbit(2) - rfac * (one + pt) * orbit(2)
          orbit(4) = orbit(4) - rfac * (one + pt) * orbit(4)
          orbit(6) = orbit(6) - rfac * (one + pt) ** 2
        endif

*---- Orbit not wanted.
      else
        x = 0.0
        y = 0.0
        nord = min(nord, 2)
      endif

*---- First-order terms (use X,Y from orbit tracking).
      call m66one(re)
      if (nord .ge. 1) then
        dr = 0.0
        di = 0.0
        do 40 iord = nord, 1, -1
          drt = (dr * x - di * y) / float(iord) + field(1,iord)
          di  = (dr * y + di * x) / float(iord) + field(2,iord)
          dr  = drt
   40   continue
        re(2,1) = - dr
        re(2,3) = + di
        re(4,1) = + di
        re(4,3) = + dr
        if (di .ne. 0.0) cplxy = .true.
      endif
      re(2,6) = + dipr * bi
      re(4,6) = - dipi * bi
      re(5,1) = - re(2,6)
      re(5,3) = - re(4,6)

*---- Second-order terms (use X,Y from orbit tracking).
      if (fsec) then
        call uzero(te, 1, 216*mwflt)
        if (nord .ge. 2) then
          dr = 0.0
          di = 0.0
          do 50 iord = nord, 2, -1
            drt = (dr * x - di * y) / float(iord-1) + field(1,iord)
            di  = (dr * y + di * x) / float(iord-1) + field(2,iord)
            dr  = drt
   50     continue
          dr = dr / two
          di = di / two
          te(2,1,1) = - dr
          te(2,1,3) = + di
          te(2,3,1) = + di
          te(2,3,3) = + dr
          te(4,1,1) = + di
          te(4,1,3) = + dr
          te(4,3,1) = + dr
          te(4,3,3) = - di
        endif
      endif

      end
+dk tmoct
      subroutine tmoct(fsec, ftrk, fract, orbit, fmap, el, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for octupole element.                                *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
*   FRACT     (real)    Fraction of length to be used.                 *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EL        (real)    Element length.                                *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      double precision ci,cr,dl,dsk3,ek,el,four,fract,octi,octr,one,
     +orbit,posi,posr,pt,re,rfac,rw,six,sk3,sk3l,te,three,tilt,tilt4,tw,
     +two
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer
+ca stflag

      dimension         rw(6,6), tw(6,6,6)

      parameter         (one    = 1.0d0)
      parameter         (two    = 2.0d0, three  = 3.0d0)
      parameter         (four   = 4.0d0, six    = 6.0d0)

*---- Initialize.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)
      if (fsec) call uzero(te, 1, 216*mwflt)

*---- Fetch data from pool.
      call ucopy(q(lcelm+melen), el, mwflt)
      dl = el * fract
      fmap = dl .ne. 0.0
      if (.not. fmap) return

*---- Set up half octupole strength.
      if (ftrk) then
        call ucopy(q(lcelm+mek3o), sk3, mwflt)
        call ucopy(q(lcelm+metlts), tilt, mwflt)

*---- Field error.
        if (lcfld .ne. 0) then
          call ucopy(q(lcfld+6*mwflt+1), dsk3, mwflt)
          sk3l = (dl * sk3 + fract * dsk3) / (one + deltas)
        else
          sk3l = (dl * sk3) / (one + deltas)
        endif
*--- apply inversion and scaling
        sk3l = sk3l * elkfact(7)
*---- Normal and skew components of octupole.
        tilt4 = four * tilt
        octr = sk3l * cos(tilt4)
        octi = sk3l * sin(tilt4)

*---- Half kick at entrance.
        posr = orbit(1) * (orbit(1)**2 - three*orbit(3)**2) / six
        posi = orbit(3) * (three*orbit(1)**2 - orbit(3)**2) / six
        cr = octr * posr - octi * posi
        ci = octr * posi + octi * posr
        orbit(2) = orbit(2) - cr / two
        orbit(4) = orbit(4) + ci / two

*---- Half radiation effects at entrance.
        if (dorad) then
          rfac = arad * gammas**3 * (cr**2 + ci**2) / (three * dl)
          pt = orbit(6)
          orbit(2) = orbit(2) - rfac * (one + pt) * orbit(2)
          orbit(4) = orbit(4) - rfac * (one + pt) * orbit(4)
          orbit(6) = orbit(6) - rfac * (one + pt) ** 2
        endif

*---- First-order terms w.r.t. orbit.
        call m66one(rw)
        posr = (orbit(1)**2 - orbit(3)**2) / four
        posi = orbit(1) * orbit(3) / two
        cr = octr * posr - octi * posi
        ci = octr * posi + octi * posr
        rw(2,1) = - cr
        rw(2,3) = + ci
        rw(4,1) = + ci
        rw(4,3) = + cr
        if (ci .ne. 0.0) cplxy = .true.

*---- Second-order terms w.r.t. orbit.
        if (fsec) then
          call uzero(tw, 1, 216*mwflt)
          cr = (octr * orbit(1) - octi * orbit(3)) / four
          ci = (octr * orbit(3) + octi * orbit(1)) / four
          tw(2,1,1) = - cr
          tw(2,1,3) = + ci
          tw(2,3,1) = + ci
          tw(2,3,3) = + cr
          tw(4,1,1) = + ci
          tw(4,1,3) = + cr
          tw(4,3,1) = + cr
          tw(4,3,3) = - ci
        endif

*---- Concatenate with drift map.
        call tmdrf(fsec, ftrk, fract, orbit, fmap, el, ek, re, te)
        call tmcat(fsec, re, te, rw, tw, re, te)

*---- Half kick at exit.
        posr = orbit(1) * (orbit(1)**2 - three*orbit(3)**2) / six
        posi = orbit(3) * (three*orbit(1)**2 - orbit(3)**2) / six
        cr = octr * posr - octi * posi
        ci = octr * posi + octi * posr
        orbit(2) = orbit(2) - cr / two
        orbit(4) = orbit(4) + ci / two

*---- Half radiation effects.
        if (dorad) then
          rfac = arad * gammas**3 * (cr**2 + ci**2) / (three * dl)
          pt = orbit(6)
          orbit(2) = orbit(2) - rfac * (one + pt) * orbit(2)
          orbit(4) = orbit(4) - rfac * (one + pt) * orbit(4)
          orbit(6) = orbit(6) - rfac * (one + pt) ** 2
        endif

*---- First-order terms w.r.t. orbit.
        call m66one(rw)
        posr = (orbit(1)**2 - orbit(3)**2) / four
        posi = orbit(1) * orbit(3) / two
        cr = octr * posr - octi * posi
        ci = octr * posi + octi * posr
        rw(2,1) = - cr
        rw(2,3) = + ci
        rw(4,1) = + ci
        rw(4,3) = + cr
        if (ci .ne. 0.0) cplxy = .true.

*---- Second-order terms w.r.t. orbit.
        if (fsec) then
          call uzero(tw, 1, 216*mwflt)
          cr = (octr * orbit(1) - octi * orbit(3)) / four
          ci = (octr * orbit(3) + octi * orbit(1)) / four
          tw(2,1,1) = - cr
          tw(2,1,3) = + ci
          tw(2,3,1) = + ci
          tw(2,3,3) = + cr
          tw(4,1,1) = + ci
          tw(4,1,3) = + cr
          tw(4,3,1) = + cr
          tw(4,3,3) = - ci
        endif
        call tmcat(fsec, rw, tw, re, te, re, te)

*---- Not orbit track requested, use drift map.
      else
        call tmdrf(fsec, ftrk, fract, orbit, fmap, el, ek, re, te)
      endif

      end
+dk tmquad
      subroutine tmquad(fsec, ftrk, fract, orbit, fmap, el, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for quadrupole element.                              *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
*   FRACT     (real)    Fraction of length to be used.                 *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EL        (real)    Element length.                                *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      double precision biby4,cx,cy,dl,dsk1,ek,el,fract,one,orbit,pt,qk,
     +qkl,qkl2,re,rfac,sk1,sx,sy,te,three,tilt,two
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer
+ca stflag

      parameter         (one = 1.0d0, two = 2.0d0, three = 3.0d0)

*---- Initialize.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)

*---- Fetch data from pool.
      call ucopy(q(lcelm+melen), el, mwflt)
      dl = el * fract
      fmap = dl .ne. 0.0
      if (.not. fmap) return

      call ucopy(q(lcelm+mek1q), sk1, mwflt)

*---- Field error.
      if (lcfld .ne. 0) then
        call ucopy(q(lcfld+2*mwflt+1), dsk1, mwflt)
        sk1 = sk1 + dsk1 / el
      endif
      sk1 = sk1 / (one + deltas)
*--- apply inversion and scaling
      sk1 = sk1 * elkfact(5)
      call ucopy(q(lcelm+metltq), tilt, mwflt)
      if (tilt .ne. 0.0) cplxy = .true.

*---- Half radiation effect at exit.
      if (dorad) then
        rfac = (arad * gammas**3 * sk1**2 * dl / three) * (orbit(1)**2 +
     +  orbit(3)**2)
        pt = orbit(6)
        orbit(2) = orbit(2) - rfac * (one + pt) * orbit(2)
        orbit(4) = orbit(4) - rfac * (one + pt) * orbit(4)
        orbit(6) = orbit(6) - rfac * (one + pt) ** 2
      endif

*---- Set up c's and s's.
      qk = sqrt(abs(sk1))
      qkl = qk * dl
      if (abs(qkl) .lt. 1.0e-3) then
        qkl2 = sk1 * dl**2
        cx = (1.0 - qkl2 / 2.0)
        sx = (1.0 - qkl2 / 6.0) * dl
        cy = (1.0 + qkl2 / 2.0)
        sy = (1.0 + qkl2 / 6.0) * dl
      else if (sk1 .gt. 0.0) then
        cx = cos(qkl)
        sx = sin(qkl) / qk
        cy = cosh(qkl)
        sy = sinh(qkl) / qk
      else
        cx = cosh(qkl)
        sx = sinh(qkl) / qk
        cy = cos(qkl)
        sy = sin(qkl) / qk
      endif

*---- First-order terms.
      re(1,1) = cx
      re(1,2) = sx
      re(2,1) = - sk1 * sx
      re(2,2) = cx
      re(3,3) = cy
      re(3,4) = sy
      re(4,3) = + sk1 * sy
      re(4,4) = cy
      re(5,6) = dl/(betas*gammas)**2
      ek(5) = dl*dtbyds

*---- Second-order terms.
      if (fsec) then
        call uzero(te, 1, 216*mwflt)
        biby4 = 1.0 / (4.0 * betas)
        te(1,1,6) = + sk1 * dl * sx * biby4
        te(1,6,1) = te(1,1,6)
        te(2,2,6) = te(1,1,6)
        te(2,6,2) = te(1,1,6)
        te(1,2,6) = - (sx + dl*cx) * biby4
        te(1,6,2) = te(1,2,6)
        te(2,1,6) = - sk1 * (sx - dl*cx) * biby4
        te(2,6,1) = te(2,1,6)

        te(3,3,6) = - sk1 * dl * sy * biby4
        te(3,6,3) = te(3,3,6)
        te(4,4,6) = te(3,3,6)
        te(4,6,4) = te(3,3,6)
        te(3,4,6) = - (sy + dl*cy) * biby4
        te(3,6,4) = te(3,4,6)
        te(4,3,6) = + sk1 * (sy - dl*cy) * biby4
        te(4,6,3) = te(4,3,6)

        te(5,1,1) = - sk1 * (dl - sx*cx) * biby4
        te(5,1,2) = + sk1 * sx**2 * biby4
        te(5,2,1) = te(5,1,2)
        te(5,2,2) = - (dl + sx*cx) * biby4
        te(5,3,3) = + sk1 * (dl - sy*cy) * biby4
        te(5,3,4) = - sk1 * sy**2 * biby4
        te(5,4,3) = te(5,3,4)
        te(5,4,4) = - (dl + sy*cy) * biby4
        te(5,6,6) = (- 6.0 * re(5,6)) * biby4
      endif

*---- Apply tilt.
      if (tilt .ne. 0.0) call tmtilt(fsec, tilt, ek, re, te)

*---- Track orbit.
      if (ftrk) call tmtrak(ek, re, te, orbit, orbit)

*---- Half radiation effect at exit.
      if (dorad) then
        rfac = (arad * gammas**3 * sk1**2 * dl / three) * (orbit(1)**2 +
     +  orbit(3)**2)
        pt = orbit(6)
        orbit(2) = orbit(2) - rfac * (one + pt) * orbit(2)
        orbit(4) = orbit(4) - rfac * (one + pt) * orbit(4)
        orbit(6) = orbit(6) - rfac * (one + pt) ** 2
      endif

      end
+dk tmrefe
      subroutine tmrefe(lseq)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Transfer matris w.r.t. ideal orbit for one (half) superperiod.     *
*   Ignores cavities, radiation, and imperfections.                    *
* Input:                                                               *
*   LSEQ(1)   (pointer) Beam line sequence bank.                       *
* Output:                                                              *
* Important common data:                                               *
*   RT(6,6)   /MAPTRN/  Transfer matrix for one (half) superperiod.    *
*   SUML      /OPTIC1/  Cumulated length.                              *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer i,icode,ienum,iflag,iocc,ipos,j,jbit,jbyt
      double precision el,etas,one,save
      integer           lseq(*)
+ca memdum
+ca seqflag
+ca seqgroup
+ca beam
+ca mapelm
+ca maptrn
+ca optic1
+ca refer
+ca status
+ca stflag
+ca zunit

      parameter         (one = 1.0d0)

      logical           fdump, fmap, dosave(10)
      character*(mcnam) elmnam

*---- Save and clear status flags.
      save = deltas
      do 10 i = 1, maxdof
        dosave(i) = doflag(i)
        doflag(i) = .false.
  10  continue
      deltas = 0.0
      gammas = gamma
      betas  = beta

*---- Initialize.
      cplxy = .false.
      cplxt = .false.
      suml = 0.0
      lsdir = lq(lseq(1)-msdir)
      lsflg = lq(lseq(1)-msflg)
      call m66one(rt)

      do 80 ipos = iq(lseq(1)+msr1), iq(lseq(1)+msr2)
        call utelem(lseq, ipos, iflag, elmnam, iocc, ienum)
        lcali = 0
        lcfld = 0
        lccom = 0
        icode = jbyt(iflag,1,mcode)
        if (icode .eq. 1) then
          fdump= jbit(iflag,mrefe) .ne. 0
          if (fdump) write (iqlog, 910) elmnam
          call tmmap(.false., .false., orbit, fmap, el, ek, re, te)
          if (fmap) then
            if (fdump) then
              write (iqlog, 920) ((re(i,j), j=1,6), i=1,6)
            endif
            call m66mpy(re, rt, rt)
            suml = suml + el
          endif
        endif
   80 continue

*---- Restore status flags.
      do 90 i = 1, maxdof
        doflag(i) = dosave(i)
   90 continue
      deltas = save
      etas   = beta * gamma * (one + deltas)
      gammas = sqrt(one + etas**2)
      betas  = etas / gammas

  910 format(' '/' TMREFE.  Entering element "',a,'".')
  920 format(t11,'Element transfer matrix:'/(' ',6e16.8))

      end
+dk tmrefl
      subroutine tmrefl(rs, ts, rd, td)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Reflect a TRANSPORT map.                                           *
* Input:                                                               *
*   RS(6,6), TS(6,6,6)  Source map.                                    *
* Output:                                                              *
*   RD(6,6), TD(6,6,6)  Destination map.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,k
      double precision rd,rs,s,sij,td,ts
      dimension         rs(6,6), ts(6,6,6), rd(6,6), td(6,6,6)
      dimension         s(6)
      data  s         / 1.0d0, -1.0d0, +1.0d0, -1.0d0, -1.0d0, +1.0d0 /

      call tminv(rs, ts, rd, td)
      do 20 i = 1, 6
      do 20 j = 1, 6
        sij = s(i) * s(j)
        rd(i,j) = rd(i,j) * sij
        do 10 k = 1, 6
          td(i,j,k) = td(i,j,k) * sij * s(k)
   10   continue
   20 continue

      end
+dk tmrf
      subroutine tmrf(fsec, ftrk, orbit, fmap, el, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for RF cavity.                                       *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EL        (real)    Element length.                                *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      double precision c0,c1,c2,ek,ek0,el,half,omega,one,orbit,phirf,
     +re,rff,rfl,rfv,rw,te,ten3m,ten6p,tw,two,twopi,vrf
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6)
      integer i,j
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer
+ca stflag

+ca physicpm
      parameter         (ten3m = 1.0d-3, ten6p = 1.0d+6)
      parameter         (half = 0.5d0, one = 1.0d0, two = 2.0d0)
+ca pi
      parameter         (twopi = 2.0 * pi)

      dimension         ek0(6), rw(6,6), tw(6,6,6)

*---- Fetch data from pool.
      call ucopy(q(lcelm+melen), el, mwflt)
      call ucopy(q(lcelm+mevltc), rfv, mwflt)
      call ucopy(q(lcelm+mefrqc), rff, mwflt)
      call ucopy(q(lcelm+melagc), rfl, mwflt)
*---- Cavity is excited, use full map.
      if (docav  .and.  rfv .ne. 0.0) then
        cplxt = .true.

*---- Set up.
        omega = rff * ten6p * twopi / clight
        vrf   = rfv * ten3m / (pc * (one + deltas))
        phirf = rfl * twopi - omega * orbit(5)
        c0 =   vrf * sin(phirf)
        c1 = - vrf * cos(phirf) * omega
        c2 = - vrf * sin(phirf) * omega**2 * half

*---- Transfer map.
        call uzero(ek, 1, 6*mwflt)
        call m66one(re)
        if (fsec) call uzero(te, 1, 216*mwflt)
        fmap = .true.
        if (ftrk .and. docav) then
          orbit(6) = orbit(6) + c0
          ek(6) = c0
          re(6,5) = c1
          if (fsec) te(6,5,5) = c2
        else
          ek(6) = c0 - c1 * orbit(5) + c2 * orbit(5)**2
          re(6,5) = c1 - two * c2 * orbit(5)
          if (fsec) te(6,5,5) = c2
        endif

*---- Sandwich cavity between two drifts.
        if (el .ne. 0.0) then
          call tmdrf(fsec, ftrk, half, orbit, fmap, el, ek0, rw, tw)

          call tmcat(fsec, re, te, rw, tw, re, te)
          call tmdrf(fsec, ftrk, half, orbit, fmap, el, ek0, rw, tw)
          call tmcat(fsec, rw, tw, re, te, re, te)
        endif
*---- Cavity not excited, use drift map.
      else
        call tmdrf(fsec, ftrk, one, orbit, fmap, el, ek, re, te)
      endif

      end
+dk tmscnd
      subroutine tmscnd(lseq)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map w.r.t. actual orbit for one (half) superperiod.      *
*   Misalignment and field errors are considered.                      *
* Input:                                                               *
*   LSEQ(1)   (pointer) Beam line expansion bank.                      *
* Output:                                                              *
* Important common data:                                               *
*   RT(6,6)   /MAPTRN/  Transfer matrix for one (half) superperiod.    *
*   TT(6,6,6) /MAPTRN/  Second order terms.                            *
*   ORBIT0(6) /OPTIC0/  Initial conditions for reference orbit.        *
*   ORBIT(6)  /OPTIC1/  Final conditions for reference orbit.          *
*   SUML      /OPTIC1/  Cumulated length.                              *
*   LCELM     /REFER/   Current element bank.                          *
*   LCALI     /REFER/   Current misalignment pointer.                  *
*   LCFLD     /REFER/   Current field error pointer.                   *
*----------------------------------------------------------------------*
+ca aparam
      integer i,icode,ienum,iflag,iocc,ipos,j,jbit,jbyt,k
      double precision el
      integer           lseq(*)
+ca memdum
+ca seqflag
+ca seqgroup
+ca mapelm
+ca maptrn
+ca optic0
+ca optic1
+ca refer
+ca status
+ca stflag
+ca zunit

      logical           fdump, fmap
      character*(mcnam) elmnam

*---- Initialize.
      call ucopy(orbit0, orbit, 6*mwflt)
      cplxy = .false.
      cplxt = .false.
      suml = 0.0
      call m66one(rt)
      call uzero(tt, 1, 216*mwflt)

      do 90 ipos = iq(lseq(1)+msr1), iq(lseq(1)+msr2)
        call utelem(lseq, ipos, iflag, elmnam, iocc, ienum)
        fdump = jbit(iflag,mscnd) .ne. 0
        icode = jbyt(iflag,1,mcode)
        if (fdump) write (iqlog, 910) elmnam

*---- Misalignment at entrance.
        if (icode .ne. 3  .and.  lcali .ne. 0) then
          call tmali1(ipos, .true., orbit, orbit, re, te)
          if (fdump) then
            write (iqlog, 920) ((re(i,j), j=1,6), i=1,6)
            write (iqlog, 960) orbit
            do 20 i = 1, 6
              write (iqlog, 930) i, ((te(i,j,k), k=1,6), j=1,6)
   20       continue
          endif
          call tmcat(.true., re, te, rt, tt, rt, tt)
        endif

*---- Element matrix and length.
        if (icode .eq. 1) then
          call tmmap(.true., .true., orbit, fmap, el, ek, re, te)
          if (fmap) then
            if (fdump) then
              write (iqlog, 940) ((re(i,j), j=1,6), i=1,6)
              write (iqlog, 960) orbit
              do 30 i = 1, 6
                write (iqlog, 930) i, ((te(i,j,k), k=1,6), j=1,6)
   30         continue
            endif
            call tmcat(.true., re, te, rt, tt, rt, tt)
            suml = suml + el
          endif
        endif

*---- Misalignment at exit.
        if (icode .ne. 2  .and.  lcali .ne. 0) then
          call tmali2(ipos, .true., orbit, orbit, re, te)
          if (fdump) then
            write (iqlog, 950) ((re(i,j), j=1,6), i=1,6)
            write (iqlog, 960) orbit
            do 40 i = 1, 6
              write (iqlog, 930) i, ((te(i,j,k), k=1,6), j=1,6)
   40       continue
          endif
          call tmcat(.true., re, te, rt, tt, rt, tt)
        endif
   90 continue

  910 format(' '/' TMSCND.  Entering element "',a,'".')
  920 format(t11,'Misalignment at entrance:'/(' ',6e16.8))
  930 format(t11,'Second order terms, I = ',i6/(' ',6e16.8))
  940 format(t11,'Element transfer matrix:'/(' ',6e16.8))
  950 format(t11,'Misalignment at exit:'/(' ',6e16.8))
  960 format(t11,'Orbit:'/(' ',6e16.8))

      end
+dk tmsect
      subroutine tmsect(fsec, el, h, dh, sk1, sk2, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for a sector dipole without fringe fields.           *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   EL        (real)    Length of the magnet body.                     *
*   H         (real)    Reference curvature of magnet.                 *
*   DH        (real)    Dipole field error.                            *
*   SK1       (real)    Quadrupole strength.                           *
*   SK2       (real)    Sextupole strengh.                             *
* Output:                                                              *
*   EK(6)     (real)    Kick due to dipole.                            *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second order terms.                            *
*----------------------------------------------------------------------*
+ca aparam
      double precision bi,bi2,bi2gi2,c1,c2,c3,c4,cg0,cg1,cg2,ch0,ch1,
     +ch2,cm,cp,cx,cy,cyy,dd,dh,difsq,dm,dp,dx,dyy,ek,el,fm,fp,fx,fyy,
     +gx,h,h2,hx,re,s1,s2,s3,s4,sk1,sk2,sm,sp,sumsq,sx,sy,syy,t1,t116,
     +t126,t166,t2,t216,t226,t266,t336,t346,t436,t446,t5,t516,t526,t566,
     +te,xk,xkl,xklsq,xksq,xs6,y0,y1,y2,y2klsq,y2ksq,yk,ykl,yklsq,yksq,
     +ys2,zc,zd,zf,zs
      logical           fsec
      dimension         ek(6), re(6,6), te(6,6,6)
+ca beam
+ca physicpm
      parameter         (c1  =   1.0d0,
     +                   c2  =   1.0d0 /      2.0d0,
     +                   c3  =   1.0d0 /     24.0d0,
     +                   c4  =   1.0d0 /    720.0d0)
      parameter         (s1  =   1.0d0,
     +                   s2  =   1.0d0 /      6.0d0,
     +                   s3  =   1.0d0 /    120.0d0,
     +                   s4  =   1.0d0 /   5040.0d0)
      parameter         (cg0 =   1.0d0 /     20.0d0,
     +                   cg1 =   5.0d0 /    840.0d0,
     +                   cg2 =  21.0d0 /  60480.0d0)
      parameter         (ch0 =   1.0d0 /     56.0d0,
     +                   ch1 =  14.0d0 /   4032.0d0,
     +                   ch2 = 147.0d0 / 443520.0d0)

      bi = 1.0 / betas
      bi2 = bi * bi
      bi2gi2 = 1.0 / (betas * gammas) ** 2

*---- Initialize.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)

*---- Horizontal.
      xksq = h**2 + sk1
      xk = sqrt(abs(xksq))
      xkl = xk * el
      xklsq = xksq * el**2
      if (abs(xklsq) .lt. 1.0e-2) then
        cx = (c1 - xklsq * (c2 - xklsq*c3))
        sx = (s1 - xklsq * (s2 - xklsq*s3)) * el
        dx = (c2 - xklsq * (c3 - xklsq*c4)) * el**2
        fx = (s2 - xklsq * (s3 - xklsq*s4)) * el**3
        gx = (cg0 - xklsq * (cg1 - xklsq*cg2)) * el**5
        hx = (ch0 - xklsq * (ch1 - xklsq*ch2)) * el**7
      else
        if (xklsq .gt. 0.0) then
          cx = cos(xkl)
          sx = sin(xkl) / xk
        else
          cx = cosh(xkl)
          sx = sinh(xkl) / xk
        endif
        dx = (1.0 - cx) / xksq
        fx = (el  - sx) / xksq
        gx = (3.0*el - sx*(4.0-cx)) / (2.0*xksq**2)
        hx = (15.0*el - sx*(22.0-9.0*cx+2.0*cx**2)) / (6.0*xksq**3)
      endif
      re(1,1) = cx
      re(1,2) = sx
      re(1,6) = h * dx * bi
      re(2,1) = - xksq * sx
      re(2,2) = cx
      re(2,6) = h * sx * bi
      re(5,2) = - re(1,6)
      re(5,1) = - re(2,6)
      re(5,6) = el*bi2gi2 - h**2*fx*bi2
      ek(1) = - dh*dx
      ek(2) = - dh*sx
      ek(5) =   h*dh*fx*bi + el*dtbyds

*---- Vertical.
      yksq = - sk1
      yk = sqrt(abs(yksq))
      ykl = yk*el
      yklsq = yksq*el**2
      if (abs(yklsq) .lt. 1.0e-2) then
        cy = (c1 - yklsq * (c2 - yklsq*c3))
        sy = (s1 - yklsq * (s2 - yklsq*s3)) * el
      else if (yklsq .gt. 0.0) then
        cy = cos(ykl)
        sy = sin(ykl) / yk
      else
        cy = cosh(ykl)
        sy = sinh(ykl) / yk
      endif
      re(3,3) = cy
      re(3,4) = sy
      re(4,3) = - yksq * sy
      re(4,4) = cy
      ek(3)   = 0.0
      ek(4)   = 0.0

*---- Second-order terms.
      if (fsec) then
        call uzero(te, 1, 216*mwflt)

*---- Pure horizontal terms.
        xs6 = (sk2 + 2.0*h*sk1) / 6.0
        ys2 = (sk2 +     h*sk1) / 2.0
        h2 = h / 2.0
        t116 = xs6 * (3.0*sx*fx - dx**2) - h * sx**2
        t126 = xs6 * (sx*dx**2 - 2.0*cx*gx) - h * sx * dx
        t166 = xs6 * (dx**3 - 2.0*sx*gx) - h2 * dx**2
        t216 = xs6 * (3.0*cx*fx + sx*dx)
        t226 = xs6 * (3.0*sx*fx + dx**2)
        t266 = xs6 * (sx*dx**2 - 2.0*cx*gx)
        t516 = h * xs6 * (3.0*dx*fx - 4.0*gx) +
     +         (sk1/2.0) * (fx + sx*dx)
        t526 = h * xs6 * (dx**3 - 2.0*sx*gx) + (sk1/2.0) * dx**2
        t566 = h * xs6 * (3.0*hx - 2.0*dx*gx) +
     +         (sk1/2.0) * gx - fx
        t1 = (sk1/2.0) * (dx**2 - sx*fx) - dx
        t2 = (sk1/2.0) * (el*dx - fx)
        t5 = fx - sk1 * (gx - fx*dx / 2.0)
        te(1,1,1) = - xs6 * (sx**2 + dx) - h2*xksq*sx**2
        te(1,1,2) = (- xs6*dx + h2*cx) * sx
        te(1,2,2) = (- xs6*dx + h2*cx) * dx
        te(1,1,6) = (- h2*t116 + (sk1/4.0)*el*sx) * bi
        te(1,2,6) = (- h2*t126 + (sk1/4.0) * (el*dx - fx) - sx/2.0) * bi
        te(1,6,6) = (- h**2*t166 + h*t1) * bi2 - h2 * dx * bi2gi2
        te(2,1,1) = - xs6 * (1.0 + 2.0*cx) * sx
        te(2,1,2) = - xs6 * (1.0 + 2.0*cx) * dx
        te(2,2,2) = - (2.0*xs6*dx + h2) * sx
        te(2,1,6) = (- h2*t216 - (sk1/4.0) * (sx - el*cx)) * bi
        te(2,2,6) = (- h2*t226 + (sk1/4.0) * el * sx) * bi
        te(2,6,6) = (- h**2*t266 + h*t2) * bi2 - h2 * sx * bi2gi2
        te(5,1,1) = (h2*xs6 * (sx*dx + 3.0*fx) -
     +              (sk1/4.0) * (el - cx*sx)) * bi
        te(5,1,2) = (h2*xs6*dx**2 + (sk1/4.0)*sx**2) * bi
        te(5,2,2) = (h*xs6*gx - sk1 * (fx - sx*dx) / 4.0 - sx/2.0) * bi
        te(5,1,6) = h2 * ((t516 - sk1 * (el*dx - fx) / 2.0) * bi2 +
     +                    sx * bi2gi2)
        te(5,2,6) = h2 * ((t526 - sk1 * (dx**2 - sx*fx) / 2.0) * bi2 +
     +                    dx * bi2gi2)
        te(5,6,6) = (h**2 * (t566 + t5) * bi2 +
     +              (3.0/2.0) * (h**2*fx - el) * bi2gi2) * bi

*---- Mixed terms.
        y2ksq = 4.0 * yksq
        call tmfoc(el, y2ksq, cyy, syy, dyy, fyy)
        y2klsq = y2ksq * el**2
        if (max(abs(y2klsq),abs(xklsq)) .le. 1.0e-2) then
          y0 = 1.0
          y1 = xklsq + y2klsq
          y2 = xklsq**2 + xklsq*y2klsq + y2klsq**2
          zc = (y0 - (y1 - y2 / 30.0) / 12.0) * el**2 /   2.0
          zs = (y0 - (y1 - y2 / 42.0) / 20.0) * el**3 /   6.0
          zd = (y0 - (y1 - y2 / 56.0) / 30.0) * el**4 /  24.0
          zf = (y0 - (y1 - y2 / 72.0) / 42.0) * el**5 / 120.0
        else if (xksq .le. 0.0  .or.  yksq .le. 0.0) then
          dd = xksq - y2ksq
          zc = (cyy - cx) / dd
          zs = (syy - sx) / dd
          zd = (dyy - dx) / dd
          zf = (fyy - fx) / dd
        else
          sumsq = (xk/2.0 + yk) ** 2
          difsq = (xk/2.0 - yk) ** 2
          call tmfoc(el, sumsq, cp, sp, dp, fp)
          call tmfoc(el, difsq, cm, sm, dm, fm)
          zc = sp * sm / 2.0
          zs = (sp*cm - cp*sm) / (4.0*xk*yk)
          if (xksq .gt. y2ksq) then
            zd = (dyy - zc) / xksq
            zf = (fyy - zs) / xksq
          else
            zd = (dx - zc) / y2ksq
            zf = (fx - zs) / y2ksq
          endif
        endif
        t336 = sk2 * (cy*zd - 2.0*sk1*sy*zf) + h * sk1 * fx * sy
        t346 = sk2 * (sy*zd - 2.0*cy*zf) + h * fx * cy
        t436 = 2.0 * ys2 * fx * cy - sk2 * sk1 * (sy*zd - 2.0*cy*zf)
        t446 = 2.0 * ys2 * fx * sy - sk2 * (cy*zd - 2.0*sk1*sy*zf)
        te(1,3,3) = + sk2*sk1*zd + ys2*dx
        te(1,3,4) = + sk2*zs/2.0
        te(1,4,4) = + sk2*zd - h2*dx
        te(2,3,3) = + sk2*sk1*zs + ys2*sx
        te(2,3,4) = + sk2*zc/2.0
        te(2,4,4) = + sk2*zs - h2*sx
        te(3,1,3) = + sk2*(cy*zc/2.0 - sk1*sy*zs) + h2*sk1*sx*sy
        te(3,1,4) = + sk2*(sy*zc/2.0 - cy*zs) + h2*sx*cy
        te(3,2,3) = + sk2*(cy*zs/2.0 - sk1*sy*zd) + h2*sk1*dx*sy
        te(3,2,4) = + sk2*(sy*zs/2.0 - cy*zd) + h2*dx*cy
        te(3,3,6) = (h2*t336 - sk1*el*sy/4.0) * bi
        te(3,4,6) = (h2*t346 - (sy + el*cy) / 4.0) * bi
        te(4,1,3) = sk2*sk1*(cy*zs - sy*zc/2.0) + ys2*sx*cy
        te(4,1,4) = sk2*(sk1*sy*zs - cy*zc/2.0) + ys2*sx*sy
        te(4,2,3) = sk2*sk1*(cy*zd - sy*zs/2.0) + ys2*dx*cy
        te(4,2,4) = sk2*(sk1*sy*zd - cy*zs/2.0) + ys2*dx*sy
        te(4,3,6) = (h2*t436 + sk1 * (sy - el*cy) / 4.0) * bi
        te(4,4,6) = (h2*t446 - sk1*el*sy/4.0) * bi
        te(5,3,3) = (- h*sk2*sk1*zf - h*ys2*fx + sk1*(el-cy*sy)/4.0)*bi
        te(5,3,4) = (- h*sk2*zd/2.0 - sk1*sy**2/4.0) * bi
        te(5,4,4) = (- h*sk2*zf + h*h2*fx - (el + sy*cy)/4.0) * bi
        call tmsymm(te)

*---- Effect of dipole error.
        if (dh .ne. 0.0) then
          re(1,1) = re(1,1) + dh * t116
          re(1,2) = re(1,2) + dh * t126
          re(1,6) = re(1,6) + dh * (2.0*h*t166 - t1) * bi
          re(2,1) = re(2,1) + dh * (t216 - h*sx)
          re(2,2) = re(2,2) + dh * t226
          re(2,6) = re(2,6) + dh * (2.0*h*t266 - t2) * bi
          re(5,1) = re(5,1) - dh * t516 * bi
          re(5,2) = re(5,2) - dh * (t526 - dx) * bi
          re(5,6) = re(5,6) -
     +              dh * h * ((2.0*t566 + t5) * bi2 + fx * bi2gi2)
          re(3,3) = re(3,3) - dh * t336
          re(3,4) = re(3,4) - dh * t346
          re(4,3) = re(4,3) - dh * t436
          re(4,4) = re(4,4) - dh * t446
          ek(1) = ek(1) - dh**2 * t166
          ek(2) = ek(2) - dh**2 * t266
          ek(5) = ek(5) + dh**2 * t566 * bi
        endif
      endif

      end
+dk tmsep
      subroutine tmsep(fsec, ftrk, fract, orbit, fmap, el, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for electrostatic separator.                         *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
*   FRACT     (real)    Fraction of length to be used.                 *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EL        (real)    Element length.                                *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      double precision by2,by24,by6,ch,dl,dy,efield,ek,ekick,ekl,el,eps,
     +fact,fract,one,orbit,re,sh,sy,te,ten3m,three,tilt,two
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer
+ca stflag

      parameter         (one   = 1.0d0)
      parameter         (by2   = 1.0d0 /  2.0d0)
      parameter         (by6   = 1.0d0 /  6.0d0)
      parameter         (by24  = 1.0d0 / 24.0d0)
      parameter         (two   = 2.0d0)
      parameter         (three = 3.0d0)
      parameter         (eps   = 1.0d-4)
      parameter         (ten3m = 1.0d-3)

*---- Initialize.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)
      if (fsec) call uzero(te, 1, 216*mwflt)

*---- Fetch data from pool.
      call ucopy(q(lcelm+melen), el, mwflt)
      fmap = el .ne. 0.0
      if (.not. fmap) return
      dl = el * fract

*---- Strength and tilt.
      if (ftrk) then
        call ucopy(q(lcelm+meflde), efield, mwflt)
      else
        efield = 0.0
      endif
      call ucopy(q(lcelm+metlte), tilt, mwflt)
      if (efield .ne. 0.0 .and. tilt .ne. 0.0) cplxy = .true.

*---- Prepare linear transformation parameters.
*     DY = (COSH(K*L) - 1) / K.
      ekick  = efield * ten3m * charge / (pc * (one + deltas))
      ekl = ekick * dl
      if (abs(ekl) .gt. eps) then
        ch = cosh(ekl)
        sh = sinh(ekl)
        sy = sh / ekick
        dy = (ch - one) / ekick**2
      else
        ch = (one + by2  * ekl**2)
        sy = (one + by6  * ekl**2) * dl
        sh = sy * ekick
        dy = (by2 + by24 * ekl**2) * dl**2
      endif

*---- Kicks.
      ek(3) = dy * (ekick / betas)
      ek(4) = sy * (ekick / betas)
      ek(5) = dl * dtbyds

*---- First-order terms.
      re(1,2) = dl
      re(3,3) = ch - ekl * sh / betas**2
      re(3,4) = sy
      re(3,6) = (dy - dl * sy / betas**2) * ekick
      re(4,3) = (sh - ekl * ch / betas**2) * ekick
      re(4,4) = ch
      re(4,6) = (sh - ekl * ch / betas**2)
      re(5,3) = - re(4,6)
      re(5,4) = - dy * ekick
      re(5,6) = - (sy - dl * ch / betas**2)

*---- Second-order terms.
      if (fsec) then
        fact = dl / (two * betas)
        te(1,2,3) = - fact * ekick
        te(1,2,6) = - fact
        fact = dl * (three*sh/gammas**2 + ekl*ch) / (two*betas**3)
        te(3,3,3) = fact * ekick**2
        te(3,3,6) = fact * ekick
        te(3,6,6) = fact
        fact = dl * (three*ch/gammas**2 + ekl*sh) / (two*betas**3)
        te(4,3,3) = fact * ekick**3
        te(4,3,6) = fact * ekick**2
        te(4,6,6) = fact * ekick
        te(5,3,3) = - fact * ekick**2
        te(5,3,6) = - fact * ekick
        te(5,6,6) = - fact
        fact = dl * sh / (two * betas)
        te(3,2,2) = fact
        te(3,4,4) = fact
        te(4,3,4) = - fact * ekick**2
        te(4,4,6) = - fact * ekick
        te(5,3,4) = fact * ekick
        te(5,4,6) = fact
        fact = dl * ch / (two * betas)
        te(3,3,4) = - fact * ekick
        te(3,4,6) = - fact
        te(4,2,2) = fact * ekick
        te(4,4,4) = fact * ekick
        te(5,2,2) = - fact
        te(5,4,4) = - fact
        call tmsymm(te)
      endif

*---- Apply tilt.
      if (tilt .ne. 0.0) call tmtilt(fsec, tilt, ek, re, te)

*---- Track orbit.
      if (ftrk) call tmtrak(ek, re, te, orbit, orbit)

      end
+dk tmsext
      subroutine tmsext(fsec, ftrk, fract, orbit, fmap, el, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for sextupole element.                               *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
*   FRACT     (real)    Fraction of length to be used.                 *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EL        (real)    Element length.                                *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      double precision dl,dsk2,ek,el,four,fract,one,orbit,pt,re,rfac,s1,
     +s2,s3,s4,six,sk2,skl,te,tilt,twelve,two
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer
+ca stflag
+ca tmcomm

      parameter         (one    =  1.0d0, two    =  2.0d0)
      parameter         (four   =  4.0d0, six    =  6.0d0)
      parameter         (twelve = 12.0d0)

*---- Initialize.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)

*---- Fetch data from pool.
      call ucopy(q(lcelm+melen), el, mwflt)
      fmap = el .ne. 0.0
      if (.not. fmap) return
      dl = el * fract

*---- Field strength.
      call ucopy(q(lcelm+mek2s), sk2, mwflt)
      call ucopy(q(lcelm+metlts), tilt, mwflt)
      if (tilt .ne. 0.0) cplxy = .true.

*---- Field error.
      if (lcfld .ne. 0) then
        call ucopy(q(lcfld+4*mwflt+1), dsk2, mwflt)
        sk2 = sk2 + dsk2 / el
      endif
      sk2 = sk2 * cohelp / (one + deltas)
*--- apply inversion and scaling
      sk2 = sk2 * elkfact(6)
*---- Half radiation effects at entrance.
      if (ftrk .and. dorad) then
        rfac = arad * gammas**3 * sk2**2 * dl * (orbit(1)**2 + orbit(3)
     +  **2)**2 / twelve
        pt = orbit(6)
        orbit(2) = orbit(2) - rfac * (one + pt) * orbit(2)
        orbit(4) = orbit(4) - rfac * (one + pt) * orbit(4)
        orbit(6) = orbit(6) - rfac * (one + pt) ** 2
      endif

*---- First-order terms.
      re(1,2) = dl
      re(3,4) = dl
      re(5,6) = dl/(betas*gammas)**2
      ek(5) = dl*dtbyds

*---- Second-order terms.
      if (fsec) then
        call uzero(te, 1, 216*mwflt)
        skl = sk2 * dl
        if (skl .ne. 0.0) then
          s1 = skl / 2.0
          s2 = s1 * dl / 2.0
          s3 = s2 * dl / 3.0
          s4 = s3 * dl / 4.0
          te(1,1,1) = - s2
          te(1,1,2) = - s3
          te(1,2,2) = - 2.0 * s4
          te(1,3,3) = + s2
          te(1,3,4) = + s3
          te(1,4,4) = + 2.0 * s4
          te(2,1,1) = - s1
          te(2,1,2) = - s2
          te(2,2,2) = - 2.0 * s3
          te(2,3,3) = + s1
          te(2,3,4) = + s2
          te(2,4,4) = + 2.0 * s3
          te(3,1,3) = + s2
          te(3,1,4) = + s3
          te(3,2,3) = + s3
          te(3,2,4) = + 2.0 * s4
          te(4,1,3) = + s1
          te(4,1,4) = + s2
          te(4,2,3) = + s2
          te(4,2,4) = + 2.0 * s3
        endif
        te(1,2,6) = - dl / (2.0 * betas)
        te(3,4,6) = te(1,2,6)
        te(5,2,2) = te(1,2,6)
        te(5,4,4) = te(1,2,6)
        te(5,6,6) = - 3.0 * re(5,6) / (2.0 * betas)
        call tmsymm(te)
      endif

*---- Apply tilt.
      if (tilt .ne. 0.0) call tmtilt(fsec, tilt, ek, re, te)

*---- Track orbit.
      if (ftrk) then
        call tmtrak(ek, re, te, orbit, orbit)

*---- Half radiation effects at exit.
        if (dorad) then
          rfac = arad * gammas**3 * sk2**2 * dl * (orbit(1)**2 + orbit
     +    (3)**2)**2 / twelve
          pt = orbit(6)
          orbit(2) = orbit(2) - rfac * (one + pt) * orbit(2)
          orbit(4) = orbit(4) - rfac * (one + pt) * orbit(4)
          orbit(6) = orbit(6) - rfac * (one + pt) ** 2
        endif
      endif

      end
+dk tmsol
      subroutine tmsol(fsec, ftrk, fract, orbit, fmap, el, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for solenoid element.                                *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
*   FRACT     (real)    Fraction of length to be used.                 *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EL        (real)    Element length.                                *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      double precision co,dl,ek,el,fract,one,orbit,re,si,sibk,six,sk,
     +skl,sks,te,temp,three,two,zero
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer
+ca stflag

      parameter         (one = 1.0d0, two = 2.0d0, six = 6.0d0)
      parameter         (zero = 0.0d0, three = 3.0d0)

*---- Initialize.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)

*---- Fetch data from pool.
      call ucopy(q(lcelm+melen), el, mwflt)
      fmap = el .ne. zero
      if (.not. fmap) return
      dl = el * fract

*---- Strength.
      call ucopy(q(lcelm+mekss), sks, mwflt)
      if (sks .ne. zero) then
        cplxy = .true.
      endif

*--- apply inversion and scaling
        sks = sks * elkfact(9)
*---- Set up C's and S's.
      sk = sks / two / (one + deltas)
      skl = sk * dl
      co = cos(skl)
      si = sin(skl)
      if (abs(skl) .lt. 1.0e-5) then
        sibk = (one - skl**2/six) * dl
      else
        sibk = si/sk
      endif

*---- First-order terms.
      re(1,1) = co**2
      re(2,2) = re(1,1)
      re(3,3) = re(1,1)
      re(4,4) = re(1,1)
      re(1,2) = co * sibk
      re(3,4) = re(1,2)
      re(1,3) = co * si
      re(2,4) = re(1,3)
      re(3,1) = - re(1,3)
      re(4,2) = re(3,1)
      re(2,1) = sk * re(3,1)
      re(4,3) = re(2,1)
      re(1,4) = si * sibk
      re(3,2) = - re(1,4)
      re(4,1) = sk * si**2
      re(2,3) = - re(4,1)
      re(5,6) = dl/(betas*gammas)**2
      ek(5) = dl*dtbyds

*---- Second-order terms.
      if (fsec) then
        call uzero(te, 1, 216*mwflt)
        temp = dl * co * si / betas
        te(1,4,6) = - temp
        te(3,2,6) =   temp
        te(1,1,6) =   temp * sk
        te(2,2,6) =   temp * sk
        te(3,3,6) =   temp * sk
        te(4,4,6) =   temp * sk
        te(2,3,6) =   temp * sk**2
        te(4,1,6) = - temp * sk**2

        temp = dl * (co**2 - si**2) / (two * betas)
        te(1,2,6) = - temp
        te(3,4,6) = - temp
        te(1,3,6) = - temp * sk
        te(2,4,6) = - temp * sk
        te(3,1,6) =   temp * sk
        te(4,2,6) =   temp * sk
        te(2,1,6) =   temp * sk**2
        te(4,3,6) =   temp * sk**2

        temp = dl / (two * betas)
        te(5,2,2) = - temp
        te(5,4,4) = - temp
        te(5,1,4) =   temp * sk
        te(5,2,3) = - temp * sk
        te(5,1,1) = - temp * sk**2
        te(5,3,3) = - temp * sk**2
        te(5,6,6) = - three * re(5,6) / (two * betas)
        call tmsymm(te)
      endif

*---- Track orbit.
      if (ftrk) call tmtrak(ek, re, te, orbit, orbit)

      end
+dk tmsrot
      subroutine tmsrot(fsec, ftrk, orbit, fmap, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for rotation about S-axis.                           *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      double precision ct,ek,orbit,re,st,te,theta
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca refer
+ca stflag

*---- Initialize.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)

*---- Fetch angle from pool.
      call ucopy(q(lcelm+meangr), theta, mwflt)
      fmap = theta .ne. 0.0
      if (.not. fmap) return

*---- First-order terms.
      cplxy = .true.
      ct = cos(theta)
      st = sin(theta)
      re(1,1) = ct
      re(1,3) = st
      re(3,1) = - st
      re(3,3) = ct
      re(2,2) = ct
      re(2,4) = st
      re(4,2) = - st
      re(4,4) = ct

*---- There are no second-order terms.
      if (fsec) call uzero(te, 1, 216*mwflt)

*---- Track orbit.
      if (ftrk) call tmtrak(ek, re, te, orbit, orbit)

      end
+dk tmsymm
      subroutine tmsymm(t)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Symmetrize second-order array T.                                   *
* Input:                                                               *
*   T(6,6,6)  (real)    Array to be symmetrized.                       *
* Output:                                                              *
*   T(6,6,6)  (real)    Symmetrized array.                             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,k,l
      double precision t
      dimension         t(6,6,6)

      do 20 k = 1, 5
      do 20 l = k+1, 6
        do 10 i = 1, 6
          t(i,l,k) = t(i,k,l)
   10   continue
   20 continue

      end
+dk tmsymp
      subroutine tmsymp(r)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Symplectify a 6 by 6 matrix R.                                     *
*   Algorithm described in the doctoral thesis by Liam Healey.         *
* Input:                                                               *
*   R(6,6)    (real)    Matrix to be symplectified.                    *
* Output:                                                              *
*   R(6,6)    (real)    The symplectified matrix.                      *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j
      double precision a,b,r,v
      dimension         r(6,6)

      dimension         a(6,6), b(6,6), v(6,6)
      logical           eflag

      do 20 i = 1, 6
        do 10 j = 1, 6
          a(i,j) = - r(i,j)
          b(i,j) = + r(i,j)
   10   continue
        a(i,i) = a(i,i) + 1.0
        b(i,i) = b(i,i) + 1.0
   20 continue

      call m66div(a, b, v, eflag)
      call m66inv(v, a)

      do 40 i = 1, 6
        do 30 j = 1, 6
          a(i,j) = (a(i,j) - v(i,j)) / 2.0
          b(i,j) = - a(i,j)
   30   continue
        b(i,i) = b(i,i) + 1.0
        a(i,i) = a(i,i) + 1.0
   40 continue

      call m66div(a, b, r, eflag)

      end
+dk tmthrd
      subroutine tmthrd(lseq, ipos, ibpos, kpro, inbpos)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Correct orbit position or angle in first pass (threader)
* Input:
*   lseq       (integer) pointer to current beam line
*   ipos       (integer) current element position in beam line
*   ibpos      (integer) current element position in buffer ndpos etc.
*   kpro       (integer) projection (1 = x, 2 = y)
* further input in commons addcmi and addcmr
* Output:
*   inbpos     (integer) buffer position for restart
*
*----------------------------------------------------------------------*
+ca aparam
+ca physicpm
+ca pi
+ca bmparm
      integer i,ibp,ibpos,icorr,inbpos,ipos,itp,j,k,kdc,kdm,kpro,lc,
     +nsub
      double precision ainv,amcorr,atemp1,atemp2,cick,d,r1,r2,tol1,tol2
      integer           lseq(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca codata
+ca elmgroup
+ca seqflag
+ca seqgroup
+ca refer
+ca optic0
+ca thrcom
      integer ncorr(2)
      dimension amcorr(6,6,2), ainv(6,6,2), atemp1(6,6), atemp2(6,6)
      dimension cick(2)

      inbpos = ibpos
*--- look for two preceding correctors of correct type
      lc = 2 * (kpro - 1)
      itp = 14 + lc
      kdm = ndocc
      ibp = ibpos
   10 continue
      icorr = 0
      j = ibp
      kdc = kdm
      do 20 i = 1, kdc
        j = j - 1
        if (j .eq. 0)  j = mwind
        if (icorr .eq. 0)  then
          ibp = ibp - 1
          kdm = kdm - 1
        endif
        if (ndtype(j) .eq. itp)  then
          icorr = icorr + 1
          ncorr(icorr) = j
          call ucopy(admatr(1,1,j), amcorr(1,1,icorr), 36*mwflt)
          call m66inv(amcorr(1,1,icorr), ainv(1,1,icorr))
          if (icorr .eq. 2) goto 40
        endif
   20 continue
*--- no two preceding correctors - change initial orbit
      call m66inv(admatr(1,1,ibpos), atemp1)
      orbit0(lc+1) = orbit0(lc+1) - (atemp1(lc+1,lc+1)
     +* adorbt(lc+1,ibpos) + atemp1(lc+1,lc+2) * adorbt(lc+2,ibpos))
      orbit0(lc+2) = orbit0(lc+2) - (atemp1(lc+2,lc+1)
     +* adorbt(lc+1,ibpos) + atemp1(lc+2,lc+2) * adorbt(lc+2,ibpos))
      inbpos = 0
      do 30 i = nlpos + 1, ipos - 1
   30 ndflag(i) = 1
      nlpos = max(nlpos, ipos - 1)
      goto 999
   40 continue
*--- get transport matrix from corr. 2 to corr. 1
      call m66mpy(amcorr, ainv(1,1,2), atemp2)
*--- check whether correctors are linearly independent
      tol1 = abs(atemp2(lc+1,lc+2))
      tol2 = abs(one - abs(atemp2(lc+2,lc+2)))
      if (tol1 .lt. adtol(5) .or. tol2 .lt. adtol(6))  then
*--- drop corrector 1, retry
        goto 10
      endif
*--- get corrector settings
      call m66mpy(admatr(1,1,ibpos), ainv(1,1,1), atemp1)
      call m66mpy(admatr(1,1,ibpos), ainv(1,1,2), atemp2)
      r1 = -(adorbt(lc+1,ibpos) - reforb(lc+1))
      r2 = -(adorbt(lc+2,ibpos) - reforb(lc+2))
      d = atemp2(lc+1,lc+2) * atemp1(lc+2,lc+2) - atemp2(lc+2,lc+2) *
     +atemp1(lc+1,lc+2)
      if (abs(d) .lt. adtol(5))  then
*--- drop corrector 1, retry
        goto 10
      endif
      cick(2) = (r1 * atemp1(lc+2,lc+2) - r2 * atemp1(lc+1,lc+2)) / d
      cick(1) = (r2 * atemp2(lc+1,lc+2) - r1 * atemp2(lc+2,lc+2)) / d
*      print *, 'cick = ', cick
*--- add kicks to kicker strengths
      do 50 i = 1, 2
        if (lq(lseq(1)-mscom) .ne. 0) then
          lccom = lq(lq(lseq(1)-mscom)-ndpos(ncorr(i)))
          if (lccom .ne. 0) then
            call ucopy(q(lccom+1), xcm, 2*mwflt)
            if (kpro .eq. 1) then
              xcm = xcm + cick(i)
            else
              ycm = ycm + cick(i)
            endif
            call ucopy(xcm, q(lccom+1), 2*mwflt)
            goto 50
          endif
        endif
        print *,' warning: kick not active: ', ncorr(i)
        goto 999
   50 continue
*--- set pointer to element in front of corr. 2
      inbpos = ncorr(2) - 1
      if (inbpos .eq. 0)  inbpos = mwind
*--- reduce ndocc, set skip flag
      nsub = ibpos - inbpos
      if (nsub .lt. 0)  nsub = nsub + mwind
      ndocc = ndocc - nsub
      k = ipos
      j = inbpos
      do 60 i = 1, nsub - 1
        j = j + 1
        if (j .gt. mwind)  j = 1
        ndflag(ndpos(j)) = 1
   60 continue
   70 continue
  999 end
+dk tmtilt
      subroutine tmtilt(fsec, tilt, ek, r, t)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Apply TILT to a TRANSPORT map.                                     *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   TILT      (real)    Roll angle.                                    *
*   EK(6)     (real)    Element kick, unrotated.                       *
*   R(6,6)    (real)    Transfer matrix, unrotated.                    *
*   T(6,6,6)  (real)    Second order terms, unrotated.                 *
* Output:                                                              *
*   EK(6)     (real)    Element kick, rotated.                         *
*   R(6,6)    (real)    Transfer matrix, rotated.                      *
*   T(6,6,6)  (real)    Second order terms, rotated.                   *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,k
      double precision c,ek,r,r1j,r2j,ri1,ri2,s,t,t1jk,t2jk,ti1k,ti2k,
     +tij1,tij2,tilt,xx
      logical           fsec
      dimension         ek(6), r(6,6), t(6,6,6)

      c = cos(tilt)
      s = sin(tilt)

*---- Rotate at entrance.
      do 40 i = 1, 6
        ri1 = r(i,1)
        r(i,1) = ri1 * c - r(i,3) * s
        r(i,3) = ri1 * s + r(i,3) * c
        ri2 = r(i,2)
        r(i,2) = ri2 * c - r(i,4) * s
        r(i,4) = ri2 * s + r(i,4) * c

        if (fsec) then
          do 10 k = 1, 6
            ti1k = t(i,1,k)
            t(i,1,k) = ti1k * c - t(i,3,k) * s
            t(i,3,k) = ti1k * s + t(i,3,k) * c
            ti2k = t(i,2,k)
            t(i,2,k) = ti2k * c - t(i,4,k) * s
            t(i,4,k) = ti2k * s + t(i,4,k) * c
   10     continue
          do 20 j = 1, 6
            tij1 = t(i,j,1)
            t(i,j,1) = tij1 * c - t(i,j,3) * s
            t(i,j,3) = tij1 * s + t(i,j,3) * c
            tij2 = t(i,j,2)
            t(i,j,2) = tij2 * c - t(i,j,4) * s
            t(i,j,4) = tij2 * s + t(i,j,4) * c
   20     continue
        endif
   40 continue

*---- Rotate kick.
      xx = ek(1)
      ek(1) = xx * c - ek(3) * s
      ek(3) = xx * s + ek(3) * c
      xx = ek(2)
      ek(2) = xx * c - ek(4) * s
      ek(4) = xx * s + ek(4) * c

*---- Rotate at exit.
      do 90 j = 1, 6
        r1j = r(1,j)
        r(1,j) = c * r1j - s * r(3,j)
        r(3,j) = s * r1j + c * r(3,j)
        r2j = r(2,j)
        r(2,j) = c * r2j - s * r(4,j)
        r(4,j) = s * r2j + c * r(4,j)
        if (fsec) then
          do 60 k = 1, 6
            t1jk = t(1,j,k)
            t(1,j,k) = c * t1jk - s * t(3,j,k)
            t(3,j,k) = s * t1jk + c * t(3,j,k)
            t2jk = t(2,j,k)
            t(2,j,k) = c * t2jk - s * t(4,j,k)
            t(4,j,k) = s * t2jk + c * t(4,j,k)
   60     continue
        endif
   90 continue

      end
+dk tmtrak
      subroutine tmtrak(ek, re, te, orb1, orb2)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track orbit and change reference for RE matrix.                    *
* Input:                                                               *
*   EK(6)     (real)    Kick on orbit.                                 *
*   RE(6,6)   (real)    Transfer matrix before update.                 *
*   TE(6,6,6) (real)    Second order terms.                            *
*   ORB1(6)   (real)    Orbit before element.                          *
* Output:                                                              *
*   ORB2(6)   (real)    Orbit after element.                           *
*   RE(6,6)   (real)    Transfer matrix after update.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer i,k,l
      double precision ek,orb1,orb2,re,sum1,sum2,te,temp
      dimension         ek(6), re(6,6), te(6,6,6), orb1(6), orb2(6)
+ca option

      dimension         temp(6)

      do 30 i = 1, 6
        sum2 = ek(i)
        do 20 k = 1, 6
          sum1 = 0.0
          do 10 l = 1, 6
            sum1 = sum1 + te(i,k,l) * orb1(l)
   10     continue
          sum2 = sum2 + (re(i,k) + sum1) * orb1(k)
          re(i,k) = re(i,k) + sum1 + sum1
   20   continue
        temp(i) = sum2
   30 continue

      call ucopy(temp, orb2, 6*mwflt)

*---- Symplectify transfer matrix.
      if (sympl) call tmsymp(re)

      end
+dk tmturn
      subroutine tmturn(lseq, deltap, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Compute closed orbit and one turn TRANSFORM map.                   *
* Input:                                                               *
*   LSEQ(1)   (pointer) Beam line expansion to be used.                *
*   DELTA     (real)    delta(p) / p.                                  *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
*   ORBIT0(6) /OPTIC0/  Closed orbit, initial conditions.              *
*   RT(6,6)   /MAPTRN/  Linear map for one turn.                       *
*   TT(6,6,6) /MAPTRN/  Quadratic terms for one turn.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iflag,lmap,nd
      double precision deltap
      logical           eflag
      integer           lseq(1)
+ca memdum
+ca seqgroup
+ca maptrn
+ca optic0
+ca stflag
+ca option
+ca coesti

*---- Search for precomputed map with same DELTAP and flags.
      iflag = 0
      do 10 i = 1, maxdof
        if (doflag(i)) then
          iflag = 2 * iflag + 1
        else
          iflag = 2 * iflag
        endif
   10 continue
      lmap = lq(lseq(1)-msmap)
   20 if (lmap .ne. 0) then
        if (abs(q(lmap+1)-real(deltap)) .lt. 1.0e-6  .and.
     +      iq(lmap+2) .eq. iflag) then
          call ucopy(q(lmap+3), orbit0, 6*mwflt)
          if (optflg(20))  call ucopy(orbit0, coest, 6*mwflt)
          call ucopy(q(lmap+6*mwflt+3), rt, 36*mwflt)
          call ucopy(q(lmap+42*mwflt+3), tt, 216*mwflt)
          return
        endif
        lmap = lq(lmap)
        go to 20
      endif

*---- Not found, compute and store map.
      call tmclor(lseq, deltap, .true., eflag)
      if (.not. eflag) then
        call tmscnd(lseq)
        nd = mwflt * (6 + 36 + 216) + 2
        call mzbook(2, lmap, lseq, -msmap, 'TMAP', 0, 0, nd, mreal, -1)
        q(lmap+1) = real(deltap)
        iq(lmap+2) = iflag
        call ucopy(orbit0, q(lmap+3), 6*mwflt)
        if (optflg(20))  call ucopy(orbit0, coest, 6*mwflt)
        call ucopy(rt, q(lmap+6*mwflt+3), 36*mwflt)
        call ucopy(tt, q(lmap+42*mwflt+3), 216*mwflt)
      endif

      end
+dk tmuser
      subroutine tmuser(fsec, ftrk, fract, orbit, fmap, el, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for user-defined element.                            *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
*   FRACT     (real)    Fraction of length to be used.                 *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EL        (real)    Element length.                                *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      double precision ek,el,fract,orbit,re,te
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca refer

*---- Initialize.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)

*---- Fetch data from pool, to be filled in, also set FMAP.
      el = 0.0
      fmap = .false.
      if (.not. fmap) return

*---- Kick, to be filled in.

*---- Transfer matrix, to be filled in.

*---- Second-order terms, to be filled in.
      if (fsec) then
        call uzero(te, 1, 216*mwflt)
      endif

*---- Track orbit.
      if (ftrk) call tmtrak(ek, re, te, orbit, orbit)

      end
+dk tmyrot
      subroutine tmyrot(fsec, ftrk, orbit, fmap, ek, re, te)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TRANSPORT map for rotation about Y-axis.                           *
*   Treated in a purely linear way.                                    *
* Input:                                                               *
*   FSEC      (logical) If true, return second order terms.            *
*   FTRK      (logical) If true, track orbit.                          *
* Input/output:                                                        *
*   ORBIT(6)  (real)    Closed orbit.                                  *
* Output:                                                              *
*   FMAP      (logical) If true, element has a map.                    *
*   EK(6)     (real)    Kick due to element.                           *
*   RE(6,6)   (real)    Transfer matrix.                               *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Important common data:                                               *
*   LCELM     /REFER/   Current element bank.                          *
*----------------------------------------------------------------------*
+ca aparam
      double precision cosphi,ek,orbit,phi,re,sinphi,tanphi,te
      logical           fsec, ftrk, fmap
      dimension         orbit(6), ek(6), re(6,6), te(6,6,6)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer

*---- Initialize.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)

*---- Fetch angle from pool.
      call ucopy(q(lcelm+meangr), phi, mwflt)
      fmap = phi .ne. 0.0
      if (.not. fmap) return

*---- Kick.
      cosphi = cos(phi)
      sinphi = sin(phi)
      tanphi = sinphi / cosphi
      ek(2) = - sinphi

*---- Transfer matrix.
      re(1,1) = 1.0 / cosphi
      re(2,2) = cosphi
      re(2,6) = - sinphi / betas
      re(5,1) = tanphi / betas

*---- Second-order terms are ignored (all coefficient of order >= 1).
      if (fsec) call uzero(te, 1, 216*mwflt)

*---- Track orbit.
      if (ftrk) call tmtrak(ek, re, te, orbit, orbit)

      end
+dk tmzzzz
+dk tpaaaa
+dk tpelem
      subroutine tpelem(elmnam, idisk)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Write element parameters on disk for TAPE option.                  *
* Input:                                                               *
*   LCELM     /REFER/   Current element bank.                          *
*   ELMNAM    (char     Name associated with current element.          *
*   IDISK     (integer) Logical unit number.                           *
*----------------------------------------------------------------------*
* Modified: 25-NOV-1998, M. Woodley (SLAC)                             *
*   Add element APER, TYPE, and ENERGY to tape file output             *
* Modified: 31-MAR-1999, M. Woodley (SLAC)                             *
*   Define position record contents for all elements according to      *
*   Extended Tape File Format (XTFF) convention                        *
*----------------------------------------------------------------------*
+ca aparam
      integer idisk,isp,lkey
      double precision temp,xkick,ykick,aper,zero
      character*(*)     elmnam
      integer i
+ca memdum
+ca bankhead
+ca beam
+ca cmdgroup
+ca elmgroup
+ca codata
+ca refer
+ca pi
      parameter (zero = 0.d0)
      character*(mcnam) key, name, type
      dimension         temp(9)
      integer bvpos
      parameter         (bvpos = 24)
      logical bvflag

      bvflag = .false.
      temp(1) = zero
      temp(2) = zero
      temp(3) = zero
      temp(4) = zero
      temp(5) = zero
      temp(6) = zero
      temp(7) = zero
      temp(8) = zero
      temp(9) = zero
      aper    = zero
      if (lcelm .eq. 0) then
        key = ' '
        name = 'INITIAL'
        type = ' '
      else
        lkey = lq(lcelm+1)
        call diname(ldkey, iq(lkey+mbnam), key)
        name = elmnam
        type = ' '
        call utgnam(lcelm, 1, 1, type)

*---- Select element type.
        isp = iq(lcelm+mbsp)
        go to ( 10,  20,  30,  40,  50,  60,  70,  80,  90, 100,
     +         110, 120, 130, 140, 150, 160, 170, 180, 190, 200,
     +         210, 220, 230, 240, 250, 260, 270, 280, 290, 300,
     +         310, 310, 310, 310, 310, 310, 310, 310, 310, 310), isp

*---- Drift.
   10   continue
*---- Monitor.
  170   continue
  180   continue
  190   continue

*---- Collimator.
  200   continue
  210   continue

*---- Beam instrument.
  240   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
        go to 500

*---- Rectangular or sector bend.
   20   continue
   30   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+meangb), temp(2), mwflt)
          call ucopy(q(lcelm+mek1b), temp(3), mwflt)
          call ucopy(q(lcelm+mek2b), temp(4), mwflt)
          call ucopy(q(lcelm+metltb), temp(5), mwflt)
          call ucopy(q(lcelm+mee1b), temp(6), mwflt)
          call ucopy(q(lcelm+mee2b), temp(7), mwflt)
          call ucopy(q(lcelm+meh1b), temp(8), mwflt)
          call ucopy(q(lcelm+meh2b), temp(9), mwflt)
          call ucopy(q(lcelm+meintbx+3*mcsiz), bvflag, 1)
*--- HG000915 use bv flag to possibly invert angle
        if (bvflag) temp(2) = beambv * temp(2)
*--- apply inversion and scaling
          do i = 3, 4
            temp(i) = elmfact(i-2) * temp(i)
          enddo
          call ucopy(q(lcelm+megapb), aper, mwflt)
        go to 500

*---- Quadrupole.
   50   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+mek1q), temp(3), mwflt)
          call ucopy(q(lcelm+metltq), temp(5), mwflt)
*--- apply inversion and scaling
          temp(3) = temp(3) * elkfact(5)
          call ucopy(q(lcelm+meaprq), aper, mwflt)
        go to 500

*---- Sextupole.
   60   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+mek2s), temp(4), mwflt)
          call ucopy(q(lcelm+metlts), temp(5), mwflt)
*--- apply inversion and scaling
          temp(4) = temp(4) * elkfact(6)
          call ucopy(q(lcelm+meaprs), aper, mwflt)
        go to 500

*---- Octupole.
   70   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+metlto), temp(5), mwflt)
          call ucopy(q(lcelm+mek3o), temp(6), mwflt)
*--- apply inversion and scaling
          temp(5) = temp(5) * elkfact(7)
          call ucopy(q(lcelm+meapro), aper, mwflt)
        go to 500

*---- Multipole.
   80   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+mek0lm), temp(2), mwflt)
          call ucopy(q(lcelm+mek1lm), temp(3), mwflt)
          call ucopy(q(lcelm+mek2lm), temp(4), mwflt)
          call ucopy(q(lcelm+met0m), temp(5), mwflt)
          call ucopy(q(lcelm+mek3lm), temp(6), mwflt)
          call ucopy(q(lcelm+met1m), temp(7), mwflt)
          call ucopy(q(lcelm+met2m), temp(8), mwflt)
          call ucopy(q(lcelm+met3m), temp(9), mwflt)
          call ucopy(q(lcelm+meaprm), aper, mwflt)
          call utglog(lcelm, bvpos, bvpos, bvflag)
*--- HG000915 use bv flag to possibly invert angle
          if (bvflag) temp(2) = beambv * temp(2)
*--- apply inversion and scaling
          do i = 2, 4
            temp(i) = elmfact(i-2) * temp(i)
          enddo
          temp(6) = elmfact(4) * temp(6)
          do i = 7, 9
            temp(i) = elmfact(i-6) * temp(i)
          enddo
        go to 500

*---- Solenoid.
   90   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+mekss), temp(6), mwflt)
*--- apply inversion and scaling
           temp(6) = temp(6) * elkfact(9)
          call ucopy(q(lcelm+meapss), aper, mwflt)
        go to 500

*---- RF cavity.
  100   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+mefrqc), temp(6), mwflt)
          call ucopy(q(lcelm+mevltc), temp(7), mwflt)
          call ucopy(q(lcelm+melagc), temp(8), mwflt)
          call ucopy(q(lcelm+melosc), temp(9), mwflt)
          call ucopy(q(lcelm+meaprc), aper, mwflt)
        go to 500

*---- Electrostatic separator.
  110   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+metlte), temp(5), mwflt)
          call ucopy(q(lcelm+meflde), temp(6), mwflt)
        go to 500

*---- Coordinate rotations.
  120   continue
  130   continue
          call ucopy(q(lcelm+meangr), temp(6), mwflt)
        go to 500

*---- Orbit correctors.
  140   continue
  150   continue
  160   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)

*---- Original setting.
          if (isp .eq. 14) then
            call ucopy(q(lcelm+mekick), xkick, mwflt)
            call ucopy(q(lcelm+mekick+mcsiz), bvflag, 1)
            ykick = zero
          else if (isp .eq. 16) then
            xkick = zero
            call ucopy(q(lcelm+mekick), ykick, mwflt)
            call ucopy(q(lcelm+mekick+mcsiz), bvflag, 1)
          else
            call ucopy(q(lcelm+mekick), xkick, mwflt)
            call ucopy(q(lcelm+mekick+mcsiz), ykick, mwflt)
            call ucopy(q(lcelm+mekick+2*mcsiz), bvflag, 1)
          endif

*---- Correction from C.O. correction algorithm.
          if (lccom .ne. 0) then
            call ucopy(q(lccom+1), xcm, 2*mwflt)
          else
            xcm = zero
            ycm = zero
          endif

*---- Store sum of original setting and correction.
          temp(5) = xcm + xkick
          temp(6) = ycm + ykick
*--- HG000915 use bv flag to possibly invert angle
          if (bvflag) then
            temp(5) = beambv * temp(5)
            temp(6) = beambv * temp(6)
          endif
        go to 500

*---- General bend (dipole, quadrupole, and skew quadrupole).
  260   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+meangg), temp(2), mwflt)
          call ucopy(q(lcelm+mek1g), temp(3), mwflt)
          call ucopy(q(lcelm+meksg), temp(4), mwflt)
          call ucopy(q(lcelm+metltg), temp(5), mwflt)
          call ucopy(q(lcelm+meintgx+3*mcsiz), bvflag, 1)
*--- HG000915 use bv flag to possibly invert angle
          if (bvflag) temp(2) = beambv * temp(2)
        go to 500

*---- Other elements.
   40   continue
  220   continue
  230   continue
  250   continue
        goto 500
  270   continue
*---- LCAVITY
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+mefrql), temp(6), mwflt)
          call ucopy(q(lcelm+medel), temp(7), mwflt)
          call ucopy(q(lcelm+mephil), temp(8), mwflt)
          call ucopy(q(lcelm+melosl), temp(9), mwflt)
          call ucopy(q(lcelm+meaprl), aper, mwflt)
        go to 500
  280   continue
  290   continue
  300   continue
  310   continue
  500   continue
      endif

      write (idisk, 920) key, name, (temp(i),i=1,4), aper, type, en0,
     +(temp(i),i=5,9)

  910 format(a4,a16,f12.6,1p,3e16.9/5e16.9)
  920 format(a4,a16,f12.6,1p,4e16.9,1x,a16,1x,e16.9/5e16.9)

      end
+dk tphead
      subroutine tphead(idisk, code)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Write heading for TAPE option.                                     *
* Input:                                                               *
*   LCSEQ     /REFER/   Current beam line sequence.                    *
*   IDISK     (integer) Logical unit number.                           *
*   CODE      (char)    Type of output to follow.                      *
*----------------------------------------------------------------------*
+ca aparam
      integer idisk,iflag,ipos,jbyt,nsup,ntot
      character*(*)     code
+ca memdum
+ca seqflag
+ca seqgroup
+ca header
+ca refer
+if windows
      double precision cjob
+el
      character*(mcnam) cjob
+ei
      logical           symm

*---- Count number of elements.
      ntot = 1
      do 90 ipos = iq(lcseq+msr1), iq(lcseq+msr2)
        iflag = iq(lq(lcseq-msflg)+ipos)
        if (jbyt(iflag,1,mcode) .eq. 1) ntot = ntot + 1
   90 continue

*---- Write header records.
      call jobnam(cjob)
      symm = iq(lcseq+msym) .ne. 0
      nsup = iq(lcseq+msup)
      write (idisk, 910) cvers, code, cdate, ctime, cjob, nsup, symm,
     +                   ntot, ctitle

  910 format(5a8,i8,l8,i8/a80)

      end
+dk tpstrc
      subroutine tpstrc(elmnam, idisk, nord)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Write element parameters on disk for STRUCTURE command.            *
* Input:                                                               *
*   LCELM     /REFER/   Current element bank.                          *
*   ELMNAM    (char)    Name associated with current element.          *
*   IDISK     (integer) Logical unit number.                           *
*   NORD      (integer) Maximum multipole order.                       *
*----------------------------------------------------------------------*
+ca aparam
      integer i,idisk,iord,isp,kord,lkey,na,nd,ne,nord
      double precision ang,dsk1,dsk2,dsk3,ferror,field,sk0l,temp,
     +tilt0,val,xcm,xkick,ycm,ykick,zero
      character*(*)     elmnam
+ca memdum
+ca bankhead
+ca beam
+ca cmdgroup
+ca elmgroup
+ca refer

+ca maxmul
      parameter         (zero = 0.0d0)

      character*(mcnam) key, name, type
      dimension         temp(2*maxmul+2)
      dimension         field(2,0:maxmul), ferror(2,0:maxmul)
      integer bvpos
      parameter         (bvpos = 24)
      logical bvflag

      bvflag = .false.
      call uzero(temp, 1, 2 * mwflt * (maxmul + 1))

      if (lcelm .eq. 0) then
        key = ' '
        name = 'INITIAL'
        type = ' '
      else
        lkey = lq(lcelm+1)
        call diname(ldkey, iq(lkey+mbnam), key)
        name = elmnam
        type = ' '
        call utgnam(lcelm, 1, 1, type)

*---- Select element type.
        isp = iq(lcelm+mbsp)
        go to ( 10,  20,  30,  40,  50,  60,  70,  80,  90, 100,
     +         110, 120, 130, 140, 150, 160, 170, 180, 190, 200,
     +         210, 220, 230, 240, 250, 260, 270, 280, 290, 300,
     +         310, 310, 310, 310, 310, 310, 310, 310, 310, 310), isp

*---- Drift.
   10   continue
*---- Monitor.
  170   continue
  180   continue
  190   continue

*---- Beam instrument.
  240   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
        go to 500

*---- Rectangular or sector bend.
   20   continue
   30   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+meangb), temp(2), mwflt)
          call ucopy(q(lcelm+mek1b), temp(3), mwflt)
          call ucopy(q(lcelm+mek2b), temp(4), mwflt)
          call ucopy(q(lcelm+metltb), temp(5), mwflt)
          call ucopy(q(lcelm+mee1b), temp(6), mwflt)
          call ucopy(q(lcelm+mee2b), temp(7), mwflt)
          call ucopy(q(lcelm+meh1b), temp(8), mwflt)
          call ucopy(q(lcelm+meh2b), temp(9), mwflt)
          call ucopy(q(lcelm+meintbx+3*mcsiz), bvflag, 1)

*---- Fetch field errors, if any.
          if (lcfld .ne. 0  .and.  temp(1) .ne. 0.0) then
            nd = min(6*mwflt,iq(lcfld-1))
            call uzero(ferror, 1, 6*mwflt)
            call ucopy(q(lcfld+1), ferror, nd)
            temp(2) = temp(2) + ferror(1,0)
            temp(3) = temp(3) + ferror(1,1) / temp(1)
            temp(4) = temp(4) + ferror(1,2) / temp(1)
          endif
*--- HG000915 use bv flag to possibly invert angle
          if (bvflag) temp(2) = beambv * temp(2)
*--- apply inversion and scaling
          do i = 3, 4
            temp(i) = elmfact(i-2) * temp(i)
          enddo
        go to 500

*---- Quadrupole.
   50   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+mek1q), temp(3), mwflt)
          call ucopy(q(lcelm+metltq), temp(5), mwflt)

*---- Fetch field error, if any.
          if (lcfld .ne. 0) then
            call ucopy(q(lcfld+2*mwflt+1), dsk1, mwflt)
            temp(3) = temp(3) + dsk1 / temp(1)
          endif
        go to 500

*---- Sextupole.
   60   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+mek2s), temp(4), mwflt)
          call ucopy(q(lcelm+metlts), temp(5), mwflt)

*---- Fetch field error, if any.
          if (lcfld .ne. 0  .and. temp(1) .ne. 0.0) then
            call ucopy(q(lcfld+4*mwflt+1), dsk2, mwflt)
            temp(4) = temp(4) + dsk2 / temp(1)
          endif
        go to 500

*---- Octupole.
   70   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+mek3o), temp(6), mwflt)
          call ucopy(q(lcelm+metlto), temp(5), mwflt)

*---- Fetch field error, if any.
          if (lcfld .ne. 0  .and.  temp(1) .ne. 0.0) then
            call ucopy(q(lcfld+6*mwflt+1), dsk3, mwflt)
            temp(6) = temp(6) + dsk3 / temp(1)
          endif
        go to 500

*---- Multipole.
   80   continue

*---- Nominal dipole field and maximum order.
          kord = min(nord,maxmul)
          call ucopy(q(lcelm+meklm), sk0l, mwflt)
          call ucopy(q(lcelm+metltm), tilt0, mwflt)
          call utglog(lcelm, bvpos, bvpos, bvflag)
          if (bvflag) sk0l = beambv * sk0l
          temp(2) = sk0l * cos(tilt0)
          temp(3) = sk0l * sin(tilt0)
          write (idisk, 910) key, name, zero, (temp(i), i = 2, 3), kord

*---- Multipole components.
          nd = 2 * mwflt * (kord + 1)
          call uzero(field, 1, nd)
          na = min(2 * maxmul + 2, iq(lcelm+mbat))
          call utgflt(lcelm, 3, na, field)

*---- Field error data.
          call uzero(ferror, 1, nd)
          if (lcfld .ne. 0) then
            ne = min(iq(lcfld-1), nd)
            call ucopy(q(lcfld+1), ferror, ne)
          endif

*---- Dipole error.
          temp(1) = ferror(1,0)
          temp(2) = ferror(2,0)

*---- Other components and errors.
          do 85 iord = 0, kord
            if (iord .eq. 0) then
              val = 0.0
            else
              val = field(1,iord)
            endif
            ang = - field(2,iord) * float(iord+1)
            temp(iord*2+1) = val*cos(ang) + ferror(1,iord)
            temp(iord*2+2) = val*sin(ang) + ferror(2,iord)
   85     continue

          write (idisk, 920) (temp(2*i+1), i = 0, kord)
          write (idisk, 920) (temp(2*i+2), i = 0, kord)
        go to 9999

*---- Solenoid.
   90   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+mekss), temp(6), mwflt)
        go to 500

*---- RF cavity.
  100   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+mefrqc), temp(6), mwflt)
          call ucopy(q(lcelm+mevltc), temp(7), mwflt)
          call ucopy(q(lcelm+melagc), temp(8), mwflt)
        go to 500

*---- Electrostatic separator.
  110   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+metlte), temp(5), mwflt)
          call ucopy(q(lcelm+meflde), temp(6), mwflt)
        go to 500

*---- Coordinate rotations.
  120   continue
  130   continue
          call ucopy(q(lcelm+meangr), temp(6), mwflt)
        go to 500

*---- Orbit correctors.
  140   continue
  150   continue
  160   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)

*---- Original setting.
          if (isp .eq. 14) then
            call ucopy(q(lcelm+mekick), xkick, mwflt)
            call ucopy(q(lcelm+mekick+mcsiz), bvflag, 1)
            ykick = 0.0
          else if (isp .eq. 16) then
            xkick = 0.0
            call ucopy(q(lcelm+mekick), ykick, mwflt)
            call ucopy(q(lcelm+mekick+mcsiz), bvflag, 1)
          else
            call ucopy(q(lcelm+mekick), xkick, mwflt)
            call ucopy(q(lcelm+mekick+mcsiz), ykick, mwflt)
            call ucopy(q(lcelm+mekick+2*mcsiz), bvflag, 1)
          endif

*---- Field errors.
          if (lcfld .ne. 0) then
            call ucopy(q(lcfld+1), ferror, 2*mwflt)
          else
            ferror(1,0) = 0.0
            ferror(2,0) = 0.0
          endif

*---- Correction from C.O. correction algorithm.
          if (lccom .ne. 0) then
            call ucopy(q(lccom+1), xcm, 2*mwflt)
          else
            xcm = 0.0
            ycm = 0.0
          endif

*---- Store sum of original setting and correction.
          temp(5) = xcm + xkick + ferror(1,0)
          temp(6) = ycm + ykick + ferror(2,0)
*--- HG000915 use bv flag to possibly invert angle
        if (bvflag) then
          temp(5) = beambv * temp(5)
          temp(6) = beambv * temp(6)
        endif
        go to 500

*---- Collimator.
  200   continue
  210   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+mexcol), temp(2), mwflt)
          call ucopy(q(lcelm+meycol), temp(3), mwflt)
        go to 500

*---- General bend (dipole, quadrupole, and skew quadrupole).
  260   continue
          call ucopy(q(lcelm+melen), temp(1), mwflt)
          call ucopy(q(lcelm+meangg), temp(2), mwflt)
          call ucopy(q(lcelm+mek1g), temp(3), mwflt)
          call ucopy(q(lcelm+meksg), temp(4), mwflt)
          call ucopy(q(lcelm+metltg), temp(5), mwflt)

*---- Fetch field errors, if any.
          if (lcfld .ne. 0  .and.  temp(1) .ne. 0.0) then
            nd = min(4*mwflt,iq(lcfld-1))
            call uzero(ferror, 1, 4*mwflt)
            call ucopy(q(lcfld+1), ferror, nd)
            temp(2) = temp(2) + ferror(1,0)
            temp(3) = temp(3) + ferror(1,1) / temp(1)
            temp(4) = temp(4) + ferror(2,1) / temp(1)
          endif
        go to 500

*---- Other elements.
   40   continue
  220   continue
  230   continue
  250   continue
  270   continue
  280   continue
  290   continue
  300   continue
  310   continue
  500   continue
      endif

      write (idisk, 930) key, name, (temp(i), i = 1, 9)

  910 format(a4,a16,f12.6,1p,2e16.9,i16)
  920 format(1p,5e16.9)
  930 format(a4,a16,f12.6,1p,3e16.9/5e16.9)

 9999 end
+dk tpzzzz
+dk traaaa
+dk trbegn
      subroutine trbegn(show, orbit)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initialize tracking mode; TRACK command execution.                 *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,nline
      double precision deltap
      logical show, orbit
+ca beam
+ca maptrn
+ca optic0
+ca range
+ca refer
+ca status
+ca stflag
+ca trdata
+ca troptc
+ca zunit

      logical           m66sta

*---- Is main beam line set?
      call lnchck('TRACK', error)
      if (error) return
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Print page header.
      if (show) call prhead('TRACK', trktitle, deltas, 0, nline, 1)

*---- One-pass system: Do not normalize.
      if (onepss) then
        do 10 i = 1, 6
          orbit0(i) = 0.0
   10   continue
        call m66one(eigen)
        ener0 = en0

*---- Fix up environment.
      else if (orbit) then
        deltap = deltas
        call enfix
        call enfreq(deltap)
        if (show) then
          call enprgl
          write (iqpr2, 910) fdamp, frand
          call enprem
          call enprrf
        endif

*---- Find dispersion and tunes, if possible.
        qx = 0.0
        qy = 0.0
        docav = .false.
        dorad = .false.
        call tmrefe(lcseq)
        call twcpin(lcseq, error)
        if (.not. error) call twcpgo(.false., .false., 0)
        docav = .true.
        dorad = frad

*---- Find closed orbit.
        call tmclor(lcseq, deltas, show, error)

*---- Find eigenvectors.
        if (.not. error) then
          if (m66sta(rt)) then
            call laseig(rt, reval, aival, eigen)
          else
            call ladeig(rt, reval, aival, eigen)
          endif
          if (show) then
            write (iqpr2, 920)
            write (iqpr2, 930) (orbit0(i), (eigen(i,j), j=1,6), i=1,6)
          endif
        endif
      endif

  910 format(t6,'damp =',t22,l1,t46,'quantum =',t62,l1)
  920 format(' '/' Closed orbit and eigenvectors at starting point:'/
     +       '     Orbit       Re(E1)      Im(E1)      Re(E2) ',
     +       '     Im(E2)      Re(E3)      Im(E3)')
  930 format(' ',7f12.6)

      end
+dk trdsp1
      subroutine trdsp1(ipos, track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Displace tracks at entry due to misalignment.                      *
* Input:                                                               *
*   IPOS      (integer) Position in beam line (unused).                *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) number of surviving tracks.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ipos,itrack,ktrack
      double precision beti,d,one,phi,psi,pt1,px1,py1,s2,s2bg,the,track,
     +two,w,w33i,x1,y1
      dimension         track(6,*)
+ca memdum
+ca beam
+ca refer

      dimension         d(6), w(3,3)
      parameter         (two = 2.0d0, one = 1.0d0)

      call ucopy(q(lcali+1), d, 6*mwflt)

*---- Build rotation matrix and compute additional drift length.
      the = d(5)
      phi = d(4)
      psi = d(6)
      call sumtrx(the, phi, psi, w)
      beti = one / betas
      w33i = one / w(3,3)
      s2   = (w(1,3) * d(1) + w(2,3) * d(2) + w(3,3) * d(3)) * w33i
      s2bg = s2 / (betas*gammas)**2

*---- Loop for all particles.
      do 90 itrack = 1, ktrack
        px1 = track(2,itrack)
        py1 = track(4,itrack)
        pt1 = track(6,itrack)
        track(2,itrack) = w(1,1) * px1 + w(2,1) * py1 +
     +    w(3,1) * (one + pt1 * beti)
        track(4,itrack) = w(1,2) * px1 + w(2,2) * py1 +
     +    w(3,2) * (one + pt1 * beti)

        x1  = track(1,itrack) + s2 * px1 - d(1)
        y1  = track(3,itrack) + s2 * py1 - d(2)
        track(1,itrack) = (w(2,2) * x1 - w(1,2) * y1) * w33i
        track(3,itrack) = (w(1,1) * y1 - w(2,1) * x1) * w33i
        track(5,itrack) = track(5,itrack) - s2bg * pt1 +
     +    ((w(1,3) * x1 + w(2,3) * y1) / w(3,3) - d(3)) * beti
   90 continue

      end
+dk trdsp2
      subroutine trdsp2(ipos, track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Displace tracks at exit of an element due to misalignment.         *
* Input:                                                               *
*   IPOS      (integer) Position in beam line.                         *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) number of surviving tracks.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ipos,itrack,ktrack
      double precision arc,beti,d,el,one,phi,psi,pt1,px1,py1,s2,s2bg,
     +the,track,two,ve,w,w33i,we,x1,y1
      dimension         track(6,*)
+ca memdum
+ca bankhead
+ca prcgroup
+ca beam
+ca refer

      dimension         d(6), ve(3), w(3,3), we(3,3)
      parameter         (one = 1.0d0, two = 2.0d0)

*---- Misalignment componentss.
      call ucopy(q(lcali+1), d, 6 * mwflt)
      the = d(5)
      phi = d(4)
      psi = d(6)
      call sumtrx(the, phi, psi, w)
      beti = one / betas

*---- Reference change from entrance to exit.
      if (iq(lcelm+mbpr) .eq. mplin) then
        call suline(ipos, el, arc, ve, we)
      else
        call suelem(el, arc, ve, we)
      endif

*---- Displacements at exit w.r.t. entrance system.
      d(1) = d(1) + w(1,1)*ve(1) + w(1,2)*ve(2) + w(1,3)*ve(3) - ve(1)
      d(2) = d(2) + w(2,1)*ve(1) + w(2,2)*ve(2) + w(2,3)*ve(3) - ve(2)
      d(3) = d(3) + w(3,1)*ve(1) + w(3,2)*ve(2) + w(3,3)*ve(3) - ve(3)

*---- Convert all references to exit and compute additional drift.
      call sutran(w, d, we)
      w33i = one / w(3,3)
      s2   = (w(1,3) * d(1) + w(2,3) * d(2) + w(3,3) * d(3)) * w33i
      s2bg = s2 / (betas*gammas)**2

*---- Loop for all particles.
      do 90 itrack = 1, ktrack
        pt1 = track(6,itrack)
        px1 = track(2,itrack) - w(3,1) * (one + pt1 * beti)
        py1 = track(4,itrack) - w(3,2) * (one + pt1 * beti)
        track(2,itrack) = (w(2,2) * px1 - w(2,1) * py1) * w33i
        track(4,itrack) = (w(1,1) * py1 - w(1,2) * px1) * w33i

        x1  = w(1,1) * track(1,itrack) + w(1,2) * track(3,itrack)
        y1  = w(2,1) * track(1,itrack) + w(2,2) * track(3,itrack)
        track(1,itrack) = x1 - s2 * track(2,itrack) + d(1)
        track(3,itrack) = y1 - s2 * track(4,itrack) + d(2)
        track(5,itrack) = track(5,itrack) + s2bg * pt1 -
     +    ((w(1,3) * x1 + w(2,3) * y1) / w(3,3) - d(3)) * beti
   90 continue

      end
+dk trdyncmd
      subroutine trdyncmd
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Determine dynamic aperture; DYNAP command.                         *
*   No attributes.                                                     *
*----------------------------------------------------------------------*
+ca aparam
+ca beam
+ca stflag
+ca trdata
+ca trdynap
+ca zunit

*---- Should have seen a DYNAPSTART command.
      if (.not. fstart) then
        call aafail('DYNAP', 1, 'Requires a "DYNAPSTART" command.')

*---- Initialise tracking.
      else
        dorad  = frad
        dodamp = fdamp
        dorand = frand
        call trbegn(.false., orbflag)

*---- Perform tracking.
        call trdynrun

*---- Output.
        write (iqpr2, 930) dynapfrac,
     +                     dynapfrac*zstart(1),dynapfrac*zstart(2),
     +                     dynapfrac*zstart(3),dynapfrac*zstart(4),
     +                               zstart(5),          zstart(6),
     +                     trstep,
     +                               zendyn(1),          zendyn(2),
     +                               zendyn(3),          zendyn(4),
     +                               zendyn(5),          zendyn(6),
     +                               ktrturns,           smear,
     +                               wxymin,             wxymax
        if (fastune)  write (iqpr2, 940) dtune, tunx, tuny
        if (lyapflag) write (iqpr2, 950) yapunov

*---- Make parameters accessible to VALUE and PUSH.
        call aasetp('DYNAPFRAC', dynapfrac)
        call aasetp('TURNS',     ktrturns*1.d0)
        call aasetp('XEND',      zendyn(1))
        call aasetp('PXEND',     zendyn(2))
        call aasetp('YEND',      zendyn(3))
        call aasetp('PYEND',     zendyn(4))
        call aasetp('TEND',      zendyn(5))
        call aasetp('PTEND',     zendyn(6))
        call aasetp('WXMIN',     wxmin)
        call aasetp('WXMAX',     wxmax)
        call aasetp('WYMIN',     wymin)
        call aasetp('WYMAX',     wymax)
        call aasetp('WXYMIN',    wxymin)
        call aasetp('WXYMAX',    wxymax)
        call aasetp('SMEAR',     smear)
        if (fastune) then
          call aasetp('TUNX',    tunx)
          call aasetp('TUNY',    tuny)
          call aasetp('DTUNE',   dtune)
        endif
        if (lyapflag) then
          call aasetp('LYAPUNOV', yapunov)
        endif
      endif

  930 format(' '/' Fractional dynamic aperture:',
     +  t34,'DYNAPFRAC =',f14.12/
     +  'BEGIN X =',t10,f14.12,t41,'PX =',f14.12/
     +  '      Y =',t10,f14.12,t41,'PY =',f14.12/
     +  '      T =',t10,f14.12,t41,'PT =',f14.12/
     +  ' Fractional step for downward search:',t39,'STEP =',f14.12/
     +  'END   X =',t10,f14.12,t41,'PX =',f14.12/
     +  '      Y =',t10,f14.12,t41,'PY =',f14.12/
     +  '      T =',t10,f14.12,t41,'PT =',f14.12/
     +  ' Survival over:',t17,'TURNS =',i7,t38,'SMEAR =', f14.12/
     +  ' WXYMIN =',t10,f14.12,t37,'WXYMAX =',f14.12)
  940 format(' Fast tune determination:  DTUNE =',f14.12/
     +  '   TUNX =',t10,f14.12,t39,'TUNY =',f14.12)
  950 format(' Interpolated Lyapunov exponent:  LYAPUNOV =',f14.12)

      end
+dk trdynrun
      subroutine trdynrun
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Tracking for dynamic aperture determination.                       *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca message
+ca option
+ca optic0
+ca refer
+ca stflag
+ca trdata
+ca trdynap
+ca trlink
+ca wstack
      integer ileng,ilyap,imeth,ipx,ipy,istep,iswork,ix,iy,izn,k,
     +maxmet,nbelow,nt,ntt,nturn,nturnhalf
      double precision eigen,fitlyap,frac,one,track,tuneabt,
     +tuneabt2,tunx1,tunx2,tuny1,tuny2

      parameter           (maxmet = 3, one = 1.0d0)

      external            ttelem, lmelem
      character*(mcnam)   dmeth(maxmet)
      dimension           track(6,3)
      integer             number(3)

      data dmeth        / 'TRANSPORT', 'LIE3    ', 'LIE4    ' /

*---- Tracking method.
      call utlook(trknam(1), dmeth, maxmet, imeth)
      if (imeth .eq. 0) then
        call utleng(trknam(1), ileng)
        msg(1) = 'Unknown method "' // trknam(1)(1:ileng) //
     +    '" --- "TRANSPORT" assumed.'
        call aawarn('TRRUN', 1, msg)
        imeth = 1
      endif

*---- Allocate working space.
      iswork = iwork
      if (fastune) then
        izn = iwork
        iwork = iwork + 4*itrturns
      else
        izn = 0
      endif
      if (lyapflag) then
        ilyap = iwork
        iwork = iwork + itrturns
      else
        ilyap = 0
      endif
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Set number of turns and flags.
      fdynap = .true.
      nturn  = itrturns
      itrfil = 0
      ipfreq = 0
      ipfreq = 0

*---- Number of steps for stability check below dynamic aperture
      nbelow = int(log(one - chkbelow) / log(one - trstep))
      dynapfrac = one

*---- Define initial conditions for one particle.
      call aagetp('XSTART',  zstart(1))
      call aagetp('PXSTART', zstart(2))
      call aagetp('YSTART',  zstart(3))
      call aagetp('PYSTART', zstart(4))
      call aagetp('TSTART',  zstart(5))
      call aagetp('PTSTART', zstart(6))
*--- store bb_kicks
      if (.not. bborbit) call bbstore()
*---- Start loop until survival is longer than NTURN.
  100 continue

*---- Set up optional closed orbit and main track.
        nt = 1
        if (dorad  .and.  .not. dodamp) then
          nt = 2
          number(1) = 0
        endif
        do k = 1, 4
          track(k,1)  = orbit0(k)
          track(k,nt) = orbit0(k) + dynapfrac * zstart(k)
        enddo
        do k = 5, 6
          track(k,1)  = orbit0(k)
          track(k,nt) = orbit0(k) + zstart(k)
        enddo
        number(nt) = 1

*---- Set up optional Lyapunov companion.
        ntt = nt
        if (lyapflag) then
          ntt = nt + 1
          do 120 k = 1, 6
            track(k,ntt) = track(k,nt)
  120     continue
          track(1,ntt) = track(1,nt) + deltax
          number(ntt) = 2
        endif

*---- Initialize max and min betatron invariants.
        wxmax = 0
        wymax = 0
        wxymax = 0
        call wmaxmin(track(1,nt))
        wxmin = wxmax
        wymin = wymax
        wxymin = wxymax

*---- Track according to selected method.
        ntrack = ntt

*---- Open main track table.
      if (trknam(2) .ne. ' ') then
        call trtbop(orbit0, eigen, trknam(2), nturn, ntrack)
      endif

        fbelow = .false.
        if (imeth .eq. 1) then
          call trexec(ttelem, 3, nturn, track, number, ntrack,
     +      dq(izn+1), dq(ilyap+1))
        else if (imeth .eq. 2) then
          call trexec(lmelem, 3, nturn, track, number, ntrack,
     +      dq(izn+1), dq(ilyap+1))
        else
          call trexec(lmelem, 4, nturn, track, number, ntrack,
     +      dq(izn+1), dq(ilyap+1))
        endif

*---- If particle is lost and DYNAPFRAC > FRACMIN then
*     reduce betatron matrix TRACK by 1 - TRSTEP and loop.
      if (ntrack .eq. 0  .and.  dynapfrac .gt. fracmin) then
        dynapfrac = dynapfrac * (one - trstep)
        go to 100
      endif

*---- Compute SMEAR and save ZENDYN.
      smear = 2.0 * (wxymax - wxymin) / (wxymax + wxymin)
      do 130 k = 1, 6
        zendyn(k) = track(k,nt) - orbit0(k)
  130 continue

*---- Check stability below dynamic aperture,
*     if particle survived NTURN turns.
      if (ktrturns .eq. nturn  .and.  nbelow .ne. 0  .and.
     +    dynapfrac .gt. fracmin) then
        fbelow = .true.
        frac = dynapfrac

*---- Start loop to check stability in NBELOW steps below DYNAP.
*     Number of tracks is NT
*     (optional closed orbit + main track)
        do 300 istep = 1, nbelow
          ntrack = nt
          frac = frac * (one - trstep)
          do 210 k = 1, 6
            track(k,1)  = orbit0(k)
            track(k,nt) = orbit0(k) + frac * zstart(k)
  210     continue

*---- Track according to selected method, all output suppressed.
          if (imeth .eq. 1) then
            call trexec(ttelem, 3, nturn, track, number, ntrack,
     +        dq(izn+1), dq(ilyap+1))
          else if (imeth .eq. 2) then
            call trexec(lmelem, 3, nturn, track, number, ntrack,
     +        dq(izn+1), dq(ilyap+1))
          else
            call trexec(lmelem, 4, nturn, track, number, ntrack,
     +        dq(izn+1), dq(ilyap+1))
          endif

*---- If particle is unstable, restart search loop at next lower step.
          if (ntrack .eq. 0) then
            dynapfrac = frac * (one - trstep)
            go to 100
          endif
  300   continue
      endif

*---- Fast tune calculation by interpolated FFT.
      if (fastune) then
        ix  = izn + 1
        ipx = ix  + itrturns
        iy  = ipx + itrturns
        ipy = iy  + itrturns
        if (nturn .le. 64) then
          tunx = tuneabt(dq(ix), dq(ipx), ktrturns)
          tuny = tuneabt(dq(iy), dq(ipy), ktrturns)
        else
          tunx = tuneabt2(dq(ix), dq(ipx), ktrturns)
          tuny = tuneabt2(dq(iy), dq(ipy), ktrturns)
        endif

*---- Fast tune variation over half the number of turns.
        nturnhalf = ktrturns / 2
        if (nturnhalf .le. 64) then
          tunx1 = tuneabt(dq(ix), dq(ipx), nturnhalf)
          tuny1 = tuneabt(dq(iy), dq(ipy), nturnhalf)
          tunx2 = tuneabt(dq(ix +nturnhalf),
     +                    dq(ipx+nturnhalf), nturnhalf)
          tuny2 = tuneabt(dq(iy +nturnhalf),
     +                    dq(ipy+nturnhalf), nturnhalf)
        else
          tunx1 = tuneabt2(dq(ix), dq(ipx), nturnhalf)
          tuny1 = tuneabt2(dq(iy), dq(ipy), nturnhalf)
          tunx2 = tuneabt2(dq(ix +nturnhalf),
     +                     dq(ipx+nturnhalf), nturnhalf)
          tuny2 = tuneabt2(dq(iy +nturnhalf),
     +                     dq(ipy+nturnhalf), nturnhalf)
        endif
        dtune = sqrt((tunx2 - tunx1)**2 + (tuny2 - tuny1)**2)
      endif

*---- Lyapunov exponent calculation over second half of tracking.
      if (lyapflag) then
        yapunov = fitlyap(dq(ilyap+1), ktrturns)
      endif

*---- Close tracking tables.
      if (ltrtab .ne. 0) call trtbcl(ltrtab)

*---- Release working store.
      iwork = iswork
      fdynap = .false.

      end
+dk trend
      subroutine trend
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Leave tracking mode; ENDTRACK command.                             *
* No attributes.                                                       *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca message
+ca option
+ca trdata
+ca trlink
+ca wstack
+ca zunit

*---- Release working space and banks.
      iwork = 0
      nwork = 0
      call mzwork(0, dq(1), dq(1), -1)
      if (ltrnum .ne. 0) call mzdrop(0, ltrnum, '.')
      if (ltrstt .ne. 0) call mzdrop(0, ltrstt, 'L')
      if (ltrnoi .ne. 0) call mzdrop(0, ltrnoi, 'L')

*---- Leave tracking mode.
      if (trace) then
        call timex(time2)
        dtime = time2 - time1
        write (msg, 920) time2, dtime
  920   format('End tracking mode, time = ',f12.3,
     +         ', time for tracking = ',f12.3,' seconds.')
        call aainfo('TREND', 1, msg)
      endif

      end
+dk trexec
      subroutine trexec(doelem, iorder, nturn, track, number, ntrk,
     +  zn, distvect)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track specified number of turns.                                   *
* Input:                                                               *
*   DOELEM    (subr)    Routine to track according to selected method. *
*   IORDER    (integer) Order for Lie algebraic tracking.              *
*   NTURN     (integer) Number of turns to be tracked.                 *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   NUMBER(*) (integer) Number of current track.                       *
*   NTRK      (integer) Number of surviving tracks.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer iorder,iturn,k,kp,kq,nline,nt,ntrk,nturn
      double precision distvect,doelem,templyap,ten6m,track,ttot,tturn,
     +wxy,zn,znt
+if udecay
      integer mdecay
      integer jjj
      common / cudecay / totsuml, decay_l, actener, deltas_0
      double precision totsuml, decay_l, actener, deltas_0
      double precision decayl
+ei
      external          doelem
      dimension         track(6,*), zn(nturn,4), distvect(*)
      integer           number(*)
+ca memdum
+ca seqgroup
+ca message
+ca beam
+ca optic0
+ca optic1
+ca range
+ca refer
+ca stflag
+ca trdata
+ca trdynap
+ca trlink
+ca troptc
+ca zunit
+if doom
+ca dmcommon
+ei

      dimension         znt(6)
      real              timeb, timee, timer

      parameter         (ten6m = 1.0d-6)

*---- Copy damping flags and possibly orbit.
      dorad  = frad
      dodamp = fdamp
      dorand = frand
+if udecay
      deltas_0 = deltas
+ei
      nt = 1
      if (dorad  .and.  .not. dodamp) then
        nt = 2
        call ucopy(orbit0, track(1,1), 6*mwflt)
      endif

*---- Save initial data in track table.
      if (ltrtab .ne. 0) then
        if (lyapflag) then
          call trtbsvly(ltrtab, 0, track(1,nt))
        else
          call trtbsv(ltrtab, 0, orbit0, track, number, ntrk)
        endif
      endif

*---- Output initial conditions.
      if (ipfreq .gt. 0) then
        call prhead('RUN', trktitle, deltas, 0, nline, 1)
        if (onepss) then
          write (iqpr2, 910)
          write (iqpr2, 935) 1, ener1
        else
          write (iqpr2, 920) ex, ey, et
          write (iqpr2, 930) 1
        endif
        call trptrn(track, number, ntrk)
      endif

*---- Open track file.
      if (iffreq .ne. 0) then
+if doom
        if (itrfil .ne. 0) call dmtrsave(0, track, number, ntrk)
        if (.not. strict)  then
+ei
        if (itrfil .ne. 0) call trflsv(0, track, number, ntrk)
+if doom
        endif
+ei
      endif

*---- Initialize data pointers.
      lsali = lq(lcseq-msali)
      lscom = lq(lcseq-mscom)
      lsdir = lq(lcseq-msdir)
      lsfld = lq(lcseq-msfld)
      lsflg = lq(lcseq-msflg)
      lcali = 0
      lccom = 0
      lcfld = 0

*---- Time required for one turn around machine.
      tturn = 0.0
      if (freq0 .ne. 0.0) tturn = ten6m / freq0
      ttot = 0.0
+if udecay
        if (ntrk .gt. 1)  then
          call aawarn('TREXEC', 1, 'More than one particle for decay')
        endif
        totsuml = 0.0
        actener = sqrt(en0**2+(2*pc+track(6,1))*track(6,1))
        decay_l = decayl(actener)
        print '(a,1p,4d12.4)', 'pc, deltas, energy, decay_l: ',
     +  pc, deltas, actener, decay_l
+ei
*---- Loop for turns.
      call timex(timeb)
      do 90 iturn = 1, nturn

*---- Apply noise perturbations.
        if (ltrnoi .ne. 0) then
          call trnset(ttot)
          call aapdrp
          ttot = ttot + tturn
        endif

*---- Track one turn.
        call trturn(doelem, iorder, iturn, track, number, ntrk)
        if (ntrk .eq. 0) go to 800

*---- DYNAP output.
        if (.not. fbelow) then
          if (fdynap) then
            do 10 kq = 1, 3, 2
              kp = kq + 1
              znt(kq) =
     +          eigen(2,kp) * (track(1,nt) - orbit0(1)) -
     +          eigen(1,kp) * (track(2,nt) - orbit0(2)) +
     +          eigen(4,kp) * (track(3,nt) - orbit0(3)) -
     +          eigen(3,kp) * (track(4,nt) - orbit0(4)) +
     +          eigen(6,kp) * (track(5,nt) - orbit0(5)) -
     +          eigen(5,kp) * (track(6,nt) - orbit0(6))
              znt(kp) =
     +          eigen(1,kq) * (track(2,nt) - orbit0(2)) -
     +          eigen(2,kq) * (track(1,nt) - orbit0(1)) +
     +          eigen(3,kq) * (track(4,nt) - orbit0(4)) -
     +          eigen(4,kq) * (track(3,nt) - orbit0(3)) +
     +          eigen(5,kq) * (track(6,nt) - orbit0(6)) -
     +          eigen(6,kq) * (track(5,nt) - orbit0(5))
   10       continue

*---- Update max and min betatron invariants;
*     convert to amplitudes (and phases: not computed).
            wx = znt(1)**2 + znt(2)**2
            wy = znt(3)**2 + znt(4)**2
            wxy = wx + wy

*---- Compare to and redefine WMIN and WMAX in TRDYNAP.
            if (wx.gt.wxmax) then
              wxmax = wx
            else if (wx.lt.wxmin) then
              wxmin = wx
            endif
            if (wy.gt.wymax) then
              wymax = wy
            else if (wy.lt.wymin) then
              wymin = wy
            endif
            if (wxy.gt.wxymax) then
              wxymax = wxy
            else if (wxy.lt.wxymin) then
              wxymin = wxy
            endif

*---- Save data in ZN(*,4) array for fast tune.
            if (fastune) then
              zn(iturn,1) = znt(1)
              zn(iturn,2) = znt(2)
              zn(iturn,3) = znt(3)
              zn(iturn,4) = znt(4)
            endif

*---- Save data in DISTVECT array for Lyapunov exponent.
            if (lyapflag) then
              templyap = 0.0
              do 20 k = 1, 6
                templyap = templyap +
     +            ((track(k,nt) - track(k,nt+1)) / deltax)**2
   20         continue
              distvect(iturn) = sqrt(templyap)
            endif
          endif

*---- Ordinary tracking output.
*     Save data in track table.
          if (ltrtab .ne. 0) then
            if (lyapflag) then
              call trtbsvly(ltrtab, iturn, track(1,nt))
            else
              call trtbsv(ltrtab, iturn, orbit0, track, number, ntrk)
            endif
          endif

*---- Save data in track file.
          if (iffreq .gt. 0) then
            if (mod(iturn, iffreq) .eq. 0 .or. iturn .eq. nturn) then
+if doom
              call dmtrsave(iturn, track, number, ntrk)
              if (.not. strict)  then
+ei
              call trflsv(iturn, track, number, ntrk)
+if doom
              endif
+ei
            endif
          endif

*---- Turn print-out.
          if (ipfreq .gt. 0  .and.  iturn .lt. nturn) then
            if (mod(iturn, ipfreq) .eq. 0) then
              write (iqpr2, 940) iturn
              call trptrn(track, number, ntrk)
            endif
          endif
        endif

*---- Restart the closed orbit.
        if (dorad  .and.  .not. dodamp) then
          call ucopy(orbit0, track(1,1), 6*mwflt)
        endif
+if checktime
*---- Test if CPU time is sufficient to go on tracking.
        call timex(timee)
        call timel(timer)
        if (timer .lt. 1.5 * (timee - timeb) + 2.0) then
          write (msg, 950) iturn
          call aawarn('TREXEC', 1, msg)
          nturn = iturn
          go to 800
        endif
        timeb = timee
+ei
   90 continue
*---- Final print-out.
  800 continue
      ktrturns = iturn - 1
+if udecay
      deltas = deltas_0
+ei
      if (ipfreq .gt. 0) then
        if (onepss) then
          write (iqpr2, 965) nturn, ener1
        else
          write (iqpr2, 960) nturn
        endif
        call trptrn(track, number, ntrk)
      endif

*---- Reset noise data.
      if (ltrnoi .ne. 0) call trnres

  910 format(' '/' Positions not normalized.')
  920 format(' '/' Positions normalized to EX =',1p,e16.8,
     +  '     EY =',e16.8,'     ET =',e16.8/
     +  ' (referred to coupled motion around closed orbit).')
  930 format(' '/' Initial particle positions before turn',i8)
  935 format(' '/' Initial particle positions before turn',i8,
     +  ' at energy: ', 1pg14.5)
  940 format(' '/' Particle positions after turn',i8)
  950 format('Tracking stopped due to time limit in turn ',i8,'.')
  960 format(' '/' Final particle positions after turn',i8)
  965 format(' '/' Final particle positions after turn',i8,
     +  ' at energy: ', 1pg14.5)

      end
+dk trflcl
      subroutine trflcl
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Close binary file for tracking results.                            *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca message
+ca trdata
+ca trlink
      integer ierr

*---- Close track file.
      call epend(itrfil, iq(ltrfbf+1), ierr)
      if (ierr .eq. 0) close(itrfil, iostat = ierr)
      if (ierr .eq. 0) then
        write (msg, 910) itrfil
  910   format('Tracking results written on logical unit ',i3)
        call aainfo('TRFLCL', 1, msg)
      endif

*---- Drop file and record buffers.
      if (ltrfbf .ne. 0) call mzdrop(0, ltrfbf, '.')
      if (ltrrbf .ne. 0) call mzdrop(0, ltrrbf, '.')

      end
+dk trflop
      subroutine trflop(cmmnt, ntrk, nturn)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Write header for track file.                                       *
* Input:                                                               *
*   CMMNT     (char*80) Comment line.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer i,icode,ierr,j,mblock,mctxt,mtrfil,mwdat,mwdum,mwtxt,nd,
     +ni,nr,ntrk,nturn
      double precision twopi
      character*(80)    cmmnt
+ca memdum
+ca message
+ca beam
+ca header
+ca optic0
+ca trdata
+ca trlink
+ca troptc

      parameter         (mtrfil = 71)
+ca pi
      parameter         (twopi = 2.0d0 * pi)
      parameter         (mblock = 32000)
      parameter         (mctxt = 200, mwtxt = mctxt / 4)
      parameter         (mwdat =  60, mwdum = 50)

      character         cprog*8, text*(mctxt)
      integer           ihead(6), itext(mwtxt), jtext(mwtxt)

      data cprog        / 'MAD     ' /
      data icode        / 7 /

*---- Set up track file: Set block size, unit is 32-bit word (4 bytes).
      itrfil = mtrfil
      nd = mblock / 2
      call epsetw(itrfil, 1, nd, ierr)
      call epsetw(itrfil, 3, 32, ierr)

*---- Lift file and record buffers.
      nd = mblock / mcwrd
      call mzbook(2, ltrfbf, ltrfbf, 1, 'FBUF', 0, 0, nd, 0, -1)
      nd = max(9 * ntrk, mwtxt + mwdat + mwdum)
      call mzbook(2, ltrrbf, ltrrbf, 1, 'RBUF', 0, 0, nd, 0, -1)

*---- Pack text information.
      text =  ctitle // cmmnt // cdate // ctime // cprog
      call uctoh(text, itext, mcwrd, mctxt)
      call stoasc(itext, 1, jtext, 1, mctxt)
      call blo32w(jtext, 1, iq(ltrrbf+1), 1, mwtxt)

*---- Pack integer data to buffer bank.
      iq(ltrrbf+mwtxt+1) = 1
      iq(ltrrbf+mwtxt+2) = ntrk
      iq(ltrrbf+mwtxt+3) = ntrk
      iq(ltrrbf+mwtxt+4) = icode
      iq(ltrrbf+mwtxt+5) = nturn
      ni = mwtxt + 5

*---- Pack real data to buffer bank.
      q(ltrrbf+mwtxt+6) = qx
      q(ltrrbf+mwtxt+7) = qy
      q(ltrrbf+mwtxt+8) = qs
      nr = mwtxt + 8
      do 20 i = 1, 6
        do 10 j = 1, 6
          q(ltrrbf+nr+j) = eigen(i,j)
   10   continue
        q(ltrrbf+nr+7) = orbit0(i)
        q(ltrrbf+nr+8) = disp0(i)
        nr = nr + 8
   20 continue

*---- Pack program-dependent data to buffer bank.
      do 30 i = 1, mwdum
        nr = nr + 1
        q(ltrrbf+nr) = 0.0
   30 continue
      call ctoibm(q(ltrrbf+ni+1), nr - ni, 3)

*---- Write buffer in EPIO format.
      ihead(5) = 0
      ihead(6) = 0
      call epoutl(itrfil,3,6,ihead,nr,q(ltrrbf+1),q(ltrfbf+1),ierr)
      if (ierr .ne. 0) then
        call aafail('TRFLOP', 1, 'Cannot write file header.')
        iffreq = 0
      endif

      end
+dk trflow
      subroutine trflow(iturn, isup, ipos, suml, track, number, ntrk)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Give overflow message.                                             *
*   This routine assumes that at least one particle is lost.           *
* Input:                                                               *
*   ITURN     (integer) Current turn number.                           *
*   ISUP      (integer) Current superperiod number.                    *
*   IPOS      (integer) Position counter.                              *
*   SUML      (integer) Accumulated length.                            *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   NUMBER(*) (integer) Number of current track.                       *
*   NTRK      (integer) Number of surviving tracks.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer i,icopy,iname,iocc,ipos,isup,itrack,iturn,jbyt,ntrk
      double precision eject,suml,track
      dimension         track(6,*)
      integer           number(*)
+ca memdum
+ca seqflag
+ca refer
+ca trdata
+ca zunit
+if udecay
      integer mdecay
      integer jjj
      common / cudecay / totsuml, decay_l, actener, deltas_0
      double precision totsuml, decay_l, actener, deltas_0
+ei

      parameter         (eject = 1.0)
      character*(mcnam) elmnam

*---- Stop when loosing any particle in DYNAP mode.
      if (fdynap) then
        ntrk = 0
        return
      endif

*---- Pack remaining particles after an overflow is detected.
      iname = (iq(lsdir+ipos) - 1) * mwnam + 1
      call uhtoc(q(ldbnk(2)+iname), mcwrd, elmnam, mcnam)
      iocc = jbyt(iq(lsflg+ipos), mocc1, mocc2)
      write (iqpr2, 910) iturn, isup, suml, elmnam, iocc
      icopy = 0
      do 80 itrack = 1, ntrk

*---- Is particle outside aperture?
        if (abs(track(1,itrack)) .gt. eject  .or.
     +      abs(track(3,itrack)) .gt. eject) then

*---- Give message for particle.
          write (iqpr2, 920) number(itrack), (track(i,itrack),i=1,6)

*---- Loosing closed orbit is fatal.
          if (number(itrack) .eq. 0) then
            call aafail('TRFLOW', 1,
     +        'Closed orbit has been lost, cannot continue tracking.')
            ntrk = 0
            return
          endif

*---- If in aperture, compact track storage.
        else
          icopy = icopy + 1
          if (icopy .ne. itrack) then
            track(1,icopy) = track(1,itrack)
            track(2,icopy) = track(2,itrack)
            track(3,icopy) = track(3,itrack)
            track(4,icopy) = track(4,itrack)
            track(5,icopy) = track(5,itrack)
            track(6,icopy) = track(6,itrack)
            number(icopy) = number(itrack)
          endif
        endif
   80 continue
      ntrk = icopy

  910 format(' Particle(s) lost during turn ',i8,', superperiod ',i8,
     +  ', s = ',f12.6,' by overflow in ',a,'[',i8,']'/
     +  ' Number',6x,'x',15x,'px',14x,'y',15x,'py',14x,'t',15x,'pt')
  920 format(' ',i6,4x,1p,6e16.8)

      end
+dk trflsv
      subroutine trflsv(iturn, track, number, ntrk)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Write particle positions for current turn to track file.           *
* Input:                                                               *
*   ITURN     (integer) Turn number.                                   *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   NUMBER(*) (integer) Number of current track.                       *
*   NTRK      (integer) Number of surviving tracks.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ierr,itrack,itrk,iturn,ni,nr,ntrk
      double precision track
      dimension         track(6,*)
      integer           number(*)
+ca memdum
+ca message
+ca beam
+ca trdata
+ca trlink

      integer           ihead(6)

*---- Skip hidden track (closed orbit).
      if (number(1) .eq. 0) then
        itrk = 2
        ihead(6) = ntrk - 1
      else
        itrk = 1
        ihead(6) = ntrk
      endif

*---- Pack integer data to buffer bank.
      ihead(5) = iturn
      ni = 0
      do 10 i = itrk, ntrk
        ni = ni + 1
        iq(ltrrbf+ni) = number(i)
   10 continue
      nr = ni

*---- Pack real data to buffer bank.
      do 20 itrack = itrk, ntrk
        q(ltrrbf+nr+1) = track(1,itrack)
        q(ltrrbf+nr+2) = track(2,itrack)
        q(ltrrbf+nr+3) = track(3,itrack)
        q(ltrrbf+nr+4) = track(4,itrack)
        q(ltrrbf+nr+5) = track(5,itrack)
        q(ltrrbf+nr+6) = track(6,itrack)
        q(ltrrbf+nr+7) = 0.0
        q(ltrrbf+nr+8) = en0
        nr = nr + 8
   20 continue
      call ctoibm(q(ltrrbf+ni+1), nr - ni, 3)

*---- Write buffer in EPIO format.
      call epoutl(itrfil,3,6,ihead,nr,q(ltrrbf+1),q(ltrfbf+1),ierr)
      if (ierr .ne. 0) then
        write (msg, 910) iturn
  910   format('Cannot write record for turn number ',i8,'.')
        call aafail('TRFLSV', 1, msg)
        iffreq = 0
      endif

      end
+dk trkill
      subroutine trkill(iflag, iturn, isup, ipos, suml, el,
     +                  track, number, ntrk)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Test for aperture limits.                                          *
* Input:                                                               *
*   IFLAG     (integer) Aperture type flag:                            *
*                       1: elliptic, 2: rectangular, 3: overflow.      *
*   ITURN     (integer) Current turn number.                           *
*   ISUP      (integer) Current superperiod number.                    *
*   IPOS      (integer) Position counter.                              *
*   SUML      (real)    Accumulated length.                            *
* Output:                                                              *
*   EL        (real)    Element length.                                *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   NUMBER(*) (integer) Number of current track.                       *
*   NTRK      (integer) Number of surviving tracks.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer i,icopy,iflag,iname,iocc,ipass,ipos,isup,itrack,iturn,
     +jbyt,npass,ntrk
      double precision apx,apy,eject,el,suml,track,xx,yy
      dimension         track(6,*)
      integer           number(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca seqflag
+ca refer
+ca trdata
+ca zunit

      character*(mcnam) elmnam
      character*25      text(3)
      logical           ellips, header, outsid, rectan
      parameter         (eject = 1.0)
      data text         / ' in elliptical aperture ',
     +                    ' in rectangular aperture ',
     +                    ' by overflow in element ' /

      ellips(xx,yy) = (xx / apx) ** 2 + (yy / apy) ** 2 .gt. 1.0
      rectan(xx,yy) = abs(xx) .gt. apx  .or.  abs(yy) .gt. apy

*---- Get aperture size.
      if (iflag .eq. 3) then
        el  = 0.0
        apx = eject
        apy = eject
        npass = 1
      else
        call ucopy(q(lcelm+melen), el, mwflt)
        call ucopy(q(lcelm+mexcol), apx, mwflt)
        call ucopy(q(lcelm+meycol), apy, mwflt)
        if (apx .eq. 0.0) apx = eject
        if (apy .eq. 0.0) apy = eject
        if (el .eq. 0.0) then
          npass = 1
        else
          npass = 2
        endif
      endif

*---- Do one or two passes through tests.
      header = .false.
      do 90 ipass = 1, npass
        icopy = 0
        do 80 itrack = 1, ntrk

*---- Is particle outside aperture?
          if (iflag .eq. 1) then
            outsid = ellips(track(1,itrack), track(3,itrack))
          else
            outsid = rectan(track(1,itrack), track(3,itrack))
          endif
          if (outsid) then

*---- Stop when loosing a particle in DYNAP mode.
            if (fdynap) then
              ntrk = 0
              return

*---- For first particle lost, print header.
            else
              if (.not. header) then
                iname = (iq(lsdir+ipos) - 1) * mwnam + 1
                call uhtoc(q(ldbnk(2)+iname), mcwrd, elmnam, mcnam)
                iocc = jbyt(iq(lsflg+ipos), mocc1, mocc2)
                write (iqpr2, 910) iturn, isup, suml, text(iflag),
     +                             elmnam, iocc
                header = .true.
              endif

*---- Give message for particle.
              write (iqpr2, 920) number(itrack), (track(i,itrack),i=1,6)

*---- Loosing closed orbit is fatal.
              if (number(itrack) .eq. 0) then
                call aafail('TRKILL', 1,
     +            'Closed orbit has been lost, ' //
     +            'cannot continue tracking.')
                ntrk = 0
                return
              endif
            endif

*---- If in aperture, compact track storage.
          else
            icopy = icopy + 1
            if (icopy .ne. itrack) then
              track(1,icopy) = track(1,itrack)
              track(2,icopy) = track(2,itrack)
              track(3,icopy) = track(3,itrack)
              track(4,icopy) = track(4,itrack)
              track(5,icopy) = track(5,itrack)
              track(6,icopy) = track(6,itrack)
              number(icopy) = number(itrack)
            endif
          endif
   80   continue
        ntrk = icopy

*---- If first pass and non-zero length, drift to end and repeat.
        if (ipass .lt. npass) call ttdrf(el, track, ntrk)
   90 continue

  910 format(' Particle(s) lost during turn ',i8,', superperiod ',i8,
     +  ', s = ',f12.6,a,a,'[',i8,']'/
     +  ' Number',6x,'x',15x,'px',14x,'y',15x,'py',14x,'t',15x,'pt')
  920 format(' ',i6,4x,1p,6e16.8)

      end
+dk trmain
      subroutine trmain(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Control routine for tracking module.                               *
* Input:                                                               *
*   IPR       (integer) Process code.                                  *
*   ISP       (integer) Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca message
+ca status
+ca trdata
+ca trlink
      integer ipr,isp,itrflg

      data itrflg       / 0 /
      save              itrflg

*--- reset title
      trktitle = 'Tracking'
*---- Initialize polynomial package and link area.
      call painit(6)
      if (itrflg .eq. 0) then
        call mzlink(0, '/TRLINK/', ltrnum, ltrcur, ltrbuf)
        itrflg = 1
        fstart = .false.
      endif

*---- Conventional tracking commands, must be in a TRACK block.
      if (isp .le. 20) then
        fdynap = .false.

*---- Check valid use of command.
        if (isp .gt. 1  .and.  imodul .ne. ipr) then
          msg(1) =
     +    'Cannot run tracking subcommand outside tracking process,'
          msg(2) = 'TRACK command required first.'
          call aafail('TRMAIN', 2, msg)
        else if (isp .le. 1  .and.  imodul .ne. 0) then
          msg(1) =
     +      'Cannot initiate tracking while previous process ' //
     +      'is not complete,'
          msg(2) = 'Enter proper ENDxxxx command first.'
          call aafail('TRMAIN', 2, msg)

*---- TRACK --- Enter tracking mode.
        else if (isp .eq. 1) then
          call trtrkcmd
          if (.not. error) imodul = ipr

*---- ENDTRACK --- Leave tracking module and drop noise data.
        else if (isp .eq. 2) then
          call trend
          imodul = 0

*---- RUN --- Perform tracking.
        else if (isp .eq. 3) then
          call trrun

*---- CONTINUE --- Continue tracking.
        else if (isp .eq. 4) then
          msg(1) = 'CONTINUE command is now identical to RUN,'
          msg(2) = 'Turns will be numbered from 1 to N.'
          call aawarn('TRMAIN', 2, msg)
          call trrun

*---- START --- Define initial conditions.
        else if (isp .eq. 5) then
          call trstrt

*---- TSAVE --- Save end conditions as initial conditions for next run.
        else if (isp .eq. 6) then
          call trsave

*---- NOISE --- Define noise on a given element.
        else if (isp .eq. 7) then
          call trnois

*---- OBSERVE --- Define observation point.
        else if (isp .eq. 8) then
          call trrobs

*---- User-defined command.
        else
          call usercm(ipr, isp)
        endif

*---- Tracking commands which initialise themselves.
      else

*---- DYNAPSTART --- Initial conditions for DYNAP.
        if (isp .eq. 21) then
          call trinicmd

*---- DYNAP --- Find dynamic aperture.
        else if (isp .eq. 22) then
          call trdyncmd

*---- User-defined command.
        else
          call usercm(ipr, isp)
        endif
      endif

      end
+dk trinicmd
      subroutine trinicmd
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Define initial conditions for a single particle;                   *
*   DYNAPSTART command.                                                *
* Attributes:                                                          *
*   X, PX, Y, PY, T, DELTAP, FX, PHIX, FY, PHIY, FT, PHIT, TURNS,      *
*   STEP, CHKBELOW, FRACMIN, FASTUNE, LYAPUNOV, DAMP, QUANTUM,         *
*   CONTINUE, METHOD, TABLE, ORBIT.                                    *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca message
+ca beam
+ca optic0
+ca refer
+ca trdata
+ca trdynap
+ca trlink
+ca troptc
+ca zunit
+ca status
+ca stflag
      integer k,kp,kq,mtrack
      double precision phi,track,trturns,twopi,z,zn

+ca pi
      parameter         (twopi = 2.0d0 * pi)
      parameter         (mtrack = 50)

      dimension         track(12), zn(6), z(6)
      integer           itype(23)
      logical           zgiv, zngiv, flcont

*---- Copy data to local storage.
      call uzero(track(1), 1, 12 * mwflt)
      call utgflt(lccmd, 1, 12, track)
      call utgtyp(lccmd, itype)
      trturns  = 64
      trstep   = 0.05d0
      chkbelow = 0.0d0
      fracmin  = 0.1d0
      fastune  = .false.
      lyapflag = .false.
      deltax   = 1.0d-7
      fdamp    = .false.
      frand    = .false.
      flcont   = .false.
      orbflag  = .true.
      call utgflt(lccmd, 13, 13, trturns)
      itrturns = int(trturns)
      call utgflt(lccmd, 14, 14, trstep)
      call utgflt(lccmd, 15, 15, chkbelow)
      call utgflt(lccmd, 16, 16, fracmin)
      call utglog(lccmd, 17, 17, fastune)
      call utgflt(lccmd, 18, 18, deltax)
      if (itype(18) .ne. 0) lyapflag = .true.
      call utglog(lccmd, 19, 19, fdamp)
      call utglog(lccmd, 20, 20, frand)
      call utglog(lccmd, 21, 21, flcont)
      call utglog(lccmd, 24, 24, orbflag)

*---- Tracking method and table name.
      trknam(1) = 'TRANSPORT'
      trknam(2) = ' '
      call utgnam(lccmd, 22, 23, trknam)

*---- Initialise orbit, emittances and eigenvectors.
      call trbegn(.false., orbflag)
      if (error) return

*---- Normalized coordinates.
      do 10 kq = 1, 5, 2
        kp = kq + 1
        phi = twopi * track(kq+7)
        zn(kq) =   track(kq+6) * cos(phi)
        zn(kp) = - track(kq+6) * sin(phi)
   10 continue

*---- Transform to unnormalized coordinates and refer to closed orbit.
      zgiv = .false.
      zngiv = .false.
      do 20 k = 1, 6
        if (itype(k) .ne. 0) zgiv = .true.
        if (itype(k+6) .ne. 0) zngiv = .true.
        zstart(k) = track(k)
     +       + sqrt(ex) * (eigen(k,1) * zn(1) + eigen(k,2) * zn(2))
     +       + sqrt(ey) * (eigen(k,3) * zn(3) + eigen(k,4) * zn(4))
     +       + sqrt(et) * (eigen(k,5) * zn(5) + eigen(k,6) * zn(6))
   20 continue

*---- Warn user about possible data conflict.
      if (zgiv .and. zngiv) then
        msg(1) = 'Absolute and normalized coordinates given,'
        msg(2) = 'Superposition used.'
        call rdwarn('START', 2, msg)
      endif

*---- Set initial betatron invariants.
      if (flcont) then
        do 30 k = 1, 6
          zstart(k) =  zstart(k) + zendyn(k)
   30   continue
      endif
      do 40 k = 1, 6
        z(k) = orbit0(k) + zstart(k)
   40 continue
      wxmax = 0d0
      wymax = 0d0
      wxymax = 0d0
      call wmaxmin(z)
      wxstart = wxmax
      wystart = wymax
      wxystart = wxymax
      wxmin = wxmax
      wymin = wymax
      wxymin = wxymax

      write (iqpr2, 930) zstart(1), zstart(2),
     +                   zstart(3), zstart(4),
     +                   zstart(5), zstart(6),
     +                   itrturns,  fracmin,  trstep, chkbelow
      write (iqpr2, 940) fastune, lyapflag, fdamp, frand, flcont
      write (iqpr2, 950) trknam(1), trknam(2)

*---- Make parameters accessible to VALUE and PUSH.
      call aasetp('XSTART',    zstart(1))
      call aasetp('PXSTART',   zstart(2))
      call aasetp('YSTART',    zstart(3))
      call aasetp('PYSTART',   zstart(4))
      call aasetp('TSTART',    zstart(5))
      call aasetp('PTSTART',   zstart(6))
      call aasetp('TURNS',     itrturns*1.d0)
      call aasetp('STEP',      trstep)
      call aasetp('CHKBELOW',  chkbelow)
      call aasetp('FRACMIN',   fracmin)
      call aasetp('WXSTART',   wxstart)
      call aasetp('WYSTART',   wystart)
      call aasetp('WXYSTART',  wxystart)
      call aasetp('D0',        deltax)

*---- Activate start flag.
      fstart = .true.

  930 format(' '/' Initial conditions w.r.t. closed orbit',
     +  ' for dynamic aperture search'/
     +  ' XSTART =',t10,f14.12,t36,'PXSTART =',f14.12/
     +  ' YSTART =',t10,f14.12,t36,'PYSTART =',f14.12/
     +  ' TSTART =',t10,f14.12,t36,'PTSTART =',f14.12/
     +  ' Tracking over:',t17,'TURNS =',i7,t36,'FRACMIN =',f14.12/
     +  ' Fractional step for downward search:',t39,'STEP =',f14.12/
     +  ' Stability analysis below dynap:',t35,'CHKBELOW =',f14.12)
  940 format(' FASTUNE = ',l1, ', LYAPUNOV = ',l1,', DAMPING = ',l1,
     +  ', QUANTUM = ',l1,', CONTINUE = ',l1)
  950 format(' METHOD = ',a,', TABLE = ',a)

      end
+dk trnois
      subroutine trnois
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Define noise for an element parameter, NOISE command.              *
* Attributes:                                                          *
*   VARIABLE  (variable)Variable to be affected.                       *
*   AMPLITUDE (real)    Amplitudes for perturbations.                  *
*   FREQUENCY (real)    Frequencies for perturbations.                 *
*   PHASE     (real)    Phases for perturbations.                      *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca vargroup
+ca keyword
+ca refer
+ca status
+ca trlink
+ca trndat
+ca datatype
      integer iamp,ibias,idata,idim,ifrq,iln,iphs,ipr,isp,nd,ndim,nkat
      double precision amp,frq,phs

*---- Variable name is required (attribute 2).
      if (mod(iq(lccmd+mbat+mctyp),10).eq.0 .or. lq(lccmd-1).eq.0) then
        call aafail('TRNOIS', 1, 'NOISE command requires a variable.')

*---- Parameter must be known (error message in EXFILL).
      else if (lq(lq(lccmd-1)-1) .eq. 0) then
        error = .true.

*---- Parameter must refer to a physical element.
      else if (iq(lq(lq(lccmd-1)-1)+mbpr) .ne. mpelm) then
        call aafail('TRNOIS', 1,
     +  'NOISE command must refer to an element.')

*---- Find dimension of noise bank.
      else
        call kwget(lckey, iln, ipr, isp, nkat)
        ndim = 0
        iamp = mbat + mcsiz
        ifrq = iamp + mcsiz * iadim1(2)
        iphs = ifrq + mcsiz * iadim1(3)
        do 10 idim = 1, min(iadim1(2),iadim1(3),iadim1(4),maxnoi)
          call ucopy(q(lccmd+iamp+mcval), amp, mwflt)
          call ucopy(q(lccmd+ifrq+mcval), frq, mwflt)
          call ucopy(q(lccmd+iphs+mcval), phs, mwflt)
          if (amp .ne. 0) then
            ndim = ndim + 1
            ampl(ndim) = amp
            freq(ndim) = frq
            phas(ndim) = phs
          endif
          iamp = iamp + mcsiz
          ifrq = ifrq + mcsiz
          iphs = iphs + mcsiz
   10   continue

*---- Book a noise bank.
        if (ndim .gt. 0) then
          nd = mwflt * (3 * ndim + 1)
          call mzbook(2, ltrnoi, ltrnoi, 1, 'NOIS', 1, 1, nd, mreal, 0)

*---- Copy variable reference.
          lcvar = lq(lccmd-1)
          lcelm = lq(lcvar-1)
          call mzcopy(2, lcvar, 2, ltrnoi, -1, '.')
          lcvar = lq(ltrnoi-1)
          call exlkvr

*---- Fetch original value of this parameter.
          ibias = mbat + (iq(lcvar+mvbias) - 1) * mcsiz
          call ucopy(q(lcelm+ibias+mcval), orig, mwflt)
          call ucopy(orig, q(ltrnoi+1), mwflt)
          idata = mwflt + 1

*---- Dependent parameter becomes independent, if varied.
          lcexp = lq(lcelm-iq(lcvar+mvbias))
          if (lcexp .ne. 0) then
            call rdwarn('TRNOIS', 1,
     +      'Parameter depends on other values --- dependence deleted.')
            call aadrop(lcexp)
            iq(lcelm+ibias+mctyp) = 10*mtflt + 1
          endif

*---- Copy amplitudes and frequencies.
          iq(ltrnoi-5) = ndim
          call ucopy(ampl, q(ltrnoi+idata), mwflt*ndim)
          idata = idata + mwflt*ndim
          call ucopy(freq, q(ltrnoi+idata), mwflt*ndim)
          idata = idata + mwflt*ndim
          call ucopy(phas, q(ltrnoi+idata), mwflt*ndim)
        endif
      endif

      end
+dk trnres
      subroutine trnres
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Reset element data which were subjected to noise to original value.*
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca vargroup
+ca refer
+ca trlink
      integer ibias
      double precision rval

*---- Loop over noise banks to reset original values.
      ltrcur = ltrnoi
  100 if (ltrcur .ne. 0) then
        lcvar = lq(ltrcur-1)
        lcelm = lq(lcvar-1)
        ibias = iq(lcvar+mvbias)
        call ucopy(q(ltrcur+1), rval, mwflt)
        call utpflt(lcelm, ibias, ibias, rval)
        ltrcur = lq(ltrcur)
        go to 100
      endif

      end
+dk trnset
      subroutine trnset(time)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Apply all noise definitions to perturbed elements.                 *
* Input:                                                               *
*   TIME      (real)    Value of time to be applied.                   *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca vargroup
+ca refer
+ca trlink
+ca trndat
      integer ibias,idata,idim,ndim
      double precision angle,time,twopi

+ca pi
      parameter         (twopi = 2.0d0 * pi)

*---- Loop over noise records to apply noise.
      ltrcur = ltrnoi
  100 if (ltrcur .ne. 0) then
        ndim = iq(ltrcur-5)
        call ucopy(q(ltrcur+1), orig, mwflt)
        idata = mwflt + 1
        call ucopy(q(ltrcur+idata), ampl, mwflt*ndim)
        idata = idata + mwflt*ndim
        call ucopy(q(ltrcur+idata), freq, mwflt*ndim)
        idata = idata + mwflt*ndim
        call ucopy(q(ltrcur+idata), phas, mwflt*ndim)

*---- Apply noise.
        do 110 idim = 1, ndim
          angle = twopi * (freq(idim) * time + phas(idim))
          orig = orig + ampl(idim) * cos(angle)
  110   continue
        lcatt = lq(ltrcur-1)
        lcelm = lq(lcatt-1)
        ibias = iq(lcatt+mvbias)
        call utpflt(lcelm, ibias, ibias, orig)
        ltrcur = lq(ltrcur)
        go to 100
      endif

      end
+dk trpelm
      subroutine trpelm(iturn, isup, ipos, suml, enerp, track, number,
     +ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print particle positions during tracking.                          *
* Input:                                                               *
*   ITURN     (integer) Turn number.                                   *
*   ISUP      (integer) Superperiod number.                            *
*   IPOS      (integer) Position counter.                              *
*   SUML      (real)    Cumulated length.                              *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   NUMBER(*) (integer) Number of current track.                       *
*   KTRACK    (integer) number of surviving tracks.                    *
*----------------------------------------------------------------------*
* Modified: 14-AUG-1999, T. Raubenheimer (SLAC)                        *
*   Modified calling parameters and format statement to print out      *
*   energy also if the energy is non-zero                              *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iname,iocc,ipos,isup,iturn,j,jbyt,ktrack
      double precision suml,track
      double precision enerp
      dimension         track(6,*)
      integer           number(*)
+ca memdum
+ca option
+ca seqflag
+ca refer
+ca zunit

      integer locunit
      logical error
      character*(mcnam) elmnam
      data locunit / 0/

      if (optflg(12)) then
*--- dump into file
        if (locunit .eq. 0) then
          call flopen('trackdump', 'SWFD', 0, 0, locunit, error)
          if (error) locunit = 77
        endif
        do j = 1, ktrack
          if (number(j) .ne. 0)
     +    write(locunit, '(i5, 1p, 7e14.6)') number(j), suml, 
     +    (track(i,j), i = 1,6)
        enddo
      else
      iname = (iq(lsdir+ipos) - 1) * mwnam + 1
      call uhtoc(q(ldbnk(2)+iname), mcwrd, elmnam, mcnam)
      iocc = jbyt(iq(lsflg+ipos), mocc1, mocc2)
      if (enerp .eq. 0.0d0) then
        write (iqpr2, 910) iturn, isup, suml, elmnam, iocc
        do 10 j = 1, ktrack
          if (number(j) .ne. 0) then
            write (iqpr2, 920) number(j), (track(i,j), i = 1, 6)
          endif
   10   continue
      else
        write (iqpr2, 915) iturn, isup, suml, elmnam, iocc
        do 20 j = 1, ktrack
          if (number(j) .ne. 0) then
            write (iqpr2, 925) number(j), (track(i,j), i = 1, 6), enerp
          endif
   20   continue
      endif
      endif

  910 format(' '/' Positions w.r.t. beam line axis, turn = ',
     +       i8,', superperiod = ',i5,', s = ',f12.6,
     +       ', element ',a,'[',i6,']'/
     +       ' number',7x,'x',15x,'px',14x,'y',15x,'py',14x,'t',15x,
     +       'pt')
  915 format(' '/' Positions w.r.t. beam line axis, turn = ',
     +       i8,', superperiod = ',i5,', s = ',f12.6,
     +       ', element ',a,'[',i6,']'/
     +       ' number',7x,'x',15x,'px',14x,'y',15x,'py',14x,'t',15x,
     +       'pt',18x,'energy')
  920 format(1x,i5,6x,1p,6e16.8)
  925 format(1x,i5,6x,1p,6e16.8,6x,1p,g10.3)

      end
+dk trphot
      subroutine trphot(el, curv, rfac)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Generate random energy loss for photons, using a look-up table to  *
*   invert the function Y.  Ultra-basic interpolation computed;        *
*   leads to an extrapolation outside the table using the two outmost  *
*   point on each side (low and high).                                 *
*   Assumes ultra-relativistic particles (beta = 1).                   *
* Author: Ghislain Roy                                                 *
* Input:                                                               *
*   EL     (real)       Element length.                                *
*   CURV   (real)       Local curvature of orbit.                      *
* Output:                                                              *
*   RFAC   (real)       Relative energy loss due to photon emissions.  *
*----------------------------------------------------------------------*
+ca aparam
+ca beam
      integer i,ierror,j,maxtab,nphot
      double precision amean,curv,dexp,dlogr,el,frndm,rfac,scalen,
     +scaleu,slope,tabxi,taby,ucrit,xi
      real real_am
      character * 20 text
*---- Table definition.
      parameter         (maxtab = 101)
      dimension         taby(maxtab), tabxi(maxtab)
+ca physicpm
      parameter (scalen = 5.0d0 / (12.0d0 * hbar * clight))
      parameter (scaleu = hbar * 3.0d0 * clight / 2.0d0)

      data (taby(i), i = 1, 52)
     +/ -1.14084005d0,  -0.903336763d0, -0.769135833d0, -0.601840854d0,
     +  -0.448812515d0, -0.345502228d0, -0.267485678d0, -0.204837948d0,
     +  -0.107647471d0, -0.022640628d0,  0.044112321d0,  0.0842842236d0,
     +   0.132941082d0,  0.169244036d0,  0.196492359d0,  0.230918407d0,
     +   0.261785239d0,  0.289741248d0,  0.322174788d0,  0.351361096d0,
     +   0.383441716d0,  0.412283719d0,  0.442963421d0,  0.472622454d0,
     +   0.503019691d0,  0.53197819d0,   0.561058342d0,  0.588547111d0,
     +   0.613393188d0,  0.636027336d0,  0.675921738d0,  0.710166812d0,
     +   0.725589216d0,  0.753636241d0,  0.778558254d0,  0.811260045d0,
     +   0.830520391d0,  0.856329501d0,  0.879087269d0,  0.905612588d0,
     +   0.928626955d0,  0.948813677d0,  0.970829248d0,  0.989941061d0,
     +   1.0097903d0,    1.02691281d0,   1.04411256d0,   1.06082714d0,
     +   1.0750246d0,    1.08283985d0,   1.0899564d0,    1.09645379d0 /
      data (taby(i), i = 53, 101)
     +/  1.10352755d0,   1.11475027d0,   1.12564385d0,   1.1306442d0,
     +   1.13513422d0,   1.13971806d0,   1.14379156d0,   1.14741969d0,
     +   1.15103698d0,   1.15455759d0,   1.15733826d0,   1.16005647d0,
     +   1.16287541d0,   1.16509759d0,   1.16718769d0,   1.16911888d0,
     +   1.17075884d0,   1.17225218d0,   1.17350936d0,   1.17428589d0,
     +   1.17558432d0,   1.17660713d0,   1.17741513d0,   1.17805469d0,
     +   1.17856193d0,   1.17896497d0,   1.17928565d0,   1.17954147d0,
     +   1.17983139d0,   1.1799767d0,    1.18014216d0,   1.18026078d0,
     +   1.18034601d0,   1.1804074d0,    1.18045175d0,   1.1804837d0,
     +   1.18051291d0,   1.18053186d0,   1.18054426d0,   1.18055236d0,
     +   1.18055761d0,   1.18056166d0,   1.18056381d0,   1.1805656d0,
     +   1.18056655d0,   1.18056703d0,   1.18056726d0,   1.1805675d0,
     +   1.18056762d0 /

      data (tabxi(i), i = 1, 52)
     +/ -7.60090017d0,  -6.90775537d0,  -6.50229025d0,  -5.99146461d0,
     +  -5.52146101d0,  -5.20300722d0,  -4.96184492d0,  -4.76768923d0,
     +  -4.46540833d0,  -4.19970512d0,  -3.98998451d0,  -3.86323285d0,
     +  -3.70908213d0,  -3.59356928d0,  -3.50655794d0,  -3.39620972d0,
     +  -3.29683733d0,  -3.20645332d0,  -3.10109282d0,  -3.0057826d0,
     +  -2.9004221d0,   -2.80511189d0,  -2.70306253d0,  -2.60369015d0,
     +  -2.50103593d0,  -2.4024055d0 ,  -2.30258512d0,  -2.20727491d0,
     +  -2.12026358d0,  -2.04022098d0,  -1.89712d0   ,  -1.7719568d0,
     +  -1.71479833d0,  -1.60943794d0,  -1.51412773d0,  -1.38629436d0,
     +  -1.30933332d0,  -1.20397282d0,  -1.10866261d0,  -0.99425226d0,
     +  -0.89159810d0,  -0.79850775d0,  -0.69314718d0,  -0.59783697d0,
     +  -0.49429631d0,  -0.40047753d0,  -0.30110508d0,  -0.19845095d0,
     +  -0.10536054d0,  -0.05129330d0,   0.0d0,          0.048790119d0 /
      data (tabxi(i), i = 53, 101)
     +/  0.104360029d0,  0.198850885d0,  0.300104618d0,  0.350656837d0,
     +   0.398776114d0,  0.451075643d0,  0.500775278d0,  0.548121393d0,
     +   0.598836541d0,  0.652325153d0,  0.69813472d0 ,  0.746687889d0,
     +   0.802001595d0,  0.850150883d0,  0.900161386d0,  0.951657832d0,
     +   1.00063193d0,   1.05082154d0,   1.09861231d0,   1.13140213d0,
     +   1.1939224d0,    1.25276291d0,   1.3083328d0,    1.36097658d0,
     +   1.4109869d0,    1.45861506d0,   1.50407743d0,   1.54756248d0,
     +   1.60943794d0,   1.64865863d0,   1.70474803d0,   1.75785792d0,
     +   1.80828881d0,   1.85629797d0,   1.90210748d0,   1.9459101d0,
     +   2.0014801d0,    2.05412364d0,   2.10413408d0,   2.15176225d0,
     +   2.19722462d0,   2.25129175d0,   2.29253483d0,   2.35137534d0,
     +   2.40694523d0,   2.45100522d0,   2.501436d0,     2.60268974d0,
     +   2.64617491d0 /

*---- AMEAN is the average number of photons emitted.,
*     NPHOT is the integer number generated from Poisson's law.
      amean = scalen * abs(arad*pc*(1.0+deltas)*el*curv) * sqrt(3.0)
      rfac = 0.0d0
      real_am = amean
      if (real_am .gt. 0.0) then
        call poissn(real_am, nphot, ierror)

        if (ierror .ne. 0) then
          write(text, '(1p,d20.12)') amean
          call aafail('TRPHOT', 1, 
     +    'Fatal: Poisson input mean =' // text)
        endif

*---- For all photons, sum the radiated photon energy,
*     in units of UCRIT (relative to total energy).

        if (nphot .ne. 0) then
          ucrit = scaleu * gammas**2 * abs(curv) / amass
          xi = 0.0d0
          do 30 i = 1, nphot

*---- Find a uniform random number in the range [ 0,3.256223 ].
*     Note that the upper limit is not exactly 15*sqrt(3)/8
*     because of imprecision in the integration of F.
            dlogr = log(3.256223d0 * frndm())

*---- Now look for the energy of the photon in the table TABY/TABXI
            do 10 j = 2, maxtab
              if (dlogr .le. taby(j) ) go to 20
 10         continue

*---- Perform linear interpolation and sum up energy lost.
 20         slope = (dlogr - taby(j-1)) / (taby(j) - taby(j-1))
            xi = dexp(tabxi(j-1) + slope * (tabxi(j) - tabxi(j-1)))
            rfac = rfac + ucrit * xi
   30     continue
        endif
      endif

      end
+dk trptrn
      subroutine trptrn(track, number, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print particle positions at end of turn.                           *
* Input:                                                               *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   NUMBER(*) (integer) Number of current track.                       *
*   KTRACK    (integer) number of surviving tracks.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer i,itrack,kp,kq,ktrack
      double precision phit,phix,phiy,tol,track,utwopi,wt,wx,wy,z,zn
      dimension         track(6,*)
      integer           number(*)
+ca beam
+ca optic0
+ca troptc
+ca zunit

+ca pi
      parameter         (utwopi = 1.0d0 / (2.0d0 * pi))
      parameter         (tol = 5.0d-18)
      dimension         z(6), zn(6)

*---- Print all particles.
      write (iqpr2, 910)
      do 90 itrack = 1, ktrack

*---- Skip hidden track (closed orbit).
        if (number(itrack) .ne. 0) then

*---- Copy track coordinates.
          do 10 i = 1, 6
            z(i) = track(i,itrack) - orbit0(i)
   10     continue

*---- Convert to normalized values.
          do 20 kq = 1, 5, 2
            kp = kq + 1
            zn(kq) = eigen(2,kp) * z(1) - eigen(1,kp) * z(2)
     +             + eigen(4,kp) * z(3) - eigen(3,kp) * z(4)
     +             + eigen(6,kp) * z(5) - eigen(5,kp) * z(6)
            zn(kp) = eigen(1,kq) * z(2) - eigen(2,kq) * z(1)
     +             + eigen(3,kq) * z(4) - eigen(4,kq) * z(3)
     +             + eigen(5,kq) * z(6) - eigen(6,kq) * z(5)
   20     continue
          zn(1) = zn(1) / sqrt(ex)
          zn(2) = zn(2) / sqrt(ex)
          zn(3) = zn(3) / sqrt(ey)
          zn(4) = zn(4) / sqrt(ey)
          zn(5) = zn(5) / sqrt(et)
          zn(6) = zn(6) / sqrt(et)

*---- Convert to amplitude and phase.
          wx = zn(1)**2 + zn(2)**2
          phix = 0.0
          if (wx .gt. tol) then
            phix = - atan2(zn(2), zn(1)) * utwopi
            if (phix .lt. 0.0) phix = phix + 1.0
          endif
          wy = zn(3)**2 + zn(4)**2
          phiy = 0.0
          if (wy .gt. tol) then
            phiy = - atan2(zn(4), zn(3)) * utwopi
            if (phiy .lt. 0.0) phiy = phiy + 1.0
          endif
          wt = zn(5)**2 + zn(6)**2
          phit = 0.0
          if (wt .gt. tol) then
            phit = - atan2(zn(6), zn(5)) * utwopi
            if (phit .lt. 0.0) phit = phit + 1.0
          endif

*---- Write track coordinates.
          write (iqpr2, 920) number(itrack),
     +      z(1), z(2), zn(1), zn(2), wx, phix,
     +      z(3), z(4), zn(3), zn(4), wy, phiy,
     +      z(5), z(6), zn(5), zn(6), wt, phit
        endif
   90 continue

  910 format(' Number',11x,'q',15x,'p',17x,'qn',12x,'pn',14x,'W',11x,
     +       'phi')
  920 format(1x,i5,5x,'x',2f16.8,2f14.8,f16.8,f12.8/
     +       11x,     'y',2f16.8,2f14.8,f16.8,f12.8/
     +       11x,     't',2f16.8,2f14.8,f16.8,f12.8)

      end
+dk trrobs
      subroutine trrobs
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Define observation point for tracking.                             *
* Attributes:                                                          *
*   PLACE     (place)   Observation point.                             *
*   TABLE     (name)    Name of track table to be filled.              *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca trodat
+ca refer
+ca status
+ca trlink
      integer ipos
      double precision eflag

      character*(mcrng) tabrng
      character*(mcnam) tabnam

*---- Recover attributes.
      lcatt = lq(lccmd-1)
      call utgpos(lcatt, lcseq, 0, ipos, eflag)
      call enrang(lcatt, tabrng)
      tabnam = tabrng
      call utgnam(lccmd, 2, 2, tabnam)

*---- Build list bank and bank for orbit and eigenvectors.
      if (.not. error) then
        call mzbook(2, ltrtmp, ltrobs, 1, 'TOBS', 2, 1, mosiz, 5, -1)
        iq(ltrtmp-5) = ipos
        call uctoh(tabnam, iq(ltrtmp+motab), mcwrd, mcnam)
        call uctoh(tabrng, iq(ltrtmp+morng), mcwrd, mcrng)
      endif

      end
+dk trrun
      subroutine trrun
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initial tracking run; RUN command.                                 *
*   Build a new tracking table.                                        *
* Attributes:                                                          *
*   METHOD    (name)    TRANSPORT, LIE3, LIE4                          *
*   TABLE     (name)    Name for track table to be generated.          *
*   TURNS     (integer) Number of turns to be tracked.                 *
*   FPRINT    (integer) Print frequency.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca beam
+ca seqflag
+ca trodat
+ca message
+ca mapelm
+ca option
+ca optic0
+ca optic1
+ca range
+ca refer
+ca status
+ca trdata
+ca trlink
+ca troptc
+ca wstack
+ca zunit
+if doom
+ca dmcommon
+ei
      integer i1,i2,ibias,icode,ienum,iflag,ileng,imeth,iocc,ipos,jbyt,
     +l,maxmet,mcmmnt,mffreq,mmeth,mpfreq,mtable,mturns,nturn
      double precision distvect,el,em,zn,zero
      common /turns/    nturn
      parameter (zero = 0.d0)
      parameter         (maxmet = 3)
      parameter         (mmeth  = 1, mtable = 2, mcmmnt = 3,
     +                   mturns = 4, mpfreq = 5, mffreq = 6)

      external          ttelem, lmelem
      character*(mcnam) dmeth(maxmet), trknam(2), tabnam, elmnam
      character*(mcrng) tabpos
      character*(mcstr) cmmnt
      dimension         em(6,6)
+if doom
      dimension         zn(1), distvect(1)
+ei
      integer           ival(3)
      logical           fmap

      data dmeth        / 'TRANSPORT', 'LIE3    ', 'LIE4    ' /

*---- Tracking method and table name.
      trknam(1) = 'TRANSPORT'
      trknam(2) = ' '
      call utgnam(lccmd, mmeth, mtable, trknam)
      call utlook(trknam(1), dmeth, maxmet, imeth)
      if (imeth .eq. 0) then
        call utleng(trknam(1), ileng)
        msg(1) = 'Unknown method "' // trknam(1)(1:ileng)
     +  // '" --- "TRANSPORT" assumed.'
        call aawarn('TRRUN', 1, msg)
        imeth = 1
      endif
*--- set print file title
      trktitle(10:) = 'method: ' // trknam(1)
*---- Get track file name and comments string.
      cmmnt = ' '
      call utgstr(lccmd, mcmmnt, mcmmnt, cmmnt)

*---- Number of turns and frequencies.
      ival(1) = 1
      ival(2) = 0
      ival(3) = 0
      call utgint(lccmd, mturns, mffreq, ival)
      nturn = max(1, ival(1))
      ipfreq = ival(2)
      iffreq = ival(3)

*---- Quit, if no particles.
      if (npart .le. 0) then
        call aawarn('TRRUN',1,'Cannot RUN --- no particles available.')

*---- Assign working storage for tracks.
      else
        ibias = 6 * mwflt * ntrack
        iwork = ibias + ntrack
        call mzwork(0, dq(1), iq(iwork+1), 2)
        call ucopy(q(ltrstt+1), dq(1), ibias)
        call ucopy(q(ltrnum+1), iq(ibias+1), ntrack)

*---- Order track tables according to their positions in beam.
        call zsorti(0, ltrobs, -5)

*---- List and open track tables.
        if (trknam(2) .ne. ' '  .or.  ltrobs .ne. 0) then
          write (iqlog, 910)

*---- Loop over track tables.
          ltrtmp = ltrobs
          if (ltrtmp .ne. 0) then
            i1 = irg1
            call ucopy(orbit0, orbit, 6*mwflt)
            call m66cpy(eigen, em)
            suml = 0.0
          endif

*---- Track up to next table position.
   10     if (ltrtmp .ne. 0) then
            i2 = iq(ltrtmp-5)
            do 20 ipos = i1, i2
              call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
              icode = jbyt(iflag, 1, mcode)

*---- Misalignment at entrance of element or line.
              if (icode .ne. 3  .and.  lcali .ne. 0) then
                call tmali1(ipos, .false., orbit, orbit, re, te)
                call m66mpy(re, em, em)
              endif

*---- Track through element.
              if (icode .eq. 1) then
                call tmmap(.true., .true., orbit, fmap, el, ek, re, te)
                if (fmap) then
                  suml = suml + el
                  call m66mpy(re, em, em)
                endif
              endif

*---- Misalignment at exit of element or line.
              if (icode .ne. 2  .and.  lcali .ne. 0) then
                call tmali2(ipos, .false., orbit, orbit, re, te)
                call m66mpy(re, em, em)
              endif
   20       continue

*---- Build table and store orbit.
            call uhtoc(q(ltrtmp+motab), mcwrd, tabnam, mcnam)
            call uhtoc(q(ltrtmp+morng), mcwrd, tabpos, mcrng)
            call trtbop(orbit, em, tabnam, nturn, ntrack)
            call mzbook(2,l,ltrtmp,-1,'TVAL',0,0,6*mwflt,mreal,0)
            if (onepss)  then
              call vzero(q(l+1), 6*mwflt)
            else
              call ucopy(orbit, q(l+1), 6*mwflt)
            endif
            write (iqlog, 920) tabpos, tabnam
            lq(ltrtmp-2) = ltrtab

*---- Go to next table.
            ltrtmp = lq(ltrtmp)
            i1 = i2 + 1
            go to 10
          endif
          ltrtab = 0

*---- Open main track table.
          if (trknam(2) .ne. ' ') then
            call trtbop(orbit0, eigen, trknam(2), nturn, ntrack)
            write (iqlog, 920) '#E', trknam(2)
          endif
        endif
*--- store beam-beam kicks
        if (.not. bborbit) call bbstore()
*---- Open track file.
        if (iffreq .ne. 0) then
+if doom
          call dmtrinit(nturn)
          call dmtrsave(0, dq(1), iq(ibias+1), ntrack)
          if (.not. strict)  then
+ei
          call trflop(cmmnt, npart, nturn)
          call trflsv(0, dq(1), iq(ibias+1), ntrack)
+if doom
          endif
+ei
        endif

*---- Set initial energy.
        ener1 = ener0
        if (ener1 .eq. zero .or. .not. ereset) ener1 = en0
*---- Track according to selected method.
        fbelow = .false.
        if (imeth .eq. 1) then
          call trexec(ttelem, 3, nturn, dq(1), iq(ibias+1), ntrack,
     +    zn, distvect)
        else if (imeth .eq. 2) then
          call trexec(lmelem, 3, nturn, dq(1), iq(ibias+1), ntrack,
     +    zn, distvect)
        else
          call trexec(lmelem, 4, nturn, dq(1), iq(ibias+1), ntrack,
     +    zn, distvect)
        endif
        call ucopy(dq(1), q(ltrstt+1), 6 * mwflt * ntrack)
        call ucopy(q(ibias+1), q(ltrnum+1), ntrack)

*---- Close tracking tables.
        if (ltrtab .ne. 0) call trtbcl(ltrtab)

        if (ltrobs .ne. 0) then
          ltrtmp = ltrobs
   30     if (ltrtmp .ne. 0) then
            call trtbcl(lq(ltrtmp-2))
            lq(ltrtmp-1) = 0
            ltrtmp = lq(ltrtmp)
            go to 30
          endif
          call mzdrop(0, ltrobs, 'L')
        endif

*---- Close track file.
+if doom
        if (iffreq .ne. 0) call dmtrclose
        if (.not. strict)  then
+ei
        if (iffreq .ne. 0) call trflcl
+if doom
        endif
+ei
*---- Drop working storage.
        iwork = 0
        call mzwork(0, dq(1), dq(1), -1)
      endif

  900 format(/' Tracking with method: ', a)
  910 format(/' The following tables will be generated:'/
     +       ' Observation point',t51,'Table name')
  920 format(' ',a,t51,a)

      end
+dk trsave
      subroutine trsave
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save final conditions of RUN as initial conditions for another     *
*   tracking run.                                                      *
* Attributes:                                                          *
*   FILENAME  (string)  Name of file to receive values.                *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca message
+ca optic0
+ca refer
+ca status
+ca trdata
+ca trlink
+ca zunit
      integer ibias,ipart,isave,iwork,j

      character*(mcfil) filnam

*---- Fetch file name
      filnam = 'tsave'
      call utgstr(lccmd, 1, 1, filnam)

*---- Quit, if no particles.
      if (ntrack .le. 0) then
        call aawarn('TRSAVE', 1,
     +  'Cannot TSAVE --- no particles available.')
      else

*---- Open disk file and save last particle positions.
        call flopen(filnam, 'SWFD', 0, 0, isave, error)
        if (.not. error) then
          iwork = 6 * ntrack
          call mzwork(0, dq(1), dq(iwork+1), 2)
          call ucopy(q(ltrstt+1), dq(1), mwflt * iwork)
          ibias = 0
          do 10 ipart = 1, ntrack
            if (iq(ltrnum+ipart) .ne. 0) then
              write (isave, 910) iq(ltrnum+ipart),
     +          (dq(ibias+j) - orbit0(j), j = 1, 6)
            endif
            ibias = ibias + 6
   10     continue
          call mzwork(0, dq(1), dq(1), -1)
          write (isave, 920)
          call flname(isave, filnam)
          call flclos(isave, error)
          if (.not. error) then
            write (msg, 930) ntrack, filnam
            call aainfo('TRSAVE', 1, msg)
          endif
        endif
      endif

  910 format('! Particle number ',i6,':'/
     +       'START, X = ',g20.12,', PX     = ',g20.12,',&'/
     +       '       Y = ',g20.12,', PY     = ',g20.12,',&'/
     +       '       T = ',g20.12,', DELTAP = ',g20.12)
  920 format('RETURN')
  930 format(i5,' particles written on file: ',a)

      end
+dk trstrt
      subroutine trstrt
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Define initial conditions for a particle; START command.           *
* Attributes:                                                          *
*   X, PX, Y, PY, DT, DE, FX, PHIX, FY, PHIY, FT, PHIT.                *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca message
+ca beam
+ca optic0
+ca refer
+ca trdata
+ca trlink
+ca troptc
      integer ibias,k,kp,kq,mtrack,nd
      double precision phi,track,twopi,z,zn

+ca pi
      parameter         (twopi = 2.0d0 * pi)
      parameter         (mtrack = 50)

      dimension         track(12), z(6), zn(6)
      integer           itype(12)
      logical           zgiv, zngiv

*---- Copy data to local storage.
      call uzero(track(1), 1, 12 * mwflt)
      call utgflt(lccmd, 1, 12, track)
      call utgtyp(lccmd, itype)

*---- Normalized coordinates.
      do 10 kq = 1, 5, 2
        kp = kq + 1
        phi = twopi * track(kq+7)
        zn(kq) =   track(kq+6) * cos(phi)
        zn(kp) = - track(kq+6) * sin(phi)
   10 continue

*---- Transform to unnormalized coordinates and refer to closed orbit.
      zgiv = .false.
      zngiv = .false.
      do 20 k = 1, 6
        if (itype(k) .ne. 0) zgiv = .true.
        if (itype(k+6) .ne. 0) zngiv = .true.
        z(k) = orbit0(k) + track(k)
     +       + sqrt(ex) * (eigen(k,1) * zn(1) + eigen(k,2) * zn(2))
     +       + sqrt(ey) * (eigen(k,3) * zn(3) + eigen(k,4) * zn(4))
     +       + sqrt(et) * (eigen(k,5) * zn(5) + eigen(k,6) * zn(6))
   20 continue

*---- Warn user about possible data conflict.
      if (zgiv .and. zngiv) then
        msg(1) = 'Absolute and normalized coordinates given,'
        msg(2) = 'Superposition used.'
        call rdwarn('TRSTRT', 2, msg)
      endif

*---- Build banks to store track.
      nd = 6 * mtrack * mwflt
      if (ltrstt .eq. 0) then
        call mzbook(2, ltrstt, ltrstt, 1, 'TRAK', 0, 0, nd, mreal, 0)
        call mzbook(2, ltrnum, ltrnum, 1, 'TNUM', 0, 0, mtrack, 2, 0)
      else if (ntrack .ge. iq(ltrnum-1)) then
        call mzpush(0, ltrstt, 0, nd, 'I')
        call mzpush(0, ltrnum, 0, mtrack, 'I')
      endif
      ibias = 6 * mwflt * ntrack
      npart = npart + 1
      ntrack = ntrack + 1
      call ucopy(z, q(ltrstt+ibias+1), 6 * mwflt)
      iq(ltrnum+ntrack) = npart

      end
+dk trtbcl
      subroutine trtbcl(ltab)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Close a track table.                                               *
* Input:                                                               *
*   LTAB      (pointer) Pointer to the track table.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer           ltab(1)
+ca memdum
+ca message
+ca tbpara

      character*(mcnam) tabnam

      call uhtoc(q(ltab(1)+mtbnam), mcwrd, tabnam, mcnam)
      call tbclos(ltab)
      msg(1) = 'Tracking table closed: ' // tabnam
      call aainfo('TRTBCL', 1, msg)

      end
+dk trtbop
      subroutine trtbop(orb, em, tabnam, nturn, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Open a track table.                                                *
* Input:                                                               *
*   ORB(6)    (real)    Local position of closed orbit.                *
*   EM(6,6)   (real)    Eigenvector matrix.                            *
*   TABNAM    (char)    Name for track table.                          *
*   NTURN     (integer) Number of turns to be stored.                  *
*   KTRACK    (integer) Number of tracks to be stored.                 *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,maxcol,nb,nc,nr,ns,ktrack,nturn
      double precision dummy,em,orb
      character*(mcnam) tabnam
      dimension         orb(6), em(6,6)
+ca beam
+ca option
+ca trlink
+ca troptc

      parameter         (maxcol = 8)
      integer           icform(maxcol)
      character*(mcnam) trkcol(maxcol)
      character*4       name

      data trkcol
     +  / 'TURNS', 'PARTICLE', 'X', 'PX', 'Y', 'PY', 'T', 'PT' /

      ns = nturn + 1
      nr = ktrack
      nc = maxcol
      nb = 1
      icform(1) = 2
      icform(2) = 2
      icform(3) = 3
      if (double) icform(3) = mreal

      do 10 i = 4, maxcol
        icform(i) = icform(3)
   10 continue

      call tbcrea(tabnam, ns, nr, nc, trkcol, icform, nb, ltrtab)

*---- Add descriptors in reverse order.
      do 30 i = 6, 1, -1
        do 20 j = 6, 1, -1
          write (name, '(''E'',I1,I1)') i, j
          call tbpdsc(ltrtab, name, mreal, 0, em(i,j), ' ')
   20   continue
   30 continue

      call tbpdsc(ltrtab, 'EX',   mreal, 0, ex,     ' ')
      call tbpdsc(ltrtab, 'EY',   mreal, 0, ey,     ' ')
      call tbpdsc(ltrtab, 'ET',   mreal, 0, et,     ' ')
      call tbpdsc(ltrtab, 'PY',   mreal, 0, orb(4), ' ')
      call tbpdsc(ltrtab, 'Y',    mreal, 0, orb(3), ' ')
      call tbpdsc(ltrtab, 'PX',   mreal, 0, orb(2), ' ')
      call tbpdsc(ltrtab, 'X',    mreal, 0, orb(1), ' ')
      call tbpdsc(ltrtab, 'TYPE', 5, 0, dummy, 'TRACK')

      end
+dk trtbsv
      subroutine trtbsv(ltab, iturn, orb, track, number, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save particle positions w.r.t. closed orbit in track table.        *
* Input:                                                               *
*   LTAB(1)   (pointer) Pointer to track table.                        *
*   ITURN     (integer) Turn number.                                   *
*   ORB(6)    (real)    Local position of closed orbit.                *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   NUMBER(*) (integer) Number of current track.                       *
*   KTRACK    (integer) number of surviving tracks.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer icoor,iform,ipart,itrack,iturn,ktrack
      double precision orb,t,track
      dimension         orb(6), track(6,*)
      integer           ltab(1), number(*)
+ca memdum
+ca tbpara
+ca trlink

      dimension         t(6)
      logical           eflag

      call tbseg(ltab, iturn + 1, eflag)
      iform = iq(lq(ltab(1)-mtbcfm)+3)
      do 30 itrack = 1, ktrack
        ipart = number(itrack)
        if (ipart .ne. 0) then
          call tbset(ltab, ipart, 3, ltrbuf)
          iq(ltrbuf+1) = iturn
          iq(ltrbuf+2) = ipart
          if (iform .eq. 4) then
            do 10 icoor = 1, 6
              t(icoor) = track(icoor,itrack) - orb(icoor)
   10       continue
            call ucopy(t, q(ltrbuf+3), 6*mwflt)
          else
            do 20 icoor = 1, 6
              q(ltrbuf+icoor+2) = track(icoor,itrack) - orb(icoor)
   20       continue
          endif
        endif
   30 continue

      end
+dk trtbsvly
      subroutine trtbsvly(ltab, iturn, track)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save Lyapunov difference of particle positions in track table.     *
* Input:                                                               *
*   LTAB(1)   (pointer) Pointer to track table.                        *
*   ITURN     (integer) Turn number.                                   *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   NUMBER(*) (integer) Number of current track.                       *
*   NTRACK    (integer) Number of surviving tracks.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer icoor,iform,iturn
      double precision t,track
      dimension         track(6,*)
      integer           ltab(1)
+ca memdum
+ca tbpara
+ca trlink

      dimension         t(6)
      logical           eflag

      call tbseg(ltab, iturn + 1, eflag)
      iform = iq(lq(ltab(1)-mtbcfm)+3)
      call tbset(ltab, 1, 3, ltrbuf)
      iq(ltrbuf+1) = iturn
      iq(ltrbuf+2) = 1
      if (iform .eq. 4) then
        do 10 icoor = 1, 6
          t(icoor) = track(icoor,1) - track(icoor,2)
   10   continue
        call ucopy(t, q(ltrbuf+3), 6*mwflt)
      else
        do 20 icoor = 1, 6
          q(ltrbuf+icoor+2) = track(icoor,1) - track(icoor,2)
   20   continue
      endif

      end
+dk trtrkcmd
      subroutine trtrkcmd
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initialize tracking mode; TRACK command reading.                   *
* Attributes:                                                          *
*   RFCAVITY  (name)    Ignored.                                       *
*   DELTAP    (real)    Ignored.                                       *
*   ONEPASS   (logical) Do not normalize for one-pass system.          *
*   DAMP      (logical) Apply synchrotron radiation damping.           *
*   RANDOM    (logical) Apply random effects of synchrotron radiation. *
*----------------------------------------------------------------------*
+ca aparam
+ca message
+ca beam
+ca option
+ca range
+ca refer
+ca stflag
+ca trdata
+ca wstack
      integer mdel,mdmp,mone,mones,mrfc,mrnd, mdump

      integer           itype(5)

      parameter         (mrfc = 1, mdel = 2)
      parameter         (mone = 3, mdmp = 4, mrnd = 5, mones = 6,
     +                   mdump = 7)

*---- Fetch attributes.
      call utgtyp(lccmd, itype)
      if (itype(mrfc) .ne. 0) then
        call aawarn('TRKCMD', 1, 'Attribute "RFCAVITY" is ignored.')
      endif
      onepss = .false.
      oneshot = .false.
      fdamp = .false.
      frand = .false.
      optflg(12) = .false.
      call utglog(lccmd, mone, mrnd, onepss)
      call utglog(lccmd, mones, mones, oneshot)
      call utglog(lccmd, mdump, mdump, optflg(12))
      if (itype(mdel) .ne. 0) call utgflt(lccmd, mdel, mdel, deltas)
      dorad = frad
      dodamp = fdamp
      dorand = frand

*---- Initialise tracking
      call trbegn(.false., .true.)

*---- Clear working storage pointers.
      iwork = 0
      nwork = 0

*---- Enter tracking mode.
      itrfil = 0
      ipfreq = 1
      ipfreq = 0

*---- Reserve space for hidden track (closed orbit).
      if (dorad  .and.  .not. dodamp) then
        ntrack = 1
      else
        ntrack = 0
      endif
      npart = 0

      if (trace) then
        call timex(time1)
        write (msg, 910) time1
        call aainfo('TRKCMD', 1, msg)
      endif

  910 format('Begin tracking mode, time = ',f12.3)

      end
+dk trturn
      subroutine trturn(doelem, iorder, iturn, track, number, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track one complete turn in the machine (control routine).          *
* Input:                                                               *
*   DOELEM    (subr)    Routine to track through one element.          *
*   IORDER    (integer) Order for Lie algebraic tracking               *
*   ITURN     (integer) Turn number.                                   *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   NUMBER(*) (integer) Number of current track.                       *
*   KTRACK    (integer) number of surviving tracks.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer i1,i2,iorder,ipos,isup,itrack,iturn,jbit,jbyt,ktrack
      double precision beti,bi2gi2,bihalf,eject,el,excurs,one,pt,px,
     +py,track,two,ttt
      external          doelem
      dimension         track(6,*)
      integer           number(*)
+ca memdum
+ca bankhead
+ca bbcomm
+ca cmdgroup
+ca elmgroup
+ca seqflag
+ca seqgroup
+ca prcgroup
+ca beam
+ca optic1
+ca range
+ca refer
+ca trdata
+ca trlink
+ca troptc
+ca zunit
+if udecay
      integer mdecay
      integer jjj
      common / cudecay / totsuml, decay_l, actener, deltas_0
      double precision totsuml, decay_l, actener
      double precision decmass, ptotloc, deltas_0, qedec(4)
+ei

      parameter         (one = 1.0d0, two = 2.0d0, eject = 1.0d0)

+if doom
      if (oneshot)  then
        call dmtrst1(ktrack)
      endif
+ei
*---- Precompute a few constants.
      suml = 0.0
      beti = one / betas
      bi2gi2 = one / (betas * gammas)**2
      bihalf = one / (two * betas)
      lcali = 0
      lcfld = 0
      lccom = 0
*---- Loop over the superperiods.
      do 100 isup = 1, nsup
        i1 = irg1
        i2 = irg2

*---- Set up for first superperiod.
        if (isup .eq. 1  .and.  ltrobs .ne. 0) then
          ltrtmp = ltrobs
          i2 = iq(ltrtmp-5)
        else
          ltrtmp = 0
        endif

*---- Loop over track tables.
   10   continue

*---- Do first (or only) half of superperiod.
          do 40 ipos = i1, i2
            bbd_pos = ipos
            lcelm = lq(ldbnk(3)-iq(lsdir+ipos))

*---- Test for physical element.
            if (iq(lcelm+mbpr) .eq. mpelm) then

*---- Drift handled inline for speed.
              if (iq(lcelm+mbsp) .eq. 1) then
                call ucopy(q(lcelm+melen), el, mwflt)
                excurs = 0.d0
                do 20 itrack = 1, ktrack
                  px = track(2,itrack)
                  py = track(4,itrack)
                  pt = track(6,itrack)
                  ttt = one/sqrt(one+two*pt*beti+pt**2 - px**2 - py**2)
                  track(1,itrack) = track(1,itrack) + el*ttt*px
                  track(3,itrack) = track(3,itrack) + el*ttt*py
                  track(5,itrack) = track(5,itrack) 
     +            + el*(beti - (beti+pt)*ttt) + el * pt * dtbyds
                  excurs = max(abs(track(1,itrack)),
     +            abs(track(3,itrack)), excurs)
   20           continue
                if (excurs .gt. eject) then
                  call trflow(iturn,isup,ipos,suml,track,number,ktrack)
                  if (ktrack .eq. 0) go to 200
+if udecay
                else
                  totsuml = totsuml + el
                  if (totsuml .gt. decay_l)  then
                    write(79,*) decay_l, suml + el
                    call udecay(pc, amass, track(2,1),
     +              track(4,1), track(6,1), qedec, decmass)
                    decay_l = 1.d20
                    ptotloc = sqrt(qedec(1)**2+qedec(2)**2+qedec(3)**2)
                    do jjj = 1, 2
                      track(2*jjj,1) = qedec(jjj) / ptotloc
                    enddo
                    track(6,1) = 0.0
                    deltas = (ptotloc - pc) / pc
                  endif
+ei
                endif
                suml = suml + el

*---- Other elements: Alignment and field error pointers (skip markers).
              else if (iq(lcelm+mbsp) .ne. 25) then
                if (lsali .ne. 0) lcali = lq(lsali-ipos)
                if (lsfld .ne. 0) lcfld = lq(lsfld-ipos)
                if (lscom .ne. 0) lccom = lq(lscom-ipos)
                if (lcali .ne. 0) call trdsp1(ipos, track, ktrack)
                if (iq(lcelm+mbsp) .eq. 8) then
                  call ttmult(track, ktrack)
                else
                  call doelem(iturn, iorder, isup, ipos, suml,
     +                        track, number, ktrack)
                endif
                if (ktrack .eq. 0) go to 200
                if (lcali .ne. 0) call trdsp2(ipos, track, ktrack)
              endif

*---- Entrance or exit of beam line.
            else if (iq(lcelm+mbpr) .eq. mplin) then
              if (lsali .ne. 0) lcali = lq(lsali-ipos)
              if (lcali .ne. 0) then
                if (jbyt(iq(lsflg+ipos), 1, mcode) .eq. 2) then
                  call trdsp1(ipos, track, ktrack)
                else
                  call trdsp2(ipos, track, ktrack)
                endif
              endif
            endif

*---- Optional print.
            if (jbit(iq(lsflg+ipos), mtrck) .ne. 0) then
             call trpelm(iturn,isup,ipos,suml,ener1,track,number,ktrack)
            endif
   40     continue

*---- Put particles in table and set up tracking up to next position.
        if (ltrtmp .ne. 0) then
          call ucopy(q(lq(ltrtmp-1)+1), orbit, 6*mwflt)
          call trtbsv(lq(ltrtmp-2), iturn, orbit, track, number, ktrack)
          ltrtmp = lq(ltrtmp)
          i1 = i2 + 1
          if (ltrtmp .ne. 0) then
            i2 = iq(ltrtmp-5)
          else
            i2 = irg2
          endif
          go to 10
        endif

*---- If line is symmetric, move backward.
        if (symm) then
          do 90 ipos = irg2, irg1, -1
            lcelm = lq(ldbnk(3)-iq(lsdir+ipos))

*---- Test for physical element.
            if (iq(lcelm+mbpr) .eq. mpelm) then

*---- Drift handled inline for speed.
              if (iq(lcelm+mbsp) .eq. 1) then
                call ucopy(q(lcelm+melen), el, mwflt)
                excurs = 0.d0
                do 70 itrack = 1, ktrack
                  px = track(2,itrack)
                  py = track(4,itrack)
                  pt = track(6,itrack)
                  ttt = one/sqrt(one+two*pt*beti+pt**2 - px**2 - py**2)
                  track(1,itrack) = track(1,itrack) + el*ttt*px
                  track(3,itrack) = track(3,itrack) + el*ttt*py
                  track(5,itrack) = track(5,itrack) 
     +            + el*(beti - (beti+pt)*ttt) + el * pt * dtbyds
                  excurs = max(abs(track(1,itrack)),
     +            abs(track(3,itrack)), excurs)
   70           continue
                if (excurs .gt. eject) then
                  call trflow(iturn,isup,ipos,suml,track,number,ktrack)
                  if (ktrack .eq. 0) go to 200
                endif
                suml = suml + el

*---- Other elements: Alignment and field error pointers (skip markers).
              else if (iq(lcelm+mbsp) .ne. 25) then
                if (lsali .ne. 0) lcali = lq(lsali-ipos)
                if (lsfld .ne. 0) lcfld = lq(lsfld-ipos)
                if (lscom .ne. 0) lccom = lq(lscom-ipos)
                if (lcali .ne. 0) call trdsp1(ipos, track, ktrack)
                if (iq(lcelm+mbsp) .eq. 8) then
                  call ttmult(track, ktrack)
                else
                  call doelem(iturn, iorder, isup, ipos, suml,
     +                        track, number, ktrack)
                endif
                if (ktrack .eq. 0) go to 200
                if (lcali .ne. 0) call trdsp2(ipos, track, ktrack)
              endif

*---- Entrance or exit of beam line.
            else if (iq(lcelm+mbpr) .eq. mplin) then
              if (lsali .ne. 0) lcali = lq(lsali-ipos)
              if (lcali .ne. 0) then
                if (jbyt(iq(lsflg+ipos), 1, mcode) .eq. 2) then
                  call trdsp1(ipos, track, ktrack)
                else
                  call trdsp2(ipos, track, ktrack)
                endif
              endif
            endif

*---- Optional print.
            if (jbit(iq(lsflg+ipos), mtrck) .ne. 0) then
             call trpelm(iturn,isup,ipos,suml,ener1,track,number,ktrack)
            endif
+if doom
*--- optional storage of first turn in DOOM
            if (oneshot) call dmtrst2(ipos,suml,track,number,ktrack)
+ei
   90     continue
        endif
  100 continue

*---- End of turn.
  200 continue
+if doom
      if (oneshot)  then
        oneshot = .false.
        call dmtrst3
      endif
+ei
      end
+dk trzzzz
+dk ttaaaa
+dk tt_wake
      subroutine tt_wake(val, irec, nrec, array)
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Binary search for wakefield routine TTWAKE                         *
* Input:                                                               *
*   VAL           (real)                                               *
*   NREC          (integer)                                            *
*   ARRAY(0:NREC) (real)                                               *
* Output:                                                              *
*   IREC          (integer)                                            *
*----------------------------------------------------------------------*
* Created:  ??-???-????, T. Raubenheimer (SLAC)                        *
*----------------------------------------------------------------------*

      implicit none
      integer irec, nrec
      double precision val, array(0:nrec)
      integer i, j, k

*---- Search.
      i = 0
      j = nrec
   10 if (j - i .le. 4) goto 100
      k = int((j + i + 1)/2)
      if (array(k) .gt. val) then
        j = k
      else
        i = k
      endif
      goto 10

  100 continue
      if (array(i) .gt. val) then
        irec = i
      elseif (array(i+1) .gt. val) then
        irec = i+1
      elseif (array(i+2) .gt. val) then
        irec = i+2
      elseif (array(i+3) .gt. val) then
        irec = i+3
      else
        irec = i+4
      endif

      end
+dk ttbb
      subroutine ttbb(parvec, track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* purpose:
*   track a set of particle through a beam-beam interaction region.
*   see mad physicist's manual for the formulas used.
*input:
*   parvec    (double)  BB element parameter vector:
*                       1:  sigma_x [m]
*                       2:  sigma_y [m]
*                       3:  x_offset [m]
*                       4:  y_offset [m]
*                       5:  classical particle radius [m]
*                       6:  total bunch charge [electron charges] of
*                           opposite beam
*                       7:  gamma = E / (m c^2)
* input/output:
*   track(6,*)(double)  track coordinates: (x, px, y, py, t, pt).
*   ktrack    (integer) number of tracks.
*----------------------------------------------------------------------*
+ca aparam
+ca bbcomm
+ca option
      integer ktrack
      double precision parvec(*), track(6,*)
      double precision zero, one, two, three, explim, pi
      parameter (zero = 0.d0, one = 1.0d0, two = 2.0d0, three = 3.0d0)
*     if x > explim, exp(-x) is outside machine limits.
      parameter         (explim = 150.0d0)
      integer itrack, ipos
      double precision sx, sy, xm, ym, sx2, sy2, xs, ys, rho2, fk, tk,
     +phix, phiy, rk, xb, yb, crx, cry, xr, yr, r, r2, cbx, cby

*---- initialize.
      pi = 4 * atan(one)
      sx = parvec(1)
      sy = parvec(2)
      xm = parvec(3)
      ym = parvec(4)
      fk = two * parvec(5) * parvec(6) / parvec(7)
      if (fk .eq. zero)  return
      ipos = 0
      if (.not. bborbit)  then
*--- find position of closed orbit bb_kick
        do ipos = 1, bbd_cnt
          if (bbd_loc(ipos) .eq. bbd_pos)  goto 1
        enddo
        ipos = 0
    1   continue
      endif
      sx2 = sx*sx
      sy2 = sy*sy
*---- limit formulae for sigma(x) = sigma(y).
      if (abs(sx2 - sy2) .le. 1.0d-3 * (sx2 + sy2)) then
        do 10 itrack = 1, ktrack
          xs = track(1,itrack) - xm
          ys = track(3,itrack) - ym
          rho2 = xs * xs + ys * ys
          tk = rho2 / (two * sx2)
          if (tk .gt. explim) then
            phix = xs * fk / rho2
            phiy = ys * fk / rho2
          else if (rho2 .ne. zero) then
            phix = xs * fk / rho2 * (one - exp(-tk) )
            phiy = ys * fk / rho2 * (one - exp(-tk) )
          else
            phix = zero
            phiy = zero
          endif
          if (ipos .ne. 0)  then
*--- subtract closed orbit kick
            phix = phix - bb_kick(1,ipos)
            phiy = phiy - bb_kick(2,ipos)
          endif
          track(2,itrack) = track(2,itrack) + phix
          track(4,itrack) = track(4,itrack) + phiy
   10   continue

*---- case sigma(x) > sigma(y).
      else if (sx2 .gt. sy2) then
        r2 = two * (sx2 - sy2)
        r  = sqrt(r2)
        rk = fk * sqrt(pi) / r
        do 20 itrack = 1, ktrack
          xs = track(1,itrack) - xm
          ys = track(3,itrack) - ym
          xr = abs(xs) / r
          yr = abs(ys) / r
          call cperrf(xr, yr, crx, cry)
          tk = (xs * xs / sx2 + ys * ys / sy2) / two
          if (tk .gt. explim) then
            phix = rk * cry
            phiy = rk * crx
          else
            xb = (sy / sx) * xr
            yb = (sx / sy) * yr
            call cperrf(xb, yb, cbx, cby)
            phix = rk * (cry - exp(-tk) * cby)
            phiy = rk * (crx - exp(-tk) * cbx)
          endif
          track(2,itrack) = track(2,itrack) + phix * sign(one,xs)
          track(4,itrack) = track(4,itrack) + phiy * sign(one,ys)
          if (ipos .ne. 0)  then
*--- subtract closed orbit kick
            track(2,itrack) = track(2,itrack) - bb_kick(1,ipos)
            track(4,itrack) = track(4,itrack) - bb_kick(2,ipos)
          endif
   20   continue

*---- case sigma(x) < sigma(y).
      else
        r2 = two * (sy2 - sx2)
        r  = sqrt(r2)
        rk = fk * sqrt(pi) / r
        do 30 itrack = 1, ktrack
          xs = track(1,itrack) - xm
          ys = track(3,itrack) - ym
          xr = abs(xs) / r
          yr = abs(ys) / r
          call cperrf(yr, xr, cry, crx)
          tk = (xs * xs / sx2 + ys * ys / sy2) / two
          if (tk .gt. explim) then
            phix = rk * cry
            phiy = rk * crx
          else
            xb  = (sy / sx) * xr
            yb  = (sx / sy) * yr
            call cperrf(yb, xb, cby, cbx)
            phix = rk * (cry - exp(-tk) * cby)
            phiy = rk * (crx - exp(-tk) * cbx)
          endif
          track(2,itrack) = track(2,itrack) + phix * sign(one,xs)
          track(4,itrack) = track(4,itrack) + phiy * sign(one,ys)
          if (ipos .ne. 0)  then
*--- subtract closed orbit kick
            track(2,itrack) = track(2,itrack) - bb_kick(1,ipos)
            track(4,itrack) = track(4,itrack) - bb_kick(2,ipos)
          endif
   30   continue
      endif

      end
+dk ttbend
      subroutine ttbend(el, track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track a set of particles through a bending magnet.                 *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) number of surviving tracks.                    *
* Output:                                                              *
*   EL        (real)    Length of quadrupole.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer isp,itrack,nd,ktrack
      double precision an,const,ct,e1,e2,el,elrad,field,h,hx,hy,one,pt,
     +px,py,rfac,rpt,rpx,rpy,sk1,sk2,sks,st,three,tilt,track,two,x,y
      dimension         track(6,ktrack)
      double precision an2
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca mapelm
+ca optic1
+ca option
+ca refer
+ca stflag

      parameter         (one = 1.0d0, two = 2.0d0, three = 3.0d0)
      logical fmap
      dimension         field(2,0:2)
      logical bvflag

      bvflag = .false.
*---- Test for non-zero length.
      call ucopy(q(lcelm+melen), el, mwflt)

      if (el .ne. 0.0) then
        isp = iq(lcelm+mbsp)

*---- RBEND or SBEND.
        if (isp .ne. 26) then
          call ucopy(q(lcelm+meangb), an, mwflt)
          call ucopy(q(lcelm+metltb), tilt, mwflt)
          call ucopy(q(lcelm+mek1b), sk1, mwflt)
          call ucopy(q(lcelm+mek2b), sk2, mwflt)
          call ucopy(q(lcelm+mee1b), e1, mwflt)
          call ucopy(q(lcelm+mee2b), e2, mwflt)
          call ucopy(q(lcelm+meintbx+3*mcsiz), bvflag, 1)
          sks = 0.0
*--- HG000915 use bv flag to possibly invert angle
          if (bvflag) an = beambv * an
          if (isp .eq. 2) then
*--- HG001026: arc length to rectangular bend
            an2 = an / 2.d0
            if (an2 .ne. 0.d0 .and. rbarc)  el = el * an2 / sin(an2)
            e1 = e1 + an2
            e2 = e2 + an2
          endif

*---- GBEND.
        else
          call ucopy(q(lcelm+meangg), an, mwflt)
          call ucopy(q(lcelm+metltg), tilt, mwflt)
          call ucopy(q(lcelm+mek1g), sk1, mwflt)
          call ucopy(q(lcelm+meksg), sks, mwflt)
          call ucopy(q(lcelm+mee1g), e1, mwflt)
          call ucopy(q(lcelm+mee2g), e2, mwflt)
          call ucopy(q(lcelm+meintgx+3*mcsiz), bvflag, 1)
          sk2 = 0.0
*--- HG000915 use bv flag to possibly invert angle
          if (bvflag) an = beambv * an
        endif

        h = an / el

*---- Fetch field errors, if any.
        if (lcfld .ne. 0) then
          nd = min(6*mwflt,iq(lcfld-1))
          call uzero(field, 1, 6*mwflt)
          call ucopy(q(lcfld+1), field, nd)
          h = h + (field(1,0) / el) / (one + deltas)
          sk1 = (sk1 + field(1,1) / el) / (one + deltas)
          sk2 = (sk2 + field(1,2) / el) / (one + deltas)
          sks = (sks + field(2,1) / el) / (one + deltas)
        else
          sk1 = sk1 / (one + deltas)
          sk2 = sk2 / (one + deltas)
          sks = sks / (one + deltas)
        endif
*--- apply inversion and scaling
        sk1 = sk1 * elmfact(1)
        sks = sks * elmfact(1)
        sk2 = sk2 * elmfact(2)

*---- Half radiation effects at entrance.
        if (dorad) then
          ct = cos(tilt)
          st = sin(tilt)
          const = arad * gammas**3 / three

*---- Full damping, optionally with random effects.
          if (dodamp) then
            do 10 itrack = 1, ktrack
              x =   track(1,itrack) * ct + track(3,itrack) * st
              y = - track(1,itrack) * st + track(3,itrack) * ct
              hx = h + sk1*(x - h*y**2/two) + sks*y +
     +             sk2*(x**2 - y**2)/two
              hy = sks*x - sk1*y - sk2*x*y
              px = track(2,itrack)
              py = track(4,itrack)
              pt = track(6,itrack)
              elrad = el * (one + h*x) * (one - tan(e1)*x)

              if (dorand) then
                call trphot(elrad, sqrt(hx**2+hy**2), rfac)
              else
                rfac = const * (hx**2 + hy**2) * elrad
              endif

              track(2,itrack) = px - rfac * (one + pt) * px
              track(4,itrack) = py - rfac * (one + pt) * py
              track(6,itrack) = pt - rfac * (one + pt) ** 2
   10       continue

*---- Energy loss like on closed orbit.
          else
            x =   track(1,1) * ct + track(3,1) * st
            y = - track(1,1) * st + track(3,1) * ct
            hx = h + sk1*(x - h*y**2/two) + sks*y +
     +           sk2*(x**2 - y**2)/two
            hy = sks*y - sk1*y - sk2*x*y
            elrad = el * (one + h*x) * (one - tan(e1)*x)
            rfac = const * elrad * (hx**2 + hy**2)
            rpx = rfac * (one + track(6,1)) * track(2,1)
            rpy = rfac * (one + track(6,1)) * track(4,1)
            rpt = rfac * (one + track(6,1)) ** 2

            do 20 itrack = 1, ktrack
              track(2,itrack) = track(2,itrack) - rpx
              track(4,itrack) = track(4,itrack) - rpy
              track(6,itrack) = track(6,itrack) - rpt
   20       continue
          endif
        endif

*---- Get map of dipole and track.
        call tmbend(.true., .false., orbit, fmap, el, ek, re, te)
        call tttrak(ek, re, te, track, ktrack)

*---- Half radiation effects at exit.
        if (dorad) then

*---- Full damping, optionally with random effects.
          if (dodamp) then
            do 30 itrack = 1, ktrack
              ct = cos(tilt)
              st = sin(tilt)
              x =   track(1,itrack) * ct + track(3,itrack) * st
              y = - track(1,itrack) * st + track(3,itrack) * ct
              hx = h + sk1*(x - h*y**2/two) + sks*y +
     +             sk2*(x**2 - y**2)/two
              hy = sks*x - sk1*y - sk2*x*y
              px = track(2,itrack)
              py = track(4,itrack)
              pt = track(6,itrack)
              elrad = el * (one + h*x) * (one - tan(e2)*x)

              if (dorand) then
                call trphot(elrad, sqrt(hx**2+hy**2), rfac)
              else
                rfac = const * (hx**2 + hy**2) * elrad
              endif

              track(2,itrack) = px - rfac * (one + pt) * px
              track(4,itrack) = py - rfac * (one + pt) * py
              track(6,itrack) = pt - rfac * (one + pt) ** 2
   30       continue

*---- Energy loss like on closed orbit.
          else
            x =   track(1,1) * ct + track(3,1) * st
            y = - track(1,1) * st + track(3,1) * ct
            hx = h + sk1*(x - h*y**2/two) + sks*y +
     +           sk2*(x**2 - y**2)/two
            hy = sks*x - sk1*y - sk2*x*y
            elrad = el * (one + h*x) * (one - tan(e2)*x)
            rfac = const * elrad * (hx**2 + hy**2)
            rpx = rfac * (one + track(6,1)) * track(2,1)
            rpy = rfac * (one + track(6,1)) * track(4,1)
            rpt = rfac * (one + track(6,1)) ** 2

            do 40 itrack = 1, ktrack
              track(2,itrack) = track(2,itrack) - rpx
              track(4,itrack) = track(4,itrack) - rpy
              track(6,itrack) = track(6,itrack) - rpt
   40       continue
          endif
        endif
      endif

      end
+dk ttcorr
      subroutine ttcorr(el, track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track particle through an orbit corrector.                         *
*   The corrector is sandwiched between two half-length drift spaces.  *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) number of surviving tracks.                    *
* Output:                                                              *
*   EL        (real)    Length of quadrupole.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer isp,itrack,ktrack
      double precision bi2gi2,bil2,curv,d,dpx,dpy,el,ferror,half,one,pt,
     +px,py,rfac,rpt,rpx,rpy,three,track,two,xkick,ykick
      dimension         track(6,*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca codata
+ca refer
+ca stflag
+ca tmcomm
+ca physicpm
      logical bvflag

      parameter         (half   = 0.5d0, one    = 1.0d0)
      parameter         (two    = 2.0d0, three  = 3.0d0)

      dimension         ferror(2)

*---- Original setting.
      bvflag = .false.
      call ucopy(q(lcelm+melen), el, mwflt)
      isp = iq(lcelm+mbsp)
      if (isp .eq. 14) then
        call ucopy(q(lcelm+mekick), xkick, mwflt)
        call ucopy(q(lcelm+mekick+mcsiz), bvflag, 1)
        ykick = 0.0
      else if (isp .eq. 16) then
        xkick = 0.0
        call ucopy(q(lcelm+mekick), ykick, mwflt)
        call ucopy(q(lcelm+mekick+mcsiz), bvflag, 1)
      else
        call ucopy(q(lcelm+mekick), xkick, mwflt)
        call ucopy(q(lcelm+mekick+mcsiz), ykick, mwflt)
        call ucopy(q(lcelm+mekick+2*mcsiz), bvflag, 1)
      endif

*---- Correction from C.O. correction algorithm.
      if (dokick  .and.  lccom .ne. 0) then
        call ucopy(q(lccom+1), xcm, 2*mwflt)
      else
        xcm = 0.0
        ycm = 0.0
      endif

*---- Field errors.
      if (lcfld .ne. 0) then
        call ucopy(q(lcfld+1), ferror, 2*mwflt)
      else
        ferror(1) = 0.0
        ferror(2) = 0.0
      endif

*---- Sum up total kicks.
      dpx = (xcm + xkick + ferror(1)) / (one + deltas)
      dpy = (ycm + ykick + ferror(2)) / (one + deltas)
*--- HG000915 use bv flag to possibly invert angle
      if (bvflag) then
        dpx = beambv * dpx
        dpy = beambv * dpy
      endif

      bil2 = el / (2.0 * betas)
      bi2gi2 = 1.0 / (betas * gammas) ** 2

*---- Half radiation effects at entrance.
      if (dorad  .and.  el .ne. 0.0) then
        if (dodamp .and. dorand) then
          curv = sqrt(dpx**2 + dpy**2) / el
        else
          rfac = arad * gammas**3 * (dpx**2 + dpy**2) / (three * el)
        endif

*---- Full damping.
        if (dodamp) then
          do 10 itrack = 1, ktrack
            if (dorand) call trphot(el, curv, rfac)
            px = track(2,itrack)
            py = track(4,itrack)
            pt = track(6,itrack)
            track(2,itrack) = px - rfac * (one + pt) * px
            track(4,itrack) = py - rfac * (one + pt) * py
            track(6,itrack) = pt - rfac * (one + pt) ** 2
   10     continue

*---- Energy loss as for closed orbit.
        else
          rpx = rfac * (one + track(6,1)) * track(2,1)
          rpy = rfac * (one + track(6,1)) * track(4,1)
          rpt = rfac * (one + track(6,1)) ** 2

          do 20 itrack = 1, ktrack
            track(2,itrack) = track(2,itrack) - rpx
            track(4,itrack) = track(4,itrack) - rpy
            track(6,itrack) = track(6,itrack) - rpt
   20     continue
        endif
      endif

*---- Half kick at entrance.
      do 30 itrack = 1, ktrack
        px = track(2,itrack) + half * dpx
        py = track(4,itrack) + half * dpy
        pt = track(6,itrack)

*---- Drift through corrector.
        d = (1.0 - pt / betas) * el
        track(1,itrack) = track(1,itrack) + px * d
        track(3,itrack) = track(3,itrack) + py * d
        track(5,itrack) = track(5,itrack) + d * bi2gi2 * pt -
     +    bil2 * (px**2 + py**2 + bi2gi2*pt**2) + el*pt*dtbyds

*---- Half kick at exit.
        track(2,itrack) = px + half * dpx
        track(4,itrack) = py + half * dpy
        track(6,itrack) = pt
   30 continue

*---- Half radiation effects at exit.
*     If not random, use same RFAC as at entrance.
      if (dorad  .and.  el .ne. 0.0) then

*---- Full damping.
        if (dodamp) then
          do 40 itrack = 1, ktrack
            if (dorand) call trphot(el, curv, rfac)
            px = track(2,itrack)
            py = track(4,itrack)
            pt = track(6,itrack)
            track(2,itrack) = px - rfac * (one + pt) * px
            track(4,itrack) = py - rfac * (one + pt) * py
            track(6,itrack) = pt - rfac * (one + pt) ** 2
   40     continue

*---- Energy loss as for closed orbit.
        else
          rpx = rfac * (one + track(6,1)) * track(2,1)
          rpy = rfac * (one + track(6,1)) * track(4,1)
          rpt = rfac * (one + track(6,1)) ** 2

          do 50 itrack = 1, ktrack
            track(2,itrack) = track(2,itrack) - rpx
            track(4,itrack) = track(4,itrack) - rpy
            track(6,itrack) = track(6,itrack) - rpt
   50     continue
        endif
      endif

      end
+dk ttcsr
      subroutine ttcsr(f_csr, el, ang, track, ktrack)
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Include the effect of logitudinal coherent radiation assuming the  *
*   steady-state solution with a gaussian bunch                        *
* Input:                                                               *
*   FCSR      (real)    Scale factor for CSR fields                    *
*   EL        (real)    Length of bend magnet                          *
*   ANG       (real)    Bend angle                                     *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   NTRACK    (integer) Number of surviving tracks.                    *
*----------------------------------------------------------------------*
* Created:  ??-JUL-1994, T. Raubenheimer (SLAC)                        *
*----------------------------------------------------------------------*

      implicit none
      double precision f_csr, el, ang, track(6,*)
      integer ktrack
+ca aparam
+ca beam
*---- The function FF is the F(s/sigz) described in the DESY FEL paper:
*     ff(s)=int(dxp/(x-xp)**(1/3)*diff(exp(-xp**2/2),xp),xp=-infty..x);
*     the points were calculated using MAPLE.

      integer i, nz
      double precision z, sigz, avez, const, f
      double precision  ff(11), xx(11)
      data              ff / 0.8665911471d-5,0.0007257949504,
     +                       0.02193754614,  0.2361703259,
     +                       0.8770375303,   1.005634918,
     +                       0.1074721257,  -0.3249321455,
     +                      -0.2397423123,  -0.1490668117,
     +                      -0.1049894581 /
      data              xx / -5.d0, -4.d0, -3.d0, -2.d0, -1.d0, 0.d0,
     +                        1.d0,  2.d0,  3.d0,  4.d0,  5.d0 /

*---- Calculate the rms bunch length
      sigz = 0.d0
      avez = 0.d0
      do i=1, ktrack
        avez = avez + track(5,i)
        sigz = sigz + track(5,i)**2
      enddo
      avez = avez / max(ktrack,1)
      sigz = sqrt(max(0.d0, sigz/max(ktrack,1)-avez**2))

*---- const = 2*r0/sqrt(2*pi)/3**(1/3)*N/gamma*Lb/R**(2/3)/sigz**(4/3)
      const = 1.55e-15 * parnum / gamma * el**(0.33333333d0)
     +      * abs(ang)**(0.666666667d0) / sigz**(1.33333333d0) * f_csr
      do i = 1, ktrack
        z = (track(5,i) - avez ) / sigz
        if (z .le. -5.d0) then
          f = 0.d0
        else if (z .ge. 5.d0) then
          f = ff(11)
        else
          z = z + 6.d0
          nz = int(z)
          f = ff(nz) + (ff(nz+1)-ff(nz)) * (z-nz)
        endif
        track(6,i) = track(6,i) + const * f
      enddo

      write (6,800) f_csr, el, ang, avez, sigz, parnum, gamma

  800 format (' f_csr: ',1pg10.3,'  el,ang: ',2g13.4,
     +        '  avez,sigz: ',2g13.4,'  n,gamma: ',2g13.4)

      end
+dk ttdrf
      subroutine ttdrf(el, track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track a set of particle through a drift space.                     *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) number of surviving tracks.                    *
* Output:                                                              *
*   EL        (real)    Length of quadrupole.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer itrack,ktrack
      double precision beti,d,el,pt,px,py,track,ttt
      dimension         track(6,*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer
      double precision one, two
      parameter (one = 1.d0, two = 2.d0)
      call ucopy(q(lcelm+melen), el, mwflt)
      beti = one / betas

      do 10 itrack = 1, ktrack
        px = track(2,itrack)
        py = track(4,itrack)
        pt = track(6,itrack)
        ttt = one/sqrt(one+two*pt*beti+pt**2 - px**2 - py**2)
        track(1,itrack) = track(1,itrack) + el*ttt*px
        track(3,itrack) = track(3,itrack) + el*ttt*py
        track(5,itrack) = track(5,itrack) 
     +  + el*(beti - (beti+pt)*ttt) + el * pt * dtbyds
   10 continue

      end
+dk ttelem
      subroutine ttelem(iturn, iorder, isup, ipos, sum,
     +                  track, number, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track through an element by TRANSPORT method (Switch routine).     *
* Output:                                                              *
*   ITURN     (integer) Turn number.                                   *
*   IORDER    (integer) Order for Lie algebraic tracking, unused.      *
*   ISUP      (integer) Superperiod number.                            *
*   IPOS      (integer) Position counter.                              *
* Input/output:                                                        *
*   SUM       (real)    Accumulated length.                            *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   NUMBER(*) (integer) Number of current track.                       *
*   KTRACK    (integer) number of surviving tracks.                    *
*----------------------------------------------------------------------*
* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Added LCAVITY element at ISP 27 ... calls routine TTLCAV           *
* Modified: 21-AUG-1999, T. Raubenheimer (SLAC)                        *
*   Added TTCSR to bend calculations                                   *
*----------------------------------------------------------------------*
+ca aparam
      integer iorder,ipos,isp,isup,iturn,nd,ktrack
      double precision el,one,parvec,sum,track,an2
      dimension         track(6,*)
      integer           number(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca codata
+ca mapelm
+ca option
+ca optic1
+ca refer
+ca stflag
+ca tmcomm
      dimension parvec(mbbparam)
      parameter         (nd = 8 * mwflt)
      parameter         (one = 1.0d0)

      integer i,j
      logical           fsec, ftrk, fmap
      double precision ang, f_csr
      fsec = .true.
      ftrk = dorad  .and.  .not. dodamp
      isp = iq(lcelm+mbsp)
      el = 0.0
*-- switch on element type
      go to ( 10,  20,  30,  40,  50,  60,  70,  80,  90, 100,
     +       110, 120, 130, 140, 150, 160, 170, 180, 190, 200,
     +       210, 220, 230, 240, 250, 260, 270, 280, 290, 300,
     +       310, 310, 310, 310, 310, 310, 310, 310, 310, 310), isp

*---- Drift space, monitors, beam instrument.
   10 continue
  170 continue
  180 continue
  190 continue
  240 continue
        call ttdrf(el, track, ktrack)
      go to 500

*---- Bending magnet.
   20 continue
   30 continue
*---- Get length, angle, and CSR factor (parameters #2, #3, and #15).
        call ucopy(q(lcelm+melen+0*mcsiz), el, mwflt)
        call ucopy(q(lcelm+melen+1*mcsiz), ang, mwflt)
        call ucopy(q(lcelm+melen+13*mcsiz), f_csr, mwflt)
*--- HG001026: arc length to rectangular bend
        if (isp .eq. 2)  then
          an2  = ang / 2
          if (an2 .ne. 0.d0 .and. rbarc)  el = el * an2 / sin(an2)
        endif
        if (f_csr .ne. 0.0d0) then
          call ttcsr(f_csr/2, el, ang, track, ktrack)
        endif
        call ttbend(el, track, ktrack)
        if (f_csr .ne. 0.0d0) then
          call ttcsr(f_csr/2, el, ang, track, ktrack)
        endif
      go to 500

*---- Arbitrary matrix.
   40 continue
        call tmarb(fsec, ftrk, orbit, fmap, el, ek, re, te)
        call tttrak(ek, re, te, track, ktrack)
      go to 500

*---- Quadrupole.
   50 continue
        call ttquad(el, track, ktrack)
      go to 500

*---- Sextupole.
   60 continue
        call ttsext(el, track, ktrack)
      go to 500

*---- Octupole.
   70 continue
        call ttoct(el, track, ktrack)
      go to 500

*---- Multipole.
   80 continue
        call ttmult(track, ktrack)
      go to 500

*---- Solenoid.
   90 continue
        call ttsol(el, track, ktrack)
      go to 500

*---- RF cavity.
  100 continue
        call ttrf(el, track, ktrack)
      go to 500

*---- Electrostatic separator.
  110 continue
        call ttsep(el, track, ktrack)
      go to 500

*---- Rotation around s-axis.
  120 continue
        call ttsrot(track, ktrack)
      go to 500

*---- Rotation around y-axis.
  130 continue
        call ttyrot(track, ktrack)
      go to 500

*---- Correctors.
  140 continue
  150 continue
  160 continue
        call ttcorr(el, track, ktrack)
      go to 500

*---- Elliptic aperture.
  200 continue
        call trkill(1,iturn,isup,ipos,sum,el,track,number,ktrack)
      go to 500

*---- Rectangular aperture.
  210 continue
        call trkill(2,iturn,isup,ipos,sum,el,track,number,ktrack)
      go to 500

*---- Beam-beam.
  220 continue
      call ucopy(q(lcelm+mesigx), parvec(1), mwflt)
      if (parvec(1) .eq. 0.d0) parvec(1) = 1.d0
      call ucopy(q(lcelm+mesigy), parvec(2), mwflt)
      if (parvec(2) .eq. 0.d0) parvec(2) = 1.d0
      call ucopy(q(lcelm+mexma), parvec(3), mwflt)
      call ucopy(q(lcelm+meyma), parvec(4), mwflt)
      parvec(5) = arad
      call ucopy(q(lcelm+mechg), parvec(6), mwflt)
      parvec(6) = parvec(6) * charge * parnum
      parvec(7) = gammas
      parvec(8) = ex
      parvec(9) = ey
      j = mechg
      do i = 1, 17
        j = j + mcsiz
        call ucopy(q(lcelm+j), parvec(i+9), mwflt)
      enddo
      if (parvec(23) .eq. 0.d0) then
*--- standard 4D
        call ttbb(parvec, track, ktrack)
      else
*--- Hirata 6D
        call beamint(parvec, track, ktrack)
      endif
      go to 500

*---- Lump.
  230 continue
        call tmlump(fsec,.false.,orbit,fmap,el,ek,re,te)
        call tttrak(ek,re,te,track,ktrack)
      go to 500

*---- Marker.
  250 continue
      go to 500

*---- General bend (dipole, quadrupole, and skew quadrupole).
  260 continue
*---- Get length, angle, and CSR factor (parameters #2, #3, and #15).
        call ucopy(q(lcelm+melen+0*mcsiz), el, mwflt)
        call ucopy(q(lcelm+melen+1*mcsiz), ang, mwflt)
        call ucopy(q(lcelm+melen+13*mcsiz), f_csr, mwflt)
        if (f_csr .ne. 0.0d0) then
          call ttcsr(f_csr/2, el, ang, track, ktrack)
        endif
        call ttbend(el, track, ktrack)
        if (f_csr .ne. 0.0d0) then
          call ttcsr(f_csr/2, el, ang, track, ktrack)
        endif
      go to 500

*---- LCAV cavity.
  270 continue
        call ttlcav(el, track, ktrack)
      go to 500
*---- Reserved.
  280 continue
  290 continue
  300 continue
      go to 500

*---- User-defined elements.
  310 continue
        call tmuser(fsec, ftrk, one, orbit, fmap, el, ek, re, te)
        call tttrak(ek, re, te, track, ktrack)
      go to 500

*---- Accumulate length.
  500 continue
      sum = sum + el

      end
+dk ttlcav
      subroutine ttlcav(el, track, ktrack)
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track a set of trajectories through a thin accelerating structure  *
*   (zero length); the structure is sandwiched between two drift       *
*   spaces of half the structure length.                               *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) Number of surviving tracks.                    *
* Output:                                                              *
*   EL        (real)    Length of structure.                           *
*----------------------------------------------------------------------*
* Created:  06-JAN-1999, T. Raubenheimer (SLAC)                        *
*   Routine copied and modified from TTRF; modified to allow wakefield *
*   tracking -- use error attributes; note ELOSS is NOT subtracted     *
*   from average energy gain if wakefields are set                     *
* Modified: 21-SEP-1999, M. Woodley (SLAC)                             *
*   Convert to standard MAD units (electric voltage in MV, frequency   *
*   in MHz, phase angles in multiples of 2pi); ELOSS attribute units   *
*   are V/C; use DODEFL flag to turn on/off edge focusing              *
*----------------------------------------------------------------------*

      implicit none
      integer ktrack
      double precision el, track(6,*)
      integer nbin, lstr, itrack
      double precision deltae, phi0, freq, eloss, volt_err, alag_err,
     +binmax, el1, vrf, omega, phirf, etas, bi2gi2, denergy, dl, px,
     +py, pt, etmp, ttt, beti
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer
+ca option
+ca optic1
+ca message
+ca physicpm
+ca pi
      double precision twopi,ten3m,ten3p,ten6m,ten6p,zero,half,
     +one,two,three
      parameter         (twopi = 2.0d0 * pi)
      parameter         (ten3m = 1.0d-3, ten3p = 1.0d+3)
      parameter         (ten6m = 1.0d-6, ten6p = 1.0d+6)
      parameter         (zero = 0.0d0, half = 0.5d0)
      parameter         (one = 1.0d0, two = 2.0d0, three = 3.0d0)

      logical           error, lwake
      character*80      lfile, tfile

      logical           dodefl
      data              dodefl /.true./
*---------+---------+---------+---------+---------+---------+---------++
*---- Fetch data from pool.
      call ucopy(q(lcelm+melen), el, mwflt)
      call ucopy(q(lcelm+melen+2*mcsiz), deltae, mwflt)
      call ucopy(q(lcelm+melen+3*mcsiz), phi0, mwflt)
      call ucopy(q(lcelm+melen+4*mcsiz), freq, mwflt)

*---- Get energy loss if it was set - otherwise it is zero.
      call ucopy(q(lcelm+melen+5*mcsiz), eloss, mwflt)
      eloss = (ten6m * eloss) * (qelect * parnum)

*---- Get errors (parameters #8 and #9).
      call ucopy(q(lcelm+melen+6*mcsiz), volt_err, mwflt)
      call ucopy(q(lcelm+melen+7*mcsiz), alag_err, mwflt)

*---- Get wakefield codes (parameters #11 and #12).
      nbin = iq(lcelm+melen+9*mcsiz)
      call ucopy(q(lcelm+melen+10*mcsiz), binmax, mwflt)

*---- Get the longitudinal wakefield filename (parameter #13).
      if (iq(lcelm+melen+11*mcsiz-2) .eq. 61) then
        lstr = iq(lcelm+melen+11*mcsiz)
        call uhtoc(iq(lq(lcelm-13)+1), mcwrd, lfile, 80)
      else
        lfile = " "
      endif

*---- Get the transverse wakefield filename (parameter #14).
      if (iq(lcelm+melen+12*mcsiz-2) .eq. 61) then
        lstr = iq(lcelm+melen+12*mcsiz)
        call uhtoc(iq(lq(lcelm-14)+1), mcwrd, tfile, 80)
      else
        tfile = " "
      endif

*---- If there are wakefields split the structure.
      if (lfile .ne. " " .or. tfile .ne. " ") then
        el1 = el / two
        deltae = deltae / two
        volt_err = volt_err / two
        eloss = eloss / two
        lwake = .true.
      else
        el1 = el
        lwake = .false.
      endif

*---- Set up.
*--- vrf, volt_err, eloss GeV
      vrf = ten3m * deltae
      volt_err = ten3m * volt_err
      eloss = ten3m * eloss
*--- omega radians/m
      omega = twopi * (ten6p * freq) / clight
*--- phirf, alag_err radians
      phirf = twopi * phi0
      alag_err = twopi * alag_err

*--- HG001121 start
      error = .false.
      if (ereset) then
*---- If incoming energy is not set, default it to 1 GeV ... warn user
*     later.
        if (ener1 .eq. zero) then
          ener1 = pc
          error = .true.
        endif
        if (ener1 .eq. zero) then
          ener1 = one
        endif

*---- Update relativistic terms at entrance to structure.
        en0 = ener1
      else
        ener1 = en0
      endif
*--- HG001121 end
*---- Update relativistic terms at entrance to structure.
      pc = sqrt(abs(en0**2 - amass**2))
      gamma = en0 / amass
      beta = pc / en0
      etas   = beta * gamma * (one + deltas)
      gammas = sqrt(one + etas**2)
      betas  = etas / gammas
      bi2gi2 = one / etas ** 2
      dtbyds = deltas * etas / betas
      beti = one / betas

*---- Change to the centroid energy value.
*     (NOTE: phase is referenced to the crest, NOT the zero crossing!)
      denergy = vrf * cos(phirf) - eloss ! gev

*---- Use EL1 rather than EL for the length.
      dl = el1 * half
      if (lwake) eloss = zero

*---- Loop for all particles.
      do 10 itrack = 1, ktrack

*---- Set up.
        px = track(2,itrack)
        py = track(4,itrack)
        pt = track(6,itrack)

*---- Thin quad to represent focusing at structure entrance.
        if (dodefl) then
          px = px - denergy / el1 / two / ener1 * track(1,itrack)
          py = py - denergy / el1 / two / ener1 * track(3,itrack)
        endif

*---- Drift to centre.
        ttt = one/sqrt(one+two*pt*beti+pt**2 - px**2 - py**2)
        track(1,itrack) = track(1,itrack) + dl*ttt*px
        track(3,itrack) = track(3,itrack) + dl*ttt*py
        track(5,itrack) = track(5,itrack) 
     +  + dl*(beti - (beti+pt)*ttt) + dl*pt*dtbyds

*---- Acceleration.
*     (NOTE: phase is referenced to the crest, NOT the zero crossing!)
        etmp = ener1 + denergy
        pt = pt + ((vrf + volt_err)
     +     * cos(phirf + alag_err - omega * track(5,itrack))
     +     - eloss - denergy) / (etmp * (one+deltas))
        px = px * ener1 / etmp
        py = py * ener1 / etmp
        pt = pt * ener1 / etmp

*---- Update relativistic terms at centre of structure.
      pc = sqrt(abs(etmp**2 - amass**2))
      gamma = etmp / amass
      beta = pc / etmp
      etas   = beta * gamma * (one + deltas)
      gammas = sqrt(one + etas**2)
      betas  = etas / gammas
      bi2gi2 = one / etas ** 2
      dtbyds = deltas * etas / betas
      beti = one / betas

*---- Drift to end.
        ttt = one/sqrt(one+two*pt*beti+pt**2 - px**2 - py**2)
        track(1,itrack) = track(1,itrack) + dl*ttt*px
        track(3,itrack) = track(3,itrack) + dl*ttt*py
        track(5,itrack) = track(5,itrack) 
     +  + dl*(beti - (beti+pt)*ttt) + dl*pt*dtbyds

*---- Thin quad to represent focusing at structure exit.
        if (dodefl) then
          px = px + denergy / el1 / two / (ener1 + denergy)
     +       * track(1,itrack)
          py = py + denergy / el1 / two / (ener1 + denergy)
     +       * track(3,itrack)
        endif

        track(2,itrack) = px
        track(4,itrack) = py
        track(6,itrack) = pt
   10 continue

*---- Energy change
      ener1 = ener1 + denergy

*---- If there were wakefields, track the wakes and then the 2nd half
*     of the structure.
      if (lwake) then
        call ttwake(two*el1, nbin, binmax, lfile, tfile, ener1, track,
     +              ktrack)

*---- Track 2nd half of structure -- loop for all particles.
        do 20 itrack = 1, ktrack

*---- Set up.
          px = track(2,itrack)
          py = track(4,itrack)
          pt = track(6,itrack)

*---- Thin quad to represent focusing at structure entrance.
          if (dodefl) then
            px = px - denergy / el1 / two / ener1 * track(1,itrack)
            py = py - denergy / el1 / two / ener1 * track(3,itrack)
          endif

*---- Drift to centre.
          beti = one / betas
          ttt = one/sqrt(one+two*pt*beti+pt**2 - px**2 - py**2)
          track(1,itrack) = track(1,itrack) + dl*ttt*px
          track(3,itrack) = track(3,itrack) + dl*ttt*py
          track(5,itrack) = track(5,itrack) 
     +    + dl*(beti - (beti+pt)*ttt) + dl*pt*dtbyds

*---- Acceleration.
*     (NOTE: phase is referenced to the crest, NOT the zero crossing!)
          pt = pt + ((vrf + volt_err)
     +       * cos(phirf + alag_err - omega * track(5,itrack))
     +       - eloss - denergy) / (ener1 + denergy) / (one+deltas)
          px = px * ener1 / (ener1 + denergy)
          py = py * ener1 / (ener1 + denergy)
          pt = pt * ener1 / (ener1 + denergy)

*---- Drift to end.
          beti = one / betas
          ttt = one/sqrt(one+two*pt*beti+pt**2 - px**2 - py**2)
          track(1,itrack) = track(1,itrack) + dl*ttt*px
          track(3,itrack) = track(3,itrack) + dl*ttt*py
          track(5,itrack) = track(5,itrack) 
     +    + dl*(beti - (beti+pt)*ttt) + dl*pt*dtbyds

*---- Thin quad to represent focusing at structure exit.
          if (dodefl) then
            px = px + denergy / el1 / two / (ener1 + denergy)
     +         * track(1,itrack)
            py = py + denergy / el1 / two / (ener1 + denergy)
     +         * track(3,itrack)
          endif

          track(2,itrack) = px
          track(4,itrack) = py
          track(6,itrack) = pt
   20   continue

*---- Energy change.
        ener1 = ener1 + denergy
      endif

*---- Update relativistic terms at exit of structure.
      en0 = ener1
      pc = sqrt(abs(en0**2 - amass**2))
      gamma = en0 / amass
      beta = pc / en0
      etas   = beta * gamma * (one + deltas)
      gammas = sqrt(one + etas**2)
      betas  = etas / gammas

*---- warn user if energy value had to be defaulted.
      if (error) then
         write (msg(1), 900) ener1 - denergy
         call aawarn ('ttlcav', 1, msg)
      endif

  900 format ('Set the initial energy value to: ',1p,g12.5)

      end
+dk ttmult
      subroutine ttmult(track, ktrack)
*----------------------------------------------------------------------*
* Purpose:                                                             *
*    Track particle through a general thin multipole.                  *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) Number of surviving tracks.                    *
* Output:                                                              *
*   EL        (real)    Length of quadrupole.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer id,ilink,iord,itrk,jtrk,lmap,ltrk,mbatch,nd,ndord,neord,
     +nord,ktrack,i,j
      double precision ang,beti,beti2,const,curv,dbi,dbr,dipi,dipr,dx,
     +dxt,dy,dyt,elrad,ez,fact,fz,half,one,ordinv,pt,px,py,rfac,
     +rpt1,rpt2,rpx1,rpx2,rpy1,rpy2,three,track,two,val
      dimension         track(6,*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer
+ca stflag
+ca tmcomm
+ca physicpm
+ca maxmul
      parameter         (one = 1.0d0, half = 0.5d0)
      parameter         (two = 2.0d0, three = 3.0d0)

      dimension         fz(2,0:maxmul), ez(2,0:maxmul), ordinv(maxmul)
      logical           first
      save              first, ordinv

      integer bvpos
      parameter         (bvpos = 24)
      logical bvflag
      parameter         (mbatch = 640)
      dimension         dxt(mbatch), dyt(mbatch)
      integer           ival(2), iang(2), iel(2)
      equivalence       (val,   ival(1)), (ang,  iang(1))
      equivalence       (elrad, iel(1))

      data first        / .true. /

*---- Clear field array.
      do 10 iord = 0, maxmul
        fz(1,iord) = 0.0
        fz(2,iord) = 0.0
   10 continue

*---- Precompute reciprocals of orders.
      if (first) then
        do 20 iord = 1, maxmul
          ordinv(iord) = one / float(iord)
   20   continue
        first = .false.
      endif

*---- Build and store multipole transfer map.
      ilink = iq(lcelm+mbat) + mbemap
      lmap = lq(lcelm-ilink)
      if (lmap .eq. 0) then
        ndord = min((iq(lcelm+mbat) - 4) / 2, maxmul)
        id = mbat + 2 * mcsiz
        nord = 0
        do 30 iord = 0, ndord
          ival(1) = iq(lcelm+id+mcval)
          ival(2) = iq(lcelm+id+mcval+1)
          iang(1) = iq(lcelm+id+mcsiz+mcval)
          iang(2) = iq(lcelm+id+mcsiz+mcval+1)
          ang = ang * float(iord+1)
          fz(1,iord) = val * cos(ang)
          fz(2,iord) = val * sin(ang)
          if (fz(1,iord).ne.0.0 .or. fz(2,iord).ne.0.0) nord = iord
          id = id + 2 * mcsiz
   30   continue
        call utglog(lcelm, bvpos, bvpos, bvflag)
*--- HG000915 use bv flag to possibly invert angle
        if (bvflag) then
          fz(1,0) = beambv * fz(1,0)
          fz(2,0) = beambv * fz(2,0)
        endif
*--- apply inversion and scaling
        do i = 1, nord
          do j = 1, 2
            fz(j,i) = fz(j,i) * elmfact(i)
          enddo
        enddo
*---- Store generated field coefficients.
        nd = 2 * mwflt * (nord + 1)
        call mzbook(2, lmap, lcelm, -ilink, 'MMAP', 0, 0, nd, mreal, 0)
        iq(lmap-5) = nord
        call ucopy(fz, q(lmap+1), nd)

*---- Fetch precomputed multipole transfer map.
      else
        nord = iq(lmap-5)
        nd = 2 * mwflt * (nord + 1)
        call ucopy(q(lmap+1), fz, nd)
      endif

*---- Nominal dipole strength.
      fact = one / (one + deltas)
      dipr = fz(1,0) * fact
      dipi = fz(2,0) * fact

*---- Extract field errors and add them to nominal strengths.
      if (lcfld .ne. 0) then
        neord = min(iq(lcfld-1) / (2 * mwflt) - 1, maxmul)
        nd = 2 * mwflt * (neord + 1)
        call ucopy(q(lcfld+1), ez, nd)

*---- Dipole error.
        dbr = (ez(1,0) - fz(1,0) * deltas) * fact
        dbi = (ez(2,0) - fz(2,0) * deltas) * fact

*---- Quadrupole and higher terms.
        do 40 iord = 1, neord
          fz(1,iord) = fz(1,iord) + ez(1,iord)
          fz(2,iord) = fz(2,iord) + ez(2,iord)
          if ((fz(1,iord).ne.0.0 .or. fz(2,iord).ne.0.0)  .and.
     +        iord .gt. nord) nord = iord
   40   continue
      else
        dbr = - fz(1,0) * deltas * fact
        dbi = - fz(2,0) * deltas * fact
      endif

*---- Fetch multipole length, used for radiation.
      iel(1) = iq(lcelm+melen)
      iel(2) = iq(lcelm+melen+1)

*---- Precompute some constants.
      beti = one / betas
      beti2 = half * beti

*==== Start tracking; Loop over batches of MBATCH particles each.
      do 200 itrk = 1, ktrack, mbatch
        ltrk = min(itrk+mbatch-1,ktrack)

*---- Pure dipole: no higher terms.
        if (nord .eq. 0) then
          do 50 jtrk = 1, ltrk - itrk + 1
            dxt(jtrk) = 0.0
            dyt(jtrk) = 0.0
   50     continue

*---- Accumulate multipole kick from highest multipole to quadrupole.
        else
          do 60 jtrk = itrk, ltrk
            dxt(jtrk-itrk+1) =
     +        fz(1,nord)*track(1,jtrk) - fz(2,nord)*track(3,jtrk)
            dyt(jtrk-itrk+1) =
     +        fz(1,nord)*track(3,jtrk) + fz(2,nord)*track(1,jtrk)
   60     continue

          do 80 iord = nord - 1, 1, -1
            do 70 jtrk = itrk, ltrk
              dx = dxt(jtrk-itrk+1)*ordinv(iord+1) + fz(1,iord)
              dy = dyt(jtrk-itrk+1)*ordinv(iord+1) + fz(2,iord)
              dxt(jtrk-itrk+1) = dx*track(1,jtrk) - dy*track(3,jtrk)
              dyt(jtrk-itrk+1) = dx*track(3,jtrk) + dy*track(1,jtrk)
   70       continue
   80     continue
          do 85 jtrk = itrk, ltrk
            dxt(jtrk-itrk+1) = fact * dxt(jtrk-itrk+1)
            dyt(jtrk-itrk+1) = fact * dyt(jtrk-itrk+1)
   85     continue
        endif

*---- Radiation loss at entrance.
        if (dorad .and. elrad .ne. 0.0) then
          const = arad * gammas**3 / three

*---- Full damping.
          if (dodamp) then
            do 110 jtrk = itrk, ltrk
              curv = sqrt((dipr + dxt(jtrk-itrk+1))**2 +
     +                    (dipi + dyt(jtrk-itrk+1))**2) / elrad

              if (dorand) then
                call trphot(elrad, curv, rfac)
              else
                rfac = const * curv**2 * elrad
              endif

              px = track(2,jtrk)
              py = track(4,jtrk)
              pt = track(6,jtrk)
              track(2,jtrk) = px - rfac * (one + pt) * px
              track(4,jtrk) = py - rfac * (one + pt) * py
              track(6,jtrk) = pt - rfac * (one + pt) ** 2
  110       continue

*---- Energy loss like for closed orbit.
          else

*---- Store energy loss on closed orbit.
            if (itrk .eq. 1) then
              rfac = const * ((dipr + dxt(1))**2 + (dipi + dyt(1))**2)
              rpx1 = rfac * (one + track(6,1)) * track(2,1)
              rpy1 = rfac * (one + track(6,1)) * track(4,1)
              rpt1 = rfac * (one + track(6,1)) ** 2
            endif

            do 120 jtrk = itrk, ltrk
              track(2,jtrk) = track(2,jtrk) - rpx1
              track(4,jtrk) = track(4,jtrk) - rpy1
              track(6,jtrk) = track(6,jtrk) - rpt1
  120       continue
          endif
        endif

*---- Apply multipole effect including dipole.
        do 140 jtrk = itrk, ltrk
          track(2,jtrk) = track(2,jtrk) -
     +      (dbr + dxt(jtrk-itrk+1) - track(6,jtrk)*beti*dipr)
          track(4,jtrk) = track(4,jtrk) +
     +      (dbi + dyt(jtrk-itrk+1) - track(6,jtrk)*beti*dipi)
          track(5,jtrk) = track(5,jtrk)
     +      - (dipr*track(1,jtrk) - dipi*track(3,jtrk)) * beti
  140   continue

*---- Radiation loss at exit.
        if (dorad .and. elrad .ne. 0.0) then

*---- Full damping.
          if (dodamp) then
            do 150 jtrk = itrk, ltrk
              curv = sqrt((dipr + dxt(jtrk-itrk+1))**2 +
     +                    (dipi + dyt(jtrk-itrk+1))**2) / elrad

              if (dorand) then
                call trphot(elrad, curv, rfac)
              else
                rfac = const * curv**2 * elrad
              endif

              px = track(2,jtrk)
              py = track(4,jtrk)
              pt = track(6,jtrk)
              track(2,jtrk) = px - rfac * (one + pt) * px
              track(4,jtrk) = py - rfac * (one + pt) * py
              track(6,jtrk) = pt - rfac * (one + pt) ** 2
  150       continue

*---- Energy loss like for closed orbit.
          else

*---- Store energy loss on closed orbit.
            if (itrk .eq. 1) then
              rfac = const * ((dipr + dxt(1))**2 + (dipi + dyt(1))**2)
              rpx2 = rfac * (one + track(6,1)) * track(2,1)
              rpy2 = rfac * (one + track(6,1)) * track(4,1)
              rpt2 = rfac * (one + track(6,1)) ** 2
            endif

            do 160 jtrk = itrk, ltrk
              track(2,jtrk) = track(2,jtrk) - rpx2
              track(4,jtrk) = track(4,jtrk) - rpy2
              track(6,jtrk) = track(6,jtrk) - rpt2
  160       continue
          endif
        endif
  200 continue

      end
+dk ttoct
      subroutine ttoct(el, track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track a set of particles through an octupole.                      *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) number of surviving tracks.                    *
* Output:                                                              *
*   EL        (real)    Length of quadrupole.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer itrack,ktrack
      double precision ci,const,cr,curv,curv2,dsk3,el,four,octi,octr,
     +one,posi,posr,pt,px,py,rfac,rpt,rpx,rpy,six,sk3,sk3l,three,tilt,
     +tilt4,track,two
      dimension         track(6,*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer
+ca stflag
+ca tmcomm

      parameter         (one    = 1.0d0)
      parameter         (two    = 2.0d0, three  = 3.0d0)
      parameter         (four   = 4.0d0, six    = 6.0d0)

*---- Fetch data from pool.
      call ucopy(q(lcelm+melen), el, mwflt)
      if (el .ne. 0.0) then

*---- Set up octupole strength.
        call ucopy(q(lcelm+mek3o), sk3, mwflt)
        call ucopy(q(lcelm+metlts), tilt, mwflt)

*---- Field error.
        if (lcfld .ne. 0) then
          call ucopy(q(lcfld+6*mwflt+1), dsk3, mwflt)
          sk3l = (el * sk3 + dsk3) / (one + deltas)
        else
          sk3l = el * sk3 / (one + deltas)
        endif

*---- Normal and skew components of octupole.
        tilt4 = four * tilt
        octr = sk3l * cos(tilt4)
        octi = sk3l * sin(tilt4)

*---- Half radiation effects at entrance.
        if (dorad) then
          const = arad * gammas**3 / three

*---- Full damping.
          if (dodamp) then
            do 20 itrack = 1, ktrack
              curv = (sk3/six) *
     +          sqrt(track(1,itrack)**2 + track(3,itrack)**2)**3

              if (dorand) then
                call trphot(el, curv, rfac)
              else
                rfac = const * curv**2 * el
              endif

              px = track(2,itrack)
              py = track(4,itrack)
              pt = track(6,itrack)
              track(2,itrack) = px - rfac * (one + pt) * px
              track(4,itrack) = py - rfac * (one + pt) * py
              track(6,itrack) = pt - rfac * (one + pt) ** 2
  20        continue

*---- Energy loss like on closed orbit.
          else
            curv2 = (sk3/six)**2 * (track(1,1)**2+track(3,1)**2)**3
            rfac = const * curv2 * el
            rpx = rfac * (one + track(6,1)) * track(2,1)
            rpy = rfac * (one + track(6,1)) * track(4,1)
            rpt = rfac * (one + track(6,1)) ** 2

            do 30 itrack = 1, ktrack
              track(2,itrack) = track(2,itrack) - rpx
              track(4,itrack) = track(4,itrack) - rpy
              track(6,itrack) = track(6,itrack) - rpt
  30        continue
          endif
        endif

*---- Half kick at entrance.
        do 10 itrack = 1, ktrack
          posr = track(1,itrack) *
     +      (track(1,itrack)**2 - three*track(3,itrack)**2) / six
          posi = track(3,itrack) *
     +      (three*track(1,itrack)**2 - track(3,itrack)**2) / six
          cr = octr * posr - octi * posi
          ci = octr * posi + octi * posr
          track(2,itrack) = track(2,itrack) - cr / two
          track(4,itrack) = track(4,itrack) + ci * two
   10   continue

*---- Drift to exit.
        call ttdrf(el, track, ktrack)

*---- Half kick at exit.
        do 40 itrack = 1, ktrack
          posr = track(1,itrack) *
     +      (track(1,itrack)**2 - three*track(3,itrack)**2) / six
          posi = track(3,itrack) *
     +      (three*track(1,itrack)**2 - track(3,itrack)**2) / six
          cr = octr * posr - octi * posi
          ci = octr * posi + octi * posr
          track(2,itrack) = track(2,itrack) - cr / two
          track(4,itrack) = track(4,itrack) + ci / two
  40    continue

*---- Half radiation effects.
        if (dorad) then

*---- Full damping.
          if (dodamp) then
            do 50 itrack = 1, ktrack
              curv = (sk3/six) *
     +          sqrt(track(1,itrack)**2 + track(3,itrack)**2)**3

              if (dorand) then
                call trphot(el, curv, rfac)
              else
                rfac = const * curv**2 * el
              endif

              px = track(2,itrack)
              py = track(4,itrack)
              pt = track(6,itrack)
              track(2,itrack) = px - rfac * (one + pt) * px
              track(4,itrack) = py - rfac * (one + pt) * py
              track(6,itrack) = pt - rfac * (one + pt) ** 2
   50       continue

*---- Energy loss like on closed orbit.
          else
            curv2 = (sk3/six)**2 * (track(1,1)**2+track(3,1)**2)**3
            rfac = const * curv2 * el
            rpx = rfac * (one + track(6,1)) * track(2,1)
            rpy = rfac * (one + track(6,1)) * track(4,1)
            rpt = rfac * (one + track(6,1)) ** 2

            do 60 itrack = 1, ktrack
              track(2,itrack) = track(2,itrack) - rpx
              track(4,itrack) = track(4,itrack) - rpy
              track(6,itrack) = track(6,itrack) - rpt
   60       continue
          endif
        endif
      endif

      end
+dk ttquad
      subroutine ttquad(el, track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track a set of particles through a quadrupole.                     *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) number of surviving tracks.                    *
* Output:                                                              *
*   EL        (real)    Length of quadrupole.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer itrack,ktrack
      double precision const,curv,curv2,cx,cy,dsk1,el,four,one,pt0,px0,
     +px1,py0,py1,qk,qkl,qkl2,rfac,rpt,rpx,rpy,sk1,sx,sy,t0,t1,three,
     +tilt,track,two,x0,x1,y0,y1,zero
      dimension         track(6,*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca mapelm
+ca refer
+ca stflag
+ca tmcomm

      parameter         (zero   = 0.0d0, one    = 1.0d0)
      parameter         (two    = 2.0d0, three  = 3.0d0)
      parameter         (four   = 4.0d0)

*---- Fetch data from pool.
      call ucopy(q(lcelm+melen), el, mwflt)
      if (el .ne. zero) then

*---- Field.
        call ucopy(q(lcelm+mek1q), sk1, mwflt)
        if (lcfld .ne. 0) then
          call ucopy(q(lcfld+2*mwflt+1), dsk1, mwflt)
          sk1 = (sk1 + dsk1 / el) / (one + deltas)
        else
          sk1 = sk1 / (one + deltas)
        endif

*---- Tilt at entrance.
        call ucopy(q(lcelm+metltq), tilt, mwflt)
        if (tilt .ne. 0.0) call tttilt(tilt, track, ktrack)

*---- Half radiation effect at exit.
        if (dorad) then
          const = arad * gammas**3 / three

*---- Full damping.
          if (dodamp) then
            do 10 itrack = 1, ktrack
              curv = sk1 * sqrt(track(1,itrack)**2 + track(3,itrack)**2)

              if (dorand) then
                call trphot(el, curv, rfac)
              else
                rfac = const * curv**2 * el
              endif

              track(2,itrack) = track(2,itrack) -
     +          rfac * (one + track(6,itrack)) * track(2,itrack)
              track(4,itrack) = track(4,itrack) -
     +          rfac * (one + track(6,itrack)) * track(4,itrack)
              track(6,itrack) = track(6,itrack) -
     +          rfac * (one + track(6,itrack))**2
   10       continue

*---- Energy loss like on closed orbit.
          else
            curv2 = sk1**2 * (track(1,1)**2 + track(3,1)**2)
            rfac = const * curv2 * el
            rpx = rfac * (one + track(6,1)) * track(2,1)
            rpy = rfac * (one + track(6,1)) * track(4,1)
            rpt = rfac * (one + track(6,1)) ** 2

            do 20 itrack = 1, ktrack
              track(2,itrack) = track(2,itrack) - rpx
              track(4,itrack) = track(4,itrack) - rpy
              track(6,itrack) = track(6,itrack) - rpt
   20       continue
          endif
        endif

*---- Compute transfer map.
        qk = sqrt(abs(sk1))
        qkl = qk * el

        if (abs(qkl) .lt. 1.0e-3) then
          qkl2 = sk1 * el**2
          cx = (1.0 - qkl2 / 2.0)
          sx = (1.0 - qkl2 / 6.0) * el
          cy = (1.0 + qkl2 / 2.0)
          sy = (1.0 + qkl2 / 6.0) * el
        else if (sk1 .gt. 0.0) then
          cx = cos(qkl)
          sx = sin(qkl) / qk
          cy = cosh(qkl)
          sy = sinh(qkl) / qk
        else
          cx = cosh(qkl)
          sx = sinh(qkl) / qk
          cy = cos(qkl)
          sy = sin(qkl) / qk
        endif

*---- Track through magnet.
        do 30 itrack = 1, ktrack
          x0  = track(1,itrack)
          px0 = track(2,itrack)
          y0  = track(3,itrack)
          py0 = track(4,itrack)
          t0  = track(5,itrack)
          pt0 = track(6,itrack)

*---- Linear part of map.
          x1  =          cx * x0 + sx * px0
          px1 =  - sk1 * sx * x0 + cx * px0
          y1  =          cy * y0 + sy * py0
          py1 =  + sk1 * sy * y0 + cy * py0

          t1 = t0
     +       + pt0*el/(betas*gammas)**2*(one-(three/two)*pt0/betas)
     +       + el*pt0*dtbyds

*---- Quadratic part of map.
          track(1,itrack) = x1 - (el*px1 + sx*px0)*(pt0/(two*betas))
          track(3,itrack) = y1 - (el*py1 + sy*py0)*(pt0/(two*betas))
          track(2,itrack) = px1 + sk1*(el*x1 - sx*x0)*(pt0/(two*betas))
          track(4,itrack) = py1 - sk1*(el*y1 - sy*y0)*(pt0/(two*betas))
          track(5,itrack) = t1 + (x0*px0 - x1*px1 + y0*py0 - y1*py1 -
     +      el*(px0**2 + py0**2 + sk1*(x0**2 - y0**2))) / (four*betas)
   30   continue

*---- Full damping.
        if (dorad) then

*---- Full damping.
          if (dodamp) then
            do 40 itrack = 1, ktrack
              curv = sk1 * sqrt(track(1,itrack)**2 + track(3,itrack)**2)

              if (dorand) then
                call trphot(el, curv, rfac)
              else
                rfac = const * curv**2 * el
              endif

              track(2,itrack) = track(2,itrack) -
     +          rfac * (one + track(6,itrack)) * track(2,itrack)
              track(4,itrack) = track(4,itrack) -
     +          rfac * (one + track(6,itrack)) * track(4,itrack)
              track(6,itrack) = track(6,itrack) -
     +          rfac * (one + track(6,itrack))**2
   40       continue

*---- Energy loss like on closed orbit.
          else
            curv2 = sk1**2 * (track(1,1)**2 + track(3,1)**2)
            rfac = const * curv2 * el
            rpx = rfac * (one + track(6,1)) * track(2,1)
            rpy = rfac * (one + track(6,1)) * track(4,1)
            rpt = rfac * (one + track(6,1)) ** 2

            do 50 itrack = 1, ktrack
              track(2,itrack) = track(2,itrack) - rpx
              track(4,itrack) = track(4,itrack) - rpy
              track(6,itrack) = track(6,itrack) - rpt
   50       continue
          endif
        endif

*---- Tilt at exit.
        if (tilt .ne. 0.0) call tttilt(- tilt, track, ktrack)
      endif

      end
+dk ttrf
      subroutine ttrf(el, track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track a set of trajectories through a thin cavity (zero length).   *
*   The cavity is sandwiched between two drift spaces of half length.  *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) number of surviving tracks.                    *
* Output:                                                              *
*   EL        (real)    Length of quadrupole.                          *
*----------------------------------------------------------------------*
* Modified: 06-JAN-1999, T. Raubenheimer (SLAC)                        *
*   Modified to allow wakefield tracking however no modification to    *
*   the logic and the nominal energy is not updated -- see routine     *
*   TTLCAV to change the nominal energy                                *
*----------------------------------------------------------------------*
+ca aparam
      integer itrack,ktrack
      double precision bi2gi2,dl,el,half,omega,one,phirf,pt,px,py,rff,
     +rfl,rfv,ten3m,ten6p,track,two,twopi,vrf,beti,ttt
      dimension         track(6,*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca optic1
+ca refer
+ca physicpm

+ca pi
      parameter         (twopi = 2.0d0 * pi)
      parameter         (ten3m = 1.0d-3)
      parameter         (ten6p = 1.0d+6)
      parameter         (half  = 0.5d0, one = 1.0d0, two = 2.0d0)

      integer           lstr, nbin
      double precision  el1, binmax
      logical           lwake
      character*80      lfile, tfile

*---- Fetch data from pool.
      call ucopy(q(lcelm+melen), el, mwflt)
      call ucopy(q(lcelm+mevltc), rfv, mwflt)
      call ucopy(q(lcelm+mefrqc), rff, mwflt)
      call ucopy(q(lcelm+melagc), rfl, mwflt)

*---- Get the longitudinal wakefield filename (parameter #17).
      if (iq(lcelm+melen+15*mcsiz-2) .eq. 61) then
        lstr = iq(lcelm+melen+15*mcsiz)
        call uhtoc(iq(lq(lcelm-17)+1), mcwrd, lfile, 80)
      else
        lfile = " "
      endif

*---- Get the transverse wakefield filename (parameter #18).
      if (iq(lcelm+melen+16*mcsiz-2) .eq. 61) then
        lstr = iq(lcelm+melen+16*mcsiz)
        call uhtoc(iq(lq(lcelm-18)+1), mcwrd, tfile, 80)
      else
        tfile = " "
      endif

*---- If there are wakefields split the cavity.
      if (lfile .ne. " " .or. tfile .ne. " ") then
        el1 = el / two
        rfv = rfv / two
        lwake = .true.
      else
        el1 = el
        lwake = .false.
      endif
*---- Set up.
      omega = rff * (ten6p * twopi / clight)
      vrf   = rfv * ten3m / (pc * (one + deltas))
      phirf = rfl * twopi
      dl    = el * half
      bi2gi2 = one / (betas * gammas) ** 2

*---- Use EL1 rather than EL for the length.
      dl = el1 * half
      beti = one / betas
*---- Loop for all particles.
      do 10 itrack = 1, ktrack

*---- Drift to centre.
        px = track(2,itrack)
        py = track(4,itrack)
        pt = track(6,itrack)
        ttt = one/sqrt(one+two*pt*beti+pt**2 - px**2 - py**2)
        track(1,itrack) = track(1,itrack) + dl*ttt*px
        track(3,itrack) = track(3,itrack) + dl*ttt*py
        track(5,itrack) = track(5,itrack) 
     +  + dl*(beti - (beti+pt)*ttt) + dl*pt*dtbyds

*---- Acceleration.
        pt = pt + vrf * sin(phirf - omega * track(5,itrack))
        track(6,itrack) = pt

*---- Drift to end.
        ttt = one/sqrt(one+two*pt*beti+pt**2 - px**2 - py**2)
        track(1,itrack) = track(1,itrack) + dl*ttt*px
        track(3,itrack) = track(3,itrack) + dl*ttt*py
        track(5,itrack) = track(5,itrack) 
     +  + dl*(beti - (beti+pt)*ttt) + dl*pt*dtbyds
   10 continue

*---- If there were wakefields, track the wakes and then the 2nd half
*     of the cavity.
      if (lwake) then
        call ttwake(two*el1, nbin, binmax, lfile, tfile, ener1, track,
     +              ktrack)

*---- Track 2nd half of cavity -- loop for all particles.
        do 20 itrack = 1, ktrack

*---- Drift to centre.
          px = track(2,itrack)
          py = track(4,itrack)
          pt = track(6,itrack)
          ttt = one/sqrt(one+two*pt*beti+pt**2 - px**2 - py**2)
          track(1,itrack) = track(1,itrack) + dl*ttt*px
          track(3,itrack) = track(3,itrack) + dl*ttt*py
          track(5,itrack) = track(5,itrack) 
     +    + dl*(beti - (beti+pt)*ttt) + dl*pt*dtbyds

*---- Acceleration.
          pt = pt + vrf * sin(phirf - omega * track(5,itrack))
          track(6,itrack) = pt

*---- Drift to end.
          ttt = one/sqrt(one+two*pt*beti+pt**2 - px**2 - py**2)
          track(1,itrack) = track(1,itrack) + dl*ttt*px
          track(3,itrack) = track(3,itrack) + dl*ttt*py
          track(5,itrack) = track(5,itrack) 
     +    + dl*(beti - (beti+pt)*ttt) + dl*pt*dtbyds
   20   continue
      endif
      end
+dk ttsep
      subroutine ttsep(el, track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track a set of trajectories through a separator.                   *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) number of surviving tracks.                    *
* Output:                                                              *
*   EL        (real)    Length of quadrupole.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer ktrack
      double precision by2,by24,by6,ch,dy,efield,ekick,ekl,el,eps,fact,
     +one,sh,sy,ten3m,three,tilt,track,two
      dimension         track(6,ktrack)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca mapelm
+ca refer
+ca stflag

      parameter         (one   = 1.0d0)
      parameter         (by2   = 1.0d0 /  2.0d0)
      parameter         (by6   = 1.0d0 /  6.0d0)
      parameter         (by24  = 1.0d0 / 24.0d0)
      parameter         (two   = 2.0d0)
      parameter         (three = 3.0d0)
      parameter         (eps   = 1.0d-4)
      parameter         (ten3m = 1.0d-3)

*---- Initialize.
      call uzero(ek, 1, 6*mwflt)
      call m66one(re)
      call uzero(te, 1, 216*mwflt)

*---- Fetch data from pool.
      call ucopy(q(lcelm+melen), el, mwflt)
      if (el .eq. 0.0) return

*---- Strength and tilt.
      call ucopy(q(lcelm+meflde), efield, mwflt)
      call ucopy(q(lcelm+metlte), tilt, mwflt)

*---- Prepare linear transformation parameters.
*     DY = (COSH(K*L) - 1) / K.
      ekick  = efield * ten3m * charge / (pc * (one + deltas))
      ekl = ekick * el
      if (abs(ekl) .gt. eps) then
        ch = cosh(ekl)
        sh = sinh(ekl)
        sy = sh / ekick
        dy = (ch - one) / ekick**2
      else
        ch = (one + by2  * ekl**2)
        sy = (one + by6  * ekl**2) * el
        sh = sy * ekick
        dy = (by2 + by24 * ekl**2) * el**2
      endif

*---- Kicks.
      ek(3) = dy * (ekick / betas)
      ek(4) = sy * (ekick / betas)
      ek(5) = el * dtbyds

*---- First-order terms.
      re(1,2) = el
      re(3,3) = ch - ekl * sh / betas**2
      re(3,4) = sy
      re(3,6) = (dy - el * sy / betas**2) * ekick
      re(4,3) = (sh - ekl * ch / betas**2) * ekick
      re(4,4) = ch
      re(4,6) = (sh - ekl * ch / betas**2)
      re(5,3) = - re(4,6)
      re(5,4) = - dy * ekick
      re(5,6) = - (sy - el * ch / betas**2)

*---- Second-order terms.
      fact = el / (two * betas)
      te(1,2,3) = - fact * ekick
      te(1,2,6) = - fact
      fact = el * (three*sh/gammas**2 + ekl*ch) / (two*betas**3)
      te(3,3,3) = fact * ekick**2
      te(3,3,6) = fact * ekick
      te(3,6,6) = fact
      fact = el * (three*ch/gammas**2 + ekl*sh) / (two*betas**3)
      te(4,3,3) = fact * ekick**3
      te(4,3,6) = fact * ekick**2
      te(4,6,6) = fact * ekick
      te(5,3,3) = - fact * ekick**2
      te(5,3,6) = - fact * ekick
      te(5,6,6) = - fact
      fact = el * sh / (two * betas)
      te(3,2,2) = fact
      te(3,4,4) = fact
      te(4,3,4) = - fact * ekick**2
      te(4,4,6) = - fact * ekick
      te(5,3,4) = fact * ekick
      te(5,4,6) = fact
      fact = el * ch / (two * betas)
      te(3,3,4) = - fact * ekick
      te(3,4,6) = - fact
      te(4,2,2) = fact * ekick
      te(4,4,4) = fact * ekick
      te(5,2,2) = - fact
      te(5,4,4) = - fact
      call tmsymm(te)

*---- Apply tilt.
      if (tilt .ne. 0.0) call tmtilt(.true., tilt, ek, re, te)

*---- Track orbit.
      call tttrak(ek, re, te, track, ktrack)

      end
+dk ttsext
      subroutine ttsext(el, track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*    Track a set of trajectories through a sextupole.                  *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) number of surviving tracks.                    *
* Output:                                                              *
*   EL        (real)    Length of quadrupole.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer itrack,ktrack
      double precision bi2gi2,const,curv,curv2,d,dsk2,dt,el,el1,el2,el3,
     +el4,four,one,pt,px,py,rfac,rpt,rpx,rpy,sk2,three,tilt,track,
     +twelve,two,x,y,zero
      dimension         track(6,*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer
+ca stflag

      parameter         (one    = 1.0d0, two    = 2.0d0)
      parameter         (three  = 3.0d0, four   = 4.0d0)
      parameter         (zero   = 0.0d0, twelve = 12.0d0)

*---- Fetch data from pool.
      call ucopy(q(lcelm+melen), el, mwflt)

*---- Field strength.
      call ucopy(q(lcelm+mek2s), sk2, mwflt)
      call ucopy(q(lcelm+metlts), tilt, mwflt)

*---- Field error.
      if (lcfld .ne. 0) then
        call ucopy(q(lcfld+4*mwflt+1), dsk2, mwflt)
        sk2 = (sk2 + dsk2 / el) / (one + deltas)
      else
        sk2 = sk2 / (one + deltas)
      endif
      sk2 = sk2 * elkfact(6)

*---- Rotation at entrance.
      if (tilt .ne. zero) call tttilt(tilt, track, ktrack)

*---- Half radiation effects at entrance.
      if (dorad) then
        const = arad * gammas**3 / three

*---- Full damping.
        if (dodamp) then
          do 10 itrack = 1, ktrack
            curv = (sk2/two) * (track(1,itrack)**2 + track(3,itrack)**2)

            if (dorand) then
              call trphot(el, curv, rfac)
            else
              rfac = const * curv**2 * el
            endif

            px = track(2,itrack)
            py = track(4,itrack)
            pt = track(6,itrack)
            track(2,itrack) = px - rfac * (one + pt) * px
            track(4,itrack) = py - rfac * (one + pt) * py
            track(6,itrack) = pt - rfac * (one + pt) ** 2
   10     continue

*---- Energy loss like on closed orbit.
        else
          curv2 = (sk2/two)**2 * (track(1,1)**2 + track(3,1)**2)**2
          rfac = const * curv2 * el
          rpx = rfac * (one + track(6,1)) * track(2,1)
          rpy = rfac * (one + track(6,1)) * track(4,1)
          rpt = rfac * (one + track(6,1)) ** 2

          do 20 itrack = 1, ktrack
            track(2,itrack) = track(2,itrack) - rpx
            track(4,itrack) = track(4,itrack) - rpy
            track(6,itrack) = track(6,itrack) - rpt
   20     continue
        endif
      endif

*---- Track trough magnet.
      el1 = sk2 * el
      el2 = el1 * el / two
      el3 = el2 * el / three
      el4 = el3 * el / four
      bi2gi2 = one / (betas * gammas) ** 2
      do 90 itrack = 1, ktrack
        x  = track(1,itrack)
        px = track(2,itrack)
        y  = track(3,itrack)
        py = track(4,itrack)
        dt = track(5,itrack)
        pt = track(6,itrack)
        d = el * (1.0 - pt / betas)
        track(1,itrack) = x + px * d
     +                - el2 * (x**2 - y**2) / two
     +                - el3 * (x*px - y*py)
     +                - el4 * (px**2 - py**2)
        track(2,itrack) = px
     +                - el1 * (x**2 - y**2) / two
     +                - el2 * (x*px - y*py)
     +                - el3 * (px**2 - py**2)
        track(3,itrack) = y + py * d
     +                + el2 * x * y
     +                + el3 * (x*py + y*px)
     +                + two * el4 * px * py
        track(4,itrack) = py
     +                + el1 * x * y
     +                + el2 * (x*py + y*px)
     +                + two * el3 * px * py
        track(5,itrack) = dt + bi2gi2*pt*d -
     +    el/betas*(px**2 + py**2 + bi2gi2*pt**2)/two + el*pt*dtbyds
   90 continue

*---- Half radiation effects at exit.
      if (dorad) then

*---- Full damping.
        if (dodamp) then
          do 30 itrack = 1, ktrack
            curv = (sk2/two) * (track(1,itrack)**2 + track(3,itrack)**2)

            if (dorand) then
              call trphot(el, curv, rfac)
            else
              rfac = const * curv**2 * el
            endif

            px = track(2,itrack)
            py = track(4,itrack)
            pt = track(6,itrack)
            track(2,itrack) = px - rfac * (one + pt) * px
            track(4,itrack) = py - rfac * (one + pt) * py
            track(6,itrack) = pt - rfac * (one + pt) ** 2
   30     continue

*---- Energy loss like on closed orbit.
        else
          curv2 = (sk2/two)**2 * (track(1,1)**2 + track(3,1)**2)**2
          rfac = const * curv2 * el
          rpx = rfac * (one + track(6,1)) * track(2,1)
          rpy = rfac * (one + track(6,1)) * track(4,1)
          rpt = rfac * (one + track(6,1)) ** 2

          do 40 itrack = 1, ktrack
            track(2,itrack) = track(2,itrack) - rpx
            track(4,itrack) = track(4,itrack) - rpy
            track(6,itrack) = track(6,itrack) - rpt
   40     continue
        endif
      endif

*---- Rotation at exit.
      if (tilt .ne. 0.0) call tttilt(- tilt, track, ktrack)

      end
+dk ttsol
      subroutine ttsol(el, track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track a set of particles through a solenoid.                       *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) number of surviving tracks.                    *
* Output:                                                              *
*   EL        (real)    Length of quadrupole.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer itrack,ktrack
      double precision bi2gi2,co,d,ek,ekl,el,one,pt,px,py,si,sidk,simk,
     +sks,ss,t,track,two,x,y
      dimension         track(6,*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer

      parameter         (one = 1.0d0, two = 2.0d0)

*---- Fetch data from pool.
      call ucopy(q(lcelm+melen), el, mwflt)
      call ucopy(q(lcelm+mekss), sks, mwflt)

*---- Track through magnet.
      ss = sks / (two * (one + deltas))
      bi2gi2 = one / (betas*gammas)**2
      do 10 itrack = 1, ktrack
        ek = ss / (1.0 + track(6,itrack))
        ekl = ek * el
        co = cos(ekl)
        si = sin(ekl)
        simk = si * ek
        if (abs(ekl) .lt. 1.0e-5) then
          sidk = (1.0 - ekl**2/6.0) * el
        else
          sidk = si / ek
        endif
        x  = co * track(1,itrack) + sidk * track(2,itrack)
        px = co * track(2,itrack) - simk * track(1,itrack)
        y  = co * track(3,itrack) + sidk * track(4,itrack)
        py = co * track(4,itrack) - simk * track(3,itrack)
        t  = track(5,itrack)
        pt = track(6,itrack)
        d  = el * (one - pt / betas)
        track(1,itrack) = co * x  + si * y
        track(2,itrack) = co * px + si * py
        track(3,itrack) = co * y  - si * x
        track(4,itrack) = co * py - si * px
        track(5,itrack) = t + bi2gi2*pt*d -
     +    el/betas*(px**2 + py**2 + bi2gi2*pt**2)/two + el*pt*dtbyds
   10 continue

      end
+dk ttsrot
      subroutine ttsrot(track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Change reference for a set of particles by S rotation.             *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) number of surviving tracks.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ktrack
      double precision tilt,track
      dimension         track(6,*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca refer

*---- Fetch angle from pool.
      call ucopy(q(lcelm+meangr), tilt, mwflt)
      call tttilt(tilt, track, ktrack)

      end
+dk tttilt
      subroutine tttilt(tilt, track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Change reference for a set of particles by S rotation.             *
* Input:                                                               *
*   TILT      (real)    Angle of rotation.                             *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) number of surviving tracks.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer itrack,ktrack
      double precision ct,st,temp,tilt,track
      dimension         track(6,*)

      ct = cos(tilt)
      st = sin(tilt)
      do 10 itrack = 1, ktrack
        temp = track(1,itrack)
        track(1,itrack) = + ct*temp + st*track(3,itrack)
        track(3,itrack) = - st*temp + ct*track(3,itrack)
        temp = track(2,itrack)
        track(2,itrack) = + ct*temp + st*track(4,itrack)
        track(4,itrack) = - st*temp + ct*track(4,itrack)
   10 continue

      end
+dk tttrak
      subroutine tttrak(ek, re, te, track, ktrack)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track a set of particle with a given TRANSPORT map.                *
* Input:                                                               *
*   EK(6)     (real)    Kick.                                          *
*   RE(6,6)   (real)    First-order terms.                             *
*   TE(6,6,6) (real)    Second-order terms.                            *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   KTRACK    (integer) number of surviving tracks.                    *
*----------------------------------------------------------------------*
+ca aparam
      integer i,itrack,ktrack
      double precision ek,re,se,te,temp,track
      dimension         ek(6), re(36), te(36,6), track(6,*)

      dimension         temp(6), se(36)

      do 60 itrack = 1, ktrack
        do 10 i = 1, 36
          se(i) = re(i)
     +      + te(i,1)*track(1,itrack) + te(i,2) * track(2,itrack)
     +      + te(i,3)*track(3,itrack) + te(i,4) * track(4,itrack)
     +      + te(i,5)*track(5,itrack) + te(i,6) * track(6,itrack)
   10   continue
        do 30 i = 1, 6
          temp(i) = ek(i)
     +      + se(i)    * track(1,itrack) + se(i+ 6) * track(2,itrack)
     +      + se(i+12) * track(3,itrack) + se(i+18) * track(4,itrack)
     +      + se(i+24) * track(5,itrack) + se(i+30) * track(6,itrack)
   30   continue
        do 50 i = 1, 6
          track(i,itrack) = temp(i)
   50   continue
   60 continue

      end
+dk ttwake
      subroutine ttwake(eleff, nbin, binmax, lfile, tfile, ener1, track,
     +                  ntrk)
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track wakefield effects.                                           *
* Input:                                                               *
*   ELEFF      (real)    Effective length of the structure.  If ELEFF  *
*                        is zero, the wakefield is assumed to be the   *
*                        integrated strength.                          *
*   NBIN       (integer) The number of bins to use.                    *
*   BINMAX     (real)    Maximum value for binning.                    *
*   LFILE      (string)  Longitudinal wakefield filename.  The         *
*                        wakefield consists of comment lines started   *
*                        with a "(" and data lines with Z in meters    *
*                        and WL in V/C/m.  It is  assumed that the Z   *
*                        values are monotonically increasing.          *
*   TFILE      (string)  Transverse wakelfield filename.               *
* Input/output:                                                        *
*   TRACK(6,*) (real)    Track coordinates: (X, PX, Y, PY, T, PT).     *
*   NTRK       (integer) Number of surviving tracks.                   *
*----------------------------------------------------------------------*
* Created:  06-JAN-1999, T. Raubenheimer (SLAC)                        *
*   Routine is based on that in Tor's private version but has updated  *
*   common block definitions; the wakefields are read on unit #51      *
*----------------------------------------------------------------------*

      implicit none
      integer nbin, ntrk
      double precision ener1, eleff, binmax, track(6,*)
+ca aparam
+ca beam
+ca trdata
+ca zunit
      integer lzmax, lrec, j, icount, nb, itrk, ib, irec
      double precision tzmax, el, dzbin, z, ch, wx, wy, dz, ww,
     +f, wl, zero, half, one, two, three
      parameter         (zero = 0.0d0, half = 0.5d0)
      parameter         (one = 1.0d0, two = 2.0d0, three = 3.0d0)

*---- Local data and parameters.
      double precision  lwake(0:2500,2), twake(0:2500,2)
      double precision  bins(-1000:1000,4)
      character*80      lfile, tfile, lold, told, buffer
      integer           trec
      save              lold, told, lrec, trec, lwake, twake
      data              lold /" "/, told /" "/
      data              lzmax / -1.d0 /, tzmax / -1.d0 /
      data              lwake(0,1) / -1.d0 /, lwake(0,2) / 0.d0 /
      data              twake(0,1) / -1.d0 /, twake(0,2) / 0.d0 /

*---- Make sure the bunch charge and the energy have been set.
      if (ener1 .le. zero .or. parnum .eq. zero) goto 990

*---- Read the longitudinal wake: units= Volts/Coulomb/meter.
      if (lfile .ne. lold .and. lfile .ne. " ") then
        lrec = 0
        open (51, file=lfile, status='old', err=900)
   10   read (51, '(a)', end=100, err=910) buffer
        if (buffer(1:1) .ne. '(') then
          lrec = lrec + 1
          if (lrec .gt. 2500) goto 940
          read (buffer, *, end=910, err=910)
     +      lwake(lrec,1), lwake(lrec,2)
        endif
        goto 10
  100   continue
        close (51)
        if (lrec .gt. 0) then
          lzmax = lwake(lrec,1)
        else
          lzmax = -one
        endif
        write (iqlog, 810) lrec, lfile
        lold = lfile
      else if (lfile .eq. " ") then
        lrec = 0
        lzmax = -one
      endif

*---- Read the transverse dipole wake: units=Volts/Coulomb/meter**2.
      if (tfile .ne. told .and. tfile .ne. " ") then
        trec=0
        open (51, file=tfile, status='OLD', err=920)
   20   read (51, '(a)', end=200, err=930) buffer
        if (buffer(1:1) .ne. '(') then
          trec = trec + 1
          if (trec .gt. 2500) goto 950
          read (buffer, *, end=930, err=930)
     +      twake(trec,1), twake(trec,2)
        endif
        goto 20
  200   continue
        close (51)
        if (trec .gt. 0) then
          tzmax = twake(trec,1)
        else
          tzmax = -one
        endif
        write (iqlog, 810) trec, tfile
        told = tfile
      else if (tfile .eq. " ") then
        trec = 0
        tzmax = -one
      endif

*---- Compute the wakefields - set constants.
      ch = 1.6e-19 * parnum / npart
      if (eleff .gt. zero) then
        el = eleff
      else
        el = one
      endif

*---- Check to see if binning is desired.
      if (nbin .gt. 0) then
        if (nbin .gt. 2001) then
          write (iqlog, 860)
          return
        endif

*---- Set up the bins: Bins(*,1) = charge
*                      Bins(2,*) = average X position
*                      Bins(3,*) = average Y position
*                      Bins(4,*) = average Z position
        nb = nint((nbin-half)/two)
        nbin = 1 + 2*nb
        if (nb .gt. 0) then
          dzbin = binmax / nb
        else
          dzbin = 1.d10
        endif
        do 300 j = -nb, nb
          bins(j,1) = zero
          bins(j,2) = zero
          bins(j,3) = zero
          bins(j,4) = zero
  300   continue

*---- Bin the data.
        icount = 0
        do 310 itrk = 1, ntrk
          z = track(5, itrk)
          ib = nint(z/dzbin)
          if (abs(ib) .le. nb) then
            icount = icount + 1
            bins(ib,1) = bins(ib,1) + ch
            bins(ib,2) = bins(ib,2) + track(1,itrk)
            bins(ib,3) = bins(ib,3) + track(3,itrk)
            bins(ib,4) = bins(ib,4) + z
          endif
  310   continue
        write (iqlog, 870) nbin, binmax, icount, ntrk

*---- Get average positions.
        do 320 j = -nb, nb
          if (bins(j,1) .ne. zero) then
            bins(j,2) = bins(j,2) * ch / bins(j,1)
            bins(j,3) = bins(j,3) * ch / bins(j,1)
            bins(j,4) = bins(j,4) * ch / bins(j,1)
          else
            bins(j,2) = zero
            bins(j,3) = zero
            bins(j,4) = zero
          endif
  320   continue

*---- Calculate wakes.
        do 340 itrk = 1, ntrk
          z = track(5, itrk) + 1.d-8
          wl = zero
          wx = zero
          wy = zero
          do 330 j = -nb, nb

*---- If particle is outside of the bin.
            if (z .lt. (j-half)*dzbin) then
              dz = bins(j,4) - z

*---- Longitudinal - find the wakefield values spanning the separation
*     dz and then interpolate.
              if (dz .le. lzmax) then
                call tt_wake(dz, irec, lrec, lwake(0,1))
                ww = lwake(irec-1,2) + (dz - lwake(irec-1,1))
     +             * (lwake(irec,2)-lwake(irec-1,2))
     +             / (lwake(irec,1)-lwake(irec-1,1))
                wl = wl + ww * bins(j,1)
              endif

*---- Transverse.
              if (dz .le. tzmax) then
                call tt_wake(dz, irec, trec, twake(0,1))
                ww = twake(irec-1,2) + (dz - twake(irec-1,1))
     +             * (twake(irec,2)-twake(irec-1,2))
     +             / (twake(irec,1)-twake(irec-1,1))
                wx = wx + ww  * bins(j,1) * bins(j,2)
                wy = wy + ww  * bins(j,1) * bins(j,3)
              endif

*---- If the particle is inside the bin.
            else if (z .lt. (j+half)*dzbin) then
              dz = -((j-half)*dzbin - z)/two
              f = -(z - (j+half)*dzbin) / dzbin

*---- Longitudinal - find the wakefield values spanning the separation
*     dz and then interpolate.
              if (dz .le. lzmax) then
                call tt_wake(dz, irec, lrec, lwake(0,1))
                ww = lwake(irec-1,2) + (dz - lwake(irec-1,1))
     +             * (lwake(irec,2)-lwake(irec-1,2))
     +             / (lwake(irec,1)-lwake(irec-1,1))
                wl = wl + ww * bins(j,1) * f
              endif

*---- Transverse.
              if (dz .le. tzmax) then
                call tt_wake(dz, irec, trec, twake(0,1))
                ww = twake(irec-1,2) + (dz - twake(irec-1,1))
     +             * (twake(irec,2)-twake(irec-1,2))
     +             / (twake(irec,1)-twake(irec-1,1))
                wx = wx + ww  * bins(j,1) * bins(j,2) * f
                wy = wy + ww  * bins(j,1) * bins(j,3) * f
              endif
            endif
  330     continue

*---- Track.
          wl = wl * el * 1.e-9 / ener1
          wx = wx * el * 1.e-9 / ener1
          wy = wy * el * 1.e-9 / ener1
          track(2,itrk) = track(2,itrk) + wx
          track(4,itrk) = track(4,itrk) + wy
          track(6,itrk) = track(6,itrk) - wl
  340   continue

*---- No binning - calculate particle by particle.
      else
        do 410 itrk = 1, ntrk
          z = track(5, itrk)
          wl = zero
          wx = zero
          wy = zero
          do 400 j = 1, ntrk
            if (track(5,j) .ge. z) then
              dz = track(5,j) - z

*---- Longitudinal - find the wakefield values spanning the separation
*     dz and then interpolate.
              if (dz .le. lzmax) then
                call tt_wake(dz, irec, lrec, lwake(0,1))
                ww = lwake(irec-1,2) + (dz - lwake(irec-1,1))
     +             * (lwake(irec,2)-lwake(irec-1,2))
     +             / (lwake(irec,1)-lwake(irec-1,1))
                wl = wl + ww
              endif

*---- Transverse.
              if (dz .le. tzmax) then
                call tt_wake(dz, irec, trec, twake(0,1))
                ww = twake(irec-1,2) + (dz - twake(irec-1,1))
     +             * (twake(irec,2)-twake(irec-1,2))
     +             / (twake(irec,1)-twake(irec-1,1))
                wx = wx + ww  * track(1,j)
                wy = wy + ww  * track(3,j)
              endif
            endif
  400     continue

*---- Track.
          wl = wl * ch * el * 1.e-9 / ener1
          wx = wx * ch * el * 1.e-9 / ener1
          wy = wy * ch * el * 1.e-9 / ener1
          track(2,itrk) = track(2,itrk) + wx
          track(4,itrk) = track(4,itrk) + wy
          track(6,itrk) = track(6,itrk) - wl
  410   continue
      endif

  810 format (/' TTWAKE  -- Read ',i5,' lines from: ',a)
  820 format (/' TTWAKE  -- Error opening file: ',a)
  830 format (/' TTWAKE  -- Error reading file: ',a/
     +        10x,'at record # ',i5,' with buffer: ',a)
  840 format (/' TTWAKE  -- Wake file too large (2500 max.): ',a)
  860 format (/' TTWAKE  -- Too many bins (MAX=2001): ',i5)
  870 format (/' TTWAKE  -- Created ',i5,' bins with max Z: ',1pg12.4/
     +        10x,'Binned ',i5,' tracks out of ',i5,' total')
  890 format (/' TTWAKE  -- BEAM command must set Energy and # Part.')

*---- Error returns.
  900 write (iqlog, 820) lfile
      return

  910 write (iqlog, 830) lfile, lrec, buffer
      close (51)
      return

  920 write (iqlog, 820) tfile
      return

  930 write (iqlog, 830) tfile, trec, buffer
      close (51)
      return

  940 write (iqlog, 840) lfile
      close (51)
      return

  950 write (iqlog, 840) tfile
      close (51)
      return

  990 write (iqlog, 890)
      return

      end
+dk ttyrot
      subroutine ttyrot(track, ntrk)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Displace tracks at entry due to misalignment.                      *
*   Treated in a purely linear way.                                    *
* Input/output:                                                        *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*   NTRK      (integer) Number of surviving tracks.                    *
* Output:                                                              *
*   EL        (real)    Length of quadrupole.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer itrk,ntrk
      double precision cosphi,ek2,one,phi,pt1,px1,r11,r22,r26,r51,
     +sinphi,t1,track,x1
      dimension         track(6,*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca beam
+ca refer

      parameter         (one = 1.0d0)

*---- Fetch angle from pool.
      call ucopy(q(lcelm+meangr), phi, mwflt)

      sinphi = sin(phi)
      cosphi = cos(phi)
      r11 = one / cosphi
      ek2 = - sinphi
      r22 =   cosphi
      r26 = - sinphi / betas
      r51 = sinphi / (betas * cosphi)

*---- Loop for all particles.
      do 90 itrk = 1, ntrk
        x1  = track(1,itrk)
        px1 = track(2,itrk)
        t1  = track(5,itrk)
        pt1 = track(6,itrk)
        track(1,itrk) = r11 * x1
        track(2,itrk) = r22 * px1 + r26 * pt1 + ek2
        track(5,itrk) = r51 * x1  + t1
   90 continue

      end
+dk ttzzzz
+dk twaaaa
+dk twbtgo
      subroutine twbtgo(list, tape, idisk)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track Twiss parameters and build internal tables.                  *
* Input:                                                               *
*   LIST      (logical) True: Print listing of results.                *
*   TAPE      (logical) True: Write output on disk.                    *
*   IDISK     (integer) Logical unit number for disk output.           *
* Important common data:                                               *
*             /MAPELM/  Element transfer map.                          *
*             /MAPTRN/  One turn transfer map.                         *
*             /OPTIC0/  Initial values.                                *
*             /OPTIC1/  Current values.                                *
*   LCELM     /REFER/   Current element bank.                          *
*   LCALI     /REFER/   Current misalignment pointer.                  *
*   LCFLD     /REFER/   Current field error pointer.                   *
*   LCSEQ     /REFER/   Current beam line sequence bank.               *
*----------------------------------------------------------------------*
* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Added ENER1 to set the initial energy value for twiss calculation   *
* Modified: 01-APR-1999, M. Woodley (SLAC)                             *
*   Set ENER1=EN0 if ENER0=0; set ENERGY (from                         *
*   COMMON /BEAFLT/) to ENER1 value if doing tape file output           *
* Modified: 14-JUL-1999, T. Raubenheimer (SLAC)                        *
*   Added /SYNCH/ common block; reset BLEN to zero in tracking loop    *
*----------------------------------------------------------------------*
+ca aparam
      integer icode,idisk,iecnt,ienum,iflag,iocc,ipos,jbit,jbyt
      double precision el,twopi,utwopi,wgt,zero
      logical           list, tape
+ca seqflag
+ca message
+ca beam
+ca mapelm
+ca maptrn
+ca optic0
+ca optic1
+ca option
+ca range
+ca refer
+ca status
+ca stflag
+ca twlink
+if doom
+ca dmcommon
+ei
+ca synch
+ca pi
      parameter         (twopi = 2.0 * pi, utwopi = 1.0 / twopi)
      parameter         (zero = 0.d0)
      logical           fmap, fprt
      character*(mcnam) elmnam

*---- Retrieve beam line description.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Initial values for lattice functions.
      betx = betx0
      alfx = alfx0
      amux = amux0
      bety = bety0
      alfy = alfy0
      amuy = amuy0
      call ucopy(orbit0, orbit, 6*mwflt)
      call ucopy(disp0, disp, 6*mwflt)
      suml = zero

*---- Initial values for chromatic functions.
      wx   = wx0
      phix = phix0
      dmux = dmux0
      wy   = wy0
      phiy = phiy0
      dmuy = dmuy0
      call ucopy(ddisp0, ddisp, 6*mwflt)

      ener1 = ener0
      if (ener1 .eq. zero .or. .not. ereset) ener1 = en0
      if (tape) en0 = ener1

*---- Maximum and r.m.s. values.
      bxmax = betx
      dxmax = disp(1)
      bymax = bety
      dymax = disp(3)
      xcomax = zero
      ycomax = zero
      sigxco = zero
      sigyco = zero
      sigdx = zero
      sigdy = zero
      synch_1 = zero
      synch_2 = zero
      synch_3 = zero
      synch_4 = zero
      synch_5 = zero

*---- Initial output.
      if (list) call twbtpr(1, ' ', 0, 0, 0)
      if (tape) then
        lcelm = 0
        call twbttp(1, ' ', idisk)
      endif

*---- Loop over positions.
      cplxy = .false.
      cplxt = .false.
      iecnt = 0
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        fprt = (ipos .eq. irg1  .or.  ipos .eq. irg2  .or.
     +          jbit(iflag,mprnt) .ne. 0) .and. list
        icode = jbyt(iflag,1,mcode)
*---- Tor: set BLEN to zero ... it may get reset in TMMAP
        blen = zero
+if doom
        currname = elmnam
        currocct = iocc
+ei
*---- Physical element.
        if (icode .eq. 1) then
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            call twbttk(.true., .false.)
          endif
          call tmmap(.true., .true., orbit, fmap, el, ek, re, te)
          if (fmap) then
            call twbttk(.true., .true.)
          endif
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            call twbttk(.true., .false.)
          endif
          suml = suml + el
          bxmax = max(betx, bxmax)
          bymax = max(bety, bymax)
          dxmax = max(abs(disp(1)), dxmax)
          dymax = max(abs(disp(3)), dymax)
          xcomax = max(abs(orbit(1)), xcomax)
          ycomax = max(abs(orbit(3)), ycomax)
          sigxco = sigxco + orbit(1)**2
          sigyco = sigyco + orbit(3)**2
          sigdx = sigdx + disp(1)**2
          sigdy = sigdy + disp(3)**2
          iecnt = iecnt + 1
          if (fprt) call twbtpr(4, elmnam, ipos, ienum, iocc)
          if (tape) call twbttp(2, elmnam, idisk)

*---- Entrance of line.
        else if (icode .eq. 2) then
          if (fprt) call twbtpr(5, elmnam, ipos, ienum, iocc)
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            call twbttk(.true., .false.)
          endif

*---- Exit of line.
        else
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            call twbttk(.true., .false.)
          endif
          if (fprt) call twbtpr(6, elmnam, ipos, ienum, iocc)
        endif

*---- SAVE option.
        if (ltwfun .ne. 0) call twbtsv(2, ipos)

*---- Fill in SAVEBETA command, if any.
        if (jbit(iflag,msbet) .ne. 0) call twsbet(ipos, .false.)
   90 continue

*---- Summary data.
      call twsumm(symm, nsup)
      wgt = max(iecnt, 1)
      sigxco = sqrt(sigxco / wgt)
      sigyco = sqrt(sigyco / wgt)
      sigdx = sqrt(sigdx / wgt)
      sigdy = sqrt(sigdy / wgt)
      cosmux = (rt(1,1) + rt(2,2)) / 2.0
      cosmuy = (rt(3,3) + rt(4,4)) / 2.0
      if (list) call twbtpr(7, ' ', 0, 0, 0)
      if (tape) call twbttp(3, ' ', idisk)

*---- Warning, if system is coupled.
      if (cplxy) then
        write (msg, 910) deltas
        call aawarn('TWBTGO', 2, msg)
      endif
      if (cplxt .or. dorad) then
        write (msg, 920)
        call aawarn('TWBTGO', 2, msg)
      endif

  910 format('TWISS found transverse coupling for delta(p)/p =',f12.6/
     +       'Please use the COUPLE option.')
  920 format('TWISS uses the RF system and synchrotron radiation ',
     +       'only to find the closed orbit.'/
     +       'for optical calculations it ignores both.')

      end
+dk twbtin
      subroutine twbtin(lseq, chrom, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initial values for Twiss parameters.                               *
* Input:                                                               *
*   LSEQ(1)   (pointer) Beam line sequence bank.                       *
*   CHROM     (logical) True, to initialize also chromatic functions.  *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
* Important common data:                                               *
*   RT(6,6)   /MAPTRN/  One turn transfer matrix.                      *
*   TT(6,6,6) /MAPTRN/  Second order terms.                            *
*             /OPTIC0/  Initial values are stored here.                *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ileng,j,k
      double precision aux,ax,ay,bx,by,eps,sinmu2,temp
      logical           chrom, eflag
      integer           lseq(*)
+ca memdum
+ca seqgroup
+ca message
+ca beam
+ca maptrn
+ca optic0
+ca status

      character*(mcnam) linnam
      character*(mcrng) rngnam
      dimension         aux(6)
      parameter         (eps = 1.0d-8)

*---- Initial dispersion.
      call twdisp(rt, rt(1,6), disp0)
      disp0(5) = 0.0
      disp0(6) = 1.0

*---- Derivative of transfer matrix w.r.t. delta(p)/p.
      if (chrom) then
        do 30 i = 1, 6
          aux(i) = 0.0
          do 20 k = 1, 6
            temp = 0.0
            do 10 j = 1, 6
              temp = temp + tt(i,j,k) * disp0(j)
   10       continue
            aux(i) = aux(i) + temp * disp0(k)
            rtp(i,k) = 2.0 * temp
   20     continue
   30   continue

*---- Derivative of dispersion.
        call twdisp(rt, aux, ddisp0)
        ddisp0(5) = 0.0
        ddisp0(6) = 0.0
      endif

*---- Horizontal motion.
      betx0 = 0.0
      alfx0 = 0.0
      amux0 = 0.0
      wx0   = 0.0
      phix0 = 0.0
      dmux0 = 0.0
      cosmux = (rt(1,1) + rt(2,2)) / 2.0
      stabx = abs(cosmux) .lt. 1.0
      if (stabx) then
        sinmu2 = - rt(1,2)*rt(2,1) - 0.25*(rt(1,1) - rt(2,2))**2
        if (sinmu2 .lt. 0.0) sinmu2 = eps
        sinmux = sign(sqrt(sinmu2), rt(1,2))
        betx0 = rt(1,2) / sinmux
        alfx0 = (rt(1,1) - rt(2,2)) / (2.0 * sinmux)
        if (chrom) then
          bx = rtp(1,2) / rt(1,2) +
     +         (rtp(1,1) + rtp(2,2)) * cosmux / (2.0 * sinmu2)
          ax = (rtp(1,1) - rtp(2,2)) / (2.0 * sinmux) -
     +         alfx0 * rtp(1,2) / rt(1,2)
          wx0 = sqrt(bx**2 + ax**2)
          if (wx0 .gt. 1.0e-8) phix0 = atan2(ax,bx)
        endif
      endif

*---- Vertical motion.
      bety0 = 0.0
      alfy0 = 0.0
      amuy0 = 0.0
      wy0   = 0.0
      phiy0 = 0.0
      dmuy0 = 0.0
      cosmuy = (rt(3,3) + rt(4,4)) / 2.0
      staby = abs(cosmuy) .lt. 1.0
      if (staby) then
        sinmu2 = - rt(3,4)*rt(4,3) - 0.25*(rt(3,3) - rt(4,4))**2
        if (sinmu2 .lt. 0.) sinmu2 = eps
        sinmuy = sign(sqrt(sinmu2), rt(3,4))
        bety0 = rt(3,4) / sinmuy
        alfy0 = (rt(3,3) - rt(4,4)) / (2.0 * sinmuy)
        if (chrom) then
          by = rtp(3,4) / rt(3,4) +
     +         (rtp(3,3) + rtp(4,4)) * cosmuy / (2.0 * sinmu2)
          ay = (rtp(3,3) - rtp(4,4)) / (2.0 * sinmuy) -
     +         alfy0 * rtp(3,4) / rt(3,4)
          wy0 = sqrt(by**2 + ay**2)
          if (wy0 .gt. 1.0e-8) phiy0 = atan2(ay,by)
        endif
      endif

*---- Give message, if unstable.
      eflag = .false.
      if (.not. (stabx .and. staby)) then
        call uhtoc(q(lseq(1)+msbn), mcwrd, linnam, mcnam)
        call utleng(linnam, ileng)
        call uhtoc(q(lseq(1)+msrn), mcwrd, rngnam, 40)
        if (staby) then
          write (msg, 910) linnam(1:ileng), rngnam, 'X', deltas
          call aawarn('TWBTIN', 3, msg)
        else if (stabx) then
          write (msg, 910) linnam(1:ileng), rngnam, 'Y', deltas
          call aawarn('TWBTIN', 3, msg)
        else
          write (msg, 920) linnam(1:ileng), rngnam, deltas
          call aawarn('TWBTIN', 3, msg)
        endif
        eflag = .true.
      endif

  910 format('Beam line "',a,'", range: ',a/
     +       'plane ',a1,' is unstable  for delta(p)/p =',f12.6/
     +       'Twiss suppressed.')
  920 format('Beam line "',a,'", range: ',a/
     +       'both planes are unstable for delta(p)/p = ',f12.6/
     +       'Twiss suppressed.')

      end
+dk twbtpr
      subroutine twbtpr(iloc, elmnam, ipos, ienum, iocc)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print listing for Twiss parameters.                                *
* Input:                                                               *
*   ILOC      (integer) Position code:                                 *
*                       1 = Beginning of system.                       *
*                       2 = Entrance of misaligned element.            *
*                       3 = Exit of misaligned element.                *
*                       4 = After an element    (ICODE = 1).           *
*                       5 = Beginning of line   (ICODE = 2).           *
*                       6 = End of line         (ICODE = 3).           *
*                       7 = End of system.                             *
*   ELMNAM    (char)    Element associated with current element.       *
*   IPOS      (integer) Position counter.                              *
*   IENUM     (integer) Element counter.                               *
*   IOCC      (integer) Occurrence counter for current element.        *
*----------------------------------------------------------------------*
+ca aparam
+ca beam
+ca optic0
+ca optic1
+ca range
+ca refer
+ca status
+ca zunit
      integer ienum,iloc,iocc,ipos,mhead,mline,mtail,nline,npage
      double precision ds,pxco,pyco,utwopi,xco,yco
      double precision zco, pzco
      logical prtacc
      logical anylcav

      character         elmnam*(mcnam), apos*5, title*(*)

      save              npage, nline

      parameter         (mhead = 3, mline = 1, mtail = 8)
+ca maxlin
+ca pi
      parameter         (utwopi = 1.0 / (2.0 * pi))
      parameter         (title = 'Linear lattice functions.')

*---  print format: if prtacc = true, include energy
      prtacc = anylcav()
*---- Scale closed orbit.
      xco = 1000.0 * orbit(1)
      pxco = 1000.0 * orbit(2)
      yco = 1000.0 * orbit(3)
      pyco = 1000.0 * orbit(4)
      zco = 1000.0 * orbit(5)
      pzco = 100.0 * orbit(6)

*---- Switch on position type.
      go to (10, 20, 30, 40, 50, 60, 70), iloc

*==== Begin of system: Initialize page layout.
   10 continue
        npage = 0
        nline = maxlin
      go to 9999

*==== Print w.r.t. displaced element at entrance.
   20 continue

*---- Reserve space on print page, for entrance and exit.
      nline = nline + 2 * mline
      if (nline .gt. maxlin) then
        npage = npage + 1
        call prhead('TWISS', title, deltas, 0, nline, npage)
        nline = nline + mhead + 2 * mline
        if (prtacc)  then
          write (iqpr2, 810)
        else
          write (iqpr2, 910)
        endif
        call prline(iqpr2)
      endif

*---- Print.
      write (apos, '(I5)') ienum
      if (prtacc)  then
        write (iqpr2, 820) apos, elmnam, iocc, suml, ener1, zco, pzco,
     +  betx, alfx, amux * utwopi, xco, pxco, disp(1), disp(2),
     +  bety, alfy, amuy * utwopi, yco, pyco, disp(3), disp(4)
      else
        write (iqpr2, 920) apos, elmnam, iocc, suml,
     +  betx, alfx, amux * utwopi, xco, pxco, disp(1), disp(2),
     +  bety, alfy, amuy * utwopi, yco, pyco, disp(3), disp(4)
      endif
      go to 9999

*==== Print w.r.t. displaced element at exit.
   30 continue
      if (prtacc)  then
        write (iqpr2, 830)
     +  betx, alfx, amux * utwopi, xco, pxco, disp(1), disp(2),
     +  bety, alfy, amuy * utwopi, yco, pyco, disp(3), disp(4)
      else
        write (iqpr2, 930)
     +  betx, alfx, amux * utwopi, xco, pxco, disp(1), disp(2),
     +  bety, alfy, amuy * utwopi, yco, pyco, disp(3), disp(4)
      endif
      go to 9999

*==== Print w.r.t. ideal orbit after an element.
   40 continue
   50 continue
   60 continue

*---- Reserve space on print page.
        nline = nline + mline
        if (nline .ge. maxlin) then
          npage = npage + 1
          call prhead('TWISS', title, deltas, 0, nline, npage)
          nline = nline + mhead + mline
          if (prtacc)  then
            write (iqpr2, 810)
          else
            write (iqpr2, 910)
          endif
          call prline(iqpr2)
        endif

*---- Print.
        if (iloc .eq. 4) then
          write (apos, '(I5)') ienum
        else if (iloc .eq. 5) then
          apos = 'begin'
        else
          apos = 'end'
        endif
      if (prtacc) then
        write (iqpr2, 820) apos, elmnam, iocc, suml, ener1, zco, pzco,
     +  betx, alfx, amux * utwopi, xco, pxco, disp(1), disp(2),
     +  bety, alfy, amuy * utwopi, yco, pyco, disp(3), disp(4)
      else
        write (iqpr2, 920) apos, elmnam, iocc, suml,
     +  betx, alfx, amux * utwopi, xco, pxco, disp(1), disp(2),
     +  bety, alfy, amuy * utwopi, yco, pyco, disp(3), disp(4)
      endif
      go to 9999

*==== Summary print-out at end of system.
   70 continue

*---- Reserve space on print page.
        call prline(iqpr2)
        nline = nline + mtail
        if (nline .gt. maxlin) then
          npage = npage + 1
          call prhead('TWISS', title, deltas, 0, nline, npage)
        endif

*---- Summary for non-periodic case.
        if (stabt) then
          ds = 1000.0 * deltat
        else
          ds = 1000.0 * (deltat + orbit0(5) - orbit(5))
        endif
        if (inval) then
          write (iqpr2, 940)
     +      circ, qx, qy, ds, xix, xiy,
     +      bxmax, bymax, dxmax, dymax, sigdx, sigdy

*---- Summary for periodic case.
        else
          write (iqpr2, 950)
     +      circ, qx, qy, ds, xix, xiy,
     +      alfa, bxmax, bymax, gamtr, dxmax, dymax, sigdx, sigdy,
     +      1000.0*xcomax, 1000.0*ycomax, 1000.0*sigxco, 1000.0*sigyco
        endif
        call prline(iqpr2)
      go to 9999
  810 format('      ELEMENT SEQUENCE                              ',
     +       'I                H O R I Z O N T A L                 ',
     +       'I                  V E R T I C A L'/
     +       ' pos.  element occ.    dist  energy   z(co)  dE(co) ',
     +       'I     betax    alfax   mux  x(co)  px(co) Dx    Dpx  ',
     +       'I     betay    alfay   muy  y(co)  py(co) Dy    Dpy'/
     +       ' no.   name    no.      [m]  [GeV]     [mm]    [%]  ',
     +       'I     [m]      [1]    [2pi]  [mm]  [.001] [m]   [1]  ',
     +       'I     [m]      [1]    [2pi]  [mm]  [.001] [m]   [1]')
  820 format(' ',a5,' ',a8,i4,f10.3,f9.3,2f7.3,
     +       2(f10.3,f10.3,f8.3,3f6.3,f6.3))
  830 format(' ',28x,2(f10.3,f10.3,f8.3,3f6.3,f6.3))

*---- Tor: FORMAT statements for synchrotron integrals ... not used

C 945 FORMAT( 1X,'Synch. Int 1 =',1PG18.6,10X,'Synch. int 2 =',G18.6,
C    +       10X,'Synch. Int 3 =',1PG18.6/
C    +        1X,'Synch. Int 4 =',1PG18.6,10X,'Synch. int 5 =',G18.6,
C    +       10X,'T566(approx) =',1PG18.6/)

  910 format('      ELEMENT SEQUENCE       ',
     +       'I                H O R I Z O N T A L               ',
     +       'I                  V E R T I C A L'/
     +       ' pos.  element occ.     dist ',
     +       'I   betax  alfax   mux    x(co)  px(co) Dx    Dpx  ',
     +       'I   betay   alfay    muy    y(co)  py(co)  Dy    Dpy'/
     +       ' no.   name    no.      [m]  ',
     +       'I   [m]    [1]     [2pi]  [mm]   [.001] [m]   [1]  ',
     +       'I   [m]     [1]      [2pi]  [mm]   [.001]  [m]   [1]')
  920 format(' ',a5,' ',a8,i4,f10.3,2(f9.3,f7.3,f8.3,f8.4,
     +2f7.3,f6.3))
  930 format(' ',28x,2(f9.3,f7.3,f8.3,f8.4,2f7.3,f6.3))
  940 format( 1x,'total length =',f18.6,10x,'mux          =',f18.6,
     +       10x,'muy          =',f18.6/
     +        1x,'delta(s)     =',f18.6,' mm',
     +        7x,'dmux         =',f18.6,10x,'dmuy         =',f18.6/
     +       43x,'betax(max)   =',f18.6,10x,'betay(max)   =',f18.6/
     +       43x,'Dx(max)      =',f18.6,10x,'Dy(max)      =',f18.6/
     +       43x,'Dx(r.m.s.)   =',f18.6,10x,'Dy(r.m.s.)   =',f18.6)
  950 format( 1x,'total length =',f18.6,10x,'Qx           =',f18.6,
     +       10x,'Qy           =',f18.6/
     +        1x,'delta(s)     =',f18.6,' mm',
     +        7x,'Qx''          =',f18.6,10x,'Qy''          =',f18.6/
     +        1x,'alfa         =',e22.6, 6x,'betax(max)   =',f18.6,
     +       10x,'betay(max)   =',f18.6/
     +        1x,'gamma(tr)    =',f18.6,10x,'Dx(max)      =',f18.6,
     +       10x,'Dy(max)      =',f18.6/
     +       43x,'Dx(r.m.s.)   =',f18.6,10x,'Dy(r.m.s.)   =',f18.6/
     +       43x,'xco(max)     =',f18.6,10x,'yco(max)     =',f18.6/
     +       43x,'xco(r.m.s.)  =',f18.6,10x,'yco(r.m.s.)  =',f18.6)
 9999 end
+dk twbtsv
      subroutine twbtsv(iflag, ipos)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save Twiss parameters for plotting etc.                            *
* Input:                                                               *
*   IFLAG     (integer) Operation desired:                             *
*                       1: Create new table.                           *
*                       2: Save one line.                              *
*                       3: Retrieve one line.                          *
*                       4: Close table.                                *
*   IPOS      (integer) Current table row number.                      *
*----------------------------------------------------------------------*
* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Changed: MAXFUN = 26 --> MAXFUN = 27, MAXCPL = 30 --> MAXCPL = 31; *
*   added energy to output table                                       *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca seqgroup
+ca beam
+ca message
+ca optic0
+ca optic1
+ca option
+ca refer
+ca twdata
+ca twlink
      integer i,iflag,ipos,l,maxcpl,maxfun,nb,nc,nr,ns
      double precision dummy,twopi,utwopi

+ca pi
      parameter         (twopi = 2.0 * pi, utwopi = 1.0 / twopi)

      parameter         (maxfun = 27, maxcpl = 31)
      character*(mcnam) funcol(maxcpl)
      integer           icfrm(maxcpl)
      data funcol
     +  / 'DELTAP', 'S',
     +    'BETX',   'ALFX',   'MUX',    'BETY',   'ALFY',   'MUY',
     +    'X',      'PX',     'Y',      'PY',
     +    'DX',     'DPX',    'DY',     'DPY',
     +    'WX',     'PHIX',   'DMUX',   'WY',     'PHIY',   'DMUY',
     +    'DDX',    'DDPX',   'DDY',    'DDPY',   'ENER',
     +    'R(1,1)', 'R(2,1)', 'R(1,2)', 'R(2,2)'                   /

*---- Create new table for lattice functions.
*     Warning: L is local link. Be careful with Zebra calls.
      if (iflag .eq. 1) then
        lsnum = lq(lcseq-msnum)
        ns = ndelta
        nr = iq(lq(lcseq-msflg)-1)
        nc = maxfun
        if (couple) nc = maxcpl
        nb = 1
        icfrm(1) = 3
        if (double) icfrm(1) = mreal
        do 10 i = 2, maxcpl
          icfrm(i) = icfrm(1)
   10   continue
        call tbcrea(funnam, ns, nr, nc, funcol, icfrm, nb, ltwfun)
        call tbpdsc(ltwfun, 'TYPE', 5, 0, dummy, 'TWISS')
        call mzbook(2, l, ltwfun, -1, 'BRNG', 0, 0, mss, 7, 0)
        call ucopy(q(lcseq+1), q(l+1), mss)

*---- Save one complete table line.
      else if (ltwfun .ne. 0) then
        if (iflag .eq. 2) then
+if doom
          if (.not. couple)  then
            rmat(1,1) = 0
            rmat(1,2) = 0
            rmat(2,1) = 0
            rmat(2,2) = 0
          endif
          call dmopt2(-1, 0, 0, deltas)
+ei
          call tbset(ltwfun, ipos, 3, ltwbuf)
          if (double) then
            call ucopy(deltas, q(ltwbuf+1), mwflt)
            call ucopy(suml, q(ltwbuf+mwflt+1), mwflt)
            call ucopy(betx, q(ltwbuf+2*mwflt+1), mwflt)
            call ucopy(alfx, q(ltwbuf+3*mwflt+1), mwflt)
            call ucopy(amux * utwopi, q(ltwbuf+4*mwflt+1), mwflt)
            call ucopy(bety, q(ltwbuf+5*mwflt+1), mwflt)
            call ucopy(alfy, q(ltwbuf+6*mwflt+1), mwflt)
            call ucopy(amuy * utwopi, q(ltwbuf+7*mwflt+1), mwflt)
            call ucopy(orbit, q(ltwbuf+8*mwflt+1), 4*mwflt)
            call ucopy(disp, q(ltwbuf+12*mwflt+1), 4*mwflt)
            call ucopy(wx, q(ltwbuf+16*mwflt+1), mwflt)
            call ucopy(phix * utwopi, q(ltwbuf+17*mwflt+1), mwflt)
            call ucopy(dmux * utwopi, q(ltwbuf+18*mwflt+1), mwflt)
            call ucopy(wy, q(ltwbuf+19*mwflt+1), mwflt)
            call ucopy(phiy * utwopi, q(ltwbuf+20*mwflt+1), mwflt)
            call ucopy(dmuy * utwopi, q(ltwbuf+21*mwflt+1), mwflt)
            call ucopy(ddisp, q(ltwbuf+22*mwflt+1), 4*mwflt)
            call ucopy(ener1, q(ltwbuf+26*mwflt+1), mwflt)
            if (couple) then
              call ucopy(rmat, q(ltwbuf+27*mwflt+1), 4*mwflt)
            endif
          else
            q(ltwbuf+ 1) = deltas
            q(ltwbuf+ 2) = suml
            q(ltwbuf+ 3) = betx
            q(ltwbuf+ 4) = alfx
            q(ltwbuf+ 5) = amux * utwopi
            q(ltwbuf+ 6) = bety
            q(ltwbuf+ 7) = alfy
            q(ltwbuf+ 8) = amuy * utwopi
            q(ltwbuf+ 9) = orbit(1)
            q(ltwbuf+10) = orbit(2)
            q(ltwbuf+11) = orbit(3)
            q(ltwbuf+12) = orbit(4)
            q(ltwbuf+13) = disp(1)
            q(ltwbuf+14) = disp(2)
            q(ltwbuf+15) = disp(3)
            q(ltwbuf+16) = disp(4)
            q(ltwbuf+17) = wx
            q(ltwbuf+18) = phix * utwopi
            q(ltwbuf+19) = dmux * utwopi
            q(ltwbuf+20) = wy
            q(ltwbuf+21) = phiy * utwopi
            q(ltwbuf+22) = dmuy * utwopi
            q(ltwbuf+23) = ddisp(1)
            q(ltwbuf+24) = ddisp(2)
            q(ltwbuf+25) = ddisp(3)
            q(ltwbuf+26) = ddisp(4)
            q(ltwbuf+27) = ener1
            if (couple) then
              q(ltwbuf+28) = rmat(1,1)
              q(ltwbuf+29) = rmat(2,1)
              q(ltwbuf+30) = rmat(1,2)
              q(ltwbuf+31) = rmat(2,2)
            endif
          endif

*---- Load one complete table line.
        else if (iflag .eq. 3) then
          call tbset(ltwfun, ipos, 1, ltwbuf)
          if (double) then
            call ucopy(q(ltwbuf+1), deltas, mwflt)
            call ucopy(q(ltwbuf+mwflt+1), suml, mwflt)
            call ucopy(q(ltwbuf+2*mwflt+1), betx, mwflt)
            call ucopy(q(ltwbuf+3*mwflt+1), alfx, mwflt)
            call ucopy(q(ltwbuf+4*mwflt+1), amux, mwflt)
            call ucopy(q(ltwbuf+5*mwflt+1), bety, mwflt)
            call ucopy(q(ltwbuf+6*mwflt+1), alfy, mwflt)
            call ucopy(q(ltwbuf+7*mwflt+1), amuy, mwflt)
            call ucopy(q(ltwbuf+8*mwflt+1), orbit(1), 4*mwflt)
            call ucopy(q(ltwbuf+12*mwflt+1), disp(1), 4*mwflt)
            call ucopy(q(ltwbuf+16*mwflt+1), wx, mwflt)
            call ucopy(q(ltwbuf+17*mwflt+1), phix, mwflt)
            call ucopy(q(ltwbuf+18*mwflt+1), dmux, mwflt)
            call ucopy(q(ltwbuf+19*mwflt+1), wy, mwflt)
            call ucopy(q(ltwbuf+20*mwflt+1), phiy, mwflt)
            call ucopy(q(ltwbuf+21*mwflt+1), dmuy, mwflt)
            call ucopy(q(ltwbuf+22*mwflt+1), ddisp(1), 4*mwflt)
            call ucopy(q(ltwbuf+26*mwflt+1), ener1, mwflt)
            amux = amux * twopi
            amuy = amuy * twopi
            phix = phix * twopi
            dmux = dmux * twopi
            phiy = phiy * twopi
            dmuy = dmuy * twopi
            if (couple) then
              call ucopy(q(ltwbuf+27*mwflt+1), rmat(1,1), 4*mwflt)
            endif
          else
            deltas   = q(ltwbuf+ 1)
            suml     = q(ltwbuf+ 2)
            betx     = q(ltwbuf+ 3)
            alfx     = q(ltwbuf+ 4)
            amux     = q(ltwbuf+ 5) * twopi
            bety     = q(ltwbuf+ 6)
            alfy     = q(ltwbuf+ 7)
            amuy     = q(ltwbuf+ 8) * twopi
            orbit(1) = q(ltwbuf+ 9)
            orbit(2) = q(ltwbuf+10)
            orbit(3) = q(ltwbuf+11)
            orbit(4) = q(ltwbuf+12)
            disp(1)  = q(ltwbuf+13)
            disp(2)  = q(ltwbuf+14)
            disp(3)  = q(ltwbuf+15)
            disp(4)  = q(ltwbuf+16)
            wx       = q(ltwbuf+17)
            phix     = q(ltwbuf+18) * twopi
            dmux     = q(ltwbuf+19) * twopi
            wy       = q(ltwbuf+20)
            phiy     = q(ltwbuf+21) * twopi
            dmuy     = q(ltwbuf+22) * twopi
            ddisp(1) = q(ltwbuf+23)
            ddisp(2) = q(ltwbuf+24)
            ddisp(3) = q(ltwbuf+25)
            ddisp(4) = q(ltwbuf+26)
            ener1 = q(ltwbuf+27)
            if (couple) then
              rmat(1,1) = q(ltwbuf+28)
              rmat(2,1) = q(ltwbuf+29)
              rmat(1,2) = q(ltwbuf+30)
              rmat(2,2) = q(ltwbuf+31)
            endif
          endif

*---- Close table file.
        else if (iflag .eq. 4) then
+if doom
          call dmopt4
+ei
          call tbpdsc(ltwfun, 'CIRCUM', mreal, 0, circ, ' ')
          call tbclos(ltwfun)
          msg(1) = 'Lattice functions saved in table: ' // funnam
          call aainfo('TWBTSV', 1, msg)
        endif
      endif

      end
+dk twbttk
      subroutine twbttk(chrom, plus)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track lattice functions, including chromatic effects.              *
* Input:                                                               *
*   CHROM     (logical) True, to track also chromatic functions.       *
*   PLUS      (logical) True, to force positive phase advance.         *
*----------------------------------------------------------------------*

* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Scale by the energy change which is r(6,6)                         *
* Modified: 19-JUL-1999, T. Raubenheimer (SLAC)                        *
*   Added synchrotron integrals to calculations                        *
* Modified: 10-SEP-1999, M. Woodley (SLAC)                             *
*   Use the determinant of the longitudinal 2x2 part of the R-matrix   *
*   instead of R(6,6) for the energy scaling.                          *
*----------------------------------------------------------------------*

+ca aparam
      integer i,j,k
      double precision aux,auxp,ax1,ax2,ay1,ay2,bx1,bx2,by1,by2,proxim,
     +rep,t2,ta,tb,temp,tg,twopi,utwopi,x,y,zero,one,two,fre,frep,
     +curlyh,detl,f
      dimension         aux(6), auxp(6), rep(6,6)
      logical           chrom, plus
+ca mapelm
+ca optic1
+ca status
+ca synch
+ca pi
      dimension         fre(6,6), frep(6,6) ! MDW: for energy scaling

      parameter         (twopi = 2.0 * pi, utwopi = 1.0 / twopi)
      parameter         (zero = 0.0d0, one = 1.0d0, two = 2.0d0)

      proxim(x, y) = x + twopi * anint((y - x) * utwopi)

*---- Synchrotron integrals before element.
      curlyh = disp(1)**2 * (one + alfx**2) / betx
     +       + two*disp(1)*disp(2)*alfx + disp(2)**2*betx
      synch_1 = synch_1 + disp(1) * rhoinv * blen/two
      synch_2 = synch_2 + rhoinv**2 * blen/two
      synch_3 = synch_3 + abs(rhoinv**3) * blen/two
      synch_5 = synch_5 + curlyh * abs(rhoinv**3) * blen/two

*---- If CHROM, compute derivative of RE and track dispersion.
      if (chrom) then
        do 30 i = 1, 6
          aux(i) = zero
          auxp(i) = zero
          do 20 k = 1, 6
            temp = zero
            do 10 j = 1, 6
              temp = temp + te(i,j,k)*disp(j)
   10       continue
            aux(i) = aux(i) + re(i,k)*disp(k)
            auxp(i) = auxp(i) + temp*disp(k) + re(i,k)*ddisp(k)
            rep(i,k) = two*temp
   20     continue
   30   continue
        call ucopy(aux, disp, 6*mwflt)
        call ucopy(auxp, ddisp, 6*mwflt)

*---- Otherwise track dispersion only.
      else
        do 80 i = 1, 6
          aux(i) = zero
          do 70 k = 1, 6
            aux(i) = aux(i) + re(i,k)*disp(k)
   70     continue
   80   continue
        call ucopy(aux, disp, 6*mwflt)
      endif

*---- Tor: modified to cancel energy change
      disp(6) = one

*---- Tor/MDW: scale by square root of the determinant of the
*     longitudinal 2x2 part of the R-matrix
      detl = re(5,5)*re(6,6) - re(5,6)*re(6,5)
      f = one / sqrt(detl)
      call m66scl(f, re, fre)
      call m66scl(f, rep, frep)

*---- Track horizontal functions including energy scaling.
      if (stabx) then
        tb = fre(1,1)*betx - fre(1,2)*alfx
        ta = fre(2,1)*betx - fre(2,2)*alfx
        t2 = tb**2 + fre(1,2)**2
        tg = fre(1,1)*alfx - fre(1,2)*(one + alfx**2) / betx

*---- Linear functions.
        alfx = - (tb*ta + fre(1,2)*fre(2,2)) / betx
        betx = t2 / betx
        amux = amux + atan2(fre(1,2), tb)
*--- HG001025: line below commented out (creates integer phase jumps)
*        if (plus .and. fre(1,2) .lt. zero) amux = amux + twopi

*---- Chromatic functions.
        if (chrom) then
          bx1 = wx*cos(phix)
          ax1 = wx*sin(phix)
          bx2 = ((tb**2 - fre(1,2)**2)*bx1
     +        - two*tb*fre(1,2)*ax1) / t2
     +        + two*(tb*frep(1,1) - tg*frep(1,2)) / betx
          ax2 = ((tb**2 - fre(1,2)**2)*ax1
     +        + two*tb*fre(1,2)*bx1) / t2
     +        - (tb*(frep(1,1)*alfx + frep(2,1)*betx)
     +        - tg*(frep(1,2)*alfx + frep(2,2)*betx)
     +        + fre(1,1)*frep(1,2) - fre(1,2)*frep(1,1)) / betx
          wx = sqrt(ax2**2 + bx2**2)
          if (wx .gt. 1.0d-8) phix = proxim(atan2(ax2, bx2), phix)
          dmux = dmux + fre(1,2)*(fre(1,2)*ax1 - tb*bx1) / t2
     +         + (fre(1,1)*frep(1,2) - fre(1,2)*frep(1,1)) / betx
        endif
      endif

*---- Track vertical functions including energy scaling.
      if (staby) then
        tb = fre(3,3)*bety - fre(3,4)*alfy
        ta = fre(4,3)*bety - fre(4,4)*alfy
        t2 = tb**2 + fre(3,4)**2
        tg = fre(3,3)*alfy - fre(3,4)*(one + alfy**2) / bety

*---- Linear functions.
        alfy = - (tb*ta + fre(3,4)*fre(4,4)) / bety
        bety = t2 / bety
        amuy = amuy + atan2(fre(3,4), tb)
*--- HG001025: line below commented out (creates integer phase jumps)
*        if (plus .and. fre(3,4) .lt. zero) amuy = amuy + twopi

*---- Chromatic functions.
        if (chrom) then
          by1 = wy*cos(phiy)
          ay1 = wy*sin(phiy)
          by2 = ((tb**2 - fre(3,4)**2)*by1
     +        - two*tb*fre(3,4)*ay1) / t2
     +        + two*(tb*frep(3,3) - tg*frep(3,4)) / bety
          ay2 = ((tb**2 - fre(3,4)**2)*ay1
     +        + two*tb*fre(3,4)*by1) / t2
     +        - (tb*(frep(3,3)*alfy + frep(4,3)*bety)
     +        - tg*(frep(3,4)*alfy + frep(4,4)*bety)
     +        + fre(3,3)*frep(3,4) - fre(3,4)*frep(3,3)) / bety
          wy = sqrt(ay2**2 + by2**2)
          if (wy .gt. 1.0d-8) phiy = proxim(atan2(ay2, by2), phiy)
          dmuy = dmuy + fre(3,4)*(fre(3,4)*ay1 - tb*by1) / t2
     +         + (fre(3,3)*frep(3,4) - fre(3,4)*frep(3,3)) / bety
        endif
      endif

*---- Synchrotron integrals after element.
      curlyh = disp(1)**2 * (one + alfx**2) / betx
     +       + two*disp(1)*disp(2)*alfx + disp(2)**2*betx
      synch_1 = synch_1 + disp(1) * rhoinv * blen/two
      synch_2 = synch_2 + rhoinv**2 * blen/two
      synch_3 = synch_3 + abs(rhoinv**3) * blen/two
      synch_5 = synch_5 + curlyh * abs(rhoinv**3) * blen/two

      end
+dk twbttp
      subroutine twbttp(iloc, elmnam, idisk)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TAPE option of TWISS command.                                      *
* Input:                                                               *
*   LCSEQ     /REFER/   Current beam line sequence.                    *
*   LCELM     /REFER/   Current beam element.                          *
*   ILOC      (integer) Position code:                                 *
*                       1 = Beginning of system.                       *
*                       2 = After an element.                          *
*                       3 = Summary at end of system.                  *
*   ELMNAM    (char)    Name associated with current element.          *
*   IDISK     (integer) Logical unit for output                        *
*----------------------------------------------------------------------*
+ca aparam
      integer i,idisk,iloc
      double precision utwopi
      character*(*)     elmnam
+ca beam
+ca optic0
+ca optic1

+ca pi
      parameter         (utwopi = 1.0 / (2.0 * pi))

*---- Begin of system: Write header record.
      if (iloc .eq. 1) call tphead(idisk, 'TWISS')

*---- After an element.
      if (iloc .le. 2) then
        call tpelem(elmnam, idisk)
        write (idisk, 910)
     +    alfx, betx, amux * utwopi, disp(1), disp(2),
     +    alfy, bety, amuy * utwopi, disp(3), disp(4),
     +    (orbit(i), i = 1, 4), suml

*---- At end of system write summary record.
      else
        write (idisk, 920) deltas, gamtr, circ,
     +    cosmux, qx, xix, bxmax, dxmax,
     +    cosmuy, qy, xiy, bymax, dymax
      endif

  910 format(1p,5e16.9/5e16.9/5e16.9)
  920 format(1p,3e16.9/5e16.9/5e16.9)

      end
+dk twchgo
      subroutine twchgo(list, tape, idisk)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track Chromatic functions.                                         *
* Input:                                                               *
*   LIST      (logical) True: Print listing of results.                *
*   TAPE      (logical) True: Write output on disk.                    *
*   IDISK     (integer) Logical unit number for disk output.           *
* Important common data:                                               *
*             /MAPELM/  Element transfer map.                          *
*             /MAPTRN/  One turn transfer map.                         *
*             /OPTIC0/  Initial values.                                *
*             /OPTIC1/  Current values.                                *
*   LCELM     /REFER/   Current element bank.                          *
*   LCALI     /REFER/   Current misalignment pointer.                  *
*   LCFLD     /REFER/   Current field error pointer.                   *
*   LCSEQ     /REFER/   Current beam line sequence bank.               *
*----------------------------------------------------------------------*
* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Added ENER1 to set the initial energy value for twiss calculation   *
* Modified: 01-APR-1999, M. Woodley (SLAC)                             *
*   Set ENER1=EN0 if ENER0=0                                           *
* Modified: 14-JUL-1999, T. Raubenheimer (SLAC)                        *
*   Added /SYNCH/ common block; reset BLEN to zero in tracking loop    *
*----------------------------------------------------------------------*
+ca aparam
      integer icode,idisk,ienum,iflag,iocc,ipos,irg1,irg2,jbit,jbyt,
     +nsup
      double precision el, twopi, utwopi, zero
      logical list, tape
+ca seqflag
+ca message
+ca beam
+ca mapelm
+ca maptrn
+ca optic0
+ca optic1
+ca option
+ca refer
+ca status
+ca stflag
+ca synch

+ca pi
      parameter (zero = 0.d0, twopi = 2.0 * pi, utwopi = 1.0 / twopi)
      logical   fmap, fprt, symm
      character*(mcnam) elmnam, linnam
      character*(mcrng) rngnam

*---- Retrieve beam line description.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Initial values for lattice functions.
      betx = betx0
      alfx = alfx0
      amux = amux0
      bety = bety0
      alfy = alfy0
      amuy = amuy0
      call ucopy(orbit0, orbit, 6*mwflt)
      call ucopy(disp0, disp, 6*mwflt)
      suml = 0.0

*---- Initial values for chromatic functions.
      wx   = wx0
      phix = phix0
      dmux = dmux0
      wy   = wy0
      phiy = phiy0
      dmuy = dmuy0
      call ucopy(ddisp0, ddisp, 6*mwflt)
      ener1 = ener0
      if (ener1 .eq. zero .or. .not. ereset) ener1 = en0
      synch_1 = zero
      synch_2 = zero
      synch_3 = zero
      synch_4 = zero
      synch_5 = zero

*---- Initial output.
      if (list) call twchpr(' ', 1, 0, 0, 0)
      if (tape) then
        lcelm = 0
        call twchtp(1, ' ', idisk)
      endif

*---- Loop over positions.
      cplxy = .false.
      cplxt = .false.
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        fprt = (ipos .eq. irg1  .or.  ipos .eq. irg2  .or.
     +          jbit(iflag,mprnt) .ne. 0) .and. list
        icode = jbyt(iflag,1,mcode)

*---- Tor: set BLEN to zero ... it may get reset in TMMAP
        blen = zero
*---- Physical element.
        if (icode .eq. 1) then
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            call twbttk(.true., .false.)
            call tmcat(.true., re, te, rt, tt, rt, tt)
          endif
          call tmmap(.true., .true., orbit, fmap, el, ek, re, te)
          if (fmap) then
            call twbttk(.true., .true.)
            suml = suml + el
            call tmcat(.true., re, te, rt, tt, rt, tt)
          endif
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            call twbttk(.true., .false.)
            call tmcat(.true., re, te, rt, tt, rt, tt)
          endif
          if (tape) call twchtp(2, elmnam, idisk)
          if (fprt) call twchpr(elmnam, 4, ipos, ienum, iocc)

*---- Entrance of line.
        else if (icode .eq. 2) then
          if (fprt) call twchpr(elmnam, 5, ipos, ienum, iocc)
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            call twbttk(.true., .false.)
            call tmcat(.true., re, te, rt, tt, rt, tt)
          endif

*---- Exit of line.
        else
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            call twbttk(.true., .false.)
            call tmcat(.true., re, te, rt, tt, rt, tt)
          endif
          if (fprt) call twchpr(elmnam, 6, ipos, ienum, iocc)
        endif

*---- Fill in SAVEBETA command, if any.
        if (jbit(iflag,msbet) .ne. 0) call twsbet(ipos, .true.)
   90 continue

*---- Summary data.
      if (list) call twchpr(' ', 7, 0, 0, 0)
      if (tape) call twchtp(3, ' ', idisk)

*---- Warning, if system is coupled.
      if (cplxy) then
        write (msg, 910) deltas
        call aawarn('TWCHGO', 2, msg)
      endif
      if (cplxt .or. dorad) then
        write (msg, 920)
        call aawarn('TWCHGO', 2, msg)
      endif

  910 format('TWISS found transverse coupling for delta(p)/p =',f12.6/
     +       'chromatic functions may be wrong.'/' ')
  920 format('TWISS uses the RF system and synchrotron radiation ',
     +       'only to find the closed orbit.'/
     +       'for optical calculations it ignores both.')

      end
+dk twchpr
      subroutine twchpr(elmnam, iloc, ipos, ienum, iocc)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print listing for Twiss parameters, CHROM option.                  *
* Input:                                                               *
*   ELMNAM    (char)    Name associated with current element.          *
*   ILOC      (integer) Position code:                                 *
*                       1 = Beginning of system.                       *
*                       2 = Entrance of misaligned element.            *
*                       3 = Exit of misaligned element.                *
*                       4 = After an element    (ICODE = 1).           *
*                       5 = Beginning of line   (ICODE = 2).           *
*                       6 = End of line         (ICODE = 3).           *
*                       7 = End of system.                             *
*   IPOS      (integer) Position counter.                              *
*   IENUM     (integer) Element counter.                               *
*   IOCC      (integer) Occurrence counter for current element.        *
*----------------------------------------------------------------------*
+ca aparam
      integer ienum,iloc,iocc,ipos,mhead,mline,nline,npage
      double precision utwopi
      character*(*)     elmnam
+ca beam
+ca optic1
+ca range
+ca refer
+ca zunit

      character*5       apos, title*(*)
      save              npage, nline

+ca maxlin
+ca pi
      parameter         (utwopi = 1.0 / (2.0 * pi))
      parameter         (mhead = 3, mline = 1)
      parameter         (title = 'Chromatic functions.')

*---- Switch on position type.
      go to (10, 20, 30, 40, 50, 60, 70), iloc

*==== Begin of system: Initialize page layout.
   10 continue
        npage = 0
        nline = maxlin
      go to 9999

*==== Print w.r.t. displaced element at entrance.
   20 continue

*---- Reserve space on print page, for entrance and exit.
        nline = nline + 2 * mline
        if (nline .gt. maxlin) then
          npage = npage + 1
          call prhead('TWISS', title, deltas, 0, nline, npage)
          nline = nline + mhead + 2 * mline
          write (iqpr2, 910)
          call prline(iqpr2)
        endif

*---- Print.
        write (apos, '(I5)') ienum
        write (iqpr2, 920) apos, elmnam, iocc, suml,
     +    wx, phix * utwopi, dmux * utwopi, ddisp(1), ddisp(2),
     +    wy, phiy * utwopi, dmuy * utwopi, ddisp(3), ddisp(4)
      go to 9999

*==== Print w.r.t. displaced element at exit.
   30 continue
        write (iqpr2, 930)
     +    wx, phix * utwopi, dmux * utwopi, ddisp(1), ddisp(2),
     +    wy, phiy * utwopi, dmuy * utwopi, ddisp(3), ddisp(4)
      go to 9999

*==== Print w.r.t. ideal orbit after an element.
   40 continue
   50 continue
   60 continue

*---- Reserve space on print page.
        nline = nline + 1
        if (nline .gt. maxlin) then
          npage = npage + 1
          call prhead('TWISS', title, deltas, 0, nline, npage)
          nline = nline + mhead + mline
          write (iqpr2, 910)
          call prline(iqpr2)
        endif

*---- Print.
        if (iloc .eq. 4) then
          write (apos, '(I5)') ienum
        else if (iloc .eq. 5) then
          apos = 'begin'
        else
          apos = 'end'
        endif
        write (iqpr2, 920) apos, elmnam, iocc, suml,
     +    wx, phix * utwopi, dmux * utwopi, ddisp(1), ddisp(2),
     +    wy, phiy * utwopi, dmuy * utwopi, ddisp(3), ddisp(4)
      go to 9999

*==== No summary print-out.
   70 continue
        call prline(iqpr2)
      go to 9999

  910 format('      ELEMENT SEQUENCE       ',
     +       'I               H O R I Z O N T A L                ',
     +       'I                 V E R T I C A L'/
     +       ' pos.  element occ.     dist',
     +       '   I   Wx        Phix      Dmux      DDx       DDpx',
     +       '   I   Wy        Phiy      Dmuy      DDy       DDpy'/
     +       ' no.   name    no.      [m] ',
     +       '   I   [1]       [2pi]     [2pi]     [m]       [1] ',
     +       '   I   [1]       [2pi]     [2pi]     [m]       [1]')
  920 format(' ',a5,' ',a8,i4,f10.3,2(1x,5f10.3))
  930 format(' ',28x,2(1x,5f10.3))

 9999 end
+dk twchtp
      subroutine twchtp(iloc, elmnam, idisk)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TAPE option of TWISS command, CHROM option.                        *
* Input:                                                               *
*   LCSEQ     /REFER/   Current beam line sequence.                    *
*   LCELM     /REFER/   Current beam element.                          *
*   ILOC      (integer) Position code:                                 *
*                       1 = Beginning of system.                       *
*                       2 = After an element.                          *
*                       3 = Summary at end of system.                  *
*   ELMNAM    (char)    Name associated with current element.          *
*   IDISK     (integer) Logical unit for output                        *
*----------------------------------------------------------------------*
+ca aparam
      integer i,idisk,iloc
      double precision utwopi
      character*(*)     elmnam
+ca optic1

+ca pi
      parameter         (utwopi = 1.0 / (2.0 * pi))

*---- Begin of system: Write header record.
      if (iloc .eq. 1) call tphead(idisk, 'CHROM')

*---- After an element.
      if (iloc .le. 2) then
        call tpelem(elmnam, idisk)
        write (idisk, 810)
     +    wx, phix * utwopi, dmux * utwopi, ddisp(1), ddisp(2),
     +    wy, phiy * utwopi, dmuy * utwopi, ddisp(3), ddisp(4),
     +    (orbit(i), i = 1, 4), suml
      endif

  810 format(1p,5e16.9/5e16.9/5e16.9)

      end
+dk twclog
      subroutine twclog(bxbar, bybar, const)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Calculation of Coulomb logarithm (and print)                       *
*   based on the formulae in AIP physics vade mecum p.264 (1981)       *
* Input:                                                               *
*   BXBAR     (real)    Average horizontal beta.                       *
*   BYBAR     (real)    Average vertical beta.                         *
* Output:                                                              *
*   CONST     (real)    Constant in eq. (IV.9.1), ZAP user's manual.   *
*----------------------------------------------------------------------*
+ca aparam
+ca beam
+ca optic0
+ca zunit
+ca physicpm
      double precision bgam,bxbar,bybar,cbunch,const,coulog,debyel,
     +densty,etrans,pnbtot,qion,rmax,rmin,rmincl,rminqm,sigtcm,sigxcm,
     +sigycm,tempev,vol

+ca pi

*---- Calculate transverse temperature as 2*P*X',
*     i.e., assume the transverse energy is temperature/2.
      qion   = abs(charge)
      etrans = 0.5d9 * (gammas * en0 - amass) * (ex / bxbar)
      tempev = 2.0 * etrans

*---- Calculate beam volume to get density (in cm**-3).
      sigxcm = 100.0 * sqrt(ex * bxbar)
      sigycm = 100.0 * sqrt(ey * bybar)
      sigtcm = 100.0 * sigt
      if (fbch) then
        vol    = 8.0 * sqrt(pi**3) * sigxcm * sigycm * sigtcm
        densty = parnum / vol
      else
        vol    = 4.0 * pi * sigxcm * sigycm * 100.0 * circ
        pnbtot = currnt * circ / (qion * qelect * betas * clight)
        densty = pnbtot / vol
      endif

*---- Calculate RMAX as smaller of SIGXCM and DEBYE length.
      debyel = 743.40d0 * sqrt(tempev/densty) / qion
      rmax   = min(sigxcm,debyel)

*---- Calculate RMIN as larger of classical distance of closest approach
*     or quantum mechanical diffraction limit from nuclear radius.
      rmincl = 1.44d-7 * qion**2 / tempev
      rminqm = hbar*clight*1.0d5 / (2.0*sqrt(2.d-3*etrans*amass))
      rmin   = max(rmincl,rminqm)
      coulog = log(rmax/rmin)
      bgam = betas * gammas
      qion   = abs(charge)
      if (fbch) then
        const = parnum * coulog * arad**2 * clight / (8.0 * pi * betas
     +  **3 * gammas**4 * ex * ey * sige * sigt)
        cbunch = qion * parnum * qelect * betas * clight / circ
      else
        const = currnt * coulog * arad**2 /
     +  (4.0 * sqrt(pi) * qion * qelect * bgam**4 * ex * ey * sige)
      endif
      write (iqpr2, 910) const

      write (iqpr2, 920) en0, betas, gammas, coulog

*---- Print warning here if Coulomb logarithm gave bad results.
*     Usually this error is due to a starting guess far from
*     the equilibrium value.
      if (coulog .lt. 0.0) then
        call aawarn('TWCLOG', 1, 'Coulomb logarithm gives invalid'
     +  // ' result --- check input parameters.')
      endif

      write (iqpr2, 940) ex, ey

      if (fbch) then
        write (iqpr2, 950) sige, sigt, parnum, cbunch
      else
        write (iqpr2, 960) sige, currnt
      endif

  910 format(' '/5x,'CONST               = ',1p,e14.6)
  920 format(' '/5x,'ENERGY              = ',f14.6,' GeV'/
     +       5x,'BETA                = ',f14.6/
     +       5x,'GAMMA               = ',f14.3/
     +       5x,'COULOMB LOG         = ',f14.3)
  940 format(' '/5x,'X-emittance         = ',1p,e14.6,' m*rad'/
     +       5x,'Y-emittance         = ',   e14.6,' m*rad')
  950 format(' '/5x,'Momentum spread     = ',1p,e14.6/
     +       5x,'Bunch length        = ',0p,f14.6,' m'/' '/
     +       5x,'Particles per bunch = ',1p,e14.6/
     +       5x,'Bunch current       = ',1p,e14.6,' A')
  960 format(' '/5x,'Momentum spread     = ',1p,e14.6/' '/
     +       5x,'Current             = ',0p,f14.6,' A'/' ')

      end
+dk twcpgo
      subroutine twcpgo(list, tape, idisk)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track Twiss parameters with optional output, version with coupling.*
* Input:                                                               *
*   LIST      (logical) List desired.                                  *
*   TAPE      (logical) TAPE option.                                   *
* Important common data:                                               *
*             /MAPELM/  Element transfer map.                          *
*             /MAPTRN/  One turn transfer map.                         *
*             /OPTIC0/  Initial values.                                *
*             /OPTIC1/  Current values.                                *
*   LCELM     /REFER/   Current element bank.                          *
*   LCALI     /REFER/   Current misalignment pointer.                  *
*   LCFLD     /REFER/   Current field error pointer.                   *
*   LCSEQ     /REFER/   Current beam line sequence bank.               *
*----------------------------------------------------------------------*
* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Added ENER1 to set the initial energy value for twiss calculation   *
* Modified: 01-APR-1999, M. Woodley (SLAC)                             *
*   Set ENER1=EN0  if ENER0=0; set ENERGY (from                        *
*   COMMON /BEAFLT/) to ENER1 value if doing tape file output           *
*----------------------------------------------------------------------*
+ca aparam
      integer icode,idisk,iecnt,ienum,iflag,iocc,ipos,jbit,jbyt
      double precision el,twopi,utwopi,wgt,zero,two
      logical           list, tape
+ca seqflag
+ca message
+ca beam
+ca mapelm
+ca maptrn
+ca optic0
+ca optic1
+ca option
+if doom
+ca dmcommon
+ei
+ca range
+ca refer
+ca stflag
+ca twlink

+ca pi
      parameter         (twopi = 2.0 * pi, utwopi = 1.0 / twopi)
      parameter         (zero = 0.d0, two = 2.0d0)
      logical           fmap, fprt
      character*(mcnam) elmnam

*---- Retrieve beam line description.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Initial values for lattice functions.
      betx = betx0
      alfx = alfx0
      amux = amux0
      bety = bety0
      alfy = alfy0
      amuy = amuy0
      call ucopy(orbit0, orbit, 6*mwflt)
      call ucopy(disp0, disp, 6*mwflt)
      call ucopy(r0mat, rmat, 4*mwflt)
      suml = zero
      ener1 = ener0
      if (ener1 .eq. zero .or. .not. ereset) ener1 = en0
      if (tape) en0 = ener1

*---- Maximum and r.m.s. values.
      bxmax = betx
      dxmax = disp(1)
      bymax = bety
      dymax = disp(3)
      xcomax = zero
      ycomax = zero
      sigxco = zero
      sigyco = zero
      sigdx = zero
      sigdy = zero

*---- Initial output.
      if (list) call twcppr(' ', 1, 0, 0, 0)
      if (tape) then
        lcelm = 0
        call twbttp(1, ' ', idisk)
      endif

*---- Loop over positions.
      iecnt = 0
      cplxy = .false.
      cplxt = .false.
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        fprt = (ipos .eq. irg1  .or.  ipos .eq. irg2  .or.
     +          jbit(iflag,mprnt) .ne. 0) .and. list
        icode = jbyt(iflag,1,mcode)

*---- Physical element.
+if doom
        currname = elmnam
        currocct = iocc
+ei
        if (icode .eq. 1) then
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            call twcptk(.false.)
          endif
          call tmmap(.true., .true., orbit, fmap, el, ek, re, te)
          if (fmap) then
            call twcptk(.true.)
          endif
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            call twcptk(.false.)
          endif
          suml = suml + el
          bxmax = max(betx, bxmax)
          bymax = max(bety, bymax)
          dxmax = max(abs(disp(1)), dxmax)
          dymax = max(abs(disp(3)), dymax)
          xcomax = max(abs(orbit(1)), xcomax)
          ycomax = max(abs(orbit(3)), ycomax)
          sigxco = sigxco + orbit(1)**2
          sigyco = sigyco + orbit(3)**2
          sigdx = sigdx + disp(1)**2
          sigdy = sigdy + disp(3)**2
          iecnt = iecnt + 1
          if (tape) call twbttp(2, elmnam, idisk)
          if (fprt) call twcppr(elmnam, 4, ipos, ienum, iocc)

*---- Entrance of line.
        else if (icode .eq. 2) then
          if (fprt) call twcppr(elmnam, 5, ipos, ienum, iocc)
          if (lcali .ne. 0) then
            call tmali1(ipos, .false., orbit, orbit, re, te)
            call twcptk(.false.)
          endif

*---- Exit of line.
        else
          if (lcali .ne. 0) then
            call tmali2(ipos, .false., orbit, orbit, re, te)
            call twcptk(.false.)
          endif
          if (fprt) call twcppr(elmnam, 6, ipos, ienum, iocc)
        endif

*---- SAVE option.
        if (ltwfun .ne. 0) call twbtsv(2, ipos)

*---- Fill in SAVEBETA command, if any.
        if (jbit(iflag,msbet) .ne. 0) call twsbet(ipos, .false.)
   90 continue

*---- Compute summary.
      call twsumm(symm, nsup)
      wgt = max(iecnt, 1)
      sigxco = sqrt(sigxco / wgt)
      sigyco = sqrt(sigyco / wgt)
      sigdx = sqrt(sigdx / wgt)
      sigdy = sqrt(sigdy / wgt)
      cosmux = (rt(1,1) + rt(2,2)) / 2.0
      cosmuy = (rt(3,3) + rt(4,4)) / 2.0

*---- Final output.
      if (list) call twcppr(' ', 7, 0, 0, 0)
      if (tape) call twbttp(3, ' ', idisk)

*---- Warning messages.
      if (cplxt .or. dorad) then
        write (msg, 910)
        call aawarn('TWCPGO', 2, msg)
      endif

  910 format('TWISS uses the RF system and synchrotron radiation ',
     +       'only to find the closed orbit.'/
     +       'for optical calculations it ignores both.')

      end
+dk twcpin
      subroutine twcpin(lseq, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initial values for linear coupling parameters.                     *
* Input:                                                               *
*   LSEQ(1)   (pointer) Beam line sequence bank.                       *
* Output:                                                              *
*   EFLAG     (logical) Error flag.                                    *
* Important common data:                                               *
*   RT(6,6)   /MAPTRN/  One turn transfer matrix.                      *
*   TT(6,6,6) /MAPTRN/  Second order terms.                            *
*             /OPTIC0/  Initial values are stored here.                *
*----------------------------------------------------------------------*
+ca aparam
      integer ileng
      double precision a,arg,aux,d,den,det,dtr,eps,sinmu2
      integer           lseq(*)
      logical           eflag
+ca memdum
+ca seqgroup
+ca message
+ca beam
+ca maptrn
+ca optic0
+ca status
      double precision zero, one
      parameter (zero = 0.d0, one = 1.d0)
      character*(mcnam) linnam
      character*(mcrng) rngnam
      dimension         aux(2,2), a(2,2), d(2,2)
      parameter         (eps = 1.0d-8)

*---- Initial dispersion.
      call twdisp(rt, rt(1,6), disp0)
      disp0(5) = 0.0
      disp0(6) = 1.0

*---- Matrix C + B(bar) and its determinant.
      aux(1,1) = rt(3,1) + rt(2,4)
      aux(1,2) = rt(3,2) - rt(1,4)
      aux(2,1) = rt(4,1) - rt(2,3)
      aux(2,2) = rt(4,2) + rt(1,3)
      det = aux(1,1) * aux(2,2) - aux(1,2) * aux(2,1)

*---- Coupling matrix.
      dtr = (rt(1,1) + rt(2,2) - rt(3,3) - rt(4,4)) / 2.0
      arg = det + dtr**2
      if (arg .ge. zero) then
        if (arg .eq. zero) then
          r0mat(1,1) = one
          r0mat(2,2) = one
          r0mat(1,2) = zero
          r0mat(2,1) = zero
        else
          den = - (dtr + sign(sqrt(arg),dtr))
          r0mat(1,1) = aux(1,1) / den
          r0mat(1,2) = aux(1,2) / den
          r0mat(2,1) = aux(2,1) / den
          r0mat(2,2) = aux(2,2) / den
        endif

*---- Decouple: Find diagonal blocks.
        a(1,1) = rt(1,1) - rt(1,3)*r0mat(1,1) - rt(1,4)*r0mat(2,1)
        a(1,2) = rt(1,2) - rt(1,3)*r0mat(1,2) - rt(1,4)*r0mat(2,2)
        a(2,1) = rt(2,1) - rt(2,3)*r0mat(1,1) - rt(2,4)*r0mat(2,1)
        a(2,2) = rt(2,2) - rt(2,3)*r0mat(1,2) - rt(2,4)*r0mat(2,2)
        d(1,1) = rt(3,3) + r0mat(1,1)*rt(1,3) + r0mat(1,2)*rt(2,3)
        d(1,2) = rt(3,4) + r0mat(1,1)*rt(1,4) + r0mat(1,2)*rt(2,4)
        d(2,1) = rt(4,3) + r0mat(2,1)*rt(1,3) + r0mat(2,2)*rt(2,3)
        d(2,2) = rt(4,4) + r0mat(2,1)*rt(1,4) + r0mat(2,2)*rt(2,4)

*---- First mode.
        cosmux = (a(1,1) + a(2,2)) / 2.0
        stabx  = abs(cosmux) .lt. 1.0
        if (stabx) then
          sinmu2 = - a(1,2)*a(2,1) - 0.25*(a(1,1) - a(2,2))**2
          if (sinmu2 .lt. 0.0) sinmu2 = eps
          sinmux = sign(sqrt(sinmu2), a(1,2))
          betx0 = a(1,2) / sinmux
          alfx0 = (a(1,1) - a(2,2)) / (2.0 * sinmux)
        else
          betx0 = 0.0
          alfx0 = 0.0
        endif

*---- Second mode.
        cosmuy = (d(1,1) + d(2,2)) / 2.0
        staby  = abs(cosmuy) .lt. 1.0
        if (staby) then
          sinmu2 = - d(1,2)*d(2,1) - 0.25*(d(1,1) - d(2,2))**2
          if (sinmu2 .lt. 0.0) sinmu2 = eps
          sinmuy = sign(sqrt(sinmu2), d(1,2))
          bety0 = d(1,2) / sinmuy
          alfy0 = (d(1,1) - d(2,2)) / (2.0 * sinmuy)
        else
          betx0 = 0.0
          alfy0 = 0.0
        endif

*---- Unstable due to coupling.
      else
        stabx = .false.
        staby = .false.
      endif

*---- Initial phase angles.
      amux0 = 0.0
      amuy0 = 0.0

*---- Give message, if unstable.
      eflag = .false.
      if (.not. (stabx .and. staby)) then
        call uhtoc(q(lseq(1)+msbn), mcwrd, linnam, mcnam)
        call utleng(linnam, ileng)
        call uhtoc(q(lseq(1)+msrn), mcwrd, rngnam, 40)
        if (staby) then
          write (msg, 910) linnam(1:ileng), rngnam, 1, deltas
          call aawarn('TWCPIN', 3, msg)
        else if (stabx) then
          write (msg, 910) linnam(1:ileng), rngnam, 2, deltas
          call aawarn('TWCPIN', 3, msg)
        else
          write (msg, 920) linnam(1:ileng), rngnam, deltas
          call aawarn('TWCPIN', 3, msg)
          eflag = .true.
        endif
      endif

  910 format('Beam line "',a,'", range: ',a/
     +       'mode ',i1,' is unstable  for delta(p)/p =',f12.6/
     +       'Values for this mode set to zero.')
  920 format('Beam line "',a,'", range: ',a/
     +       'both modes are unstable for delta(p)/p = ',f12.6/
     +       'TWISS suppressed.')

 9999 end
+dk twcppr
      subroutine twcppr(elmnam, iloc, ipos, ienum, iocc)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Print listing for Twiss parameters.                                *
* Input:                                                               *
*   ELMNAM    (char)    Name associated with current element.          *
*   ILOC      (integer) Position code:                                 *
*                       1 = Beginning of system.                       *
*                       2 = Entrance of misaligned element.            *
*                       3 = Exit of misaligned element.                *
*                       4 = After an element    (ICODE = 1).           *
*                       5 = Beginning of line   (ICODE = 2).           *
*                       6 = End of line         (ICODE = 3).           *
*                       7 = End of system.                             *
*   IPOS      (integer) Position counter.                              *
*   IENUM     (integer) Element counter.                               *
*----------------------------------------------------------------------*
+ca aparam
      integer ienum,iloc,iocc,ipos,mhead,mline,mtail,nline,npage
      double precision pxco,pyco,utwopi,xco,yco
      character*(*)     elmnam
+ca beam
+ca optic0
+ca optic1
+ca range
+ca refer
+ca status
+ca zunit

      character         apos*5, title*(*)
      save              npage, nline

+ca maxlin
+ca pi
      parameter         (utwopi = 1.0 / (2.0 * pi))
      parameter         (mhead = 6, mline = 2, mtail = 8)
      parameter         (title = 'Coupled lattice functions.')

*---- Scale closed orbit.
      xco = 1000.0 * orbit(1)
      pxco = 1000.0 * orbit(2)
      yco = 1000.0 * orbit(3)
      pyco = 1000.0 * orbit(4)

*---- Switch on position type.
      go to (10, 20, 30, 40, 50, 60, 70), iloc

*---- Begin of system: Initialize page layout.
   10 continue
        npage = 0
        nline = maxlin
      go to 9999

*---- Print w.r.t. displaced element at entrance.
   20 continue
        nline = nline + 2 * mline
        if (nline .gt. maxlin) then
          npage = npage + 1
          call prhead('TWISS', title, deltas, 0, nline, npage)
          nline = nline + 2 * mline + mhead
          write (iqpr2, 910)
          call prline(iqpr2)
        endif
        write (apos, '(I5)') ienum
        write (iqpr2, 920) apos, elmnam, iocc, suml,
     +    betx, alfx, amux * utwopi,
     +    rmat(1,1), rmat(1,2), xco, pxco, disp(1), disp(2),
     +    bety, alfy, amuy * utwopi,
     +    rmat(2,1), rmat(2,2), yco, pyco, disp(3), disp(4)
      go to 9999

*---- Print w.r.t. displaced element at exit.
   30 continue
        write (iqpr2, 930)
     +    betx, alfx, amux * utwopi,
     +    rmat(1,1), rmat(1,2), xco, pxco, disp(1), disp(2),
     +    bety, alfy, amuy * utwopi,
     +    rmat(2,1), rmat(2,2), yco, pyco, disp(3), disp(4)
      go to 9999

*---- Print w.r.t. surrounding beam line.
   40 continue
   50 continue
   60 continue
        nline = nline + mline
        if (nline .ge. maxlin) then
          npage = npage + 1
          call prhead('TWISS', title, deltas, 0, nline, npage)
          nline = nline + mhead + mline
          write (iqpr2, 910)
          call prline(iqpr2)
        endif
        if (iloc .eq. 4) then
          write (apos, '(I5)') ienum
        else if (iloc .eq. 5) then
          apos = 'begin'
        else
          apos = 'end'
        endif
        write (iqpr2, 920) apos, elmnam, iocc, suml,
     +    betx, alfx, amux * utwopi,
     +    rmat(1,1), rmat(1,2), xco, pxco, disp(1), disp(2),
     +    bety, alfy, amuy * utwopi,
     +    rmat(2,1), rmat(2,2), yco, pyco, disp(3), disp(4)
      go to 9999

*---- Summary at end of system.
   70 continue
        call prline(iqpr2)
        nline = nline + mtail
        if (nline .gt. maxlin) then
          npage = npage + 1
          call prhead('TWISS', title, deltas, 0, nline, npage)
        endif

*---- Summary for non-periodic case.
        if (inval) then
          write (iqpr2, 940) circ, qx, qy, -1000.0*orbit(5),
     +      bxmax, bymax, dxmax, dymax

*---- Summary for periodic case.
        else
          write (iqpr2, 950) circ, qx ,qy, -1000.0*orbit(5),
     +      alfa, bxmax, bymax, gamtr, dxmax, dymax, sigdx, sigdy,
     +      1000.*xcomax, 1000.*ycomax, 1000.*sigxco, 1000.*sigyco
        endif
        call prline(iqpr2)
      go to 9999

  910 format('      ELEMENT SEQUENCE       I            M O D E S',
     +       '            I   C O U P L I N G   ',
     +       'I      O R B I T      I D I S P E R S I O N'/
     +       ' pos.  element occ.     dist I      beta1     alfa1',
     +       '     mu1    I    R(1,1)    R(1,2) ',
     +       'I    x(co)     px(co) I    Dx        Dpx'/
     +       ' no.   name    no.      [m]  I      [m]       [1]  ',
     +       '     [2pi]  I    [1]       [m]    ',
     +       'I    [mm]      [.001] I    [m]       [1]'/
     +       '                             I      beta2     alfa2',
     +       '     mu2    I    R(2,1)    R(2,2) ',
     +       'I    y(co)     py(co) I    Dy        Dpy'/
     +       '                             I      [m]       [1]  ',
     +       '     [2pi]  I    [1/m]     [1]    ',
     +       'I    [mm]      [.001] I    [m]       [1]')
  920 format(' ',a5,' ',a8,i4,f10.4,f12.4,2f10.4,2x,2f10.4,2x,2f10.4,2x,
     +       2f10.4/
     +       ' ',28x,f12.4,2f10.4,2x,2f10.4,2x,2f10.4,2x,2f10.4)
  930 format(' ',28x,f12.4,2f10.4,2x,2f10.4,2x,2f10.4,2x,2f10.4)
  940 format( 1x,'total length =',f18.6,10x,'mu1          =',f18.6,
     +       10x,'mu2          =',f18.6/
     +        1x,'delta(s)     =',f18.6,' mm'/
     +       43x,'beta1(max)   =',f18.6,10x,'beta1(max)   =',f18.6/
     +       43x,'Dx(max)      =',f18.6,10x,'Dy(max)      =',f18.6)
  950 format( 1x,'total length =',f18.6,10x,'Q1           =',f18.6,
     +       10x,'Q2           =',f18.6/
     +        1x,'delta(s)     =',f18.6,' mm'/
     +        1x,'alfa         =',e22.6, 6x,'betax(max)   =',f18.6,
     +       10x,'betay(max)   =',f18.6/
     +        1x,'gamma(tr)    =',f18.6,10x,'Dx(max)      =',f18.6,
     +       10x,'Dy(max)      =',f18.6/
     +       43x,'Dx(r.m.s.)   =',f18.6,10x,'Dy(r.m.s.)   =',f18.6/
     +       43x,'xco(max)     =',f18.6,10x,'yco(max)     =',f18.6/
     +       43x,'xco(r.m.s.)  =',f18.6,10x,'yco(r.m.s.)  =',f18.6)

 9999 end
+dk twcptk
      subroutine twcptk(plus)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Track coupled lattice functions.                                   *
* Input:                                                               *
*   PLUS      (logical) True, to force positive phase advance.         *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j
      double precision a,adet,b,c,dt,tempa,tempb,twopi
      logical           plus
+ca mapelm
+ca optic1
+ca status

      dimension         a(2,2), b(2,2), c(2,2), dt(6)

+ca pi
      parameter         (twopi = 2.0 * pi)

*---- Dispersion.
      do 20 i = 1, 6
        dt(i) = 0.0
        do 10 j = 1, 6
          dt(i) = dt(i) + re(i,j) * disp(j)
   10   continue
   20 continue
      call ucopy(dt, disp, 6*mwflt)

*---- Auxiliary matrices.
      a(1,1) = re(1,1) - (re(1,3) * rmat(1,1) + re(1,4) * rmat(2,1))
      a(1,2) = re(1,2) - (re(1,3) * rmat(1,2) + re(1,4) * rmat(2,2))
      a(2,1) = re(2,1) - (re(2,3) * rmat(1,1) + re(2,4) * rmat(2,1))
      a(2,2) = re(2,2) - (re(2,3) * rmat(1,2) + re(2,4) * rmat(2,2))
      b(1,1) = re(3,1) - (re(3,3) * rmat(1,1) + re(3,4) * rmat(2,1))
      b(1,2) = re(3,2) - (re(3,3) * rmat(1,2) + re(3,4) * rmat(2,2))
      b(2,1) = re(4,1) - (re(4,3) * rmat(1,1) + re(4,4) * rmat(2,1))
      b(2,2) = re(4,2) - (re(4,3) * rmat(1,2) + re(4,4) * rmat(2,2))
      c(1,1) = re(3,3) + (re(3,1) * rmat(2,2) - re(3,2) * rmat(2,1))
      c(1,2) = re(3,4) - (re(3,1) * rmat(1,2) - re(3,2) * rmat(1,1))
      c(2,1) = re(4,3) + (re(4,1) * rmat(2,2) - re(4,2) * rmat(2,1))
      c(2,2) = re(4,4) - (re(4,1) * rmat(1,2) - re(4,2) * rmat(1,1))

*---- Track R matrix.
      adet = a(1,1) * a(2,2) - a(1,2) * a(2,1)
      rmat(1,1) = - (b(1,1) * a(2,2) - b(1,2) * a(2,1)) / adet
      rmat(1,2) =   (b(1,1) * a(1,2) - b(1,2) * a(1,1)) / adet
      rmat(2,1) = - (b(2,1) * a(2,2) - b(2,2) * a(2,1)) / adet
      rmat(2,2) =   (b(2,1) * a(1,2) - b(2,2) * a(1,1)) / adet
*---- Mode 1.
      if (stabx) then
        tempb = a(1,1) * betx - a(1,2) * alfx
        tempa = a(2,1) * betx - a(2,2) * alfx
        alfx = - (tempa * tempb + a(1,2) * a(2,2)) / (adet * betx)
        betx =   (tempb * tempb + a(1,2) * a(1,2)) / (adet * betx)
        amux = amux + atan2(a(1,2),tempb)
      endif

*---- Mode 2.
      if (staby) then
        tempb = c(1,1) * bety - c(1,2) * alfy
        tempa = c(2,1) * bety - c(2,2) * alfy
        alfy = - (tempa * tempb + c(1,2) * c(2,2)) / (adet * bety)
        bety =   (tempb * tempb + c(1,2) * c(1,2)) / (adet * bety)
        amuy = amuy + atan2(c(1,2),tempb)
      endif

      end
+dk twdisp
      subroutine twdisp(rt, vect, disp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initial values for dispersion or its first derivative by delta.    *
*   Only the first four components of the vectors are set.             *
* Input:                                                               *
*   RT(6,6)   (real)    One turn transfer matrix.                      *
*   VECT(6)   (real)    Right-hand side:                               *
*                       Column 6 of RT for dispersion,                 *
*                       Auxiliary vector for derivative of dipersion.  *
* Output:                                                              *
*   DISP(6)   (real)    Dispersion vector.                             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,irank,j
      double precision a,disp,rt,vect
      dimension         rt(6,6), vect(6), disp(6)

      dimension         a(4,5)

      do 20 i = 1, 4
        do 10 j = 1, 4
          a(i,j) = rt(i,j)
   10   continue
        a(i,i) = a(i,i) - 1.0
        a(i,5) = - vect(i)
   20 continue

      call solver(a, 4, 1, irank)

      if (irank .ge. 4) then
        do 30 i = 1, 4
          disp(i) = a(i,5)
   30   continue
      else
        call aawarn('TWDISP', 1,
     +  'Unable to compute dispersion --- dispersion set to zero.')
        do 40 i = 1, 4
          disp(i) = 0.0
   40   continue
      endif

      end
+dk twfill
      subroutine twfill(lbank)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Fill initial lattice parameters from a data bank.                  *
* Input:                                                               *
*   LBANK(1)  (pointer) TWISS or BETA0 bank to be copied.              *
* Important common data:                                               *
*             /OPTIC0/  Initial values for lattice functions.          *
*----------------------------------------------------------------------*
* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Added energy to beta0 bank.                                        *
*----------------------------------------------------------------------*
+ca aparam
      integer ibetx,ibety
      double precision twopi
      integer           lbank(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca message
+ca optic0
+ca refer
+ca status

+ca pi
      parameter         (twopi = 2.0d0 * pi)

*---- Linear functions.
      amux0 = amux0 / twopi
      amuy0 = amuy0 / twopi
      call utgflt(lbank, 1, 6, betx0)
      amux0 = amux0 * twopi
      amuy0 = amuy0 * twopi
      call utgflt(lbank, 7, 12, orbit0)
      call utgflt(lbank, 13, 16, disp0)
      ibetx = mbat
      if (mod(iq(lccmd+ibetx+mctyp),10).ne.0 .and. betx0.eq.0.0) then
        betx0 = 0.0
        alfx0 = 0.0
        stabx = .false.
      endif
      ibety = mbat + 3 * mcsiz
      if (mod(iq(lccmd+ibety+mctyp),10).ne.0 .and. bety0.eq.0.0) then
        bety0 = 0.0
        alfy0 = 0.0
        staby = .false.
      endif

*---- Chromatic functions.
      call utgflt(lbank, 17, 22, wx0)
      call utgflt(lbank, 23, 26, ddisp0)
      call utgflt(lbank, 27, 27, ener0)

      end
+dk twibs
      subroutine twibs
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   INTRABEAM SCATTERING, IBS Command                                  *
*   These routines are a much reduced version of IBS as taken          *
*   from the program ZAP, written by M. Zisman.                        *
*   One should refer to the ZAP USERS MANUAL LBL-21270 UC-28.          *
* Attribute:                                                           *
*   TABLE     (name)    Name of Twiss table.                           *
*----------------------------------------------------------------------*
+ca aparam
+ca seqflag
+ca beam
+ca optic1
+ca range
+ca refer
+ca twlink
+ca zunit
+ca physicpm
      integer ienum,iflag,iocc,ipos,jbit,jbyt,nline
      double precision alx,alxbar,alxwtd,aly,alybar,ax1,ax2,ay1,ay2,
     +betax,betay,beteff,bx1,bx2,bxbar,bxinv,by1,by2,bybar,byinv,bywtd,
     +const,dels,dpx,dpx1,dpx2,dpxbr,dpxwtd,dx,dx1,dx2,dxbar,dxwtd,half,
     +hscrpt,hscwtd,s1,s2,salxb,salyb,sbxb,sbxinv,sbyb,sbyinv,sdpxb,
     +sdxb,taul,taux,tauy,tavl,tavlc,tavx,tavxc,tavy,tavyc,tlbar,tlidc,
     +tlwtd,txbar,txidc,txwtd,tybar,tyidc,tywtd,wnorm,zero

      character*(mcnam) elmnam*(mcnam), tabnam*(mcnam), title*(*)
      logical           head

      parameter         (half = 0.5d0, zero = 0.0d0)
      parameter         (title = 'Intrabeam scattering.')

*---- Retrieve table name to be used.
      tabnam = 'TWISS'
      call utgnam(lccmd, 1, 1, tabnam)
      call enfix

*---- Initialize variables to accumulate weighted average lifetimes.
      tavlc  = 0.0
      tavxc  = 0.0
      tavyc  = 0.0
      dxwtd  = 0.0
      dpxwtd = 0.0
      bywtd  = 0.0
      alxwtd = 0.0
      hscwtd = 0.0
      wnorm  = 0.0
      sbxb   = 0.0
      sbyb   = 0.0
      salxb  = 0.0
      salyb  = 0.0
      sdxb   = 0.0
      sdpxb  = 0.0
      sbxinv = 0.0
      sbyinv = 0.0

*---- Open file for lattice parameters.
      call tbopen(tabnam, 1, ltwfun)

*---- Pick up the beam line data.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)
      
*---- Print header.
      call prhead('IBS', title, zero, 0, nline, 1)
      if (fbch) then
        write (iqpr2, 910) prtnam, '  '
      else
        write (iqpr2, 910) prtnam, 'un'
      endif
      call enprgl
      call enprem
      call enprrf

*---- Loop over lattice points to calculate lifetimes.
      head = .false.
      do 90 ipos = irg1, irg2

*---- Pickup various pointers for elements.
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)

*---- Advance through an element ?
        if (jbyt(iflag,1,mcode) .eq. 1) then

*---- Pick up optical functions for entrance of element.
          call twbtsv(3, ipos - 1)
          s1     = suml
          bx1    = betx
          by1    = bety
          ax1    = alfx
          ay1    = alfy
          dx1    = disp(1)
          dpx1   = disp(2)

*---- Pick up optical functions for exit of element.
          call twbtsv(3, ipos)
          s2     = suml
          bx2    = betx
          by2    = bety
          ax2    = alfx
          ay2    = alfy
          dx2    = disp(1)
          dpx2   = disp(2)
          dels   = s2 - s1

          betax  = half * (bx2 + bx1)
          sbxb   = sbxb + betax * dels
          sbxinv = sbxinv + dels / betax

          betay  = half * (by2 + by1)
          sbyb   = sbyb + betay * dels
          sbyinv = sbyinv + dels / betay

          alx    = half * (ax2 + ax1)
          salxb  = salxb + alx * dels

          aly    = half * (ay2 + ay1)
          salyb  = salyb + aly * dels

          dx     = half * (dx2 + dx1)
          sdxb   = sdxb + dx * dels

          dpx    = half * (dpx2 + dpx1)
          sdpxb  = sdpxb + dpx * dels

*---- Calculate weighted average in region of non-zero DX's.
*     These values are used to calculate "average" ring lifetimes
*     in TWSINT.
          if (dx .gt. 0.0) then
            wnorm  = wnorm + dels
            dxwtd  = dxwtd + dels * dx
            dpxwtd = dpxwtd + dels * dpx
            bywtd  = bywtd + dels / sqrt(betay)
            alxwtd = alxwtd + dels * alx
            hscrpt = betax * dpx**2 + 2.0 * alx * dx * dpx +
     +               (1.0 + alx**2) * dx**2 / betax
            hscwtd = hscwtd + dels * sqrt(hscrpt)
          endif

*---- TWSINT calculates the Bjorken/Mtingwa integral.
          call twsint(betax, betay, alx, dx, dpx, txidc, tyidc, tlidc)

*---- Accumulate contributions.
          tavlc = tavlc + tlidc * dels
          tavxc = tavxc + txidc * dels
          tavyc = tavyc + tyidc * dels

*---- See if an element has been flagged by the PRINT command.
          if(jbit(iflag,mprnt) .ne. 0) then
            if (.not. head) then
              write (iqpr2, 920)
              head = .true.
            endif
            write (iqpr2, 930) ienum, elmnam, tlidc, txidc, tyidc
          endif
        endif
   90 continue

*---- Close optical function table.
      call tbclos(ltwfun)

*---- We have finished reading the lattice from MAD
      bxbar  = sbxb / s2
      bybar  = sbyb / s2
      alxbar = salxb / s2
      alybar = salyb / s2
      dxbar  = sdxb / s2
      dpxbr  = sdpxb / s2
      bxinv  = sbxinv / s2
      byinv  = sbyinv / s2

      dxwtd  = dxwtd / wnorm
      dpxwtd = dpxwtd / wnorm
      bywtd  = bywtd / wnorm
      bywtd  = 1.0 / bywtd**2
      alxwtd = alxwtd / wnorm
      hscwtd = (hscwtd/wnorm)**2
      beteff = dxwtd**2 / hscwtd

*---- Integral for averaged quantities.
      call twsint(bxbar,bybar,alxbar,dxbar,dpxbr, txbar,tybar,tlbar)

*---- Integral for effective quantities.
      call twsint(beteff,bywtd,alxwtd,dxwtd,dpxwtd, txwtd,tywtd,tlwtd)

*---- Calculate the Coulomb logarithm.
      call twclog(bxbar, bybar, const)

*---- Output (weighted) average values.
      write (iqpr2, 940) bxbar, bybar, dxbar, alxbar, alybar, dpxbr,
     +                   bxinv, byinv

*---- Output averaged values.
      tavl   = tavlc * const / s2
      tavx   = tavxc * const / s2
      tavy   = tavyc * const / s2

      taul   = 1.0 / tavl
      taux   = 1.0 / tavx
      tauy   = 1.0 / tavy

      write (iqpr2, 950) tavl, tavx, tavy, taul, taux, tauy

  910 format(' '/' Particle beam: ',a,10x,a,'bunched.')
  920 format(' '/' Individual lattice point lifetimes'/' '/
     +       26x,'TLI/const',10x,'TXI/const',10x,'TYI/const'/
     +       27x,'(1/sec)',12x,'(1/sec)',12x,'(1/sec)'/' ')
  930 format(1x,i8,2x,a8,3x,3(1pe15.6,3x))
  940 format(' '/' Ring average values (m)'/' '/ 5x,'betx   = ',
     +       1pe13.5,4x, 'bety   = ',1pe13.5,4x,'Dx  = ',1pe12.5/
     +       5x,'alfx   = ',1pe13.5,4x,'alfy   = ',1pe13.5,4x,'Dpx = ',
     +       1pe12.5/5x,'1/betx = ',1pe13.5,4x,'1/bety = ',1pe13.5)
  950 format(' '/5x,'(Weighted) average rates (1/sec):'/
     +       5x,'Longitudinal= ',1p,e15.6/
     +       5x,'Horizontal  = ',   e15.6/
     +       5x,'Vertical    = ',   e15.6/
     +       ' '/5x,'(Weighted) average lifetimes (sec):'/
     +       5x,'Longitudinal= ',1p,e15.6/
     +       5x,'Horizontal  = ',   e15.6/
     +       5x,'Vertical    = ',   e15.6/' ')

      end
+dk twiss
      subroutine twiss
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   TWISS command: Track linear lattice parameters.                    *
* Attributes, must be given in this order in the dictionary:           *
*   BETX      (real)    Horizontal beta.                        ( 1)   *
*   ALFX      (real)    Horizontal alpha.                       ( 2)   *
*   MUX       (real)    Horizontal phase.                       ( 3)   *
*   BETY      (real)    Vertical beta.                          ( 4)   *
*   ALFY      (real)    Vertical alpha.                         ( 5)   *
*   MUY       (real)    Vertical phase.                         ( 6)   *
*   X         (real)    Horizontal position for closed orbit.   ( 7)   *
*   PX        (real)    Horizontal momentum for closed orbit.   ( 8)   *
*   Y         (real)    Vertical position for closed orbit.     ( 9)   *
*   PY        (real)    Vertical momentum for closed orbit.     (10)   *
*   T         (real)    Longitudinal position for closed orbit. (11)   *
*   PT        (real)    Momentum error for closed orbit.        (12)   *
*   DX        (real)    Horizontal dispersion.                  (13)   *
*   DPX       (real)    Disperstion for horizontal momentum.    (14)   *
*   DY        (real)    Vertical dispersion.                    (15)   *
*   DPY       (real)    Dispersion for vertical momentum.       (16)   *
*----------------------------------------------------------------------*
*   WX        (real)    Horizontal chromatic amplitude.         (17)   *
*   PHIX      (real)    Horizontal chromatic phase.             (18)   *
*   DMUX      (real)    Chromatic derivative of hor. phase.     (19)   *
*   WY        (real)    Vertical chromatic amplitude.           (20)   *
*   PHIY      (real)    Vertical chromatic phase.               (21)   *
*   DMUY      (real)    Chromatic derivative of vert. phase.    (22)   *
*   DDX       (real)    Second-order horizontal dispersion.     (23)   *
*   DDPX      (real)    Second-order dispersion for hor. mom.   (24)   *
*   DDY       (real)    Second-order vertical dispersion.       (25)   *
*   DDPY      (real)    Second-order dispersion for vert. mom.  (26)   *
*----------------------------------------------------------------------*
*   ENERGY    (real)    Energy value                            (27)   *
*----------------------------------------------------------------------*
*   CHROM     (logical) CHROM option.                           (28)   *
*   COUPLE    (logical) COUPLE option.                          (29)   *
*----------------------------------------------------------------------*
*   TAPE      (string)  TAPE option: File name.                 (30)   *
*   SAVE      (name)    SAVE option: Table name.                (31)   *
*   TUNES     (name)    TUNES option: Table name.               (32)   *
*   BETA0     (name)    Bank for initial conditions.            (33)   *
*   LINE      (line)    Line for initial conditions.            (34)   *
*   DELTAP(25)(real)    Momentum error values.                  (35)   *
*----------------------------------------------------------------------*
* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Add ENERGY attribute; change MAXTWS=26 to MAXTWS=27                *
* Modified: 02-APR-1999, M. Woodley (SLAC)                             *
*   Set ENER1 (in COMMON /OPTIC1/) before call to TMSCND if there are   *
*   LCAVITY elements present in the current beamline; reset data in    *
*   BEAM common via a call to ENGET after call to TMSCND.  If initial  *
*   conditions come from a BETA0, update initial values from command   *
*   attributes via a second call to TWFILL                             *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca seqgroup
+ca strgroup
+ca message
+ca beam
+ca maptrn
+ca option
+ca optic0
+ca optic1
+ca refer
+ca status
+ca stflag
+ca twdata
+ca twlink
+ca datatype
      integer ibeta,ibetx,ibety,idata,idelta,idisk,ileng,iline,jdelta,
     +maxdel,maxnam,maxtws,mdelta,mflag,mline,mname,mtape
      double precision dval, zero, ener_st

      parameter         (maxtws=27)
      parameter (zero = 0.d0)
      parameter         (maxnam=4, maxdel=25)
      character*(mcfil) strnam, filnam
      character*(mcnam) seqnm, twsnam(maxnam)
      dimension         dval(maxdel)
      logical           betflg, eflag, linflg, tape, twsflg(2)
      parameter         (mflag = maxtws + 1, mtape = mflag + 2,
     +                   mname = mtape + 1, mline = mname + maxnam,
     +                   mdelta = mline  + 1)

      logical           anylcav

*==== PHASE 1: Check data.
*---- Check main beam line.
      call lnchck('TWISS ', error)
      if (error) go to 9999

*---- Option flags.
      twsflg(1) = .false.
      twsflg(2) = .false.
      call utglog(lccmd, maxtws + 1, maxtws + 2, twsflg)
      chrom  = twsflg(1)
      couple = twsflg(2)

*---- File name for TAPE option.
      strnam = ' '
      call utgstr(lccmd, mtape, mtape, strnam)
      tape = strnam .ne. ' '

*---- BETA0 and table names.
      twsnam(1) = ' '
      twsnam(2) = ' '
      twsnam(3) = ' '
      twsnam(4) = ' '
      call utgnam(lccmd, mname, mname + maxnam - 1, twsnam)
      funnam = twsnam(1)
      sumnam = twsnam(2)
      betnam = twsnam(3)
      seqnm = twsnam(4)
      betflg = betnam .ne. ' '
      if (seqnm .ne. ' ')  call get_active(seqnm, 'TWISS')
*---- LINE attribute.
      iline = mbat + (mline - 1) * mcsiz
      linflg = mod(iq(lccmd+iline+mctyp),10) .ne. 0
      if (betflg) then
        call utleng(betnam, ileng)
        call difind(ldbnk, betnam(1:ileng), ibeta, ltwbet)
        if (ltwbet .eq. 0) then
          msg(1) = 'Initial BETA0 bank "' // betnam(1:ileng)
     +    // '" not found.'
          call aafail('TWISS', 1, msg)
        else if (iq(ltwbet+mbpr) .ne. mpenv  .or.
     +           iq(ltwbet+mbsp) .ne. 2) then
          msg(1) = '"' // betnam(1:ileng) // '" is not a "BETA0" bank.'
          call aafail('TWISS ', 1, msg)
        else if (linflg) then
          call aafail('TWISS', 1,
     +    'Conflicting options BETA0 and LINE have been specified.')
        endif
      endif

*---- Momentum error values.
      ndelta = 0
      idata = mbat + mcsiz * (mdelta - 1)
      do 30 jdelta = 1, maxdel
        if (mod(iq(lccmd+idata+mctyp),10) .ne. 0) then
          ndelta = ndelta + 1
          call ucopy(q(lccmd+idata+mcval), dval(ndelta), mwflt)
        endif
        idata = idata + mcsiz
   30 continue
*---- If no value given, default is zero.
      if (ndelta .eq. 0) then
        dval(1) = 0.0
        ndelta = 1
      endif
*==== PHASE 2: Initialize flags, tables, and files.
      if (error) go to 9999

*---- Prepare sequence for LINE option.
      if (linflg) then
        call lnrefe(lccmd, mline, ltwlin, lroot, -minit)
      endif

*---- Initial value flag.
      ibetx = mbat
      ibety = mbat + 3 * mcsiz
      inval = (mod(iq(lccmd+ibetx+mctyp),10) .ne. 0  .and.
     +         mod(iq(lccmd+ibety+mctyp),10) .ne. 0)  .or.
     +        betflg  .or.  linflg

*---- Open file for "TAPE" option.
      if (tape) then
        call flopen(strnam, 'SWFD', 0, 0, idisk, eflag)
        tape = .not. eflag
      endif

*---- Create internal table for lattice functions.
      ltwfun = 0
      if (funnam .ne. ' ') then
        call twbtsv(1, 0)
+if doom
*--- create (intern) doom-twiss master table
        call dmopt1(funnam, 1, -1, funnam, 0)
+ei
      endif

*---- Create internal table for summary data.
      ltwsum = 0
      if (sumnam .ne. ' ') call twsmsv(1, 0)

*---- Set up RF system.
      call enfix

*==== PHASE 3: Perform computation for all momentum errors requested.
      if (error) go to 9999
      do 90 idelta = 1, ndelta
        eflag = .false.
        if (ltwfun .ne. 0) then
          call tbseg(ltwfun, idelta, eflag)
          if (eflag) then
            stabx = .false.
            staby = .false.
*            if (ltwfun .ne. 0) call mzdrop(0, ltwfun, '.')
*            if (ltwsum .ne. 0) call mzdrop(0, ltwsum, '.')
            goto 80
          endif
        endif
        call uzero(betx0, 1, 30*mwflt)
        call uzero(qx, 1, 19*mwflt)
        disp0(5) = 0.0
        disp0(6) = 1.0
        deltas = dval(idelta)
        call enfreq(deltas)
        
        if (anylcav()) then
          ener1 = ener0
          if (ener1 .eq. zero .or. .not. ereset) ener1 = en0
        endif
        ener_st = en0
*---- Initial values from command attributes.
        if (inval) then
          stabx = .true.
          staby = .true.

*---- LINE attribute.
          if (linflg) then
            call tmturn(ltwlin, deltas, eflag)
            if (eflag) go to 80
            if (couple) then
              call twcpin(ltwlin, eflag)
              call tmderi(tt, disp0, rtp)
            else
              call twbtin(ltwlin, .true., eflag)
            endif
            if (eflag) go to 80

*---- BETA0 attribute.
          else if (betflg) then
            call twfill(ltwbet)
*--- override BETA0 stuff if necessary
            call twfill(lccmd)
          endif
          if (anylcav()) then
            call tmscnd(lcseq)
            call enget
          else
            call tmscnd(lcseq)
          endif
          call tmderi(tt, disp0, rtp)

*---- Initial values from periodic solution.
        else
          call tmturn(lcseq, deltas, eflag)
          if (iq(lcseq+msym) .ne. 0) call tmmksm(.true.)
          if (couple) then
            call twcpin(lcseq, eflag)
            call tmderi(tt, disp0, rtp)
          else
            call twbtin(lcseq, .true., eflag)
          endif
          if (eflag) go to 80
        endif

*---- Update initial values from command attributes.
        call twfill(lccmd)

*---- Initial values of BETX and BETY must not be zero.
        if (betx0 .eq. 0.0  .or. bety0 .eq. 0.0) then
          call aafail('TWISS', 1,
     +      'Both initial BETX and BETY should be non-zero.')
          go to 80
        endif
        en0 = ener_st
*---- Build table of lattice functions, coupled.
        if (couple) then
          call twcpgo(.true., tape, idisk)

*---- Build table of lattice functions, uncoupled.
        else
          call twbtgo(.true., tape, idisk)

*---- List chromatic functions.
          if (chrom) then
            call twchgo(.true., tape, idisk)
          endif
        endif

*---- Build global values table.
+if doom
        call dmopt3(-1)
+ei
        if (ltwsum .ne. 0) call twsmsv(2, idelta)
   80   continue
   90 continue

*---- Reset delta(p)/p to zero.
      deltas = 0.0
      call enfreq(deltas)

*---- Close disk file.
      if (tape) then
        call flclos(idisk, error)
        if (.not. error) then
          call flname(idisk, filnam)
          msg(1) = 'Lattice functions written on file: ' // filnam
          call aainfo('TWISS', 1, msg)
        endif
      endif
*---- Drop LINE condition bank.
      if (ltwlin .ne. 0) call lndrop(ltwlin)

*---- Close lattice function table.
      if (ltwfun .ne. 0) call twbtsv(4, 0)

*---- Close global values table.
      if (ltwsum .ne. 0) call twsmsv(4, 0)
 9999 end
+dk twmain
      subroutine twmain(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Switch routine (subprocess code) for Twiss section.                *
* Input:                                                               *
*   IPR       (integer) Process code.                                  *
*   ISP       (integer) Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca beam
+ca optic0
+ca twlink
+ca wstack
      integer ipr,isp,itwflg

      data itwflg       / 0 /

      if (itwflg .eq. 0) then
        call mzlink(0, '/TWLINK/', ltwlin, ltwlin, ltwsum)
        itwflg = 1
      endif

*---- User-defined services.
      if (isp .le. 0  .or.  isp .gt. 40) then
        call usercm(ipr, isp)

*---- ISP = 1, TWISS.
      else if (isp .eq. 1) then
        call twiss

*---- ISP = 2, OPTICS.
      else if (isp .eq. 2) then
        call twoptc

*---- ISP = 5, NORMAL.
      else if (isp .eq. 3) then
        call emnorm

*---- ISP = 6, EMIT.
      else if (isp .eq. 4) then
        call ememdo

*---- ISP = 7, EIGEN.
      else if (isp .eq. 5) then
        call emevdo

*---- ISP = 8, ENVELOPE.
      else if (isp .eq. 6) then
        call emendo

*---- ISP = 9, TWISS3
      else if (isp .eq. 7) then
        call emtwdo

*---- ISP = 11, BMPM
      else if (isp .eq. 21) then
        call bmmain

*---- ISP = 12, IBS.
      else if (isp .eq. 22) then
        call twibs

*---- ISP = 13, SECTORMAP
      else if (isp .eq. 23) then
        call twsmap
      endif

*---- Save computed quantities.
      if (isp .ge. 1  .and.  isp .le. 10) then
        call aasetp('QX',   qx)
        call aasetp('QY',   qy)
        call aasetp('QS',   qs)
        call aasetp('QX''', xix)
        call aasetp('QY''', xiy)
        call aasetp('ALFX', alfx0)
        call aasetp('ALFY', alfy0)
        call aasetp('BETX', betx0)
        call aasetp('BETY', bety0)
        call aasetp('X0',   orbit0(1))
        call aasetp('PX0',  orbit0(2))
        call aasetp('Y0',   orbit0(3))
        call aasetp('PY0',  orbit0(4))
        call aasetp('T0',   orbit0(5))
        call aasetp('PT0',  orbit0(6))
      endif

*---- Drop working space.
      iwork = 0
      nwork = 0
      call mzwork(0, dq(1), dq(1), - 1)

      end
+dk twopgo
      subroutine twopgo(cent, list)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Selective Twiss output.                                            *
* Input:                                                               *
*   CENT      (logical) True if values desired at centres.             *
*   LIST      (logical) True if listing is desired.                    *
* Important common data:                                               *
*             /MAPELM/  Element transfer map.                          *
*             /MAPTRN/  One turn transfer map.                         *
*             /OPTIC0/  Initial values.                                *
*             /OPTIC1/  Current values.                                *
*   LCELM     /REFER/   Current element bank.                          *
*   LCALI     /REFER/   Current misalignment pointer.                  *
*   LCFLD     /REFER/   Current field error pointer.                   *
*   LCSEQ     /REFER/   Current beam line sequence bank.               *
*----------------------------------------------------------------------*
* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Added ENER1 to set the initial energy value for twiss calculation;  *
*   did not include energy values in output; modified optics tracking  *
*   to include energy                                                  *
* Modified: 01-APR-1999, M. Woodley (SLAC)                             *
*   Set ENER1=EN0                       if ENER0=0                     *
*----------------------------------------------------------------------*
+ca aparam
      integer icode,ienum,iflag,iform,iocc,ipos,jbit,jbyt
      double precision el,fract,half,twopi,utwopi,zero
      logical           cent, list
+ca memdum
+ca bankhead
+ca markbits
+ca seqflag
+ca seqgroup
+ca message
+ca beam
+if doom
+ca dmcommon
+ei
+ca mapelm
+ca maptrn
+ca optic1
+ca optic0
+ca option
+ca range
+ca refer
+ca status
+ca stflag
+ca twlink

+ca pi
      parameter         (twopi = 2.0 * pi, utwopi = 1.0 / twopi)
      parameter         (zero  = 0.0d0, half = 0.5d0)
      logical           fmap, fprt
      character*(mcnam) elmnam, eltab(4), extab(4)

*---- Retrieve beam line description.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Initial values for lattice functions.
      betx = betx0
      alfx = alfx0
      amux = amux0
      bety = bety0
      alfy = alfy0
      amuy = amuy0
      call ucopy(orbit0, orbit, 6*mwflt)
      call ucopy(disp0, disp, 6*mwflt)
      suml = zero

*---- Initial values for chromatic functions.
      wx   = wx0
      phix = phix0
      dmux = dmux0
      wy   = wy0
      phiy = phiy0
      dmuy = dmuy0
      call ucopy(ddisp0, ddisp, 6*mwflt)

      ener1 = ener0
      if (ener1 .eq. zero .or. .not. ereset) ener1 = en0

*---- Loop over positions.
      cplxy = .false.
      cplxt = .false.
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
+if doom
        currocct = iocc
        currname = elmnam
+ei
        fprt = jbit(iflag,moptc) .ne. 0
        icode = jbyt(iflag,1,mcode)

*==== Physical elements.
        if (icode .eq. 1) then

*---- Names for CENTRE or EXIT.
          eltab(1) = elmnam
          lckey = lq(lcelm+1)
          call diname(ldkey, iq(lckey+mbnam), eltab(2))
          lccls = lq(lcelm-iq(lcelm+mbat)-mbecls)
          if (jbit(iq(lcelm),mxcls) .ne. 0  .or.  lccls .eq. 0)
     +      lccls = lcelm
          call diname(ldbnk, iq(lccls+mbnam), eltab(3))
          eltab(4) = '~'

*---- Names for SPLIT.
          call utgnam(lcelm, 1, 1, eltab(4))
          extab(1) = '~'
          extab(2) = 'SPLIT'
          extab(3) = elmnam
          extab(4) = '~'

*---- Misalignment at entrance.
          if (lcali .ne. 0) then
            call tmali1(ipos, .true., orbit, orbit, re, te)
            call twbttk(.true., .false.)
          endif

*---- Output at selected split position(s).
          lcspl = 0
          if (lq(lcseq-msspl) .ne. 0) lcspl = lq(lq(lcseq-msspl)-ipos)

*---- Output for SPLIT fractions in first half of element.
   10     if (lcspl .ne. 0) then
            call ucopy(q(lcspl+mwnam+3), fract, mwflt)
            if (fract .lt. half) then
              call uhtoc(q(lcspl+2), mcwrd, extab(1), mcnam)
              call twopsv(2, 3, extab, fract)
              lcspl = lq(lcspl)
              go to 10
            endif
          endif

*---- Output for CENTRE option.
          if (fprt .and. cent) then
            call twopsv(2, 3, eltab, half)
          endif

*---- Output for SPLIT fractions in second half of element.
   20     if (lcspl .ne. 0) then
            call ucopy(q(lcspl+mwnam+3), fract, mwflt)
            call uhtoc(q(lcspl+2), mcwrd, extab(1), mcnam)
            call twopsv(2, 3, extab, fract)
            lcspl = lq(lcspl)
            go to 20
          endif

*---- Find transfer map and move through element.
          call tmmap(.true., .true., orbit, fmap, el, ek, re, te)
          if (fmap) then
            suml = suml + el
            call twbttk(.true., .true.)
          endif

*---- Misalignment at exit.
          if (lcali .ne. 0) then
            call tmali2(ipos, .true., orbit, orbit, re, te)
            call twbttk(.true., .false.)
          endif

*---- Output at exit of element.
          if (fprt  .and.  .not. cent) call twopsv(2, 2, eltab, zero)

*==== Entrance of line.
        else if (icode .eq. 2) then
          if (fprt) then
            eltab(1) = elmnam
            eltab(2) = 'LINE'
            eltab(3) = 'LINE'
            eltab(4) = '~'
            call twopsv(2, 1, eltab, zero)
          endif
          if (lcali .ne. 0) then
            call tmali1(ipos, .true., orbit, orbit, re, te)
            call twbttk(.true., .false.)
          endif

*==== Exit of line.
        else
          if (lcali .ne. 0) then
            call tmali2(ipos, .true., orbit, orbit, re, te)
            call twbttk(.true., .false.)
          endif
          if (fprt) then
            eltab(1) = elmnam
            eltab(2) = 'LINE'
            eltab(3) = 'LINE'
            eltab(4) = '~'
            call twopsv(2, 1, eltab, zero)
          endif
        endif

*---- Fill in SAVEBETA command, if any.
        if (jbit(iflag,msbet) .ne. 0) call twsbet(ipos, .false.)
   90 continue

*---- Compute summary data.
      call twsumm(symm, nsup)
+if doom
      call dmopt3(0)
+ei
      iform = 3
      if (double) iform = mreal
      call tbpdsc(ltwopt, 'DELTA',  iform, 0, deltas, ' ')
      call tbpdsc(ltwopt, 'CIRCUM', mreal, 0, circ,   ' ')
      call tbpdsc(ltwopt, 'QX',     iform, 0, qx,     ' ')
      call tbpdsc(ltwopt, 'QY',     iform, 0, qy,     ' ')
      call tbpdsc(ltwopt, 'XIX',    iform, 0, xix,    ' ')
      call tbpdsc(ltwopt, 'XIY',    iform, 0, xiy,    ' ')
      if (.not. inval) then
        call tbpdsc(ltwopt, 'ALFA',   iform, 0, alfa,   ' ')
        call tbpdsc(ltwopt, 'GAMTR',  iform, 0, gamtr,  ' ')
      endif

*---- Warn if machine is coupled.
      if (cplxy) then
        write (msg, 910) deltas
        call aawarn('TWOPGO', 2, msg)
      endif
      if (cplxt .or. dorad) then
        write (msg, 920)
        call aawarn('TWOPGO', 2, msg)
      endif

  910 format('OPTICS found transverse coupling for delta(p)/p =',f12.6/
     +       'results may be wrong.')
  920 format('OPTICS uses the RF system and synchrotron radiation ',
     +       'only to find the closed orbit.'/
     +       'for optical calculations it ignores both.')

      end
+dk twopsv
      subroutine twopsv(iflag, kflag, ctab, fract)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Build OPTICS table.                                                *
* Input:                                                               *
*   IFLAG     (integer) Operation desired.                             *
*                       1: Create new table.                           *
*                       2: Save one line.                              *
*                       4: Close table.                                *
*   KFLAG     (integer) Type of output requested:                      *
*                       1: No extrapolation, no element data.          *
*                       2: No extrapolation, but element data.         *
*                       3: Extrapolation and element data.             *
*   CTAB(*)   (char)    For IFLAG = 1: Columns selected.               *
*                       For IFLAG = 2: Character info to be output.    *
*   FRACT     (real)    Fraction of element for interpolation.         *
*----------------------------------------------------------------------*
* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   LCAV handling at statement number 270 HOWEVER attributes are not   *
*   correct; modified optics tracking similar to that in TWBTTK        *
* Modified: 11-JAN-1999, T. Raubenheimer (SLAC)                        *
*   Included FINTX attribute in RBEND, SBEND, and GBEND (NOTE: FINTX   *
*   is assumed to have same value as FINT if it is not set or is       *
*   negative as is the default in the dictionary file) (NOTE: FINTX    *
*   parameter does NOT work properly here!!!); added warning about     *
*   incorrect operation with FINTX                                     *
* Modified: 25-MAR-1999, M. Woodley (SLAC)                             *
*   Fix pointer to FINTX parameter                                     *
* Modified: 10-SEP-1999, M. Woodley (SLAC)                             *
*   Use the determinant of the longitudinal 2x2 part of the R-matrix   *
*   instead of R(6,6) for the energy scaling.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer i,idata,iflag,ileng,ipos,isp,j,jbias,jform,jtab,k,kflag,
     +ktab,ltemp,maxcol,mnorm,mskew,mtwrow,nb,nc,nd,ne,nr,ns,ntab
      double precision ampl,angl,aux,auxp,ax1,ax2,ay1,ay2,bx1,bx2,by1,
     +by2,corr,ddpx,ddpy,ddx,ddy,delt,dh,dl,dmxx,dmyy,dpx,dpy,dx,dy,e1,
     +e2,efld,ek,el,elag,elrd,ferror,fint,fract,freq,h,h1,h2,harm,hgap,
     +hkik,one,phxx,phyy,proxim,pxco,pyco,radl,re,rep,rw,sk0l,sk1,sk1l,
     +sk2,sk2l,sk3,sk3l,sk4l,sk5l,sk6l,sk7l,sk8l,sk9l,sks,sksl,spos,
     +ss0l,ss1l,ss2l,ss3l,ss4l,ss5l,ss6l,ss7l,ss8l,ss9l,t,t2,ta,table,
     +tb,te,temp,tg,tilt,tw,utwopi,vkik,volt,wxx,wyy,x,xalf,xbet,xco,
     +xkick,xmu,y,yalf,ybet,yco,ykick,ymu,zero,two
      character*(mcnam) ctab(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca elmgroup
+ca seqgroup
+ca message
+ca beam
+ca codata
+ca optic1
+ca option
+ca refer
+ca status
+ca tbpara
+ca twdata
+ca twlink
+ca physicpm
      double precision detl, f, fintx

+ca pi
      parameter         (utwopi = 1.0d0 / (2.0d0 * pi))
      parameter         (nd = 20 * mwflt, mtwrow = 500)
      parameter         (zero = 0.0d0, one = 1.0d0, two = 2.d0)
      parameter         (maxcol = 70)

      logical           fmap
      dimension         ek(6), re(6,6), rep(6,6), rw(6,6), temp(6)
      double precision  fre(6,6), frep(6,6)
      double precision an2
      dimension         aux(6), auxp(6)
      dimension         te(6,6,6), tw(6,6,6)
      dimension         ferror(2,0:9), table(maxcol)
      character*(mcnam) madnam(maxcol), word

      integer           itab(50), iform(50)
      save              ipos, itab, iform, ntab
      integer bvpos
      parameter         (bvpos = 24)
      logical bvflag
      equivalence
     +    (xbet, table( 5)), (xalf, table( 6)), (xmu,  table( 7)),
     +    (ybet, table( 8)), (yalf, table( 9)), (ymu,  table(10)),
     +    (xco,  table(11)), (pxco, table(12)),
     +    (yco,  table(13)), (pyco, table(14)),
     +    (dx,   table(15)), (dpx,  table(16)),
     +    (dy,   table(17)), (dpy,  table(18)),
     +    (wxx,  table(19)), (phxx, table(20)), (dmxx, table(21)),
     +    (wyy,  table(22)), (phyy, table(23)), (dmyy, table(24)),
     +    (ddx,  table(25)), (ddpx, table(26)),
     +    (ddy,  table(27)), (ddpy, table(28)), (elrd, table(29))
      equivalence
     +    (delt, table(31)), (spos, table(32)), (radl, table(33)),
     +    (el,   table(34)), (volt, table(35)), (elag, table(36)),
     +    (freq, table(37)), (harm, table(38)), (tilt, table(39)),
     +    (sksl, table(40)), (hkik, table(41)), (vkik, table(42)),
     +    (e1,   table(43)), (e2,   table(44)), (h1,   table(45)),
     +    (h2,   table(46)), (efld, table(47))
      parameter (mnorm = 51, mskew = 61)
      equivalence
     +    (sk0l, table(51)), (sk1l, table(52)), (sk2l, table(53)),
     +    (sk3l, table(54)), (sk4l, table(55)), (sk5l, table(56)),
     +    (sk6l, table(57)), (sk7l, table(58)), (sk8l, table(59)),
     +    (sk9l, table(60)),
     +    (ss0l, table(61)), (ss1l, table(62)), (ss2l, table(63)),
     +    (ss3l, table(64)), (ss4l, table(65)), (ss5l, table(66)),
     +    (ss6l, table(67)), (ss7l, table(68)), (ss8l, table(69)),
     +    (ss9l, table(70))

      data (madnam(i), i = 1, 30)
     +    / 'NAME',    'KEYWORD', 'CLASS',   'TYPE',
     +      'BETX',    'ALFX',    'MUX',
     +      'BETY',    'ALFY',    'MUY',
     +      'X',       'PX',      'Y',       'PY',
     +      'DX',      'DPX',     'DY',      'DPY',
     +      'WX',      'PHIX',    'DMUX',
     +      'WY',      'PHIY',    'DMUY',
     +      'DDX',     'DDPX',    'DDY',     'DDPY',
     +      'LRAD',    ' ' /
      data (madnam(i), i = 31, 50)
     +    / 'DP',      'S',       'RADLOSS', 'L',
     +      'VOLT',    'LAG',     'FREQ',    'HARMON',
     +      'TILT',    'KS',      'HKICK',   'VKICK',
     +      'E1',      'E2',      'H1',      'H2',      'EFIELD',
     +      ' ',       ' ',       ' ' /
      data (madnam(i), i = 51, 70)
     +    / 'K0L',     'K1L',     'K2L',     'K3L',     'K4L',
     +      'K5L',     'K6L',     'K7L',     'K8L',     'K9L',
     +      'KS0L',    'KS1L',    'KS2L',    'KS3L',    'KS4L',
     +      'KS5L',    'KS6L',    'KS7L',    'KS8L',    'KS9L' /

      proxim(x, y) = (x * utwopi) + anint((y - x) * utwopi)

      bvflag = .false.
*==== Create table.
      if (iflag .eq. 1) then
        ntab = 0
        do 10 jtab = 1, 50
          if (ctab(jtab) .ne. ' ') then
            call utleng(ctab(jtab), ileng)
            call utlook(ctab(jtab)(1:ileng), madnam, maxcol, ktab)
            if (ktab .eq. 0) then
              msg(1) = 'Unknown column name "' // ctab(jtab)(1:ileng)
     +        // '" ignored.'
              call aawarn('TWOPSV', 1, msg)
            else
              ntab = ntab + 1
              ctab(ntab) = madnam(ktab)
              itab(ntab) = ktab
              iform(ntab) = 3
              if (double) iform(ntab) = 4
              if (ktab .le. 4) iform(ntab) = 5
            endif
          endif
   10   continue

*---- Create the table.
        ns = ndelta
        nr = mtwrow
        nc = ntab
        nb = 1
        call tbcrea(optnam, ns, nr, nc, ctab, iform, nb, ltwopt)
        call tbpdsc(ltwopt, 'TYPE', 5, 0, zero, 'OPTICS')
        ipos = 0
+if doom
        call dmopt1(optnam, kflag, ntab, ctab, iform)
+ei
*==== Save one line.
      else if (ltwopt .ne. 0) then
        if (iflag .eq. 2) then

*---- Set up unit map and clear table.
          dl = 0.0
          call uzero(ek, 1, 6*mwflt)
          call m66one(re)
          call uzero(te, 1, 216*mwflt)
          call uzero(table, 1, maxcol*mwflt)

*---- Extract field errors.
          call uzero(ferror, 1, nd)
          if (lcfld .ne. 0) then
            ne = min(iq(lcfld-1), nd)
            call ucopy(q(lcfld+1), ferror, ne)
          endif

*---- Skip extrapolation for beam line entry or exit.
          if (kflag .ne. 1) then

*---- Get length, as well as extrapolation length.
            call ucopy(q(lcelm+melen), el, mwflt)
            dl = fract * el
            isp = iq(lcelm+mbsp)

*---- Select element type.
            go to (110,120,130,140,150,160,170,180,190,200,
     +             210,220,230,240,250,260,270,280,290,300,
     +             310,320,330,340,350,360,370,380,390,400,
     +             410,410,410,410,410,410,410,410,410,410),isp

*---- Drift, Monitor, Collimator, Beam instrument.
  110       continue

*---- LCAV cavity.
  270       continue
              call ucopy(q(lcelm+mevltc), volt, mwflt)
              call ucopy(q(lcelm+mefrqc), freq, mwflt)
              call ucopy(q(lcelm+melagc), elag, mwflt)
              harm = iq(lcelm+mehrmc)
              if (kflag .eq. 3) then
                call tmdrf(.true.,.false.,fract,orbit,fmap,el,ek,re,te)
              endif
            go to 500
  280       continue
  290       continue
  300       continue
  310       continue
  340       continue
            if (kflag .eq. 3) then
              call tmdrf(.true.,.false.,fract,orbit,fmap,el,ek,re,te)
            endif
            go to 500

*---- Bending magnets, RBEND or SBEND.
  120       continue
  130       continue
              call ucopy(q(lcelm+meangb), sk0l, mwflt)
              call ucopy(q(lcelm+mek1b), sk1, mwflt)
              call ucopy(q(lcelm+mek2b), sk2, mwflt)
              call ucopy(q(lcelm+mek3b), sk3, mwflt)
              call ucopy(q(lcelm+mee1b), e1, mwflt)
              call ucopy(q(lcelm+mee2b), e2, mwflt)
              call ucopy(q(lcelm+metltb), tilt, mwflt)
              call ucopy(q(lcelm+meh1b), h1, mwflt)
              call ucopy(q(lcelm+meh2b), h2, mwflt)
              call ucopy(q(lcelm+megapb), hgap, mwflt)
              call ucopy(q(lcelm+meintb), fint, mwflt)
              call ucopy(q(lcelm+meintbx+3*mcsiz), bvflag, 1)
              call ucopy(q(lcelm+meintbx), fintx, mwflt)
              sk0l = sk0l + ferror(1,0)
              sk1l = elmfact(1)*(sk1*el + ferror(1,1))
              sk2l = elmfact(2)*(sk2*el + ferror(1,2))
              sk3l = elmfact(3)*(sk3*el + ferror(1,3))
              sksl = 0.0
*--- HG000915 use bv flag to possibly invert angle
              if (bvflag) sk0l = beambv * sk0l
            go to 365

*---- General bend (dipole, quadrupole, and skew quadrupole).
  360       continue
              call ucopy(q(lcelm+meangg), sk0l, mwflt)
              call ucopy(q(lcelm+mek1g), sk1, mwflt)
              call ucopy(q(lcelm+meksg), sks, mwflt)
              call ucopy(q(lcelm+mee1g), e1, mwflt)
              call ucopy(q(lcelm+mee2g), e2, mwflt)
              call ucopy(q(lcelm+metltg), tilt, mwflt)
              call ucopy(q(lcelm+meh1g), h1, mwflt)
              call ucopy(q(lcelm+meh2g), h2, mwflt)
              call ucopy(q(lcelm+megapg), hgap, mwflt)
              call ucopy(q(lcelm+meintg), fint, mwflt)
              call ucopy(q(lcelm+meintgx), fintx, mwflt)
              call ucopy(q(lcelm+meintgx+3*mcsiz), bvflag, 1)
              sk0l = sk0l + ferror(1,0)
              sk1l = elmfact(1) * (sk1*el + ferror(1,1))
              sk2l = 0.0
              sk3l = 0.0
              ss1l = elmfact(1) * (sks*el + ferror(2,1))
*--- HG000915 use bv flag to possibly invert angle
              if (bvflag) sk0l = beambv * sk0l

*---- Extrapolate to desired position.
  365       continue
              if (kflag .eq. 3  .and.  el .ne. 0.0) then
                if (isp .eq. 2) then
*--- HG001026: arc length to rectangular bend
                  an2 = sk0l / 2.d0
                  if (an2 .ne. 0.d0 .and. rbarc)
     +            el = el * an2 / sin(an2)
                  e1 = e1 + an2
                endif
                h = sk0l / el
                dh = ferror(1,0) / el
                sk1 = sk1l / el
                sk2 = sk2l / el
                sk3 = sk3l / el
                sks = sksl / el

                corr = (h + h) * hgap * fint
*---- Tor: warn user that TWOPSV and TWOPGO do not handle FINTX
*     correctly.
                if (fintx .gt. zero) then
                  msg(1) = 'OPTICS command does not handle FINTX '
     +                     //'attribute correctly'
                  call aawarn ('TWOPSV', 1, msg)
                endif
                call tmfrng(.true.,h,sk1,e1,h1,one,corr,ek,re,te)
                if (isp .ne. 26) then
                  call tmsect(.true.,dl,h,dh,sk1,sk2,ek,rw,tw)
                else
                  call tmgsec(.true.,dl,h,dh,sk1,sks,ek,rw,tw)
                endif
                call tmcat(.true.,rw,tw,re,te,re,te)
                if (tilt .ne. 0.0) call tmtilt(.true.,tilt,ek,re,te)
              endif
              if (el .ne. 0.0) then
                radl = - 2.0 * arad * charge * gammas**3 * sk0l**2 /
     +          (3.0 * el)
              endif
            go to 500

*---- Quadrupole.
  150       continue
              call ucopy(q(lcelm+mek1q), sk1, mwflt)
              call ucopy(q(lcelm+metltq), tilt, mwflt)
              sk1l = elkfact(5) * (sk1*el + ferror(1,1))
              if (kflag .eq. 3) then
                call tmquad(.true.,.false.,fract,orbit,fmap,el,ek,re,te)
              endif
            go to 500

*---- Sextupole.
  160       continue
              call ucopy(q(lcelm+mek2s), sk2, mwflt)
              call ucopy(q(lcelm+metlts), tilt, mwflt)
              sk2l = elkfact(6) * (sk2*el + ferror(1,2))

              if (kflag .eq. 3) then
                call tmsext(.true.,.false.,fract,orbit,fmap,el,ek,re,te)
              endif
            go to 500

*---- Octupole.
  170       continue
              call ucopy(q(lcelm+mek3o), sk3, mwflt)
              call ucopy(q(lcelm+metlts), tilt, mwflt)
              sk3l = elkfact(7) * (sk3*el + ferror(1,3))

              if (kflag .eq. 3) then
                call tmoct(.true.,.false.,fract,orbit,fmap,el,ek,re,te)
              endif
            go to 500

*---- Multipole.
  180       continue
              idata = meklm
              call utglog(lcelm, bvpos, bvpos, bvflag)
              call ucopy(q(lcelm+idata), ampl, mwflt)
              idata = idata + mcsiz
              call ucopy(q(lcelm+idata), angl, mwflt)
              idata = idata + mcsiz
              table(mnorm) = ferror(1,0) + ampl * cos(angl)
              table(mskew) = ferror(2,0) + ampl * sin(angl)
              if (bvflag) then
                table(mnorm) = beambv * table(mnorm)
                table(mskew) = beambv * table(mskew)
              endif
              do i = 1, 9
                call ucopy(q(lcelm+idata), ampl, mwflt)
                idata = idata + mcsiz
                call ucopy(q(lcelm+idata), angl, mwflt)
                idata = idata + mcsiz
                angl = real(i+1) * angl
                table(i+mnorm) = ferror(1,i) + ampl * cos(angl)
                table(i+mnorm) = elmfact(i) * table(i+mnorm)
                table(i+mskew) = ferror(2,i) + ampl * sin(angl)
                table(i+mskew) = elmfact(i) * table(i+mskew)
              enddo

*---- Radiation loss.
              if (el .ne. 0.0) then
                radl = - 2.0 * arad * charge * gammas**3 *
     +            (sk0l**2 + ss0l**2) / (3.0 * el)
              endif
              el = 0.0
              call ucopy(q(lcelm+melen), elrd, mwflt)
            go to 500

*---- Solenoid.
  190       continue
              call ucopy(q(lcelm+mekss), sks, mwflt)
              sksl = sks * el
              if (kflag .eq. 3) then
                call tmsol(.true.,.false.,fract,orbit,fmap,el,ek,re,te)
              endif
            go to 500

*---- RF cavity.
  200       continue
              call ucopy(q(lcelm+mevltc), volt, mwflt)
              call ucopy(q(lcelm+mefrqc), freq, mwflt)
              call ucopy(q(lcelm+melagc), elag, mwflt)
              harm = iq(lcelm+mehrmc)
              if (kflag .eq. 3) then
                call tmdrf(.true.,.false.,fract,orbit,fmap,el,ek,re,te)
              endif
            go to 500

*---- Electrostatic separator.
  210       continue
              call ucopy(q(lcelm+meflde), efld, mwflt)
              call ucopy(q(lcelm+metlte), tilt, mwflt)
              if (kflag .eq. 3) then
                call tmsep(.true.,.false.,fract,orbit,fmap,el,ek,re,te)
              endif
            go to 500

*---- No extrapolation for the following:
*       Arbitrary matrix, rotations, markers, beam-beam, lump, reserved.
  140       continue
  220       continue
  230       continue
  320       continue
  330       continue
  350       continue
  370       continue
  380       continue
  390       continue
  400       continue
  410       continue
            el = 0.0
            go to 500

*---- Corrector.
  240       continue
  250       continue
  260       continue

*---- Original setting.
              if (isp .eq. 14) then
                call ucopy(q(lcelm+mekick), xkick, mwflt)
                call ucopy(q(lcelm+mekick+mcsiz), bvflag, 1)
                ykick = 0.0
              else if (isp .eq. 16) then
                xkick = 0.0
                call ucopy(q(lcelm+mekick), ykick, mwflt)
                call ucopy(q(lcelm+mekick+mcsiz), bvflag, 1)
              else
                call ucopy(q(lcelm+mekick), xkick, mwflt)
                call ucopy(q(lcelm+mekick+mcsiz), ykick, mwflt)
                call ucopy(q(lcelm+mekick+2*mcsiz), bvflag, 1)
              endif

*---- Correction from C.O. correction algorithm.
              if (lccom .ne. 0) then
                call ucopy(q(lccom+1), xcm, 2*mwflt)
              else
                xcm = 0.0
                ycm = 0.0
              endif

*---- Store sum of original setting and correction.
              hkik = xcm + xkick + ferror(1,0)
              vkik = ycm + ykick + ferror(2,0)
*--- HG000915 use bv flag to possibly invert angle
              if (bvflag) then
                hkik = beambv * hkik
                vkik = beambv * vkik
              endif

*---- Extrapolate.
              if (kflag .eq. 3) then
                call tmcorr(.true.,.false.,fract,orbit,fmap,el,ek,re,te)
              endif
            go to 500

  500       continue
          endif

*---- Track orbit to desired position.
          if (fmap) then
            call tmtrak(ek, re, te, orbit, temp)
          else
            call ucopy(orbit, temp, 6*mwflt)
          endif

*---- Longitudinal position and energy error.
          spos = suml + fract * el
          delt = orbit(6)

*---- Dispersion.
          do 530 i = 1, 6
            aux(i) = 0.0
            auxp(i) = 0.0
            do 520 k = 1, 6
              t = 0.0
              do 510 j = 1, 6
                t = t + te(i,j,k) * disp(j)
  510         continue
              aux(i) = aux(i) + re(i,k) * disp(k)
              auxp(i) = auxp(i) + t * disp(k) + re(i,k) * ddisp(k)
              rep(i,k) = 2.0 * t
  520       continue
  530     continue
          call ucopy(aux, dx, 4*mwflt)
          call ucopy(auxp, ddx, 4*mwflt)

*---- Tor/MDW: scale by square root of the determinant of the
*     longitudinal 2x2 part of the R-matrix
          detl = re(5,5)*re(6,6) - re(5,6)*re(6,5)
          f = one / sqrt(detl)
          call m66scl(f, re, fre)
          call m66scl(f, rep, frep)

*---- Horizontal lattice functions including energy scaling.
          if (stabx) then
            tb = fre(1,1)*betx - fre(1,2)*alfx
            ta = fre(2,1)*betx - fre(2,2)*alfx
            t2 = tb**2 + fre(1,2)**2
            tg = fre(1,1)*alfx - fre(1,2)*(one + alfx**2) / betx

*---- Linear functions.
            xalf = - (tb*ta + fre(1,2)*fre(2,2)) / betx
            xbet = t2 / betx
            xmu = (amux + atan2(fre(1,2), tb)) * utwopi
            if (re(1,2) .lt. zero) xmu = xmu + one

*---- Chromatic functions.
            bx1 = wx*cos(phix)
            ax1 = wx*sin(phix)
            bx2 = ((tb**2 - fre(1,2)**2)*bx1
     +          - two*tb*fre(1,2)*ax1) / t2
     +          + two*(tb*frep(1,1) - tg*frep(1,2)) / xbet
            ax2 = ((tb**2 - fre(1,2)**2)*ax1
     +            + two*tb*fre(1,2)*bx1) / t2
     +          - (tb*(frep(1,1)*xalf + frep(2,1)*xbet)
     +          - tg*(frep(1,2)*xalf + frep(2,2)*xbet)
     +          + fre(1,1)*frep(1,2) - fre(1,2)*frep(1,1)) / xbet
            wxx = sqrt(ax2**2 + bx2**2)
            if (wxx .gt. 1.0d-8) phxx = proxim(atan2(ax2, bx2), phix)
            dmxx = (dmux + fre(1,2)*(fre(1,2)*ax1 - tb*bx1) / t2
     +           + (fre(1,1)*frep(1,2) - fre(1,2)*frep(1,1)) / xbet)
     +           * utwopi
          else
            xalf = zero
            xbet = zero
            xmu = zero
            wxx = zero
            phxx = zero
            dmxx = zero
          endif

*---- Vertical lattice functions including energy scaling.
          if (staby) then
            tb = fre(3,3)*bety - fre(3,4)*alfy
            ta = fre(4,3)*bety - fre(4,4)*alfy
            t2 = tb**2 + fre(3,4)**2
            tg = fre(3,3)*alfy - fre(3,4)*(one + alfy**2) / bety

*---- Linear functions.
            yalf = - (tb*ta + fre(3,4)*fre(4,4)) / bety
            ybet = t2 / bety
            ymu = (amuy + atan2(fre(3,4), tb)) * utwopi
            if (re(3,4) .lt. zero) ymu = ymu + one

*---- Chromatic functions.
            by1 = wy*cos(phiy)
            ay1 = wy*sin(phiy)
            by2 = ((tb**2 - fre(3,4)**2)*by1
     +            - two*tb*fre(3,4)*ay1) / t2
     +          + two*(tb*frep(3,3) - tg*frep(3,4)) / ybet
            ay2 = ((tb**2 - fre(3,4)**2)*ay1
     +            + two*tb*fre(3,4)*by1) / t2
     +          - (tb*(frep(3,3)*yalf + frep(4,3)*ybet)
     +          - tg*(frep(3,4)*yalf + frep(4,4)*ybet)
     +          + fre(3,3)*frep(3,4) - fre(3,4)*frep(3,3)) / ybet
            wyy = sqrt(ay2**2 + by2**2)
            if (wyy .gt. 1.0d-8) phyy = proxim(atan2(ay2, by2), phiy)
            dmyy = (dmuy + fre(3,4)*(fre(3,4)*ay1 - tb*by1) / t2
     +           + (fre(3,3)*frep(3,4) - fre(3,4)*frep(3,3)) / ybet)
     +           * utwopi
          else
            yalf = zero
            ybet = zero
            ymu = zero
            wyy = zero
            phyy = zero
            dmyy = zero
          endif
*---- Closed orbit.
          xco  = 1000.0 * temp(1)
          pxco = 1000.0 * temp(2)
          yco  = 1000.0 * temp(3)
          pyco = 1000.0 * temp(4)

*---- Increase table size, if so required.
          ipos = ipos + 1
          if (ipos .gt. iq(ltwopt+mtbrow)) then
            ltemp = lq(ltwopt-mtbbky)
            call mzpush(0, ltemp, mtwrow, mtwrow, 'I')
            iq(ltwopt+mtbrow) = iq(ltwopt+mtbrow) + mtwrow
          endif

*---- Store table line.
          call tbset(ltwopt, ipos, 3, ltwbuf)
          do 610 jtab = 1, ntab
            jform = iq(lq(ltwopt-mtbcfm)+jtab)
            jbias = iq(lq(ltwopt-mtbcps)+jtab)
            if (jform .eq. 3) then
              q(ltwbuf+jbias+1) = table(itab(jtab))
            else if (jform .eq. 4) then
              call ucopy(table(itab(jtab)), q(ltwbuf+jbias+1), mwflt)
            else
              word = ctab(itab(jtab))
              call uctoh(word, iq(ltwbuf+jbias+1), mcwrd, mcnam)
            endif
  610     continue
+if doom
          call dmopt2(ntab, itab, iform, table)
+ei
*==== Close table.
        else if (iflag .eq. 4) then
          call tbclos(ltwopt)
+if doom
          call dmopt4
+ei
        endif
      endif

      end
+dk twoptc
      subroutine twoptc
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   OPTICS command: Selective output of linear lattice parameters.     *
* Attributes, must be given in this order in the dictionary:           *
*   BETX      (real)    Horizontal beta.                        ( 1)   *
*   ALFX      (real)    Horizontal alfa.                        ( 2)   *
*   MUX       (real)    Horizontal phase.                       ( 3)   *
*   BETY      (real)    Vertical beta.                          ( 4)   *
*   ALFY      (real)    Vertical alfa.                          ( 5)   *
*   MUY       (real)    Vertical phase.                         ( 6)   *
*   X         (real)    Horizontal position for closed orbit.   ( 7)   *
*   PX        (real)    Horizontal momentum for closed orbit.   ( 8)   *
*   Y         (real)    Vertical position for closed orbit.     ( 9)   *
*   PY        (real)    Vertical momentum for closed orbit.     (10)   *
*   T         (real)    Longitudinal position for closed orbit. (11)   *
*   PT        (real)    Momentum error for closed orbit.        (12)   *
*   DX        (real)    Horizontal dispersion.                  (13)   *
*   DPX       (real)    Disperstion for horizontal momentum.    (14)   *
*   DY        (real)    Vertical dispersion.                    (15)   *
*   DPY       (real)    Dispersion for vertical momentum.       (16)   *
*----------------------------------------------------------------------*
*   WX        (real)    Horizontal chromatic amplitude.         (17)   *
*   PHIX      (real)    Horizontal chromatic phase.             (18)   *
*   DMUX      (real)    Chromatic derivative of hor. phase.     (19)   *
*   WY        (real)    Vertical chromatic amplitude.           (20)   *
*   PHIY      (real)    Vertical chromatic phase.               (21)   *
*   DMUY      (real)    Chromatic derivative of vert. phase.    (22)   *
*   DDX       (real)    Second-order horizontal dispersion.     (23)   *
*   DDPX      (real)    Second-order dispersion for hor. mom.   (24)   *
*   DDY       (real)    Second-order vertical dispersion.       (25)   *
*   DDPY      (real)    Second-order dispersion for vert. mom.  (26)   *
*----------------------------------------------------------------------*
*   ENER1      (real)    Energy value                            (27)   *
*----------------------------------------------------------------------*
*   CENTRE    (logical) True, if values are desired at centres. (28)   *
*   LINE      (line)    Line for initial conditions.            (29)   *
*   BETA0     (name)    Bank for initial conditions.            (30)   *
*   FILENAME  (string)  File name for OPTICS results.           (31)   *
*   DELTAP    (real)    Momentum error (single value).          (32)   *
*   COLUMN(50)(name)    Selected table column names.            (33)   *
*----------------------------------------------------------------------*
* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Add ENERGY attribute; change MAXTWS=26 to MAXTWS=27                *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca seqgroup
+ca strgroup
+ca message
+ca beam
+ca maptrn
+ca optic0
+ca refer
+ca status
+ca twdata
+ca twlink
+if doom
+ca dmcommon
+ei
      integer ibeta,ibetx,ibety,idum,ileng,iline,iunit,jtb,maxtws,mbeta,
     +mcent,mcols,mdelta,mfile,mline
      double precision deltap,rdum

      parameter         (maxtws = 27)
      logical           betflg, cent, eflag, linflg
      character *(mcnam) seqnm
      character*(mcnam) ctab(50), twsnam(2)
      character*(mcfil) strnam, filnam
      parameter         (mcent  = maxtws + 1, mline  = maxtws + 2,
     +                   mbeta  = maxtws + 3, mfile  = maxtws + 5,
     +                   mdelta = maxtws + 6, mcols  = maxtws + 7)

*==== PHASE 1: Check data.
*---- Check main beam line.
      call lnchck('OPTICS', error)
      if (error) go to 9999

*---- CENTRE flag.
      cent = .false.
      call utglog(lccmd, mcent, mcent, cent)

*---- Names for BETA0.
      twsnam(1) = ' '
      twsnam(2) = ' '
      call utgnam(lccmd, mbeta, mbeta+1, twsnam)
      betnam = twsnam(1)
      betflg = betnam .ne. ' '
      seqnm = twsnam(2)
      if (seqnm .ne. ' ')  call get_active(seqnm, 'TWOPTC')

*---- File for TFS output.
      strnam = 'optics'
      call utgstr(lccmd, mfile, mfile, strnam)
      optnam = 'OPTICS'

*---- Flag BETA0 and LINE attributes.
      iline = mbat + (mline - 1) * mcsiz
      linflg = mod(iq(lccmd+iline+mctyp),10) .ne. 0
      if (betflg) then
        call utleng(betnam, ileng)
        call difind(ldbnk, betnam(1:ileng), ibeta, ltwbet)
        if (ltwbet .eq. 0) then
          msg(1) = 'Initial BETA0 bank "' // betnam(1:ileng)
     +    // '" not found.'
          call aafail('TWOPTC', 1, msg)
        else if (iq(ltwbet+mbpr) .ne. mpenv  .or.
     +           iq(ltwbet+mbsp) .ne. 2) then
          msg(1) = '"' // betnam(1:ileng) // '" is not a "BETA0" bank.'
          call aafail('TWOPTC', 1, msg)
        else if (linflg) then
          call aafail('TWOPTC', 1,
     +    'Conflicting options BETA0 and LINE have been specified.')
        endif
      endif

*---- Momentum error value.
      deltap = 0.0
      call utgflt(lccmd, mdelta, mdelta, deltap)
      ndelta = 1
      chrom  = .false.
      couple = .false.

*---- Selected column names.
      do 30 jtb = 1, 50
        ctab(jtb) = ' '
   30 continue
      call utgnam(lccmd, mcols, mcols+49, ctab)

*==== PHASE 2: Initialize flags, tables, and files.
      if (error) go to 9999

*---- Prepare sequence for LINE option.
      if (linflg) then
        call lnrefe(lccmd, mline, ltwlin, lroot, -minit)
      endif

*---- Initial value flag.
      ibetx = mbat
      ibety = mbat + 3 * mcsiz
      inval = (mod(iq(lccmd+ibetx+mctyp),10) .ne. 0  .and.
     +         mod(iq(lccmd+ibety+mctyp),10) .ne. 0)  .or.
     +        betflg  .or.  linflg

*---- Open table to save selected functions.
      call twopsv(1, idum, ctab, rdum)

*---- Set up RF system.
      call enfix
      call enfreq(deltap)

*==== PHASE 3: Perform computation for all momentum errors requested.
      if (error) go to 9999
      call uzero(betx0, 1, 30*mwflt)
      disp0(5) = 0.0
      disp0(6) = 1.0

*---- Initial values from command attributes.
      if (inval) then
        stabx = .true.
        staby = .true.

*---- LINE attribute.
        if (linflg) then
          call tmturn(ltwlin, deltas, eflag)
          if (eflag) go to 90
          call twbtin(ltwlin, .true., eflag)
          if (eflag) go to 90

*---- BETA0 attribute.
        else if (betflg) then
          call twfill(ltwbet)
        endif
        call tmscnd(lcseq)
        call tmderi(tt, disp0, rtp)

*---- Initial values from periodic solution.
      else
        call tmturn(lcseq, deltas, eflag)
        if (iq(lcseq+msym) .ne. 0) call tmmksm(.true.)
        call twbtin(lcseq, .true., eflag)
        if (eflag) go to 90
      endif

*---- Update initial values from command attributes.
      call twfill(lccmd)

*---- Track lattice functions and build table.
      call twopgo(cent, .true.)

*---- Drop LINE condition bank.
      if (ltwlin .ne. 0) call lndrop(ltwlin)

*---- Close table.
   90 continue
      call twopsv(4, idum, ctab, rdum)

+if doom
      if (.not. strict)  then
+ei
*---- Write table on TFS file.
      call flopen(strnam, 'SWFD', 0, 0, iunit, eflag)
      if (.not. eflag) then
        call flname(iunit, filnam)
        call tbwtfs(optnam, iunit)
        call flclos(iunit, error)
        if (.not. error) then
        msg(1) = 'Lattice functions written on file: ' // filnam
        call aainfo('TWOPTC', 1, msg)
        endif
        call tbopen(optnam, 0, ltwopt)
        call tbdrop(ltwopt)
      endif
+if doom
      endif
+ei

 9999 end
+dk twsbet
      subroutine twsbet(ipos, fsec)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save lattice functions for subsequent TWISS, in a BETA0 bank       *
* Input:                                                               *
*   IPOS      (integer) Position where BETA0 bank is linked.           *
*   FSEC      (logical) If true, store also chromatic functions.       *
*----------------------------------------------------------------------*
* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Added energy to BETA0 bank; added warning if chromatic functions   *
*   are not set                                                        *
*----------------------------------------------------------------------*
+ca aparam
      integer ikey,ipos
      double precision twopi
      logical           fsec
+ca memdum
+ca message
+ca optic1
+ca refer
+ca twlink

+ca pi
      parameter         (twopi = 2.0d0 * pi)

*---- Search for desired BETA0 bank chain.
      call difind(ldkey, 'BETA0', ikey, lckey)
      ltwbet = lq(lckey-1)
*---- Loop to store in proper bank(s).
   10 if (ltwbet .ne. 0) then
        if (iq(ltwbet-5) .eq. ipos) then

*---- Store lattice functions.
          amux = amux / twopi
          amuy = amuy / twopi
          call utpflt(ltwbet, 1, 6, betx)
          amux = amux * twopi
          amuy = amuy * twopi
          call utpflt(ltwbet, 7, 12, orbit)
          call utpflt(ltwbet, 13, 16, disp)
          if (fsec) then
            call utpflt(ltwbet, 17, 22, wx)
            call utpflt(ltwbet, 23, 26, ddisp)
          else
            msg(1) = 'Chromatic functions in BETA0 are zero.'
            msg(2) = 'Use CHROM option to get non-zero values.'
            call aawarn ('TWSBET', 2, msg)
          endif
          call utpflt(ltwbet, 27, 27, ener1)

*---- Go to next bank.
        endif
        ltwbet = lq(ltwbet)
        go to 10
      endif

      end
+dk twsint
      subroutine twsint(betax, betay, alx, dx, dpx, txi, tyi, tli)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Subroutine uses Simpson's rule integration                         *
*   to calculate Bjorken/Mtingwa integrals (eqn. 3.4)                  *
*   Particle Accelerators 13, 115 (1983)                               *
*                                                                      *
*   Equivalent expressions are found in Conte/Martini                  *
*   Particle Accelerators 17, 1 (1985)                                 *
*                                                                      *
*   Integrals are broken into decades to optimize speed.               *
*                                                                      *
*   For the VAX, values may not exceed 10**33, therefore TSTLOG=33     *
*   For the IBM, values may not exceed 10**74, therefore TSTLOG=74     *
*   (PMG, March 1988)                                                  *
*                                                                      *
*   The integral is split into MAXDEC decades with NS steps /decade.   *
*   TEST is used for testing convergence of the integral               *
* Input:                                                               *
*   BETAX     (real)    Horizontal beta.                               *
*   BETAY     (real)    Vertical beta.                                 *
*   ALX       (real)    Horizontal alpha.                              *
*   DX        (real)    Horizontal dispersion.                         *
*   DPX       (real)    Derivative of horizontal dispersion.           *
* Output:                                                              *
*   TXI       (real)    Horizontal rate / const.                       *
*   TYI       (real)    Vertical rate / const.                         *
*   TLI       (real)    Longitudinal rate / const.                     *
*----------------------------------------------------------------------*
+ca aparam
+ca message
+ca beam
      integer iiz,iloop,maxdec,ns
      double precision a,al,alam,aloop,alx,am,b,betax,betay,bl,c1,c2,c3,
     +ccy,chklog,cl,coeff,cof,cprime,cscale,cx,cy,dpx,dx,f,func,h,phi,
     +polyl,polyx,polyy,power,r1,suml,sumx,sumy,td1,td2,ten,term,test,
     +tl1,tl2,tli,tmpl,tmpx,tmpy,tstlog,tx1,tx2,txi,ty1,ty2,tyi,zintl,
     +zintx,zinty

+ca physicpm

      parameter         (tstlog = 74.0)
      parameter         (power  = - 2.0d0 / 3.0d0)
      parameter         (maxdec = 30, ns = 50)
      parameter         (ten = 10.0, test = 1.0d-7)
      dimension         al(31), bl(30), coeff(2)
      data coeff        / 2.0, 4.0 /

      phi    = dpx + (alx * dx / betax)
      am     = 1.0
      c1     = (gammas * dx)**2 / (ex * betax)
      c3     = betax / ex
      c2     = c3 * (gammas*phi)**2
      cx     = c1 + c2
      cl     = am * (gammas/sige)**2
      cy     = betay / ey
      r1     = 3.0 / cy
      a      = cx + cl
      b      = (c3 + cy) * (c1 + cl) + cy * c2

*---- Define CPRIME=C*CSCALE to try to keep the value.
*     small enough for the VAX in single precision or
*     IBM in double precision.
*     Test LOG(C) to see if it needs scaling
      cscale = 1.0
      chklog = log10(c3) + log10(cy) + log10(c1 + cl)
      if (chklog .gt. tstlog) cscale = ten**(tstlog-chklog)
      cprime = c3 * cy * cscale * (c1 + cl)

*---- Split integral into decades, with NS steps per decade.
*     variables to save integral segments
      zintl  = 0.0
      zintx  = 0.0
      zinty  = 0.0

*---- Constants for integration loop.
*     To keep the numbers reasonable, the numerator is
*     scaled by 1/CPRIME and the denominator by 1/CPRIME**2.
*     The extra factor of CPRIME is accounted for after integrating
      ccy    = cprime**power
      td1    = (a + c3) * ccy
      td2    = 1.0 / (sqrt(ccy) * cscale * cy)
      tl1    = (2.0 * a - cy - c3) / cprime
      tl2    = (b - 2.0 * c3 * cy) / cprime
      ty1    = (- a - c3 + 2.0 * cy) / cprime
      ty2    = (b + cy * c3) / cprime - r1 / cscale
      tx1    = (2.0 * a * (cx - c3) - cy * cx -
     +   c3 * (cy - cl - 2.0 * c3 - 6.0 * c2)) / cprime
      tx2    = (c3 + cx) * ((b + c3 * cy) / cprime) -
     +   6.0 / cscale + 3.0 * c3 * cy * (cl / cprime)

      al(1)  = 0.0

      do 90 iloop = 1, maxdec
        bl(iloop) = ten**iloop
        al(iloop+1) = bl(iloop)
        h = (bl(iloop) - al(iloop)) / ns
        aloop = al(iloop)

*---- Evaluate Simpson's rule summation for one interval.
*     The integrand is calculated in the loop itself
        term = sqrt((cy + aloop) * ccy) *
     +       sqrt(aloop * ccy * aloop + td1 * aloop + td2)
        func = sqrt(aloop) / term**3
        polyl = tl1 * aloop + tl2
        polyx = tx1 * aloop + tx2
        polyy = ty1 * aloop + ty2
        suml = func * polyl
        sumx = func * polyx
        sumy = func * polyy

        do 10 iiz = 1, ns
          alam = aloop + iiz * h
          cof = coeff(mod(iiz,2)+1)
          term = sqrt((cy+alam)*ccy) *
     +         sqrt(alam*ccy*alam+td1*alam+td2)
          f = sqrt(alam) / term**3
          polyl = tl1 * alam + tl2
          polyx = tx1 * alam + tx2
          polyy = ty1 * alam + ty2

          suml = suml + cof * f * polyl
          sumx = sumx + cof * f * polyx
          sumy = sumy + cof * f * polyy
   10   continue

        suml = suml - f * polyl
        sumx = sumx - f * polyx
        sumy = sumy - f * polyy
        tmpl = (suml / 3.0) * h
        tmpx = (sumx / 3.0) * h
        tmpy = (sumy / 3.0) * h
        zintl = zintl + tmpl
        zintx = zintx + tmpx
        zinty = zinty + tmpy

*---- Test to see if integral has converged.
        if (abs(tmpl/zintl) .lt. test .and.
     +      abs(tmpx/zintx) .lt. test .and.
     +      abs(tmpy/zinty) .lt. test) go to 100
   90 continue
      write (msg, 910) maxdec
  910 format('Bjorken/Mtingwa integrals did not converge in ',
     +       i3,' decades.')
      call aawarn('TWSINT', 1, msg)
  100 continue

*---- Divide answers by cprime to account for scaling.
      txi    =      (zintx / cprime)
      tli    = cl * (zintl / cprime)
      tyi    = cy * (zinty / cprime)

      end
+dk twsmap
      subroutine twsmap
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   SECTORMAP command: Compute maps by sectors.                        *
*   sectors are delimited by positions marked for OPTICS output.       *
* Attribute:                                                           *
*   FILENAME  (string)  Name of file to receive output.                *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca seqflag
+ca header
+ca mapelm
+ca maptrn
+ca message
+ca beam
+ca optic0
+ca optic1
+ca range
+ca refer
+ca status
+if doom
+ca dmcommon
+ei
      integer icode,iecnt,ienum,iflag,iocc,ipos,iunit,jbit,jbyt
      double precision deltap,el

      character*(mcnam) elmnam
      character*(mcfil) filnam
      logical           fmap, eflag

*---- Check main beam line.
      call lnchck('TWISS ', error)
      if (error) go to 9999

+if doom
      if (.not. strict)  then
+ei
*---- Open output file.
      filnam = 'map'
      call utgstr(lccmd, 1, 1, filnam)
      call flopen(filnam, 'SWFD', 0, 0, iunit, error)
      if (error) go to 9999
      write (iunit, 910) ctitle, cdate, ctime, deltas
+if doom
      endif
+ei
+if doom
      call dmsect1()
+ei
*---- Retrieve momentum error.
      deltap = 0.0
      call utgflt(lccmd, 2, 2, deltap)

*---- Retrieve beam line description.
      call utbeam(lcseq, irg1, irg2, symm, nsup, linnam, rngnam)

*---- Set up RF system.
      call enfix
      call enfreq(deltap)

*---- Initial values from periodic solution.
      call tmturn(lcseq, deltas, eflag)

*---- Initial values for cumulated length and map.
      suml = 0.0
      call ucopy(orbit0, orbit, 6*mwflt)
      call m66one(rt)
      call uzero(tt, 1, 216*mwflt)
      iecnt = 0

*---- Loop over positions.
      do 90 ipos = irg1, irg2
        call utelem(lcseq, ipos, iflag, elmnam, iocc, ienum)
        icode = jbyt(iflag,1,mcode)

*---- Physical element.
        if (icode .eq. 1) then
          if (lcali .ne. 0) then
            call tmali1(ipos, .true., orbit, orbit, re, te)
            call tmcat(.true., re, te, rt, tt, rt, tt)
          endif

          call tmmap(.true., .true., orbit, fmap, el, ek, re, te)

          if (fmap) then
            call tmcat(.true., re, te, rt, tt, rt, tt)
          endif

          if (lcali .ne. 0) then
            call tmali2(ipos, .true., orbit, orbit, re, te)
            call tmcat(.true., re, te, rt, tt, rt, tt)
          endif

          suml = suml + el
        endif

*---- Test for output.
        if (jbit(iflag,moptc) .ne. 0) then
          call twwmap(iunit, suml, elmnam, iocc,
     +    rt, tt, orbit0, orbit)
        endif
   90 continue

+if doom
      if (.not. strict)  then
+ei
*---- Final output.
      call flname(iunit, filnam)
      call flclos(iunit, error)
      if (.not. error) then
        msg(1) = 'Sector maps written on file: ' // filnam
        call aainfo('TWSMAP', 1, msg)
      endif
+if doom
      endif
+ei
 910  format(a80/'"',a8,'"','"',a8,'"',e20.10)

 9999 end
+dk twwmap
      subroutine twwmap(iunit, suml, elmnam, iocc,
     +rt, tt, orbit0, orbit)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Save transfer map including kick.                                  *
*----------------------------------------------------------------------*
+ca aparam
+if doom
+ca dmcommon
+ei
      integer i,iunit,k,l,iocc
      double precision ek,orbit,orbit0,rt,sum1,sum2,suml,temp,tt
      character*(mcnam) elmnam
      dimension         rt(6,6), tt(6,6,6), orbit0(6), orbit(6)

      dimension         ek(6), temp(6)

*---- Track ORBIT0 using zero kick.
      do 30 i = 1, 6
        sum2 = orbit(i)
        do 20 k = 1, 6
          sum1 = 0.0
          do 10 l = 1, 6
            sum1 = sum1 + tt(i,k,l) * orbit0(l)
   10     continue
          sum2 = sum2 - (rt(i,k) - sum1) * orbit0(k)
          rt(i,k) = rt(i,k) - 2.0 * sum1
   20   continue
        temp(i) = sum2
   30 continue

*---- Kick is actual ORBIT minus result of track.
      do 80 i = 1, 6
         ek(i) = temp(i)
 80   continue

+if doom
      if (.not. strict)  then
+ei
*---- Output.
      write (iunit, 920) suml, elmnam
      write (iunit, 930) ek
      write (iunit, 930) rt
      write (iunit, 930) tt
+if doom
      endif
      call dmsect2(suml, elmnam, iocc, ek, rt, tt)
+ei
*---- Save new ORBIT0 and re-initialize map.
      call ucopy(orbit, orbit0, 6*mwflt)
      call m66one(rt)
      call uzero(tt, 1, 216*mwflt)

 920  format(g20.6,a20)
 930  format(6e16.8)

      end
+dk twsmsv
      subroutine twsmsv(iflag, idelta)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Build table of Twiss summary data (tunes, chromaticities etc.).    *
* Input:                                                               *
*   IFLAG     (integer) Operation desired:                             *
*                       1: Create new table for summary.               *
*                       2: Save one line.                              *
*                       3: Retrieve one line.                          *
*                       4: Close table.                                *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca message
+ca beam
+ca optic0
+ca option
+ca twdata
+ca twlink
      integer i,idelta,iflag,iform,maxtun,nb,nc,nr,ns
      double precision dummy

      parameter         (maxtun = 17)
      character*(mcnam) tuncol(maxtun)
      integer           icfrm(maxtun)
      data tuncol
     +                  / 'DELTAP', 'ALFA',   'GAMMATR',
     +                    'QX',     'QY',     'XIX',    'XIY',
     +                    'XRMS',   'YRMS',   'XMAX',   'YMAX',
     +                    'BXMAX',  'BYMAX',  'DXMAX',  'DYMAX',
     +                    'DXRMS',  'DYRMS' /

*---- Create internal table for global quantities.
      if (iflag .eq. 1) then
        ns = 1
        nr = ndelta
        nc = maxtun
        nb = 1
        iform = 3
        if (double) iform = mreal
        do 10 i = 1, maxtun
          icfrm(i) = iform
   10   continue
        call tbcrea(sumnam, ns, nr, nc, tuncol, icfrm, nb, ltwsum)
        call tbpdsc(ltwsum, 'TYPE', 5, 0, dummy, 'TUNES')

*---- Save one table line.
      else if (ltwsum .ne. 0) then
        if (iflag .eq. 2) then
          call tbset(ltwsum, idelta, 3, ltwbuf)
          if (double) then
            call ucopy(deltas, q(ltwbuf+1), mwflt)
            call ucopy(alfa, q(ltwbuf+mwflt+1), mwflt)
            call ucopy(gamtr, q(ltwbuf+2*mwflt+1), mwflt)
            call ucopy(qx, q(ltwbuf+3*mwflt+1), mwflt)
            call ucopy(qy, q(ltwbuf+4*mwflt+1), mwflt)
            call ucopy(xix, q(ltwbuf+5*mwflt+1), mwflt)
            call ucopy(xiy, q(ltwbuf+6*mwflt+1), mwflt)
            call ucopy(sigxco, q(ltwbuf+7*mwflt+1), mwflt)
            call ucopy(sigyco, q(ltwbuf+8*mwflt+1), mwflt)
            call ucopy(xcomax, q(ltwbuf+9*mwflt+1), mwflt)
            call ucopy(ycomax, q(ltwbuf+10*mwflt+1), mwflt)
            call ucopy(bxmax, q(ltwbuf+11*mwflt+1), mwflt)
            call ucopy(bymax, q(ltwbuf+12*mwflt+1), mwflt)
            call ucopy(dxmax, q(ltwbuf+13*mwflt+1), mwflt)
            call ucopy(dymax, q(ltwbuf+14*mwflt+1), mwflt)
            call ucopy(sigdx, q(ltwbuf+15*mwflt+1), mwflt)
            call ucopy(sigdy, q(ltwbuf+16*mwflt+1), mwflt)
          else
            q(ltwbuf+ 1) = deltas
            q(ltwbuf+ 2) = alfa
            q(ltwbuf+ 3) = gamtr
            q(ltwbuf+ 4) = qx
            q(ltwbuf+ 5) = qy
            q(ltwbuf+ 6) = xix
            q(ltwbuf+ 7) = xiy
            q(ltwbuf+ 8) = sigxco
            q(ltwbuf+ 9) = sigyco
            q(ltwbuf+10) = xcomax
            q(ltwbuf+11) = ycomax
            q(ltwbuf+12) = bxmax
            q(ltwbuf+13) = bymax
            q(ltwbuf+14) = dxmax
            q(ltwbuf+15) = dymax
            q(ltwbuf+16) = sigdx
            q(ltwbuf+17) = sigdy
          endif

*---- Retrieve one table line.
        else if (iflag .eq. 3) then
          if (double) then
            call ucopy(q(ltwbuf+1), deltas, mwflt)
            call ucopy(q(ltwbuf+mwflt+1), alfa, mwflt)
            call ucopy(q(ltwbuf+2*mwflt+1), gamtr, mwflt)
            call ucopy(q(ltwbuf+3*mwflt+1), qx, mwflt)
            call ucopy(q(ltwbuf+4*mwflt+1), qy, mwflt)
            call ucopy(q(ltwbuf+5*mwflt+1), xix, mwflt)
            call ucopy(q(ltwbuf+6*mwflt+1), xiy, mwflt)
            call ucopy(q(ltwbuf+7*mwflt+1), sigxco, mwflt)
            call ucopy(q(ltwbuf+8*mwflt+1), sigyco, mwflt)
            call ucopy(q(ltwbuf+9*mwflt+1), xcomax, mwflt)
            call ucopy(q(ltwbuf+10*mwflt+1), ycomax, mwflt)
            call ucopy(q(ltwbuf+11*mwflt+1), bxmax, mwflt)
            call ucopy(q(ltwbuf+12*mwflt+1), bymax, mwflt)
            call ucopy(q(ltwbuf+13*mwflt+1), dxmax, mwflt)
            call ucopy(q(ltwbuf+14*mwflt+1), dymax, mwflt)
            call ucopy(q(ltwbuf+15*mwflt+1), sigdx, mwflt)
            call ucopy(q(ltwbuf+16*mwflt+1), sigdy, mwflt)
          else
            deltas = q(ltwbuf+ 1)
            alfa   = q(ltwbuf+ 2)
            gamtr  = q(ltwbuf+ 3)
            qx     = q(ltwbuf+ 4)
            qy     = q(ltwbuf+ 5)
            xix    = q(ltwbuf+ 6)
            xiy    = q(ltwbuf+ 7)
            sigxco = q(ltwbuf+ 8)
            sigyco = q(ltwbuf+ 9)
            xcomax = q(ltwbuf+10)
            ycomax = q(ltwbuf+11)
            bxmax  = q(ltwbuf+12)
            bymax  = q(ltwbuf+13)
            dxmax  = q(ltwbuf+14)
            dymax  = q(ltwbuf+15)
            sigdx  = q(ltwbuf+16)
            sigdy  = q(ltwbuf+17)
          endif

*---- Close table file.
        else if (iflag .eq. 4) then
          call tbpdsc(ltwsum, 'CIRCUM', mreal, 0, circ, ' ')
          call tbclos(ltwsum)
          msg(1) = 'Tunes saved in table: ' // sumnam
          call aainfo('TWSMSV', 1, msg)
        endif
      endif

      end
+dk twsumm
      subroutine twsumm(symm, nsup)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Compute summary data for TWISS and OPTICS commands.                *
* Important common data:                                               *
*             /MAPTRN/  One turn transfer map.                         *
*             /OPTIC0/  Initial values.                                *
*----------------------------------------------------------------------*
* Modified: 28-DEC-1998, T. Raubenheimer (SLAC)                        *
*   Include energy in summary calculation for non-periodic case        *
* Modified: 10-SEP-1999, M. Woodley (SLAC)                             *
*   Use the determinant of the longitudinal 2x2 part of the R-matrix   *
*   instead of R(6,6) for the energy scaling.                          *
*----------------------------------------------------------------------*
+ca aparam
      integer i,nsup
      double precision ax0,ay0,bx0,by0,eta,sd,sx,sy,t2,tb,twopi,utwopi,
     +zero,one,two
      logical           symm
+ca beam
+ca maptrn
+ca optic0
+ca optic1
+ca status
+ca twdata

+ca pi
      parameter         (twopi = 2.0 * pi, utwopi = 1.0 / twopi)
      parameter         (zero = 0.0d0, one = 1.0d0, two = 2.0d0)

      double precision  f, detl
      double precision  frt(6,6), frtp(6,6) ! MDW: for energy scaling
*---- Summary data for non-periodic case.
      if (inval) then
        qx = amux * utwopi
        qy = amuy * utwopi
        if (.not. couple) then

*---- Tor/MDW: include energy scaling for uncoupled non-periodic case;
*     scale by square root of the determinant of the longitudinal 2x2
*     part of the R-matrix
          detl = rt(5,5) * rt(6,6) - rt(5,6) * rt(6,5)
          f = one / sqrt(detl)
          call m66scl(f, rt, frt)
          call m66scl(f, rtp, frtp)

          tb = frt(1,1) * betx0 - frt(1,2) * alfx0
          t2 = tb**2 + frt(1,2)**2
          bx0 = wx0 * cos(phix0)
          ax0 = wx0 * sin(phix0)
          xix = dmux0 + frt(1,2) * (frt(1,2) * ax0 - tb * bx0) / t2
     +        + (frt(1,1) * frtp(1,2) - frt(1,2) * frtp(1,1)) / betx
          xix = xix * utwopi

          tb = frt(3,3) * bety0 - frt(3,4) * alfy0
          t2 = tb**2 + frt(3,4)**2
          by0 = wy0 * cos(phiy0)
          ay0 = wy0 * sin(phiy0)
          xiy = dmuy0 + frt(3,4) * (frt(3,4) * ay0 - tb * by0) / t2
     +        + (frt(3,3) * frtp(3,4) - frt(3,4) * frtp(3,3)) / bety
          xiy = xiy * utwopi
        endif
        circ = suml
        alfa = 0.0
        gamtr = 0.0
        cosmux = 0.0
        cosmuy = 0.0

*---- Summary data for periodic case.
      else
        if (symm) then
          amux = amux + amux
          amuy = amuy + amuy
          suml = suml + suml
        endif
        qx = nsup * amux * utwopi
        qy = nsup * amuy * utwopi
        sd = rt(5,6)
        sx = tt(1,1,6) + tt(2,2,6)
        sy = tt(3,3,6) + tt(4,4,6)
        do 120 i = 1, 4
          sd = sd + rt(5,i) * disp0(i)
          sx = sx + (tt(1,1,i) + tt(2,2,i)) * disp0(i)
          sy = sy + (tt(3,3,i) + tt(4,4,i)) * disp0(i)
  120   continue
        if (.not. couple) then
          if (stabx) then
            xix = - nsup * sx / (twopi * sinmux)
          else
            xix = 0.0
          endif
          if (staby) then
            xiy = - nsup * sy / (twopi * sinmuy)
          else
            xiy = 0.0
          endif
        endif
        circ = nsup * suml
        eta = - sd * betas**2 / suml
        alfa = 1.0 / gammas**2 + eta
        if (alfa .gt. 0.0) then
          gamtr = sqrt(1.0 / alfa)
        else if (alfa .eq. 0.0) then
          gamtr = 0.0
        else
          gamtr = - sqrt(- 1.0 / alfa)
        endif
      endif

      end
+dk twzzzz
+dk utaaaa
+dk utbeam
      subroutine utbeam(lseq, irg1, irg2, symm, nsup, linnam, rngnam)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Fetch data for a beam line sequence.                               *
* Input:                                                               *
*   LSEQ(1)   (pointer) Beam line sequence bank.                       *
* Output:                                                              *
*   IRG1      (integer) Begin of range index.                          *
*   IRG2      (integer) End of range index.                            *
*   SYMM      (logical) Symmetry flag.                                 *
*   NSUP      (integer) Number of superperiods.                        *
*   LINNAM    (char)    Name of beam line.                             *
*   RNGNAM    (char)    Name of range.                                 *
*----------------------------------------------------------------------*
+ca aparam
      integer irg1,irg2,nsup
      integer           lseq(*)
      logical           symm
      character*(mcnam) linnam
      character*(mcrng) rngnam
+ca memdum
+ca seqgroup

*---- Retrieve sequence and range data.
      if (lseq(1) .ne. 0) then
        irg1 = iq(lseq(1)+msr1)
        irg2 = iq(lseq(1)+msr2)
        symm = iq(lseq(1)+msym) .ne. 0
        nsup = iq(lseq(1)+msup)
        call uhtoc(q(lseq(1)+msbn), mcwrd, linnam, mcnam)
        call uhtoc(q(lseq(1)+msrn), mcwrd, rngnam, 40)
      endif

      end
+dk utclrc
      subroutine utclrc
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Clear occurrence counters in all physical elements and lines.      *
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca refer
      integer idir

*---- For all directory entries clear occurrence count.
      do 10 idir = 1, iq(ldbnk(3)+1)
        iq(ldbnk(4)+idir) = 0
   10 continue

      end
+dk utdash
      subroutine utdash(patt, init, last, ltok)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Build pattern entry for a character class.                         *
* Input:                                                               *
*   PATT      (char)    Input pattern.                                 *
*   INIT      (integer) Current position in pattern.                   *
*   LAST      (integer) Length of pattern in characters.               *
*   LTOK      (pointer) Points to current token bank.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ichar,init,j,j1,j2,jt,last
      character*(*)     patt
      integer           ltok(1)
+ca memdum

+ca bslash
      character*1       c

*---- Is pattern exhausted?
      i = init
      if (i .gt. last) go to 200

*---- Loop until ']' is seen.
  100 if (patt(i:i) .ne. ']') then
        c = patt(i:i)
        if (c .eq. '-') then
          if (i .le. init  .or.  i .ge. last) then
            call setbit(ichar(c), iq(ltok(1)+3), 1)
          else
            i = i + 1
            j1 = ichar(patt(i-2:i-2))
            j2 = ichar(patt(i:i))
            if (j1 .gt. j2) then
              jt = j1
              j1 = j2
              j2 = jt
            endif
            do 110 j = j1, j2
              call setbit(j, iq(ltok(1)+3), 1)
  110       continue
          endif
        else if (c .eq. bslash) then
          i = i + 1
          if (i .gt. last) go to 200
          c = patt(i:i)
        endif
        call setbit(ichar(c), iq(ltok(1)+3), 1)
        i = i + 1
        if (i .le. last) go to 100
      endif

*---- Check.
  200 if (i .gt. last  .or.  patt(i:i) .ne. ']') then
        ltok(1) = 0
        init = last + 1
      else
        init = i + 1
      endif

      end
+dk utelem
      subroutine utelem(lseq, ipos, iflag, elmnam, iocc, ienum)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Fetch data for current element in current beam line sequence.      *
* Input:                                                               *
*   LSEQ(1)   (pointer) Pointer to working beam line.                  *
*   IPOS      (integer) Current element position in working line.      *
* Output:                                                              *
*   IFLAG     (integer) Current position flag word.                    *
*   ELMNAM    (char)    Current element name.                          *
*   IOCC      (integer) Occurrence number.                             *
*   LCELM     /REFER/   Current element bank.                          *
*   LCALI     /REFER/   Current alignment error pointer.               *
*   LCFLD     /REFER/   Current field error pointer.                   *
*----------------------------------------------------------------------*
+ca aparam
      integer idir,ienum,iflag,ileng,iname,iocc,ipos,jbyt
      integer           lseq(*)
      character*(mcnam) elmnam
+ca memdum
+ca seqflag
+ca seqgroup
+ca message
+ca refer
+ca stflag

      idir = iq(lq(lseq(1)-msdir)+ipos)
      lcelm = lq(ldbnk(3)-idir)
      ienum = iq(lq(lseq(1)-msnum)+ipos)
      iname = (idir - 1) * mwnam + 1
      call uhtoc(q(ldbnk(2)+iname), mcwrd, elmnam, mcnam)
      iflag = iq(lq(lseq(1)-msflg)+ipos)
      iocc = jbyt(iflag,mocc1,mocc2)
      if (lcelm .eq. 0) then
        call utleng(elmnam, ileng)
        msg(1) = 'Unknown element name "' // elmnam(1:ileng)
     +  // '" occurs in working line.'
        call aafail('UTELEM', 1, msg)
      endif
      lcali = 0
      lcfld = 0
      lccom = 0
      if (doali  .and.  lq(lseq(1)-msali) .ne. 0) then
        lcali = lq(lq(lseq(1)-msali)-ipos)
      endif
      if (dofld  .and.  lq(lseq(1)-msfld) .ne. 0) then
        lcfld = lq(lq(lseq(1)-msfld)-ipos)
      endif
      if (dokick  .and.  lq(lseq(1)-mscom) .ne. 0) then
        lccom = lq(lq(lseq(1)-mscom)-ipos)
      endif

      end
+dk utgflt
      subroutine utgflt(lcmd, icat1, icat2, data)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Fetch command attributes of real type.                             *
*   Deferred expressions are evaluated by this routine.                *
* Input:                                                               *
*   LCMD(1)   (pointer) Command to be used.                            *
*   ICAT1     (integer) First attribute number.                        *
*   ICAT2     (integer) Last attribute number.                         *
* Output:                                                              *
*   DATA(*)   (real)    Vector to be filled.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,icat,icat1,icat2,idest
      double precision data
      integer           lcmd(*)
      dimension         data(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca refer
+ca datatype

      ibias = mbat + (icat1 - 1) * mcsiz
      idest = 1
      do 90 icat = icat1, icat2
        if (iq(lcmd(1)+ibias+mctyp) .gt. 10 * mtflt  .and.
     +      iq(lcmd(1)+ibias+mctyp) .le. 10 * mtflt + 3) then
          if(iq(lcmd(1)+ibias+mctyp) .eq. 10 * mtflt + 3) then
            lcexp = lq(lcmd(1)-icat)
            call exeval(lcexp)
          endif
          call ucopy(q(lcmd(1)+ibias+mcval), data(idest), mwflt)
        endif
        ibias = ibias + mcsiz
        idest = idest + 1
   90 continue

      end
+dk utgint
      subroutine utgint(lcmd, icat1, icat2, idata)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Fetch command attributes.                                          *
* Input:                                                               *
*   LCMD(1)   (pointer) Command to be used.                            *
*   ICAT1     (integer) First attribute number.                        *
*   ICAT2     (integer) Last attribute number.                         *
* Output:                                                              *
*   IDATA(*)  (integer) Vector to be filled.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,icat,icat1,icat2,idest
      integer           lcmd(*), idata(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca datatype

      ibias = mbat + (icat1 - 1) * mcsiz
      idest = 1
      do 90 icat = icat1, icat2
        if (iq(lcmd(1)+ibias+mctyp) .eq. 10 * mtint + 1) then
          idata(idest) = iq(lcmd(1)+ibias+mcval)
        endif
        ibias = ibias + mcsiz
        idest = idest + 1
   90 continue

      end
+dk utglog
      subroutine utglog(lcmd, icat1, icat2, data)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Fetch command attributes of logical type.                          *
* Input:                                                               *
*   LCMD(1)   (pointer) Command to be used.                            *
*   ICAT1     (integer) First attribute number.                        *
*   ICAT2     (integer) Last attribute number.                         *
* Output:                                                              *
*   DATA(*)   (logical) Vector to be filled.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,icat,icat1,icat2,idest
      integer           lcmd(*)
      logical           data(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca datatype

      ibias = mbat + (icat1 - 1) * mcsiz
      idest = 1
      do 90 icat = icat1, icat2
        if (iq(lcmd(1)+ibias+mctyp) .eq. 10 * mtlog + 1) then
          data(idest) = iq(lcmd(1)+ibias+mcval) .ne. 0
        endif
        ibias = ibias + mcsiz
        idest = idest + 1
   90 continue

      end
+dk utgnam
      subroutine utgnam(lcmd, icat1, icat2, data)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Fetch command attributes of character type.                        *
* Input:                                                               *
*   LCMD(1)   (pointer) Command to be used.                            *
*   ICAT1     (integer) First attribute number.                        *
*   ICAT2     (integer) Last attribute number.                         *
* Output:                                                              *
*   DATA(*)   (char)    Vector to be filled.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,icat,icat1,icat2,idest
      integer           lcmd(*)
      character*(mcnam) data(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca datatype

      ibias = mbat + (icat1 - 1) * mcsiz
      idest = 1
      do 90 icat = icat1, icat2
        if (iq(lcmd(1)+ibias+mctyp) .eq. 10 * mtnam + 1) then
          call uhtoc(q(lcmd(1)+ibias+mcval), mcwrd, data(idest), mcnam)
        endif
        ibias = ibias + mcsiz
        idest = idest + 1
   90 continue

      end
+dk utgpos
      subroutine utgpos(lrng, lseq, iend, ipos, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find place in beam line sequence.                                  *
* Input:                                                               *
*   LRNG(1)   (pointer) Range reference bank.                          *
*   LSEQ(1)   (pointer) Beam line sequence bank.                       *
*   IEND      (integer) 0: Begin of range, 3: End of range.            *
* Output:                                                              *
*   IPOS      (integer) Bias of position.                              *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer icode,idir,iend,iflag,ileng,index,iocc,ipos,jbyt,jdir
      integer           lrng(*), lseq(*)
      logical           eflag
+ca memdum
+ca bankhead
+ca cmdgroup
+ca prcgroup
+ca seqflag
+ca seqgroup
+ca message
+ca status
+ca refer

      character*(mcnam) elmnam

      eflag = .false.

*---- Check for existing sequence bank.
      call lnchck('UTGPOS', error)
      if (error) go to 800

      lsdir = lq(lseq(1)-msdir)
      lsflg = lq(lseq(1)-msflg)
      icode = iq(lrng(1)+iend+1)
      index = iq(lrng(1)+iend+3)

*---- Start of main beam line.
      if (icode .eq. 1) then
        ipos = 1
        go to 9999

*---- End of main beam line.
      else if (icode .eq. 2) then
        ipos = iq(lsflg-1)
        go to 9999

*---- Start of range.
      else if (icode .eq. 3) then
        ipos = iq(lseq(1)+msr1)
        go to 9999

*---- End of range.
      else if (icode .eq. 4) then
        ipos = iq(lseq(1)+msr2)
        go to 9999

*---- Find numbered position in working range.
      else if (icode .eq. 5) then
        iocc = 0
        do 10 ipos = 1, iq(lsflg-1)
          if (jbyt(iq(lsflg+ipos),1,mcode) .eq. 1) then
            iocc = iocc + 1
            if (iocc .ge. index) go to 9999
          endif
   10   continue

*---- Numbered position not found.
        write (msg, 910) index
  910   format('Element number ',i8,' not found in working beam line.')

*---- Named position: Set code to be searched for.
*     Element             (IFLAG = 1),
*     Beam line begin     (IFLAG = 2),
*     Beam line end       (IFLAG = 3).
      else
        idir = iq(lrng(1)+iend+2)
        lcelm = lq(ldbnk(3)-idir)
        if (iq(lcelm+mbpr) .eq. mpelm) then
          iflag = 1
        else if (iend .eq. 0) then
          iflag = 2
        else
          iflag = 3
        endif

*---- Find occurrence of name and code in working range.
        iocc = 0
        do 90 ipos = 1, iq(lsflg-1)
          if (jbyt(iq(lsflg+ipos),1,mcode) .eq. iflag) then
            jdir = iq(lsdir+ipos)
            lcelm = lq(ldbnk(3)-jdir)

*---- Try the present object itself.
            if (jdir .eq. idir) then
              iocc = iocc + 1
              if (iocc .ge. index) go to 9999

*---- Try all classes which may contain the present element.
            else if (iq(lcelm+mbpr) .eq. mpelm) then
              lccls = lcelm
   20         if (lccls .ne. 0) then
                jdir = iq(lccls+mbnam)
                if (jdir .eq. idir) then
                  iocc = iocc + 1
                  if (iocc .ge. index) go to 9999
                endif
                lccls = lq(lccls-iq(lccls+mbat)-mbecls)
                go to 20
              endif
            endif
          endif
   90   continue

*---- Name not found.
        call diname(ldbnk, idir, elmnam)
        call utleng(elmnam, ileng)
        if (iflag .eq. 1) then
          if (index .eq. 0) then
            write (msg, 920) elmnam(1:ileng)
  920       format('Element "',a,'" not found in working beam line.')
          else
            write (msg, 930) elmnam(1:ileng), index
  930       format('Element "',a,'[',i6,
     +      ']" not found in working beam line.')
          endif
        else
          if (index .eq. 0) then
            write (msg, 940) elmnam(1:ileng)
  940       format('Beam line "',a,'" not found in working beam line.')
          else
            write (msg, 950) elmnam(1:ileng), index
  950       format('Beam line "',a,'[',i6,
     +      ']" not found in working beam line.')
          endif
        endif
      endif

*---- Error exit.
  800 continue
      call aafail('UTGPOS', 1, msg)
      eflag = .true.

 9999 end
+dk utgrng
      subroutine utgrng(lrng, lseq, ipos1, ipos2, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find range limits within the working beam line.                    *
* Input:                                                               *
*   LRNG(1)   (pointer) Range reference bank.                          *
*   LSEQ(1)   (pointer) Beam line sequence bank.                       *
* Output:                                                              *
*   IPOS1     (integer) Begin of range.                                *
*   IPOS2     (integer) End of range.                                  *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer ipos1,ipos2
      integer           lrng(*), lseq(*)
      logical           eflag

      eflag = .false.
      ipos1 = 0
      ipos2 = 0

*---- Find start position.
      call utgpos(lrng, lseq, 0, ipos1, eflag)
      if (.not. eflag) then

*---- Find end position.
        call utgpos(lrng, lseq, 3, ipos2, eflag)
        if (.not. eflag) then

*---- Check range for proper ordering.
          if (ipos1 .gt. ipos2) then
            call aafail('UTGRNG', 1, 'Begin and end of range inverted.')
            eflag = .true.
          endif
        endif
      endif

      end
+dk utgstr
      subroutine utgstr(lcmd, icat1, icat2, data)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Fetch command attributes of real type.                             *
*   Deferred expressions are evaluated by this routine.                *
* Input:                                                               *
*   LCMD(1)   (pointer) Command to be used.                            *
*   ICAT1     (integer) First attribute number.                        *
*   ICAT2     (integer) Last attribute number.                         *
* Output:                                                              *
*   DATA(*)   (char)    Vector to be filled.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,icat,icat1,icat2,idest,len,ll
      integer           lcmd(*)
      character*(*)     data(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca datatype

      ibias = mbat + (icat1 - 1) * mcsiz
      idest = 1
      do 90 icat = icat1, icat2
        if (iq(lcmd(1)+ibias+mctyp) .eq. 10 * mtstr + 1) then
          data(idest) = ' '
          ll = min(len(data(1)), iq(lcmd(1)+ibias+mcval))
          call uhtoc(q(lq(lcmd(1)-icat)+1), mcwrd, data(idest), ll)
        endif
        ibias = ibias + mcsiz
        idest = idest + 1
   90 continue

      end
+dk utgtyp
      subroutine utgtyp(lcmd, itype)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Fetch types of command attributes (zero for unset ones).           *
* Input:                                                               *
*   LCMD(1)   (pointer) Command to be used.                            *
* Output:                                                              *
*   ITYPE(*)  (real)    Vector of type codes to be filled.             *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,icat,itype
      integer           lcmd(*)
      dimension         itype(*)
+ca memdum
+ca bankhead
+ca cmdgroup

      ibias = mbat
      do 90 icat = 1, iq(lcmd(1)+mbat)
        if (mod(iq(lcmd(1)+ibias+mctyp),10) .ne. 0) then
          itype(icat) = iq(lcmd(1)+ibias+mctyp) / 10
        else
          itype(icat) = 0
        endif
        ibias = ibias + mcsiz
   90 continue

      end
+dk utleng
      subroutine utleng(word, leng)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find last non-blank character in WORD.                             *
* Input:                                                               *
*   WORD      (char)    Word to be processed.                          *
* Output:                                                              *
*   LENG      (integer) Length of WORD (1 if all blanks).              *
*----------------------------------------------------------------------*
+ca aparam
      integer i,len,leng
      character*(*)     word

      leng = 1
      do 10 i = len(word), 1, -1
        if (word(i:i) .ne. ' ') then
          leng = i
          return
        endif
   10 continue

      end
+dk utlook
      subroutine utlook(word, dict, ndict, idict)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Find WORD in dictionary DICT, accepting unique abbreviations.      *
* Input:                                                               *
*   WORD        (char)  Word to be looked up.                          *
*   DICT(NDICT) (char)  Table of allowed values.                       *
* Output:                                                              *
*   IDICT    (integer)  Position of WORD in DICT                       *
*                       (zero if word is blank or not found).          *
*----------------------------------------------------------------------*
+ca aparam
      integer idict,jdict,leng,n,ndict
      character*(*)     word
      character*(mcnam) dict(*)

      character*(mcnam) temp

*---- First try unabbreviated form.
      temp = word
      do 10 idict = 1, ndict
        if (temp .eq. dict(idict)) go to 9999
   10 continue

*---- WORD not found:  Try abbreviations,  N counts ambiguities.
      call utleng(word, leng)
      n = 0
      if (leng .ge. 2) then
        do 20 jdict = 1, ndict
          temp = dict(jdict)(1:leng)
          if (word .eq. temp) then
            idict = jdict
            n = n + 1
          endif
   20   continue
      endif
      if (n .ne. 1) idict = 0

 9999 end
+dk utmtch
      subroutine utmtch(name, i, last, lpatt, found)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Match NAME with the pattern token at LPATT.                        *
* Input:                                                               *
*   NAME      (char)    Name to be matched with pattern.               *
*   INIT      (integer) Current character number.                      *
*   LAST      (integer) Last character in name.                        *
*   LPATT     (pointer) Input pattern.                                 *
* Output:                                                              *
*   FOUND     (logical) Success flag.                                  *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ichar,k,last,n
      character*80      name
      integer           lpatt(1)
      logical           found
+ca memdum
+ca utpgroup

      found = .false.
      if (i .gt. last) return
      k = ichar(name(i:i))
      go to (10, 20 , 30 , 40 , 50), iq(lpatt(1)+1)

*---- Arbitrary character.
   10 found = .true.
      go to 9999

*---- Character class.
   20 call getbit(k, iq(lpatt(1)+3), n)
      found = n .ne. 0
      go to 9999

*---- Complemented character class.
   30 call getbit(k, iq(lpatt(1)+3), n)
      found = n .eq. 0
      go to 9999

*---- Closure cannot occur here.
   40 go to 9999

*---- Litteral character.
   50 found = k .eq. iq(lpatt(1)+2)

 9999 end
+dk utmtpt
      subroutine utmtpt(lpatt, name, found)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Match NAME with the wildcard pattern at LPATT.                     *
* Input:                                                               *
*   LPATT     (pointer) Input pattern.                                 *
*   NAME      (char)    Name to be matched with pattern.               *
* Output:                                                              *
*   FOUND     (logical) Success flag.                                  *
* Warning:                                                             *
*   Routine uses local links. No Zebra calls allowed.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer i,k,l,last,ltok
      integer           lpatt(1)
      character*(*)     name
      logical           found
+ca memdum
+ca utpgroup
      integer           istak(20), lstak(20), kstak(20)

*---- Initialize.
      call utleng(name, last)
      i = 1
      ltok = lpatt(1)
      l = 0
      if (ltok .eq. 0) i = last + 1

*---- Begin of procedure "match".
*     While we are not at end of pattern ...
  100 if (ltok .eq. 0) go to 200

*---- Closure.
        if (iq(ltok+1) .ne. mclos) go to 150
          ltok = lq(ltok)
          k = i
  110     if (i .gt. last) go to 120
            call utmtch(name, i, last, ltok, found)
            if (.not. found) go to 120
            i = i + 1
          go to 110

*---- Match remaining pattern.
  120     continue
          ltok = lq(ltok)
  130     if (i .lt. k) go to 100
            l = l + 1
            istak(l) = i
            lstak(l) = ltok
            kstak(l) = k
            go to 100
  140       i = istak(l) - 1
            ltok = lstak(l)
            k = kstak(l)
            l = l - 1
          go to 130

*---- Arbitrary single character.
  150   continue
          call utmtch(name, i, last, ltok, found)
          if (.not. found) go to 210
          i = i + 1
          ltok = lq(ltok)
        go to 100

*---- End of procedure "match".
*     Success, if name and pattern both exhausted.
  200 continue
      found = i .gt. last  .and.  ltok .eq. 0

*---- If failed, restart at closure with next shorter string.
      if (found) return
  210 if (l .gt. 0) go to 140

      end
+dk utocnm
      subroutine utocnm(oldnam, iocc, newnam)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Generate a unique name from a name and an occurrence count.        *
* Input:                                                               *
*   OLDNAM    (char)    Name to be combined with occurrence count.     *
*   IOCC      (integer) Occurrence count.
* Output:                                                              *
*   NEWNAM    (char)    Generated name.                                *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iocc,l
      character*(mcnam) oldnam, newnam

      character*8       number

      do 10 l = mcnam, 1, -1
        if (oldnam(l:l) .ne. ' ') go to 20
   10 continue
   20 write (number, '(I8)') iocc
      do 30 i = 1, 8
        if (number(i:i) .ne. ' ') go to 40
   30 continue
   40 l = min(l,i+mcnam-11)
      newnam = oldnam(1:l) // '[' // number(i:8) // ']'

      end
+dk utpatt
      subroutine utpatt(patt, lpatt)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Transform wildcard pattern to a useful form.                       *
* Input:                                                               *
*   PATT      (char)    Input pattern.                                 *
* Output:                                                              *
*   LPATT     (pointer) Points to transformed pattern.                 *
* Warning:                                                             *
*   Routine uses local link LTOK. Don't add other Zebra calls.         *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ichar,last,ltok
      character*(*)     patt
      integer           lpatt(1)
+ca memdum
+ca message

      character*1       c
+ca bslash
+ca utpgroup

*---- Test for invalid input.
      lpatt(1) = 0
      if (patt .eq. ' ') go to 9999
      call utleng(patt, last)
      if (patt(1:1) .eq. '*') go to 800

*---- Loop over pattern.
      i = 1
  100 if (i .le. last) then
        ltok = 0
        call mzbook(2, ltok, ltok, 1, 'PATT', 1, 1, 10, 2, 0)
        c = patt(i:i)

*---- Arbitrary character '.'.
        if (c .eq. '.') then
          iq(ltok+1) = many
          i = i + 1

*---- Character class character '['.
        else if (c .eq. '[') then
          if (i .ge. last) go to 800
          if (patt(i+1:i+1) .eq. '^') then
            iq(ltok+1) = mnccl
            i = i + 2
          else
            iq(ltok+1) = mccl
            i = i + 1
          endif
          call utdash(patt, i, last, ltok)
          if (ltok .eq. 0) go to 800

*---- Closure character '*'.
        else if (c .eq. '*') then
          iq(ltok+1) = mclos
          i = i + 1

*---- Escape character '\'.
        else if (c .eq. bslash) then
          if (i .ge. last) go to 800
          iq(ltok+1) = mlit
          iq(ltok+2) = ichar(patt(i+1:i+1))
          i = i + 2

*---- Litteral character.
        else
          iq(ltok+1) = mlit
          iq(ltok+2) = ichar(c)
          i = i + 1
        endif

*---- Link bank in proper position.
*     Put closure bank after the repeated token, any other at front.
*     Closure cannot be first bank.
        if (iq(ltok+1) .eq. mclos) then
          call zshunt(0, ltok, lpatt, 0, 0)
        else
          call zshunt(0, ltok, lpatt, 1, 0)
        endif
        go to 100
      endif

*---- Invert list of tokens.
      call ztopsy(0, lpatt)
      go to 9999

*---- Error: Delete pattern and return.
  800 call mzdrop(0, lpatt, 'L')
      msg(1) = 'Invalid pattern: ' // patt
      msg(2) = '".*" used.'
      call aawarn('UTPATT', 2, msg)
      lpatt(1) = 0

 9999 end
+dk utpflt
      subroutine utpflt(lcmd, icat1, icat2, data)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Store command attributes of real type.                             *
*   This routine destroys expressions present for these attributes,    *
*   and it marks the bank as modified.                                 *
* Input:                                                               *
*   LCMD(1)   (pointer) Command to be used.                            *
*   ICAT1     (integer) First attribute number.                        *
*   ICAT2     (integer) Last attribute number.                         *
*   DATA(*)   (real)    Vector to be stored.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,icat,icat1,icat2,isrce
      double precision data,rval
      integer           lcmd(*)
      dimension         data(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca refer
+ca datatype

      logical modflg

      ibias = mbat + (icat1 - 1) * mcsiz
      isrce = 1
      modflg = .false.

      do 90 icat = icat1, icat2
        call ucopy(q(lcmd(1)+ibias+mcval), rval, mwflt)
        modflg = modflg .or. rval .ne. data(isrce)

        if (iq(lcmd(1)+ibias+mctyp) / 10 .eq. mtflt) then
          lcexp = lq(lcmd(1)-icat)
          if(lcexp .ne. 0) call aadrop(lcexp)
          call ucopy(data(isrce), q(lcmd(1)+ibias+mcval), mwflt)
          iq(lcmd(1)+ibias+mctyp) = 10 * mtflt + 1
        endif

        ibias = ibias + mcsiz
        isrce = isrce + 1
   90 continue

      if (modflg) call aamark('UTPFLT', lcmd)

      end
+dk utpint
      subroutine utpint(lcmd, icat1, icat2, idata)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Store command attributes.                                          *
* Input:                                                               *
*   LCMD(1)   (pointer) Command to be used.                            *
*   ICAT1     (integer) First attribute number.                        *
*   ICAT2     (integer) Last attribute number.                         *
*   IDATA(*)  (integer) Vector to be stored.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,icat,icat1,icat2,isrce
      integer           lcmd(*), idata(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca datatype

      ibias = mbat + (icat1 - 1) * mcsiz
      isrce = 1
      do 90 icat = icat1, icat2
        if (iq(lcmd(1)+ibias+mctyp) / 10 .eq. mtint) then
          iq(lcmd(1)+ibias+mcval) = idata(isrce)
          iq(lcmd(1)+ibias+mctyp) = 10 * mtint + 1
        endif
        ibias = ibias + mcsiz
        isrce = isrce + 1
   90 continue

      end
+dk utplog
      subroutine utplog(lcmd, icat1, icat2, data)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Store command attributes of logical type.                          *
* Input:                                                               *
*   LCMD(1)   (pointer) Command to be used.                            *
*   ICAT1     (integer) First attribute number.                        *
*   ICAT2     (integer) Last attribute number.                         *
*   DATA(*)   (logical) Vector to be stored.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,icat,icat1,icat2,isrce
      integer           lcmd(*)
      logical           data(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca datatype

      ibias = mbat + (icat1 - 1) * mcsiz
      isrce = 1
      do 90 icat = icat1, icat2
        if (iq(lcmd(1)+ibias+mctyp) / 10 .eq. mtlog) then
          iq(lcmd(1)+ibias+mcval) = 0
          if (data(isrce)) iq(lcmd(1)+ibias+mcval) = 1
          iq(lcmd(1)+ibias+mctyp) = 10 * mtlog + 1
        endif
        ibias = ibias + mcsiz
        isrce = isrce + 1
   90 continue

      end
+dk utpnam
      subroutine utpnam(lcmd, icat1, icat2, data)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Store command attributes of character type.                        *
* Input:                                                               *
*   LCMD(1)   (pointer) Command to be used.                            *
*   ICAT1     (integer) First attribute number.                        *
*   ICAT2     (integer) Last attribute number.                         *
*   DATA(*)   (char)    Vector to be stored.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer ibias,icat,icat1,icat2,isrce
      integer           lcmd(*)
      character*(mcnam) data(*)
+ca memdum
+ca bankhead
+ca cmdgroup
+ca datatype

      ibias = mbat + (icat1 - 1) * mcsiz
      isrce = 1
      do 90 icat = icat1, icat2
        if (iq(lcmd(1)+ibias+mctyp) / 10 .eq. mtnam) then
          call uctoh(data(isrce), iq(lcmd(1)+ibias+mcval), mcwrd, mcnam)
          iq(lcmd(1)+ibias+mctyp) = 10 * mtnam + 1
        endif
        ibias = ibias + mcsiz
        isrce = isrce + 1
   90 continue

      end
+dk utzzzz
+dk zzaaaa
+dk anylcav
      logical function anylcav()
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Check for presence of LCAVITY elements in the current beamline.    *
* Input:                                                               *
*   None                                                               *
* Result:                                                              *
*   .TRUE.   There is at least one LCAVITY element.                    *
*   .FALSE.  There are no LCAVITY elements.                            *
*----------------------------------------------------------------------*
* Created:  01-APR-1999, M. Woodley (SLAC)                             *
*----------------------------------------------------------------------*

      implicit none
+ca aparam
+ca memdum
+ca bankhead
+ca prcgroup
+ca seqgroup
+ca refer
      integer ipos, lelm
      logical flag

      flag = .false.
      ipos = iq(lcseq+msr1)
   10 if (ipos .le. iq(lcseq+msr2) .and. (.not. flag)) then
        lelm = lq(ldbnk(3)-iq(lq(lcseq-msdir)+ipos))
        if (iq(lelm+mbpr) .eq. mpelm) then
          if (iq(lelm+mbsp) .eq. 27) then
            flag = .true.
          endif
        endif
        ipos = ipos+1
        go to 10
      endif
      anylcav = flag

      end
+dk bsequn
      integer function bsequ_number(snam)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   get storage number for beam sequence name
* Input:
*   snam   (character)  sequence name
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca beam
+ca strgroup
      character *(mcnam) snam
      integer i, k
*--- look for sequence among active
      k = 0
      do i = 1, liftbeam
        if (bseqnames(i) .eq. snam)  k = i
      enddo
      bsequ_number = k
      end
+dk chinit
      subroutine chinit
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Initialize character code translation tables.                      *
*----------------------------------------------------------------------*
+ca aparam
+ca chcode
      integer i,ic,ichar,j

      character*1       digit(0:9), lower(26), upper(26)
      data digit        / '0','1','2','3','4','5','6','7','8','9' /
      data lower        / 'a','b','c','d','e','f','g','h','i','j',
     +                    'k','l','m','n','o','p','q','r','s','t',
     +                    'u','v','w','x','y','z' /
      data upper        / 'A','B','C','D','E','F','G','H','I','J',
     +                    'K','L','M','N','O','P','Q','R','S','T',
     +                    'U','V','W','X','Y','Z' /

      do 10 i = 0, 255
        ichtyp(i) = 11
        ch2low(i) = char(i)
        ch2upp(i) = char(i)
   10 continue

      do 20 j = 0, 9
        ic = ichar(digit(j))
        ichtyp(ic) = j
   20 continue

      do 30 j = 1, 26
        ic = ichar(lower(j))
        ichtyp(ic) = 10
        ch2upp(ic) = upper(j)
        ic = ichar(upper(j))
        ichtyp(ic) = 10
        ch2low(ic) = lower(j)
   30 continue

      end
+dk cperrf
      subroutine cperrf(xx, yy, wx, wy)
      implicit none
*----------------------------------------------------------------------*
* purpose:
*   uses wwerf, double precision complex error function,
*   written at cern by K. Koelbig.
* input:
*   xx, yy    (double)    real + imag argument
* output:
*   wx, wy    (double)    real + imag function result
*----------------------------------------------------------------------*
+ca aparam
      complex cmplx
      double precision xx, yy, wx, wy
      complex*16 z1, z2, wwerf
      real*8 d(2)
      equivalence (d, z2)

      z1 = cmplx(xx, yy)
      z2 = wwerf(z1)
      wx = d(1)
      wy = d(2)
      end
+dk ccperrf
      subroutine ccperrf(xx, yy, wx, wy)
      implicit none
*----------------------------------------------------------------------*
* purpose:
*   modification of wwerf, double precision complex error function,
*   written at cern by K. Koelbig.
* input:
*   xx, yy    (double)    real + imag argument
* output:
*   wx, wy    (double)    real + imag function result
*----------------------------------------------------------------------*
+ca aparam
      double precision xx, yy, wx, wy
      double precision cc, one, two, xlim, ylim
      parameter         (cc     = 1.12837 91670 9551d0)
      parameter         (one    = 1.d0)
      parameter         (two    = 2.d0)
      parameter         (xlim   = 5.33d0)
      parameter         (ylim   = 4.29d0)
      double precision  x, y, q, h, xl, xh, yh, tx, ty, tn, sx, sy,
     +saux
      double precision  rx(33), ry(33)
      integer n, nc, nu

      x = abs(xx)
      y = abs(yy)

      if (y .lt. ylim  .and.  x .lt. xlim) then
        q  = (one - y / ylim) * sqrt(one - (x/xlim)**2)
        h  = one / (3.2d0 * q)
        nc = 7 + int(23.0*q)
        xl = h**(1 - nc)
        xh = y + 0.5d0/h
        yh = x
        nu = 10 + int(21.0*q)
        rx(nu+1) = 0.
        ry(nu+1) = 0.

        do 10 n = nu, 1, -1
          tx = xh + n * rx(n+1)
          ty = yh - n * ry(n+1)
          tn = tx*tx + ty*ty
          rx(n) = 0.5d0 * tx / tn
          ry(n) = 0.5d0 * ty / tn
   10   continue

        sx = 0.
        sy = 0.

        do 20 n = nc, 1, -1
          saux = sx + xl
          sx = rx(n) * saux - ry(n) * sy
          sy = rx(n) * sy + ry(n) * saux
          xl = h * xl
   20   continue

        wx = cc * sx
        wy = cc * sy
      else
        xh = y
        yh = x
        rx(1) = 0.
        ry(1) = 0.

        do 30 n = 9, 1, -1
          tx = xh + n * rx(1)
          ty = yh - n * ry(1)
          tn = tx*tx + ty*ty
          rx(1) = 0.5d0 * tx / tn
          ry(1) = 0.5d0 * ty / tn
   30   continue

        wx = cc * rx(1)
        wy = cc * ry(1)
      endif

*      if(y .eq. 0.) wx = exp(-x**2)
      if(yy .lt. 0.) then
        wx =   two * exp(y*y-x*x) * cos(two*x*y) - wx
        wy = - two * exp(y*y-x*x) * sin(two*x*y) - wy
        if(xx .gt. 0.) wy = -wy
      else
        if(xx .lt. 0.) wy = -wy
      endif

      end
+dk factor
      function factor(n)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Compute factorial function of N.                                   *
* Input:                                                               *
*   N         (integer) Number for which N! is to be found.            *
* Result:     (real)    N!                                             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ifact,n
      double precision factor

      ifact = 1
      do 10 i = 1, n
        ifact = ifact * i
   10 continue
      factor = ifact

      end
+dk fdjac2
      subroutine fdjac2(fcn,m,n,x,fvec,fjac,ldfjac,iflag,epsfcn,wa)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   This subroutine computes a forward-difference approximation        *
*   to the M by N Jacobian matrix associated with a specified          *
*   problem of M functions in N variables.                             *
* Input:                                                               *
*       FCN is the name of the user-supplied subroutine which          *
*         calculates the functions. FCN must be declared               *
*         in an external statement in the user calling                 *
*         program, and should be written as follows:                   *
*                                                                      *
*         SUBROUTINE FCN(M,N,X,FVEC,IFLAG)                             *
*         DIMENSION X(N),FVEC(M)                                       *
*         CALCULATE THE FUNCTIONS AT X AND                             *
*         RETURN THIS VECTOR IN FVEC.                                  *
*         RETURN                                                       *
*         END                                                          *
*                                                                      *
*         The value of IFLAG should be set to zero, unless there       *
*         is an error in evaluation of the function.                   *
*                                                                      *
*       M is a positive integer input variable set to the number       *
*         of functions.                                                *
*                                                                      *
*       N is a positive integer input variable set to the number       *
*         of variables. N must not exceed M.                           *
*                                                                      *
*       X is an input array of length N.                               *
*                                                                      *
*       FVEC is an input array of length M which must contain the      *
*         functions evaluated at X.                                    *
*                                                                      *
*       FJAC is an output M by N array which contains the              *
*         approximation to the Jacobian matrix evaluated at X.         *
*                                                                      *
*       LDFJAC is a positive integer input variable not less than M    *
*         which specifies the leading dimension of the array FJAC.     *
*                                                                      *
*       IFLAG is an integer variable which tells the calling program   *
*         wether the approximation is valid.                           *
*                                                                      *
*       EPSFCN is an input variable used in determining a suitable     *
*         step length for the forward-difference approximation. This   *
*         approximation assumes that the relative errors in the        *
*         functions are of the order of EPSFCN. If EPSFCN is less      *
*         than the machine precision, it is assumed that the relative  *
*         errors in the functions are of the order of the machine      *
*         precision.                                                   *
*                                                                      *
*       WA is a work array of length M.                                *
* Source:                                                              *
*   Argonne National Laboratory. MINPACK Project. March 1980.          *
*   Burton S. Garbow, Kenneth E. Hillstrom, Jorge J. More.             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iflag,j,ldfjac,m,n
      double precision eps,epsfcn,fjac,fvec,h,temp,wa,x,zero
      external          fcn
      dimension         x(n), fvec(m), fjac(ldfjac,n), wa(m)
+ca mchpar
      parameter         (zero   = 0.0d0)

      eps = sqrt(max(epsfcn,epsmch))
      iflag = 0

      do 20 j = 1, n
         temp = x(j)
         h = eps*abs(temp)
         if (h .eq. zero) h = eps
         x(j) = temp + h
         call fcn(m,n,x,wa,iflag)
         x(j) = temp
         if (iflag .ne. 0) go to 30
         do 10 i = 1, m
            fjac(i,j) = (wa(i) - fvec(i))/h
   10    continue
   20 continue
   30 continue

      end
+dk fft
      subroutine fft(data, nn, isign)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Computes the FFT                                                   *
* Author: numerical receipes,  pg. 395                                 *
*   DATA:     is a real array with the signal on input                 *
*             with the Fourier transform on output.                    *
*   N:        is the number of data: must be a power of 2              *
*   ISIGN=1:  direct Fourier transform                                 *
*   ISIGN=-1: inverse Fourier transform                                *
*----------------------------------------------------------------------*
+ca aparam
      integer i,isign,istep,j,m,mmax,n,nn
      double precision data,half,one,tempi,tempr,theta,two,twopi,wi,wpi,
     +wpr,wr,wtemp,zero
      dimension data(*)

+ca pi
      parameter (zero = 0.0d0, half = 0.5d0, one = 1.0d0, two = 2.0d0,
     +           twopi = 2.0d0 * pi)

*---- Rearrange the data points.
      n = 2 * nn
      j = 1
      do 11 i = 1, n, 2
        if(j .gt. i) then
          tempr = data(j)
          tempi = data(j+1)
          data(j) = data(i)
          data(j+1) = data(i+1)
          data(i) = tempr
          data(i+1) = tempi
        endif
        m = n / 2
   1    if (m .ge. 2  .and.  j .gt. m) then
          j = j - m
          m = m / 2
          go to 1
        endif
        j = j + m
  11    continue
      mmax = 2
   2  if (n .gt. mmax) then
        istep = 2 * mmax
        theta = twopi / (isign * mmax)
        wpr = - two * sin(half * theta)**2
        wpi = sin(theta)
        wr = one
        wi = zero
        do 13 m = 1, mmax, 2
          do 12 i = m, n, istep
            j = i + mmax
            tempr = wr * data(j)   - wi * data(j+1)
            tempi = wr * data(j+1) + wi * data(j)
            data(j)   = data(i)   - tempr
            data(j+1) = data(i+1) - tempi
            data(i)   = data(i)   + tempr
            data(i+1) = data(i+1) + tempi
  12      continue
          wtemp = wr
          wr = wr * wpr - wi    * wpi + wr
          wi = wi * wpr + wtemp * wpi + wi
  13    continue
        mmax = istep
        go to 2
      endif

      end
+dk frndm
      function frndm()
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Return a real pseudo-random number in the range [0,1).             *
*----------------------------------------------------------------------*
+ca aparam
+ca ranqzq
      double precision frndm,scale

      parameter         (scale  = 1.0d0 / maxran)
      if (next .gt. nr) call irngen
      frndm = scale * irn(next)
      next = next + 1
      end
+dk fitlyap
      double precision function fitlyap(distvect, nturn)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   Computes interpolated Lyapunov exponent.
*   DISTVECT (normalized) distance between two companion particles
*   NTURN is the number of turns.
*----------------------------------------------------------------------*
+ca aparam
      integer ilogd,ilogn,in,mf,n1,n2,n3,npoint,nturn
      double precision deltalog1,deltalog2,deltalog3,distvect,dlmax,
     +fitlyap1,fitlyap2,fitlyap3,slopexy
      dimension distvect(*)
+ca memdum
+ca wstack

*---- Assign working space.
      ilogd = iwork
      ilogn = ilogd + nturn
      in    = ilogn + nturn
      iwork = in    + nturn
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

      do 10 mf = 1, nturn
        dq(ilogd+mf) = log(distvect(mf))
        dq(in+mf)    = mf
        dq(ilogn+mf) = log(dq(in+mf))
   10 continue

*---- Loglog fit over 3 subsequent periods of NPOINT = NTURN/4 TURNS
*     starting at N1 = NPOINT + 1, i.e. at the second fourth
      npoint = int(nturn / 4)
      n1 = npoint + 1
      n2 = n1 + npoint
      n3 = n2 + npoint

*---- DELTALOG = deviation from 1 of loglog slope.
      dlmax = 1.0d-1

      deltalog1 = slopexy(dq(ilogn+n1), dq(ilogd+n1), npoint) - 1.0d0
      deltalog2 = slopexy(dq(ilogn+n2), dq(ilogd+n2), npoint) - 1.0d0
      deltalog3 = slopexy(dq(ilogn+n3), dq(ilogd+n3), npoint) - 1.0d0

      if (deltalog1 .lt. dlmax  .and.  deltalog2 .lt. dlmax  .and.
     +    deltalog3 .lt. dlmax) then
        fitlyap = 0.0d0
      else
        fitlyap1 = slopexy(dq(in+n1), dq(ilogd+n1), npoint)
        fitlyap2 = slopexy(dq(in+n2), dq(ilogd+n2), npoint)
        fitlyap3 = slopexy(dq(in+n3), dq(ilogd+n3), npoint)

        if (fitlyap1 .lt. fitlyap2) then
          fitlyap = fitlyap2
        else
          fitlyap = fitlyap1
        endif
        if (fitlyap .lt. fitlyap3) then
          fitlyap = fitlyap3
        endif
      endif

*---- release working store.
      iwork = ilogd

      end
+dk getact
      subroutine get_active(snam,caller)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   get requested active sequence (set lcseq)
* Input:
*   snam   (character)  sequence name
*   caller (character)  calling routine
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca strgroup
+ca refer
      character *(mcnam) snam
      character *(*)     caller
      integer k, sequ_number, lastnb
*--- look for sequence among active
      k = sequ_number(snam)
      if (k .eq. 0)  then
        call aawarn(caller, 1,
     +  'Unknown sequence ' // snam(:lastnb(snam)) //
     +  ' requested, old kept.')
      elseif (k .ne. currseq)  then
        lcseq = lq(lq(lroot-mcseq)-k)
        currseq = k
        sequnam = seqnames(k)
*--- set proper beam
        call enget
*---- Precomputed maps become invalid.
        call lnmark(caller)
      endif
      end
+dk getbit
      subroutine getbit(i, m, l)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Extract I'th bit of bit string M, put it to L                      *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ibit,iword,jbit,l
      integer           m(*)

      iword = i / 32 + 1
      ibit  = mod(i-1,32) + 1
      l = jbit(m(iword), ibit)

      end
+dk grndm
      subroutine grndm(gr1, gr2)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Return two floating point numbers from a Gaussian distribution     *
*   with zero mean and unit sigma.                                     *
* Output:                                                              *
*   GR1, GR2  (real)    Two random numbers.                            *
*----------------------------------------------------------------------*
+ca aparam
      double precision frndm,gr1,gr2,xi1,xi2,zzr
   10 continue
        xi1 = frndm() * 2. - 1.
        xi2 = frndm() * 2. - 1.
        zzr = xi1**2 + xi2**2
      if (zzr .gt. 1.) go to 10
*---- Transform accepted point to Gaussian distribution:
      zzr = sqrt(-2. * log(zzr)/zzr)
      gr1 = xi1 * zzr
      gr2 = xi2 * zzr
      end
+dk hqr2
      subroutine hqr2(ndim, n, ilow, iupp, h, wr, wi, vecs, ierr)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Finds eigenvalues and eigenvectors of an unsymmetric real matrix,  *
*   A which has been reduced to upper Hessenberg form, H, by the       *
*   subroutine ORTHES. The orthogonal transformations must be placed   *
*   in the array VECS by subroutine ORTRAN.                            *
*                                                                      *
*   Translation of the ALGOL procedure HQR2 in:                        *
*   Handbook Series Linear Algebra,                                    *
*   Num. Math. 16, 181 - 204 (1970) by G. Peters and J. H. Wilkinson.  *
* Input:                                                               *
*   N         (integer) Order of the Hessenberg matrix H.              *
*   ILOW,IUPP (integer)                                                *
*   H(NDIM,N) (real)    The Hessenberg matrix produced by ORTHES.      *
*   VECS(NDIM,N) (real) A square matrix of order N containing the      *
*                       similarity transformation from A to H          *
* Output:                                                              *
*   H(NDIM,N) (real)    Modified.                                      *
*   WR(N)     (real)    Real parts of eigenvalues of H (or A).         *
*   WI(N)     (real)    Imaginary parts of eigenvalues of H (or A).    *
*   VECS(NDIM,N) (real) The unnormalized eigenvectors of A.            *
*                       Complex vectors are stored as pairs of reals.  *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ien,ierr,ilow,its,iupp,j,k,l,m,n,na,ndim
      double precision den,h,hnorm,p,q,r,ra,s,sa,t,temp,tempi,tempr,
     +vecs,vi,vr,w,wi,wr,x,y,z
      dimension         h(ndim,n), wr(n), wi(n), vecs(ndim,n)
+ca mchpar

      ierr = 0

*---- Store isolated roots.
      do 10 i = 1, n
        if (i .lt. ilow  .or.  i .gt. iupp) then
          wr(i) = h(i,i)
          wi(i) = 0.0
        endif
   10 continue

      ien = iupp
      t = 0.0

*---- Next eigenvalue.
   60 if (ien .ge. ilow) then
        its = 0
        na = ien - 1

*---- Next iteration; look for single small sub-diagonal element.
   70   continue
          do 80 l = ien, ilow + 1, -1
            if (abs(h(l,l-1)) .le.
     +          epsmch * (abs(h(l-1,l-1)) + abs(h(l,l)))) go to 100
   80     continue
          l = ilow
  100     continue
          x = h(ien,ien)
          if (l .eq. ien) go to 270
          y = h(na,na)
          w = h(ien,na) * h(na,ien)
          if (l .eq. na) go to 280
          if (its .eq. 30) then
            ierr = ien
            go to 9999
          endif

*---- Form exceptional shift.
          if (its .eq. 10  .or.  its .eq. 20) then
            t = t + x
            do 120 i = ilow, ien
              h(i,i) = h(i,i) - x
  120       continue
            s = abs(h(ien,na)) + abs(h(na,ien-2))
            x = 0.75 * s
            y = x
            w = - 0.4375 * s * s
          endif
          its = its + 1

*---- Look for two consecutive small sub-diagonal elements.
          do 140 m = ien - 2, l, - 1
            z = h(m,m)
            r = x - z
            s = y - z
            p = (r * s - w) / h(m+1,m) + h(m,m+1)
            q = h(m+1,m+1) - z - r - s
            r = h(m+2,m+1)
            s = abs(p) + abs(q) + abs(r)
            p = p / s
            q = q / s
            r = r / s
            if (m .eq. l) go to 150
            if (abs(h(m,m-1)) * (abs(q) + abs(r)) .le. epsmch * abs(p)
     x       * (abs(h(m-1,m-1)) + abs(z) + abs(h(m+1,m+1)))) go to 150
  140     continue

  150     continue
          h(m+2,m) = 0.0
          do 160 i = m + 3, ien
            h(i,i-2) = 0.0
            h(i,i-3) = 0.0
  160     continue

*---- Double QR step involving rows L to IEN and columns M to IEN.
          do 260 k = m, na
            if (k .ne. m) then
              p = h(k,k-1)
              q = h(k+1,k-1)
              if (k .ne. na) then
                r = h(k+2,k-1)
              else
                r = 0.0
              endif
              x = abs(p) + abs(q) + abs(r)
              if (x .eq. 0.0) go to 260
              p = p / x
              q = q / x
              r = r / x
            endif
            s = sign(sqrt(p**2+q**2+r**2),p)
            if (k .ne. m) then
              h(k,k-1) = - s * x
            else if (l .ne. m) then
              h(k,k-1) = - h(k,k-1)
            endif
            p = p + s
            x = p / s
            y = q / s
            z = r / s
            q = q / p
            r = r / p

*---- Row modification.
            do 210 j = k, n
              p = h(k,j) + q * h(k+1,j)
              if (k .ne. na) then
                p = p + r * h(k+2,j)
                h(k+2,j) = h(k+2,j) - p * z
              endif
              h(k+1,j) = h(k+1,j) - p * y
              h(k,j) = h(k,j) - p * x
  210       continue

*---- Column modification.
            j = min(ien,k+3)
            do 230 i = 1, j
              p = x * h(i,k) + y * h(i,k+1)
              if (k .ne. na) then
                p = p + z * h(i,k+2)
                h(i,k+2) = h(i,k+2) - p * r
              endif
              h(i,k+1) = h(i,k+1) - p * q
              h(i,k) = h(i,k) - p
  230       continue

*---- Accumulate transformations.
            do 250 i = ilow, iupp
              p = x * vecs(i,k) + y * vecs(i,k+1)
              if (k .ne. na) then
                p = p + z * vecs(i,k+2)
                vecs(i,k+2) = vecs(i,k+2) - p * r
              endif
              vecs(i,k+1) = vecs(i,k+1) - p * q
              vecs(i,k) = vecs(i,k) - p
  250       continue
  260     continue

*---- Go to next iteration.
        go to 70

*==== One real root found.
  270   h(ien,ien) = x + t
        wr(ien) = h(ien,ien)
        wi(ien) = 0.0
        ien = na
        go to 60

*==== Two roots (real pair or complex conjugate) found.
  280   p = (y - x) / 2.0
        q = p**2 + w
        z = sqrt(abs(q))
        x = x + t
        h(ien,ien) = x
        h(na,na) = y + t

*---- Real pair.
        if (q .gt. 0.0) then
          z = p + sign(z,p)
          wr(na) = x + z
          wr(ien) = x - w / z
          wi(na) = 0.0
          wi(ien) = 0.0
          x = h(ien,na)
          r = sqrt(x**2+z**2)
          p = x / r
          q = z / r

*---- Row modification.
          do 290 j = na, n
            z = h(na,j)
            h(na,j) = q * z + p * h(ien,j)
            h(ien,j) = q * h(ien,j) - p * z
  290     continue

*---- Column modification.
          do 300 i = 1, ien
            z = h(i,na)
            h(i,na) = q * z + p * h(i,ien)
            h(i,ien) = q * h(i,ien) - p * z
  300     continue

*---- Accumulate transformations.
          do 310 i = ilow, iupp
            z = vecs(i,na)
            vecs(i,na) = q * z + p * vecs(i,ien)
            vecs(i,ien) = q * vecs(i,ien) - p * z
  310     continue

*---- Complex pair.
        else
          wr(na) = x + p
          wr(ien) = x + p
          wi(na) = z
          wi(ien) = -z
        endif

*----- Go to next root.
        ien = ien - 2
        go to 60
      endif

*==== Compute matrix norm.
      hnorm = 0.0
      k = 1
      do 520 i = 1, n
        do 510 j = k, n
          hnorm = hnorm + abs(h(i,j))
  510   continue
        k = i
  520 continue

*==== Back substitution.
      do 690 ien = n, 1, -1
        p = wr(ien)
        q = wi(ien)
        na = ien - 1

*---- Real vector.
        if (q .eq. 0.0) then
          m = ien
          h(ien,ien) = 1.0
          do 640 i = na, 1, -1
            w = h(i,i) - p
            r = h(i,ien)
            do 610 j = m, na
              r = r + h(i,j) * h(j,ien)
  610       continue
            if (wi(i) .lt. 0.0) then
              z = w
              s = r
            else
              m = i
              if (wi(i) .eq. 0.0) then
                temp = w
                if (w .eq. 0.0) temp = epsmch * hnorm
                h(i,ien) = - r / temp
              else
                x = h(i,i+1)
                y = h(i+1,i)
                q = (wr(i) - p)**2 + wi(i)**2
                t = (x * s - z * r) / q
                h(i,ien) = t
                if (abs(x) .gt. abs(z)) then
                  h(i+1,ien) = - (r + w * t) / x
                else
                  h(i+1,ien) = - (s + y * t) / z
                endif
              endif
            endif
  640     continue

*---- Complex vector associated with lamda = P - i * Q.
        else if (q .lt. 0.0) then
          m = na
          if (abs(h(ien,na)) .gt. abs(h(na,ien))) then
            h(na,na) = - (h(ien,ien) - p) / h(ien,na)
            h(na,ien) = - q / h(ien,na)
          else
            den = (h(na,na) - p)**2 + q**2
            h(na,na) = - h(na,ien) * (h(na,na) - p) / den
            h(na,ien) = h(na,ien) * q / den
          endif
          h(ien,na) = 1.0
          h(ien,ien) = 0.0
          do 680 i = ien - 2, 1, - 1
            w = h(i,i) - p
            ra = h(i,ien)
            sa = 0.0
            do 660 j = m, na
              ra = ra + h(i,j) * h(j,na)
              sa = sa + h(i,j) * h(j,ien)
  660       continue
            if (wi(i) .lt. 0.0) then
              z = w
              r = ra
              s = sa
            else
              m = i
              if (wi(i) .eq. 0.0) then
                den = w**2 + q**2
                h(i,na) = - (ra * w + sa * q) / den
                h(i,ien) = (ra * q - sa * w) / den
              else
                x = h(i,i+1)
                y = h(i+1,i)
                vr = (wr(i) - p)**2 + wi(i)**2 - q**2
                vi = 2.0 * (wr(i) - p) * q
                if (vr .eq. 0.0  .and.  vi .eq. 0.0) then
                  vr = epsmch * hnorm
     +               * (abs(w) + abs(q) + abs(x) + abs(y) + abs(z))
                endif
                tempr = x * r - z * ra + q * sa
                tempi = x * s - z * sa - q * ra
                den = vr**2 + vi**2
                h(i,na) = (tempr * vr + tempi * vi) / den
                h(i,ien) = (tempi * vr - tempr * vi) / den
                if (abs(x) .gt. abs(z) + abs(q)) then
                  h(i+1,na) = (- ra - w * h(i,na) + q * h(i,ien)) / x
                  h(i+1,ien) = (- sa - w * h(i,ien) - q * h(i,na)) / x
                else
                  tempr = - r - y * h(i,na)
                  tempi = - s - y * h(i,ien)
                  den = z**2 + q**2
                  h(i+1,na) = (tempr * z + tempi * q) / den
                  h(i+1,ien) = (tempi * z - tempr * q) / den
                endif
              endif
            endif
  680     continue
        endif
  690 continue

*==== Vectors of isolated roots.
      do 720 i = 1, n
        if (i .lt. ilow  .or.  i .gt. iupp) then
          do 710 j = i, n
            vecs(i,j) = h(i,j)
  710     continue
        endif
  720 continue

*==== Multiply by transformation matrix to give eigenvectors of the
*     original full matrix.
      do 790 j = n, ilow, - 1
        m = min(j,iupp)
        if (wi(j) .lt. 0.0) then
          l = j - 1
          do 740 i = ilow, iupp
            y = 0.0
            z = 0.0
            do 730 k = ilow, m
              y = y + vecs(i,k) * h(k,l)
              z = z + vecs(i,k) * h(k,j)
  730       continue
            vecs(i,l) = y
            vecs(i,j) = z
  740     continue
        else if (wi(j) .eq. 0.0) then
          do 760 i = ilow, iupp
            z = 0.0
            do 750 k = ilow, m
              z = z + vecs(i,k) * h(k,j)
  750       continue
            vecs(i,j) = z
  760     continue
        endif
  790 continue

 9999 end
+dk htlsq
      subroutine htlsq(a, b, m, n, epsm, iter, x, ipiv, r, sqr, dot)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   This subroutine applies successive Householder transformations     *
*   to A and B in order to minimize the norm of  R = A*X - B.          *
* Input:                                                               *
*   A(M,N)    (real)    Input matrix (distroyed by HTLSQ).             *
*   B(M)      (real)    Right hand side (distroyed by HTLSQ).          *
*   EPSM      (real)    Tolerance.                                     *
*   ITER      (real)    Limit for number of transformations.           *
* Output:                                                              *
*   X(N)      (real)    Result vector.                                 *
* Working space:                                                       *
*   IPIV(N)   (integer) Permutation vector.                            *
*   R(M)      (real)    Residual vector.                               *
*   SQR(N)    (real)    Working space.                                 *
*   DOT(N)    (real)    Working space.                                 *
*----------------------------------------------------------------------*
+ca aparam
      integer i,itemp,iter,itmax,j,k,kpivot,m,n
      double precision a,b,beta,dot,eps1,epsm,gg,h,hh,pivot,pivott,r,
     +sigma,sqr,sqrmin,sum,temp,x
      dimension         a(m,n), b(m), x(n), r(m), sqr(n), dot(n)
      integer           ipiv(n)

*---- Find scalar products SQR(K)=A(K)*A(K) and DOT(K)=A(K)*B.
      sum = 0.0
      do 90 k = 1, n
        ipiv(k) = k
        hh = 0.0
        gg = 0.0
        do 80 i = 1, m
          hh = hh + a(i,k) * a(i,k)
          gg = gg + a(i,k) * b(i)
   80   continue
        sum = sum + hh
        sqr(k) = hh
        dot(k) = gg
   90 continue
      sqrmin = 1.e-8 * sum / n

*==== Begin of iteration loop.
      itmax = min(n,iter)
      if (itmax .eq. 0) itmax = n
      do 500 k = 1, itmax

*---- Search for largest change.
        pivot  = 0.0
        kpivot = 0
        do 110 j = k, n
          if (sqr(j) .gt. sqrmin) then
            pivott = dot(j) * dot(j) / sqr(j)
            if (pivott .gt. pivot) then
              kpivot = j
              pivot  = pivott
            endif
          endif
  110   continue

*---- If no suitable pivot found, stop.
        if (kpivot .eq. 0) then
          iter = k - 1
          go to 600
        endif

*---- Move pivot column to position.
        if (kpivot .gt. k) then
          temp        = sqr(k)
          sqr(k)      = sqr(kpivot)
          sqr(kpivot) = temp
          temp        = dot(k)
          dot(k)      = dot(kpivot)
          dot(kpivot) = temp
          itemp        = ipiv(k)
          ipiv(k)      = ipiv(kpivot)
          ipiv(kpivot) = itemp
          do 120 i = 1, m
            temp        = a(i,k)
            a(i,k)      = a(i,kpivot)
            a(i,kpivot) = temp
  120     continue
        endif

*---- Find beta, sigma, and vector U(K).
        hh = 0.0
        do 130 i = k, m
          hh = hh + a(i,k) * a(i,k)
  130   continue
        sigma = sign(sqrt(hh), a(k,k))
        sqr(k) = - sigma
        a(k,k) = a(k,k) + sigma
        beta = 1.0 / (a(k,k) * sigma)

*---- Transform remaining columns of A.
        do 250 j = k + 1, n
          hh = 0.0
          do 210 i = k, m
            hh = hh + a(i,k) * a(i,j)
  210     continue
          h = beta * hh
          do 220 i = k, m
            a(i,j) = a(i,j) - a(i,k) * h
  220     continue
  250   continue

*---- Transform vector B.
        hh = 0.0
        do 260 i = k, m
          hh = hh + a(i,k) * b(i)
  260   continue
        h = beta * hh
        do 270 i = k, m
          b(i) = b(i) - a(i,k) * h
  270   continue

*---- Update scalar products SQR(J)=A(J)*A(J) and DOT(J)=A(J)*B.
        do 310 j = k + 1, n
          sqr(j) = sqr(j) - a(k,j) * a(k,j)
          dot(j) = dot(j) - a(k,j) * b(k)
  310   continue

*---- Recalculate solution vector X.
        x(k) = b(k) / sqr(k)
        do 350 i = k - 1, 1, - 1
          x(i) = b(i)
          do 320 j = i + 1, k
            x(i) = x(i) - a(i,j) * x(j)
  320     continue
          x(i) = x(i) / sqr(i)
  350   continue

*---- Find original residual vector by backward transformation.
        do 410 i = 1, m
          r(i) = b(i)
  410   continue
        do 450 j = k, 1, - 1
          r(j) = 0.0
          hh = 0.0
          do 420 i = j, m
            hh = hh + a(i,j) * r(i)
  420     continue
          h = hh / (sqr(j) * a(j,j))
          do 430 i = j, m
            r(i) = r(i) + a(i,j) * h
  430     continue
  450   continue

*---- Check for convergence.
        eps1 = r(1)**2
        do 460 i = 2, m
          eps1 = eps1 + r(i)**2
  460   continue
        eps1 = sqrt(eps1/max(m,1))
        if (eps1 .le. epsm) then
          iter = k
          go to 600
        endif
  500 continue

*==== End of iteration loop.
      iter = itmax
  600 continue

*---- Re-order corrector strengths.
      do 610 k = 1, n
        sqr(k) = x(k)
        x(k) = 0.0
  610 continue
      do 620 k = 1, iter
        x(ipiv(k)) = sqr(k)
  620 continue

      end
+dk init55
      subroutine init55(iseed)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Using the given seed value, initialize the pseudo-random number    *
*   generator and load the array IRN with a set of random numbers in   *
*   [0, MAXRAN).                                                       *
* Input:                                                               *
*   ISEED     (integer) A seed value in the range [0..MAXRAN).         *
*----------------------------------------------------------------------*
+ca aparam
+ca ranqzq
      integer i,ii,iseed,j,k,nd

      parameter         (nd = 21)

      j = mod(abs(iseed), maxran)
      irn(nr) = j
      k = 1
      do 10 i = 1, nr - 1
        ii = mod(nd*i, nr)
        irn(ii) = k
        k = j - k
        if (k .lt. 0) k = k + maxran
        j = irn(ii)
   10 continue

*---- Call IRNGEN a few times to "warm it up".
      call irngen
      call irngen
      call irngen

      end
+dk irngen
      subroutine irngen
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Generate the next "NR" elements in the pseudo-random sequence.     *
*----------------------------------------------------------------------*
+ca aparam
+ca ranqzq
      integer i,j,nj

      parameter         (nj = 24)

      do 10 i = 1, nj
        j = irn(i) - irn(i+nr-nj)
        if (j .lt. 0) j = j + maxran
        irn(i) = j
   10 continue

      do 20 i = nj + 1, nr
        j = irn(i) - irn(i-nj)
        if (j .lt. 0) j = j + maxran
        irn(i) = j
   20 continue

      next = 1

      end
+dk lmdif
      subroutine lmdif(fcn, m, n, x, fvec, epsfcn, diag, factor,
     +                 fjac, ldfjac, ipvt, qtf, wa1, wa2, wa3, wa4)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   The purpose of LMDIF is to minimize the sum of the squares of      *
*   M nonlinear functions in N variables by a modification of          *
*   the Levenberg-Marquardt algorithm. The user must provide a         *
*   subroutine which calculates the functions. The Jacobian is         *
*   then calculated by a forward-difference approximation.             *
*                                                                      *
*       FCN is the name of the user-supplied subroutine which          *
*         calculates the functions. FCN must be declared               *
*         in an external statement in the user calling                 *
*         program, and should be written as follows:                   *
*                                                                      *
*         SUBROUTINE FCN(M,N,X,FVEC,IFLAG)                             *
*         DIMENSION X(N),FVEC(M)                                       *
*         CALCULATE THE FUNCTIONS AT X AND                             *
*         RETURN THIS VECTOR IN FVEC.                                  *
*         RETURN                                                       *
*         END                                                          *
*                                                                      *
*         The value of IFLAG should be set to zero, unless there       *
*         is an error in evaluation of the function.                   *
*                                                                      *
*       M is a positive integer input variable set to the number       *
*         of functions.                                                *
*                                                                      *
*       N is a positive integer input variable set to the number       *
*         of variables. N must not exceed M.                           *
*                                                                      *
*       X is an array of length N. On input X must contain             *
*         an initial estimate of the solution vector. On output X      *
*         contains the final estimate of the solution vector.          *
*                                                                      *
*       FVEC is an output array of length M which contains             *
*         the functions evaluated at the output X.                     *
*                                                                      *
*       EPSFCN is an input variable used in determining a suitable     *
*         step length for the forward-difference approximation. This   *
*         approximation assumes that the relative errors in the        *
*         functions are of the order of EPSFCN. If EPSFCN is less      *
*         than the machine precision, it is assumed that the relative  *
*         errors in the functions are of the order of the machine      *
*         precision.                                                   *
*                                                                      *
*       DIAG is an array of length N. If MODE = 1 (see                 *
*         below), DIAG is internally set. If MODE = 2, DIAG            *
*         must contain positive entries that serve as                  *
*         multiplicative scale factors for the variables.              *
*                                                                      *
*       FACTOR is a positive input variable used in determining the    *
*         initial step bound. This bound is set to the product of      *
*         FACTOR and the Euclidean norm of DIAG*X if nonzero, or else  *
*         to FACTOR itself. In most cases FACTOR should lie in the     *
*         interval (.1,100.). 100. Is a generally recommended value.   *
*                                                                      *
*       FJAC is an output M by N array. The upper N by N submatrix     *
*         of FJAC contains an upper triangular matrix R with           *
*         diagonal elements of nonincreasing magnitude such that       *
*                                                                      *
*                T     T           T                                   *
*               P *(JAC *JAC)*P = R *R,                                *
*                                                                      *
*         where P is a permutation matrix and JAC is the final         *
*         calculated Jacobian. column J of P is column IPVT(J)         *
*         (see below) of the identity matrix. The lower trapezoidal    *
*         part of FJAC contains information generated during           *
*         the computation of R.                                        *
*                                                                      *
*       LDFJAC is a positive integer input variable not less than M    *
*         which specifies the leading dimension of the array FJAC.     *
*                                                                      *
*       IPVT is an integer output array of length N. IPVT              *
*         defines a permutation matrix P such that JAC*P = Q*r,        *
*         where JAC is the final calculated Jacobian, Q is             *
*         orthogonal (not stored), and R is upper triangular           *
*         with diagonal elements of nonincreasing magnitude.           *
*         column J of P is column IPVT(J) of the identity matrix.      *
*                                                                      *
*       QTF is an output array of length N which contains              *
*         the first N elements of the vector (Q transpose)*FVEC.       *
*                                                                      *
*       WA1, WA2, and WA3 are work arrays of length N.                 *
*                                                                      *
*       WA4 is a work array of length M.                               *
* Source:                                                              *
*   Argonne National Laboratory. MINPACK Project. March 1980.          *
*   Burton S. Garbow, Kenneth E. Hillstrom, Jorge J. More.             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iflag,info,iter,j,l,ldfjac,level,m,n
      double precision actred,delta,diag,dirder,epsfcn,epsil,factor,
     +fjac,fnorm,fnorm1,ftol,fvec,gnorm,gtol,one,p0001,p1,p25,p5,p75,
     +par,pnorm,prered,qtf,ratio,sum,temp,temp1,temp2,two,vmod,wa1,wa2,
     +wa3,wa4,x,xnorm,xtol,zero
      external          fcn
      dimension         x(n), fvec(m), diag(n), fjac(ldfjac,n), qtf(n),
     +                  wa1(n), wa2(n), wa3(n), wa4(m)
      integer           ipvt(n)
+ca message
+ca minuit
+ca mchpar

      parameter         (one    = 1.0d0)
      parameter         (two    = 2.0d0)
      parameter         (p1     = 0.1d0)
      parameter         (p5     = 0.5d0)
      parameter         (p25    = 0.25d0)
      parameter         (p75    = 0.75d0)
      parameter         (p0001  = 0.0001d0)
      parameter         (epsil  = 1.0d-8)
      parameter         (zero   = 0.0d0)

      info = 0
      ftol = epsfcn
      gtol = epsil
      xtol = epsil
      crout = 'LMDIF'
      cstat = 'start'

*---- Check the input parameters for errors.
      if (n .le. 0 .or. m .lt. n .or. ldfjac .lt. m
     +    .or. ftol .lt. zero .or. xtol .lt. zero .or. gtol .lt. zero
     +    .or. nfcnmx .le. 0 .or. factor .le. zero) go to 300

*---- Evaluate the function at the starting point and find its norm.
      call fcn(m,n,x,fvec,iflag)
      nfcn = nfcn + 1
      if (iflag .ne. 0) then
        msg(1) = 'Matching stopped, start point seems to be unstable,'
        msg(2) = '(Maybe a "LINE = ..." condition is unstable).'
        call aawarn('LMDIF', 2, msg)
        info = - 1
        go to 300
      endif
      fnorm = vmod(m, fvec)
      fmin = fnorm**2
      edm = fmin

*---- Quit, when initial value is already OK.
      if (fmin .le. ftol) then
        info = 4
        go to 300
      endif
      if (ilevel .ge. 1) call mtprnt(n, x)

*---- Initialize Levenberg-Marquardt parameter and iteration count
      par = zero
      iter = 1

*---- Beginning of the outer loop.
   30 continue

*---- Calculate the Jacobian matrix.
         call fdjac2(fcn,m,n,x,fvec,fjac,ldfjac,iflag,xtol,wa4)
         nfcn = nfcn + n
         if (iflag .ne. 0) then
           info = - 1
           go to 300
         endif

*---- Compute the QR factorization of the Jacobian.
         call qrfac(m,n,fjac,ldfjac,.true.,ipvt,n,wa1,wa2,wa3)

*---- On the first iteration scale according to the norms
*     of the columns of the initial Jacobian.
*     Calculate the norm of the scaled X
*     and initialize the step bound delta.
         if (iter .eq. 1) then
            do 50 j = 1, n
               diag(j) = wa2(j)
               if (wa2(j) .eq. zero) diag(j) = one
               wa3(j) = diag(j)*x(j)
   50       continue
            xnorm = vmod(n, wa3)
            delta = factor*xnorm
            if (delta .eq. zero) delta = factor
         endif

*---- Form (Q transpose)*FVEC and store the first N components in QTF.
         do 90 i = 1, m
            wa4(i) = fvec(i)
   90    continue
         do 130 j = 1, n
            if (fjac(j,j) .ne. zero) then
               sum = zero
               do 100 i = j, m
                  sum = sum + fjac(i,j)*wa4(i)
  100          continue
               temp = -sum/fjac(j,j)
               do 110 i = j, m
                  wa4(i) = wa4(i) + fjac(i,j)*temp
  110          continue
            endif
            fjac(j,j) = wa1(j)
            qtf(j) = wa4(j)
  130    continue

*---- Compute the norm of the scaled gradient.
         gnorm = zero
         if (fnorm .ne. zero) then
            do 160 j = 1, n
               l = ipvt(j)
               if (wa2(l) .ne. zero) then
                  sum = zero
                  do 140 i = 1, j
                     sum = sum + fjac(i,j)*(qtf(i)/fnorm)
  140             continue
                  gnorm = max(gnorm,abs(sum/wa2(l)))
               endif
  160       continue
         endif

*---- Test for convergence of the gradient norm.
         if (gnorm .le. gtol) info = 4
         if (info .ne. 0) go to 300

*---- Rescale if necessary.
         do 180 j = 1, n
            diag(j) = max(diag(j),wa2(j))
  180    continue

*---- Beginning of the inner loop.
  200    continue

*---- Determine the Levenberg-Marquardt parameter.
            call lmpar(n,fjac,ldfjac,ipvt,diag,qtf,delta,par,wa1,wa2,
     +                 wa3,wa4)

*---- Store the direction P and X + P. Calculate the norm of P.
            do 210 j = 1, n
               wa1(j) = -wa1(j)
               wa2(j) = x(j) + wa1(j)
               wa3(j) = diag(j)*wa1(j)
  210       continue
            pnorm = vmod(n, wa3)

*---- On the first iteration, adjust the initial step bound.
            if (iter .eq. 1) delta = min(delta,pnorm)

*---- Evaluate the function at X + P and calculate its norm.
            call fcn(m,n,wa2,wa4,iflag)
            nfcn = nfcn + 1
            if (iflag .ne. 0) then
              fnorm1 = two * fnorm
            else
              fnorm1 = vmod(m, wa4)
            endif

*---- Compute the scaled actual reduction.
            actred = -one
            if (p1*fnorm1 .lt. fnorm) actred = one - (fnorm1/fnorm)**2

*---- Compute the scaled predicted reduction and
*     the scaled directional derivative.
            do 230 j = 1, n
               wa3(j) = zero
               l = ipvt(j)
               temp = wa1(l)
               do 220 i = 1, j
                  wa3(i) = wa3(i) + fjac(i,j)*temp
  220          continue
  230       continue
            temp1 = vmod(n, wa3)/fnorm
            temp2 = (sqrt(par)*pnorm)/fnorm
            prered = temp1**2 + temp2**2/p5
            dirder = -(temp1**2 + temp2**2)

*---- Compute the ratio of the actual to the predicted reduction.
            ratio = zero
            if (prered .ne. zero) ratio = actred/prered

*---- Update the step bound.
            if (ratio .le. p25) then
               if (actred .ge. zero) temp = p5
               if (actred .lt. zero)
     +            temp = p5*dirder/(dirder + p5*actred)
               if (p1*fnorm1 .ge. fnorm .or. temp .lt. p1) temp = p1
               delta = temp*min(delta,pnorm/p1)
               par = par/temp
            else if (par .eq. zero .or. ratio .ge. p75) then
               delta = pnorm/p5
               par = p5*par
            endif

*---- Test for successful iteration.
            if (ratio .ge. p0001) then

*---- Successful iteration. Update X, FVEC, and their norms.
               do 270 j = 1, n
                  x(j) = wa2(j)
                  wa2(j) = diag(j)*x(j)
  270          continue
               do 280 i = 1, m
                  fvec(i) = wa4(i)
  280          continue
               xnorm = vmod(n, wa2)
               fnorm = fnorm1
               iter = iter + 1

*---- If requested, print iterates.
               fmin = fnorm**2
               edm = gnorm * fmin
               cstat = 'progress'
               level = 3
               if (mod(iter,10) .eq. 0) level = 2
               if (ilevel .ge. level) call mtprnt(n, x)
            endif

*---- Tests for convergence.
            if (abs(actred) .le. ftol .and. prered .le. ftol
     +          .and. p5*ratio .le. one) info = 1
            if (delta .le. xtol*xnorm) info = 2
            if (abs(actred) .le. ftol .and. prered .le. ftol
     +          .and. p5*ratio .le. one .and. info .eq. 2) info = 3
            if (fmin .le. ftol) info = 4
            if (info .ne. 0) go to 300

*---- Tests for termination and stringent tolerances.
            if (nfcn .ge. nfcnmx) info = 5
            if (abs(actred) .le. epsmch .and. prered .le. epsmch
     +          .and. p5*ratio .le. one) info = 6
            if (delta .le. epsmch*xnorm) info = 7
            if (gnorm .le. epsmch) info = 8
            if (info .ne. 0) go to 300

*---- End of the inner loop. Repeat if iteration unsuccessful.
          if (ratio .lt. p0001) go to 200

*---- End of the outer loop.
       go to 30

*---- Termination, either normal or user imposed.
  300 continue
      call mtputi(n, x)
      if (info .lt. 0) then
        cstat = 'unstable'
      else if (info .eq. 0) then
        cstat = 'error'
      else if (info .lt. 5) then
        cstat = 'converged'
      else if (info .eq. 5) then
        cstat = 'call limit'
      else
        cstat = 'accuracy limit'
      endif
      if (ilevel .ge. 1) call mtprnt(n, x)

      end
+dk lmpar
      subroutine lmpar(n,r,ldr,ipvt,diag,qtb,delta,par,x,sdiag,wa1,wa2)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Given an M by N matrix A, an N by N nonsingular diagonal           *
*   matrix D, an M-vector B, and a positive number DELTA,              *
*   the problem is to determine a value for the parameter              *
*   PAR such that if X solves the system                               *
*                                                                      *
*           A*X = B,     SQRT(PAR)*D*X = 0,                            *
*                                                                      *
*   in the least squares sense, and DXNORM is the Euclidean            *
*   norm of D*X, then either PAR is zero and                           *
*                                                                      *
*           (DXNORM-DELTA) .LE. 0.1*DELTA,                             *
*                                                                      *
*   or PAR is positive and                                             *
*                                                                      *
*           ABS(DXNORM-DELTA) .LE. 0.1*DELTA.                          *
*                                                                      *
*   This subroutine completes the solution of the problem              *
*   if it is provided with the necessary information from the          *
*   QR factorization, with column pivoting, of A. That is, if          *
*   A*P = Q*R, where P is a permutation matrix, Q has orthogonal       *
*   columns, and R is an upper triangular matrix with diagonal         *
*   elements of nonincreasing magnitude, then LMPAR expects            *
*   the full upper triangle of R, the permutation matrix P,            *
*   and the first N components of (Q transpose)*B. On output           *
*   LMPAR also provides an upper triangular matrix S such that         *
*                                                                      *
*            T   T                   T                                 *
*           P *(A *A + PAR*D*D)*P = S *S.                              *
*                                                                      *
*   S is employed within LMPAR and may be of separate interest.        *
*                                                                      *
*   Only a few iterations are generally needed for convergence         *
*   of the algorithm. If, however, the limit of 10 iterations          *
*   is reached, then the output PAR will contain the best              *
*   value obtained so far.                                             *
*                                                                      *
*       N is a positive integer input variable set to the order of R.  *
*                                                                      *
*       R is an N by N array. On input the full upper triangle         *
*         must contain the full upper triangle of the matrix R.        *
*         on output the full upper triangle is unaltered, and the      *
*         strict lower triangle contains the strict upper triangle     *
*         (transposed) of the upper triangular matrix S.               *
*                                                                      *
*       LDR is a positive integer input variable not less than N       *
*         which specifies the leading dimension of the array R.        *
*                                                                      *
*       IPVT is an integer input array of length N which defines the   *
*         permutation matrix P such that A*P = Q*R. column J of P      *
*         is column IPVT(J) of the identity matrix.                    *
*                                                                      *
*       DIAG is an input array of length N which must contain the      *
*         diagonal elements of the matrix D.                           *
*                                                                      *
*       QTB is an input array of length N which must contain the first *
*         N elements of the vector (Q transpose)*B.                    *
*                                                                      *
*       DELTA is a positive input variable which specifies an upper    *
*         bound on the Euclidean norm of D*X.                          *
*                                                                      *
*       PAR is a nonnegative variable. On input PAR contains an        *
*         initial estimate of the Levenberg-Marquardt parameter.       *
*         on output PAR contains the final estimate.                   *
*                                                                      *
*       X is an output array of length N which contains the least      *
*         squares solution of the system A*X = B, SQRT(PAR)*D*X = 0,   *
*         for the output PAR.                                          *
*                                                                      *
*       SDIAG is an output array of length N which contains the        *
*         diagonal elements of the upper triangular matrix S.          *
*                                                                      *
*       WA1 and WA2 are work arrays of length N.                       *
* Source:                                                              *
*   Argonne National Laboratory. MINPACK Project. March 1980.          *
*   Burton S. Garbow, Kenneth E. Hillstrom, Jorge J. More.             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,iter,j,k,l,ldr,n,nsing
      double precision delta,diag,dxnorm,fp,gnorm,p001,p1,par,parc,parl,
     +paru,qtb,r,sdiag,sum,temp,vmod,wa1,wa2,x,zero
      dimension         r(ldr,n), diag(n), qtb(n), x(n), sdiag(n),
     +                  wa1(n), wa2(n)
      integer           ipvt(n)
+ca mchpar

      parameter         (p1     = 0.1d0)
      parameter         (p001   = 0.001d0)
      parameter         (zero   = 0.0d0)

*---- Compute and store in X the Gauss-Newton direction. If the
*     Jacobian is rank-deficient, obtain a least squares solution.
      nsing = n
      do 10 j = 1, n
         wa1(j) = qtb(j)
         if (r(j,j) .eq. zero .and. nsing .eq. n) nsing = j - 1
         if (nsing .lt. n) wa1(j) = zero
   10 continue
      do 40 k = 1, nsing
         j = nsing - k + 1
         wa1(j) = wa1(j)/r(j,j)
         temp = wa1(j)
         do 20 i = 1, j - 1
            wa1(i) = wa1(i) - r(i,j)*temp
   20    continue
   40 continue
      do 60 j = 1, n
         l = ipvt(j)
         x(l) = wa1(j)
   60 continue

*---- Initialize the iteration counter.
*     Evaluate the function at the origin, and test
*     for acceptance of the Gauss-Newton direction.
      iter = 0
      do 70 j = 1, n
         wa2(j) = diag(j)*x(j)
   70 continue
      dxnorm = vmod(n, wa2)
      fp = dxnorm - delta
      if (fp .le. p1*delta) go to 220

*---- If the Jacobian is not rank deficient, the Newton
*     step provides a lower bound, PARL, for the zero of
*     the function. Otherwise set this bound to zero.
      parl = zero
      if (nsing .ge. n) then
         do 80 j = 1, n
            l = ipvt(j)
            wa1(j) = diag(l)*(wa2(l)/dxnorm)
   80    continue
         do 110 j = 1, n
            sum = zero
            do 90 i = 1, j - 1
               sum = sum + r(i,j)*wa1(i)
   90       continue
            wa1(j) = (wa1(j) - sum)/r(j,j)
  110    continue
         temp = vmod(n, wa1)
         parl = ((fp/delta)/temp)/temp
      endif

*---- Calculate an upper bound, PARU, for the zero of the function.
      do 140 j = 1, n
         sum = zero
         do 130 i = 1, j
            sum = sum + r(i,j)*qtb(i)
  130    continue
         l = ipvt(j)
         wa1(j) = sum/diag(l)
  140 continue
      gnorm = vmod(n, wa1)
      paru = gnorm/delta
      if (paru .eq. zero) paru = fltmin/min(delta,p1)

*---- If the input PAR lies outside of the interval (PARL,PARU),
*     set PAR to the closer endpoint.
      par = max(par,parl)
      par = min(par,paru)
      if (par .eq. zero) par = gnorm/dxnorm

*---- Beginning of an iteration.
  150 continue
         iter = iter + 1

*---- Evaluate the function at the current value of PAR.
         if (par .eq. zero) par = max(fltmin,p001*paru)
         temp = sqrt(par)
         do 160 j = 1, n
            wa1(j) = temp*diag(j)
  160    continue
         call qrsolv(n,r,ldr,ipvt,wa1,qtb,x,sdiag,wa2)
         do 170 j = 1, n
            wa2(j) = diag(j)*x(j)
  170    continue
         dxnorm = vmod(n, wa2)
         temp = fp
         fp = dxnorm - delta

*---- If the function is small enough, accept the current value
*     of PAR. also test for the exceptional cases where PARL
*     is zero or the number of iterations has reached 10.
         if (abs(fp) .le. p1*delta
     +       .or. parl .eq. zero .and. fp .le. temp
     +            .and. temp .lt. zero .or. iter .eq. 10) go to 220

*---- Compute the Newton correction.
         do 180 j = 1, n
            l = ipvt(j)
            wa1(j) = diag(l)*(wa2(l)/dxnorm)
  180    continue
         do 210 j = 1, n
            wa1(j) = wa1(j)/sdiag(j)
            temp = wa1(j)
            do 190 i = j + 1, n
               wa1(i) = wa1(i) - r(i,j)*temp
  190       continue
  210    continue
         temp = vmod(n, wa1)
         parc = ((fp/delta)/temp)/temp

*---- Depending on the sign of the function, update PARL or PARU.
         if (fp .gt. zero) parl = max(parl,par)
         if (fp .lt. zero) paru = min(paru,par)

*---- Compute an improved estimate for PAR.
         par = max(parl,par+parc)

*---- End of an iteration.
         go to 150
  220 continue

*---- Termination.
      if (iter .eq. 0) par = zero

      end
+dk ncopy
      subroutine ncopy(i1, i2, n)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Copy integer arays
*----------------------------------------------------------------------*
      integer i1(*), i2(*), n, i
      do i = 1, n
        i2(i) = i1(i)
      enddo
      end
+dk orthes
      subroutine orthes(ndim, n, ilow, iupp, a, d)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Converts an unsymmetric real matrix, A, to upper Hessenberg form   *
*   applying successive orthogonal transformations.                    *
*                                                                      *
*   Translation of the ALGOL procedure ORTHES in:                      *
*   Handbook Series Linear Algebra,                                    *
*   Num. Math. 12, 349-368 (1968) by R. S. Martin and J. H. Wilkinson. *
* Input:                                                               *
*   N         (integer) Order of the matrix A.                         *
*   ILOW,IUPP (integer) Determine a submatrix, set by BALANC.          *
*                       May be set to 1 and N respectively.            *
*   A(NDIM,N) (real)    Input matrix.                                  *
* Output:                                                              *
*   A(NDIM,N) (real)    The matrix A, converted to upper Hessenberg.   *
*                       The lower triangle contains information        *
*                       about the orthogonal transformations.          *
*   D(N)      (real)    Further information.                           *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ilow,iupp,j,m,n,ndim
      double precision a,d,f,g,h,scale
      dimension         a(ndim,n), d(n)

      do 90 m = ilow + 1, iupp - 1
        h = 0.0
        d(m) = 0.0

*---- Find scale factor.
        scale = 0.0
        do 10 i = m, iupp
          scale = scale + abs(a(i,m-1))
   10   continue
        if (scale .ne. 0.0) then
          do 20 i = iupp, m, - 1
            d(i) = a(i,m-1) / scale
            h = h + d(i) * d(i)
   20     continue

          g = sign(sqrt(h),d(m))
          h = h + d(m) * g
          d(m) = d(m) + g

*---- Form (I - (u*uT) / h) * A.
          do 50 j = m, n
            f = 0.0
            do 30 i = iupp, m, - 1
              f = f + d(i) * a(i,j)
   30       continue
            f = f / h
            do 40 i = m, iupp
              a(i,j) = a(i,j) - f * d(i)
   40       continue

   50     continue

*---- Form (I - (u*uT) / h) * A * (I - (u*uT) / h).
          do 80 i = 1, iupp
            f = 0.0
            do 60 j = iupp, m, - 1
              f = f + d(j) * a(i,j)
   60       continue
            f = f / h
            do 70 j = m, iupp
              a(i,j) = a(i,j) - f * d(j)
   70       continue
   80     continue

          d(m) = scale * d(m)
          a(m,m-1) = - scale * g
        endif
   90 continue

      end
+dk ortran
      subroutine ortran(ndim, n, ilow, iupp, h, d, v)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Accumulate the orthogonal similarity transformation used by        *
*   ORTHES to reduce a general real matrix A to upper Hessenberg form. *
*                                                                      *
*   Translation of the ALGOL procedure ORTRANS in:                     *
*   Handbook Series Linear Algebra,                                    *
*   Num. Math. 16, 181-204 (1970) by G. Peters and J. H. Wilkinson.    *
* Input:                                                               *
*   N         (integer) Order of the matrices A and V.                 *
*   ILOW,IUPP (integer) Determine a sub-matrix set by BALANC.          *
*                       May be set to 1 and N respectively.            *
*   H(NDIM,N) (real)    The matrix resulting from running ORTHES.      *
*   D(N)      (real)    Further information about the transformation.  *
* Output:                                                              *
*   V(NDIM,N) (real)    The accumulated transformation.                *
*   D(N)      (real)    Destroyed.                                     *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ilow,iupp,j,k,m,n,ndim
      double precision d,h,v,x,y
      dimension         h(ndim,n), d(n), v(ndim,n)

*---- Initialize V to identity matrix.
      do 20 i = 1, n
        do 10 j = 1, n
          v(i,j) = 0.0
   10   continue
        v(i,i) = 1.0
   20 continue

*---- Accumulate transformations.
      do 90 k = iupp - 2, ilow, - 1
        m = k + 1
        y = h(m,k)
        if (y .ne. 0.0) then
          y = y * d(m)

          do 30 i = k + 2, iupp
            d(i) = h(i,k)
   30     continue
*
          do 60 j = m, iupp
            x = 0.0
            do 40 i = m, iupp
              x = x + d(i) * v(i,j)
   40       continue
            x = x / y
            do 50 i = m, iupp
              v(i,j) = v(i,j) + x * d(i)
   50       continue
   60     continue
        endif
   90 continue

      end
+dk qrfac
      subroutine qrfac(m,n,a,lda,pivot,ipvt,lipvt,rdiag,acnorm,wa)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   This subroutine uses Householder transformations with column       *
*   pivoting (optional) to compute a QR factorization of the           *
*   M by N matrix a. That is, QRFAC determines an orthogonal           *
*   matrix Q, a permutation matrix P, and an upper trapezoidal         *
*   matrix R with diagonal elements of nonincreasing magnitude,        *
*   such that A*P = Q*R. The Householder transformation for            *
*   column K, K = 1,2,...,min(M,N), is of the form                     *
*                                                                      *
*                           T                                          *
*           I - (1/U(K))*U*U                                           *
*                                                                      *
*   where U has zeros in the first K-1 positions. The form of          *
*   this transformation and the method of pivoting first               *
*   appeared in the corresponding LINPACK subroutine.                  *
*                                                                      *
*       M is a positive integer input variable set to the number       *
*         of rows of A.                                                *
*                                                                      *
*       N is a positive integer input variable set to the number       *
*         of columns of A.                                             *
*                                                                      *
*       A is an M by N array. On input A contains the matrix for       *
*         which the QR factorization is to be computed. On output      *
*         The strict upper trapezoidal part of A contains the strict   *
*         upper trapezoidal part of R, and the lower trapezoidal       *
*         part of A contains a factored form of Q (the non-trivial     *
*         elements of the U vectors described above).                  *
*                                                                      *
*       LDA is a positive integer input variable not less than M       *
*         which specifies the leading dimension of the array A.        *
*                                                                      *
*       PIVOT is a logical input variable. If PIVOT is set true,       *
*         then column pivoting is enforced. If PIVOT is set false,     *
*         then no column pivoting is done.                             *
*                                                                      *
*       IPVT is an integer output array of length LIPVT. Ipvt          *
*         defines the permutation matrix P such that a*p = Q*r.        *
*         column J of P is column IPVT(J) of the identity matrix.      *
*         if PIVOT is false, IPVT is not referenced.                   *
*                                                                      *
*       LIPVT is a positive integer input variable. If PIVOT is false, *
*         then LIPVT may be as small as 1. If PIVOT is true, then      *
*         LIPVT must be at least N.                                    *
*                                                                      *
*       RDIAG is an output array of length N which contains the        *
*         diagonal elements of R.                                      *
*                                                                      *
*       ACNORM is an output array of length N which contains the       *
*         norms of the corresponding columns of the input matrix A.    *
*         If this information is not needed, then ACNORM can coincide  *
*         with RDIAG.                                                  *
*                                                                      *
*       WA is a work array of length N. If PIVOT is false, then WA     *
*         can coincide with RDIAG.                                     *
* Source:                                                              *
*   Argonne National Laboratory. MINPACK Project. March 1980.          *
*   Burton S. Garbow, Kenneth E. Hillstrom, Jorge J. More.             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,k,kmax,lda,lipvt,m,minmn,n
      double precision a,acnorm,ajnorm,one,p05,rdiag,sum,temp,vmod,wa,
     +zero
      integer           ipvt(lipvt)
      logical           pivot
      dimension         a(lda,n), rdiag(n), acnorm(n), wa(n)
+ca mchpar

      parameter         (one    = 1.0d0)
      parameter         (p05    = 0.05d0)
      parameter         (zero   = 0.0d0)

*---- Compute the initial column norms and initialize several arrays.
      do 10 j = 1, n
         acnorm(j) = vmod(m, a(1,j))
         rdiag(j) = acnorm(j)
         wa(j) = rdiag(j)
         if (pivot) ipvt(j) = j
   10 continue

*---- Reduce A to R with Householder transformations.
      minmn = min(m,n)
      do 110 j = 1, minmn
         if (pivot) then

*---- Bring the column of largest norm into the pivot position.
            kmax = j
            do 20 k = j, n
               if (rdiag(k) .gt. rdiag(kmax)) kmax = k
   20       continue
            if (kmax .ne. j) then
               do 30 i = 1, m
                  temp = a(i,j)
                  a(i,j) = a(i,kmax)
                  a(i,kmax) = temp
   30          continue
               rdiag(kmax) = rdiag(j)
               wa(kmax) = wa(j)
               k = ipvt(j)
               ipvt(j) = ipvt(kmax)
               ipvt(kmax) = k
            endif
         endif

*---- Compute the Householder transformation to reduce the
*     J-th column of A to a multiple of the J-th unit vector.
         ajnorm = vmod(m-j+1, a(j,j))
         if (ajnorm .ne. zero) then
            if (a(j,j) .lt. zero) ajnorm = -ajnorm
            do 50 i = j, m
               a(i,j) = a(i,j)/ajnorm
   50       continue
            a(j,j) = a(j,j) + one

*---- Apply the transformation to the remaining columns
*     and update the norms.
            do 90 k = j + 1, n
               sum = zero
               do 60 i = j, m
                  sum = sum + a(i,j)*a(i,k)
   60          continue
               temp = sum/a(j,j)
               do 70 i = j, m
                  a(i,k) = a(i,k) - temp*a(i,j)
   70          continue
               if (pivot .and. rdiag(k) .ne. zero) then
                  temp = a(j,k)/rdiag(k)
                  rdiag(k) = rdiag(k)*sqrt(max(zero,one-temp**2))
                  if (p05*(rdiag(k)/wa(k))**2 .le. epsmch) then
                     rdiag(k) = vmod(m-j, a(j+1,k))
                     wa(k) = rdiag(k)
                  endif
               endif
   90       continue
         endif
         rdiag(j) = -ajnorm
  110 continue

      end
+dk qrsolv
      subroutine qrsolv(n,r,ldr,ipvt,diag,qtb,x,sdiag,wa)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Given an M by N matrix A, an N by N diagonal matrix D,             *
*   and an M-vector B, the problem is to determine an X which          *
*   solves the system                                                  *
*                                                                      *
*           A*X = B,     D*X = 0,                                      *
*                                                                      *
*   in the least squares sense.                                        *
*                                                                      *
*   This subroutine completes the solution of the problem              *
*   if it is provided with the necessary information from the          *
*   QR factorization, with column pivoting, of A. That is, if          *
*   A*P = Q*R, where P is a permutation matrix, Q has orthogonal       *
*   columns, and R is an upper triangular matrix with diagonal         *
*   elements of nonincreasing magnitude, then QRSOLV expects           *
*   the full upper triangle of R, the permutation matrix P,            *
*   and the first N components of (Q transpose)*B. The system          *
*   A*X = B, D*X = 0, is then equivalent to                            *
*                                                                      *
*                  T      T                                            *
*           R*Z = Q *B,  P *D*P*Z = 0,                                 *
*                                                                      *
*   where X = P*Z. If this system does not have full rank,             *
*   then a least squares solution is obtained. On output QRSOLV        *
*   also provides an upper triangular matrix S such that               *
*                                                                      *
*            T   T               T                                     *
*           P *(A *A + D*D)*P = S *S.                                  *
*                                                                      *
*     S is computed within QRSOLV and may be of separate interest.     *
*                                                                      *
*       N is a positive integer input variable set to the order of R.  *
*                                                                      *
*       R is an N by N array. On input the full upper triangle         *
*         must contain the full upper triangle of the matrix R.        *
*         On output the full upper triangle is unaltered, and the      *
*         strict lower triangle contains the strict upper triangle     *
*         (transposed) of the upper triangular matrix S.               *
*                                                                      *
*       LDR is a positive integer input variable not less than N       *
*         which specifies the leading dimension of the array R.        *
*                                                                      *
*       IPVT is an integer input array of length N which defines the   *
*         permutation matrix P such that A*P = Q*R. Column J of P      *
*         is column IPVT(J) of the identity matrix.                    *
*                                                                      *
*       DIAG is an input array of length N which must contain the      *
*         diagonal elements of the matrix D.                           *
*                                                                      *
*       QTB is an input array of length N which must contain the first *
*         N elements of the vector (Q transpose)*B.                    *
*                                                                      *
*       X is an output array of length N which contains the least      *
*         squares solution of the system A*X = B, D*X = 0.             *
*                                                                      *
*       SDIAG is an output array of length N which contains the        *
*         diagonal elements of the upper triangular matrix S.          *
*                                                                      *
*       WA is a work array of length N.                                *
* Source:                                                              *
*   Argonne National Laboratory. MINPACK Project. March 1980.          *
*   Burton S. Garbow, Kenneth E. Hillstrom, Jorge J. More.             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,j,k,l,ldr,n,nsing
      double precision cos,cotan,diag,p25,p5,qtb,qtbpj,r,sdiag,sin,sum,
     +tan,temp,wa,x,zero
      integer           ipvt(n)
      dimension         r(ldr,n), diag(n), qtb(n), x(n), sdiag(n), wa(n)

      parameter         (p5     = 0.5d0)
      parameter         (p25    = 0.25d0)
      parameter         (zero   = 0.0d0)

*---- Copy R and (Q transpose)*B to preserve input and initialize S.
*     In particular, save the diagonal elements of R in X.
      do 20 j = 1, n
         do 10 i = j, n
            r(i,j) = r(j,i)
   10    continue
         x(j) = r(j,j)
         wa(j) = qtb(j)
   20 continue

*---- Eliminate the diagonal matrix D using a Givens rotation.
      do 100 j = 1, n

*---- Prepare the row of D to be eliminated, locating the
*     diagonal element using P from the QR factorization.
         l = ipvt(j)
         if (diag(l) .ne. zero) then
            do 30 k = j, n
               sdiag(k) = zero
   30       continue
            sdiag(j) = diag(l)

*---- The transformations to eliminate the row of D
*     modify only a single element of (Q transpose)*B
*     beyond the first N, which is initially zero.
            qtbpj = zero
            do 80 k = j, n

*---- Determine a Givens rotation which eliminates the
*     appropriate element in the current row of D.
               if (sdiag(k) .ne. zero) then
                  if (abs(r(k,k)) .lt. abs(sdiag(k))) then
                     cotan = r(k,k)/sdiag(k)
                     sin = p5/sqrt(p25+p25*cotan**2)
                     cos = sin*cotan
                  else
                     tan = sdiag(k)/r(k,k)
                     cos = p5/sqrt(p25+p25*tan**2)
                     sin = cos*tan
                  endif

*---- Compute the modified diagonal element of R and
*     the modified element of ((Q transpose)*b,0).
                  r(k,k) = cos*r(k,k) + sin*sdiag(k)
                  temp = cos*wa(k) + sin*qtbpj
                  qtbpj = -sin*wa(k) + cos*qtbpj
                  wa(k) = temp

*---- Accumulate the tranformation in the row of S.
                  do 60 i = k + 1, n
                     temp = cos*r(i,k) + sin*sdiag(i)
                     sdiag(i) = -sin*r(i,k) + cos*sdiag(i)
                     r(i,k) = temp
   60             continue
               endif
   80       continue
         endif

*---- Store the diagonal element of S and restore
*     the corresponding diagonal element of R.
         sdiag(j) = r(j,j)
         r(j,j) = x(j)
  100 continue

*---- Solve the triangular system for z. If the system is
*     singular, then obtain a least squares solution.
      nsing = n
      do 110 j = 1, n
         if (sdiag(j) .eq. zero .and. nsing .eq. n) nsing = j - 1
         if (nsing .lt. n) wa(j) = zero
  110 continue
      do 140 j = nsing, 1, - 1
         sum = zero
         do 120 i = j + 1, nsing
            sum = sum + r(i,j)*wa(i)
  120       continue
         wa(j) = (wa(j) - sum)/sdiag(j)
  140 continue

*---- Permute the components of Z back to components of X.
      do 160 j = 1, n
         l = ipvt(j)
         x(l) = wa(j)
  160 continue

      end
+dk sequnum
      integer function sequ_number(snam)
      implicit none
*----------------------------------------------------------------------*
* Purpose:
*   get storage number for sequence name
* Input:
*   snam   (character)  sequence name
*----------------------------------------------------------------------*
+ca aparam
+ca memdum
+ca strgroup
+ca refer
      character *(mcnam) snam
      integer i, k
*--- look for sequence among active
      k = 0
      do i = 1, liftseq
        if (seqnames(i) .eq. snam)  k = i
      enddo
      sequ_number = k
      end
+dk setbit
      subroutine setbit(i, m, l)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Store bit at L into I'th bit of bit string M.                      *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ibit,iword,l
      integer           m(*)

      iword = i / 32 + 1
      ibit  = mod(i-1,32) + 1
      call sbit(l, m(iword), ibit)

      end
+dk slopexy
      double precision function slopexy(vectorx, vectory, nturn)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Computes slope a for linear fit of Y = a X + b.                    *
* VECTORX  is the array of abscissas X,                                *
* VECTORX  is the array of ordinates Y to interpolate,                 *
* NTURN    is their dimension.                                         *
*----------------------------------------------------------------------*
+ca aparam
      integer mf,nturn
      double precision vectorx,vectory,x2mean,xmean,xymean,ymean

      dimension vectorx(*), vectory(*)

      xmean  = 0.d0
      ymean  = 0.d0
      x2mean = 0.d0
      xymean = 0.d0

      do mf = 1, nturn
        xmean  = xmean + vectorx(mf)
        ymean  = ymean + vectory(mf)
        x2mean = x2mean + vectorx(mf)**2
        xymean = xymean + vectorx(mf) * vectory(mf)
      enddo

      xmean  = xmean / nturn
      ymean  = ymean / nturn
      x2mean = x2mean / nturn
      xymean = xymean / nturn

      slopexy = (xymean - xmean * ymean) / (x2mean - xmean**2)

      end
+dk solver
      subroutine solver(augmat, ndim, mdim, irank)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Solve the linear equation  A * X = B.                              *
* Input:                                                               *
*   AUGMAT(n,n+m)       A(n,n), augmented by B(n,m).                   *
*   NDIM, MDIM          n, m.                                          *
* Output:                                                              *
*   AUGMAT(n,n+m)       Identity(n,n), augmented by X(n,m).            *
*   IRANK               Rank of A.                                     *
*----------------------------------------------------------------------*
+ca aparam
      integer ic,ip,ir,irank,it,mdim,nc,ndim,nr
      double precision augmat,h,pivot
      dimension         augmat(ndim,ndim+mdim)

      nr = ndim
      nc = ndim + mdim

      do 100 it = 1, nr
        pivot = 0.
        ip = 0
        do 10 ir = it, nr
          if (abs(augmat(ir,it)) .ge. abs(pivot)) then
            pivot = augmat(ir,it)
            ip = ir
          endif
   10   continue

        if (pivot .eq. 0.0) go to 9999
        irank = it

        do 30 ic = 1, nc
          augmat(ip,ic) = augmat(ip,ic) / pivot
   30   continue

        if (ip .ne. it) then
          do 50 ic = 1, nc
            h = augmat(ip,ic)
            augmat(ip,ic) = augmat(it,ic)
            augmat(it,ic) = h
   50     continue
        endif

        do 70 ir = 1, nr
          if (ir .ne. it) then
            h = augmat(ir,it)
            do 60 ic = 1, nc
              augmat(ir,ic) = augmat(ir,ic) - h * augmat(it,ic)
   60       continue
          endif
   70   continue
  100 continue

      irank = ndim

 9999 end
+dk symeig
      subroutine symeig(a, nd, n, eigen, nval)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Eigenvalues of a real symmetric matrix in ascending order.         *
* Input:                                                               *
*   A(ND,ND)  (real)    Symmetric input matrix; destroyed by call.     *
*   N         (integer) Rank of matrix.                                *
* Output:                                                              *
*   EIGEN(*)  (real)    Eigenvalues of A in descending order.          *
*   NVAL      (integer) Number of eigenvalues found.                   *
*----------------------------------------------------------------------*
+ca aparam
      integer i,it,itmax,iw,j,k,l,m,n,nd,nval
      double precision a,b,c,eigen,eps,f,g,h,p,r,s
      dimension         a(nd,nd), eigen(nd)
+ca memdum
+ca wstack

      parameter         (eps = 1.0d-20)
      parameter         (itmax = 15)

*---- Allocate working space.
      iw = iwork
      iwork = iw + nd
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Matrix is 1 * 1.
      nval = n
      if (n .le. 0) go to 300
      if (n .eq. 1) then
        eigen(1) = a(1,1)
        go to 300
      endif

*---- Matrix is 2 * 2.
      if (n .eq. 2) then
        f = a(1,1) + a(2,2)
        g = sqrt((a(1,1) - a(2,2))**2 + 4.0 * a(2,1)**2)
        eigen(1) = (f - g) / 2.0
        eigen(2) = (f + g) / 2.0
        go to 300
      endif

*---- N is at least 3, reduce to tridiagonal form.
      do 90 i = n, 3, -1
        g = 0.0
        do 10 k = 1, i-2
          g = g + a(i,k)**2
   10   continue
        eigen(i) = a(i,i)
        if (g .eq. 0.0) then
          dq(iw+i) = a(i,i-1)
        else
          h = g + a(i,i-1)**2
          dq(iw+i) = sign(sqrt(h),a(i,i-1))
          h = h + a(i,i-1) * dq(iw+i)
          a(i,i-1) = a(i,i-1) + dq(iw+i)
          f = 0.0
          do 50 j = 1, i-1
            g = 0.0
            do 40 k = 1, i-1
              if (k .le. j) then
                g = g + a(j,k) * a(i,k)
              else
                g = g + a(k,j) * a(i,k)
              endif
   40       continue
            dq(iw+j) = g / h
            f = f + dq(iw+j) * a(i,j)
   50     continue
          do 70 j = 1, i-1
            dq(iw+j) = dq(iw+j) - (f / (h + h)) * a(i,j)
            do 60 k = 1, j
              a(j,k) = a(j,k) - a(i,j) * dq(iw+k) - dq(iw+j) * a(i,k)
   60       continue
   70     continue
        endif
   90 continue
      dq(iw+2) = a(2,1)
      dq(iw+1) = 0.0
      eigen(2) = a(2,2)
      eigen(1) = a(1,1)

*---- Iterate on tridiagonal matrix.
      do 110 i = 2, n
        dq(iw+i-1) = dq(iw+i)
  110 continue

      dq(iw+n) = 0.0
      f = 0.0
      b = 0.0
      do 200 l = 1, n
        b = max(eps*(abs(eigen(l))+abs(dq(iw+l))),b)
        do 120 m = l, n
          if (abs(dq(iw+m)) .le. b) go to 130
  120   continue
        m = n
  130   if (m .ne. l) then
          do 160 it = 1, itmax
            p = (eigen(l+1) - eigen(l)) / (2.0 * dq(iw+l))
            if (abs(p) .gt. 1.0e10) then
              r = abs(p)
            else
              r = sqrt(p*p+1.0)
            endif
            h = eigen(l) - dq(iw+l) / (p + sign(r,p))
            do 140 i = l, n
              eigen(i) = eigen(i) - h
  140       continue
            f = f + h
            p = eigen(m)
            c = 1.0
            s = 0.0
            do 150 i = m-1, l, -1
              g = c * dq(iw+i)
              h = c * p
              r = sqrt(dq(iw+i)**2+p**2)
              dq(iw+i+1) = s * r
              s = dq(iw+i) / r
              c = p / r
              p = c * eigen(i) - s * g
              eigen(i+1) = h + s * (c * g + s * eigen(i))
  150       continue
            dq(iw+l) = s * p
            eigen(l) = c * p
            if (abs(dq(iw+l)) .le. b) go to 170
  160     continue
          nval = l - 1
          go to 300
        endif
  170   p = eigen(l) + f
        do 180 i = l, 2, -1
          if (p .ge. eigen(i-1)) go to 190
          eigen(i) = eigen(i-1)
  180   continue
        i = 1
  190   eigen(i) = p
  200 continue

*---- Release working space.
  300 continue
      iwork = iw

      end
+dk symsol
      subroutine symsol(a, n, eflag)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Invert symmetric matrix.                                           *
* Input:                                                               *
*   A(*,*)    (real)    Matrix to be inverted.                         *
*   N         (integer) Actual size of A.                              *
* Output:                                                              *
*   A(*,*)    (real)    Inverted matrix.                               *
*   EFLAG     (logical) Error flag.                                    *
*----------------------------------------------------------------------*
+ca aparam
      integer i,ip,is,iw,j,k,n
      double precision a,si
      dimension         a(n,n)
      logical           eflag
+ca memdum
+ca wstack

*---- Allocate working space.
      is = iwork
      ip = is + n
      iw = ip + n
      iwork = iw + n
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Scale upper triangle.
      eflag = .true.
      do 10 i = 1, n
        si = a(i,i)
        if (si .le. 0.0) go to 100
        dq(is+i) = 1.0 / sqrt(si)
   10 continue
      do 20 i = 1, n
      do 20 j = i, n
        a(i,j) = a(i,j) * dq(is+i) * dq(is+j)
   20 continue

*---- Invert upper triangle.
      do 50 i = 1, n
        if (a(i,i) .eq. 0.0) go to 100
        dq(ip+i) = 1.0
        dq(iw+i) = 1.0 / a(i,i)
        a(i,i) = 0.0
        do 30 j = 1, n
          if (j .lt. i) then
            dq(ip+j) = a(j,i)
            dq(iw+j) = dq(ip+j) * dq(iw+i)
            a(j,i) = 0.0
          else if (j .gt. i) then
            dq(ip+j) = a(i,j)
            dq(iw+j) = - dq(ip+j) * dq(iw+i)
            a(i,j) = 0.0
          endif
   30   continue
        do 40 j = 1, n
        do 40 k = j, n
          a(j,k) = a(j,k) + dq(ip+j) * dq(iw+k)
   40   continue
   50 continue

*---- Rescale upper triangle and symmetrize.
      do 60 i = 1, n
      do 60 j = i, n
        a(i,j) = a(i,j) * dq(is+i) * dq(is+j)
        a(j,i) = a(i,j)
   60 continue
      eflag = .false.

*---- Release working space.
  100 continue
      iwork = is

      end
+dk tuneabt
      double precision function tuneabt(x, xp, maxn)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Computes the tune using formula (18) of CERN SL/95-84 (AP).        *
*   No filter.                                                         *
*   (best suited for MAXN <= 64 TURNS)                                 *
* X, XP are the coordinates of the orbit,                              *
* MAXN  is the length of the orbit.                                    *
* Authors:                                                             *
*   R. Bartolini - CERN and Bologna University,                        *
*   E. TODESCO   - INFN and CERN.                                      *
*----------------------------------------------------------------------*
+ca aparam
      integer ix,maxn,mf,mft,nft,nftmax,npoint
      double precision arg,assk,cf1,cf2,cf3,ftmax,one,temp,two,x,
     +xp,zero
      dimension          x(*), xp(*)
+ca memdum
+ca wstack

+ca pi
      parameter          (zero = 0.0, one = 1.0, two = 2.0)

*---- Use first NPOINT points.
      mft = int(log(float(maxn)) / log(two))
      npoint = 2**mft

*---- Assign working space.
      ix    = iwork
      iwork = iwork + 2 * npoint
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Copy data to local storage, no filter.
      do 10 mf = 1, npoint
        dq(ix+2*mf-1) = x(mf)
        dq(ix+2*mf)   = xp(mf)
   10 continue
      call fft(dq(ix+1), npoint, -1)

*---- Search for maximum of Fourier spectrum.
      ftmax = zero
      nftmax = 0
      do 20 nft = 1, npoint
        temp = sqrt(dq(ix+2*nft-1)**2 + dq(ix+2*nft)**2)
        if (temp .gt. ftmax) then
          ftmax  = temp
          nftmax = nft
        endif
   20 continue

*---- Improve estimate by interpolation.
      cf1 = sqrt(dq(ix+2*nftmax-3)**2 + dq(ix+2*nftmax-2)**2)
      cf2 = sqrt(dq(ix+2*nftmax-1)**2 + dq(ix+2*nftmax)**2)
      cf3 = sqrt(dq(ix+2*nftmax+1)**2 + dq(ix+2*nftmax+2)**2)
      if (cf3 .gt. cf1) then
        arg  = sin(pi / npoint) / (cf2 / cf3 + cos(pi / npoint))
        assk = float(nftmax) + npoint / pi * atan(arg)
      else
        arg  = sin(pi / npoint) / (cf1 / cf2 + cos(pi / npoint))
        assk = float(nftmax-1) + npoint / pi * atan(arg)
      endif
      tuneabt = one - (assk - one) / float(npoint)

*---- Release working storage.
      iwork = ix

      end
+dk tuneabt2
      double precision function tuneabt2(x, xp, maxn)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Computes the tune using the interpolated FFT with Hanning filter.  *
*   See CERN SL/95-84 formula (25).                                    *
*   (best suited for MAXN > 64 turns)                                  *
* X, XP are the coordinates of the orbit,                              *
* MAXN  is the length of the orbit.                                    *
* Authors:                                                             *
*   R. Bartolini - CERN and Bologna University,                        *
*   E. TODESCO   - INFN and CERN.                                      *
*----------------------------------------------------------------------*
+ca aparam
      integer ix,maxn,mf,mft,nft,nftmax,nn,npoint
      double precision assk,cf1,cf2,cf3,co,ftmax,one,p1,p2,scra1,
     +scra2,scra3,scra4,si,step,temp,two,twopi,x,xp,zero
      dimension          x(*), xp(*)
+ca memdum
+ca wstack

+ca pi
      parameter          (twopi = 2.0 * pi)
      parameter          (zero = 0.0, one = 1.0, two = 2.0)

*---- Use first NPOINT points.
      mft = int(log(float(maxn)) / log(two))
      npoint = 2**mft

*---- Assign working space.
      ix    = iwork
      iwork = iwork + 2 * npoint
      if (iwork .gt. nwork) then
        call mzwork(0, dq(1), dq(iwork+1), 2)
        nwork = iwork
      endif

*---- Copy data to local storage using Hanning filter.
      step = pi / npoint
      do 10 mf = 1, npoint
        temp = sin(mf * step)**2
        dq(ix+2*mf-1) = temp * x(mf)
        dq(ix+2*mf)   = temp * xp(mf)
   10 continue
      call fft(dq(ix+1), npoint, -1)

*---- Search for maximum of Fourier spectrum.
      ftmax = zero
      nftmax = 0
      do 20 nft = 1, npoint
        temp = sqrt(dq(ix+2*nft-1)**2 + dq(ix+2*nft)**2)
        if (temp .gt. ftmax) then
          ftmax  = temp
          nftmax = nft
        endif
   20 continue
      cf1 = sqrt(dq(ix+2*nftmax-3)**2 + dq(ix+2*nftmax-2)**2)
      cf2 = sqrt(dq(ix+2*nftmax-1)**2 + dq(ix+2*nftmax)**2)
      cf3 = sqrt(dq(ix+2*nftmax+1)**2 + dq(ix+2*nftmax+2)**2)
      if (cf3 .gt. cf1) then
        p1 = cf2
        p2 = cf3
        nn = nftmax
      else
        p1 = cf1
        p2 = cf2
        nn = nftmax-1
      endif

*---- Interpolation.
      co = cos(twopi / npoint)
      si = sin(twopi / npoint)
      scra1 = co**2 * (p1 + p2)**2 - 2*p1*p2*(2*co**2 - co - one)
      scra2 = (p1 + p2*co) * (p1 - p2)
      scra3 = p1**2 + p2**2 + 2*p1*p2*co
      scra4 = (-scra2 + p2*sqrt(scra1)) / scra3
      assk = nn + npoint / twopi * asin(si * scra4)
      tuneabt2 = one - (assk - one) / float(npoint)

*---- Release working storage.
      iwork = ix

      end
+dk usercm
      subroutine usercm(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   This routine is called for all codes which are not predefined.     *
*   It can be replaced to hook in user commands.                       *
* Input:                                                               *
*   IPR       (integer) Process code.                                  *
*   ISP       (integer) Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca header
+ca message
      integer ipr,isp
      write (msg, 910) ipr, isp
      call rdwarn('USERCM', 1, msg)
  910 format('Unknown command, PR =',i5,', SP =',i5,'.')
      end
+if noplot
       subroutine gxterm
       end
+ei
+dk userdf
      subroutine userdf(ipr, isp)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   This routine is called for all codes which are not predefined.     *
*   It can be replaced to hook in user definitions.                    *
* Input:                                                               *
*   IPR       (integer) Process code.                                  *
*   ISP       (integer) Subprocess code.                               *
*----------------------------------------------------------------------*
+ca aparam
+ca message
      integer ipr,isp

      write (msg, 910) ipr, isp
  910 format('Unknown definition, PR =',i5,', SP =',i5,'.')
      call rdwarn('USERDF', 1, msg)

      end
+dk user0
      function user0()
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Generate random number from user-defined distribution.             *
* Input:                                                               *
*   No arguments.                                                      *
* Result:                                                              *
*   The user-generated random number.                                  *
*----------------------------------------------------------------------*
+ca aparam
      double precision user0

*---- Replace next line by code to generate the distribution.
      user0 = 0.

      end
+dk user1
      function user1(a)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Generate random number from user-defined distribution.             *
* Input:                                                               *
*   A         (real)    One argument for the distribution.             *
* Result:                                                              *
*   The user-generated random number.                                  *
*----------------------------------------------------------------------*
+ca aparam
      double precision a,user1,frndm

*---- Replace next line by code to generate the distribution.
      user1 = frndm()

      end
+dk user2
      function user2(a, b)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Generate random number from user-defined distribution.             *
* Input:                                                               *
*   A, B      (real)    Two arguments for the distribution.            *
* Result:                                                              *
*   The user-generated random number.                                  *
*----------------------------------------------------------------------*
+ca aparam
      double precision a,b,user2

*---- Replace next line by code to generate the distribution.
      user2 = 0.

      end
+dk vdot
      function vdot(n, a, b)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Dot product of two vectors.                                        *
* Input:                                                               *
*   A(N)      (real)    First input vector.                            *
*   B(N)      (real)    Second input vector.                           *
*   N         (integer) Length of A and B.                             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,n
      double precision a,b,sum,vdot
      dimension         a(n), b(n)

      sum = 0.0
      do 10 i = 1, n
        sum = sum + a(i) * b(i)
   10 continue
      vdot = sum

      end
+dk vmod
      function vmod(n, a)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Norm of a vector.                                                  *
* Input:                                                               *
*   A(N)      (real)    Input vector.                                  *
*   N         (integer) Length of A and B.                             *
*----------------------------------------------------------------------*
+ca aparam
      integer i,n
      double precision a,sum,vmod
      dimension         a(n)

      sum = 0.0
      do 10 i = 1, n
        sum = sum + a(i) * a(i)
   10 continue
      vmod = sqrt(sum)

      end
+dk wmaxmin
      subroutine wmaxmin(track)
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Computes maximum and minimum betatron invariants during tracking.  *
* Input:                                                               *
*   TRACK(6,*)(real)    Track coordinates: (X, PX, Y, PY, T, PT).      *
*----------------------------------------------------------------------*
+ca aparam
      integer i,kp,kq
      double precision track,utwopi,wx,wxy,wy,z,zn
      dimension         track(6)
+ca beam
+ca optic0
+ca trdynap
+ca troptc
+ca zunit

+ca pi
      parameter         (utwopi = 1.0d0 / (2.0d0 * pi))
      dimension         z(6), zn(6)

*---- Copy track coordinates.
      do 10 i = 1, 6
        z(i) = track(i) - orbit0(i)
   10 continue

*---- Convert to normalized values.
      do 20 kq = 1, 5, 2
        kp = kq + 1
        zn(kq) = eigen(2,kp) * z(1) - eigen(1,kp) * z(2)
     +         + eigen(4,kp) * z(3) - eigen(3,kp) * z(4)
     +         + eigen(6,kp) * z(5) - eigen(5,kp) * z(6)
        zn(kp) = eigen(1,kq) * z(2) - eigen(2,kq) * z(1)
     +         + eigen(3,kq) * z(4) - eigen(4,kq) * z(3)
     +         + eigen(5,kq) * z(6) - eigen(6,kq) * z(5)
   20 continue

*---- Convert to amplitudes (and phases: not computed).
      wx = zn(1)**2 + zn(2)**2
      wy = zn(3)**2 + zn(4)**2
      wxy = wx + wy

*---- Compare to and redefine WMIN and WMAX in TRDYNAP.
      if (wx.gt.wxmax) then
        wxmax = wx
      else if (wx.lt.wxmin) then
        wxmin = wx
      endif
      if (wy.gt.wymax) then
        wymax = wy
      else if (wy.lt.wymin) then
        wymin = wy
      endif
      if (wxy.gt.wxymax) then
        wxymax = wxy
      else if (wxy.lt.wxymin) then
        wxymin = wxy
      endif

      end
+dk zabend
      subroutine zabend
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Handle fatal run termination.                                      *
*----------------------------------------------------------------------*
+ca aparam

+ca zunit

      call zphase(-3)
      call aafail('ZABEND', 1, 'Program terminated.')
      stop

      end
+dk zend
      subroutine zend
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Close down all activities (called by MZEND).                       *
*----------------------------------------------------------------------*
+ca aparam
+ca header
+ca message
+ca status
+ca zunit
      integer nline
      integer idate(2), itime(2)

+if .not.noplot

*---- Close plot metafile.
      if (iplflg .ne. 0) call gxterm
+ei

*---- Enter termination phase.
      call zphase(-1)

*---- Print error counts and ending time.
      call datimh(idate, itime)
      call uhtoc(idate, mcwrd, cdate, 8)
      call uhtoc(itime, mcwrd, ctime, 8)
      if (nwarn .ne. 0  .or.  nfail .ne. 0) then
        write (msg, 910) nwarn, nfail
        nline = 3
      else
        nline = 1
      endif
      write (msg(nline), 920) cdate, ctime
      call aainfo('ZEND', nline, msg)

*---- Terminate ZEBRA.
      call mzend

  910 format(i5,' Warning messages,'/i5,' Error messages.')
  920 format(6x,'MAD terminated on ',a8,' at ',a8)

      end
+dk ztelus
      subroutine ztelus
      implicit none
*----------------------------------------------------------------------*
* Purpose:                                                             *
*   Handle errors considered as non-serious by ZEBRA.                  *
*----------------------------------------------------------------------*
+ca aparam
      integer id,mode

      common /ztellc/ id, mode
+ca zunit

      if (id .eq. 99) then
        call aafail('ZTELUS', 1, 'Dynamic store full --- terminated.')
      else
        call aafail('ZTELUS', 1, 'ZEBRA call failed --- terminated.')
      endif
      mode = 3

      end
+dk zzzzzz
